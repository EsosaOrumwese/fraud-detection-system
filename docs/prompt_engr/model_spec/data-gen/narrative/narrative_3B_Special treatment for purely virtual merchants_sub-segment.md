Online‑only merchants pose an existential challenge to a spatially grounded simulator: they settle in a single legal jurisdiction, yet the transaction stream they generate appears to originate from data‑centres, payment gateways and consumer IPs scattered across dozens of time‑zones. The sub‑segment titled **“Special treatment for purely virtual merchants”** inserts a dedicated pathway so that such entities still satisfy our catalogue schema, still interact naturally with the LGCP arrival engine, and still drive downstream fraud features like “impossible travel” or “remote cross‑border spend,” all without inventing brick‑and‑mortar coordinates that never existed.

The branching condition fires the moment the hurdle layer finishes building a merchant row. Each `merchant_id` carries the boolean flag `is_virtual`, derived from the MCC table shipped in `mcc_channel_rules.yaml`; MCCs in the 6000 range (financial services), 5815 (digital streaming) and any merchant with `channel==ONLINE` and `requires_ship_address==False` flip the flag. When the flag is true the normal spatial pipeline diverts into the virtual‑merchant track. That YAML is located at `config/virtual/mcc_channel_rules.yaml` (fields: `semver`, `sha256_digest`), where `semver` follows semantic versioning and `sha256_digest` is recorded as `virtual_rules_digest` in the manifest for policy governance.

The very first divergence is at outlet creation. The physical‑site generator would have sampled an integer outlet count from a hurdle model: that logic is bypassed and a single **settlement node** is created. Its `site_id` is a SHA‑1 of `(merchant_id,"SETTLEMENT")`. For latitude and longitude the code writes the legal seat’s coordinates as published in the company’s SEC or Companies House filing; the lookup table `virtual_settlement_coords.csv` holds these values and their evidence URLs. That CSV resides at `artefacts/virtual/virtual_settlement_coords.csv` (columns: `merchant_id,lat,lon,evidence_url`), and its `semver` and `sha256_digest` are stored under `settlement_coord_semver` and `settlement_coord_digest` in the manifest to lock coordinate provenance. The coordinate is used only for settlement reporting and never appears as the origin of customer traffic. The evidence\_url is geocoded via the offline `pelias_cached.sqlite` bundle stored at `artefacts/geocode/pelias_cached.sqlite` (semver, `sha256_digest` recorded as `pelias_digest`), ensuring reproducible offline geocoding.

Because fraud features often rely on IP geo‑lookup, the simulator must still generate plausible *customer‑facing* geo information. That requirement is met by instantiating a **CDN‑edge catalogue** per virtual merchant. The catalogue is built once, immediately after the settlement node, by reading the YAML ledger `cdn_country_weights.yaml`. That ledger lives at `config/virtual/cdn_country_weights.yaml` (keys: `country_iso → weight`, `edge_scale`, `semver`, `sha256_digest`), with its digest recorded as `cdn_weights_digest` in the manifest to govern edge‑distribution policies. For example, a US‑domiciled streaming service gets edge weights: US 0.55, CA 0.07, DE 0.05, GB 0.05, BR 0.04, and so on for sixty countries. The weights derive from Akamai’s “State of the Internet” report; each country weight is multiplied by a global integer **E = 500**, chosen so that no edge catalogue is smaller than 50 nodes or larger than 800, and rounded with the same largest‑remainder routine used elsewhere. Coordinates for these edge nodes are sampled from the Facebook HRSL GeoTIFF raster (`artefacts/rasters/hrsl_100m.tif`, resolution 100 m) whose `sha256_digest` is `hrsl_digest` in the manifest, but they are stored in a separate table `edge_catalogue/<merchant_id>.parquet` whose schema is `(edge_id, country_iso, tzid, lat, lon, edge_weight)`. Edge IDs are deterministic SHA‑1 hashes of `(merchant_id, country_iso, running_index)`. Upon completion, the script hashes the Parquet file byte‑for‑byte, writes the digest under `edge_digest_<merchant_id>` into the dataset manifest, and appends a line `<merchant_id>,<sha256>` to `edge_catalogue_index.csv` (tracked under manifest key `edge_catalogue_index_digest`) so the router can detect any later drift.

A key design decision is keeping **two distinct time‑zones for every virtual merchant transaction**. The first, `tzid_operational`, is the local zone of the edge node that ultimately serves the customer. The second, `tzid_settlement`, is the zone of the legal seat—often the head‑office in Delaware or Dublin. When the LGCP arrival engine asks for an event, it supplies the settlement zone’s local clock to the NHPP sampler; that preserves corporate‑day seasonality, because marketing emails still land at midnight headquarters time. Once a candidate local timestamp appears, the router draws a CDN edge using a per‑merchant alias table whose probabilities are the normalised `edge_weight`s. The Philox sub‑stream key is computed as `SHA256(global_seed ∥ "CDN" ∥ merchant_id)`; this derivation is defined in `config/routing/rng_policy.yml` with its `semver` and `sha256_digest` stored as `cdn_key_digest` in the manifest for deterministic alias sampling. That edge’s zone determines the *apparent* `local_time_offset` written into the `transaction` row, while the UTC conversion uses the settlement offset to produce `event_time_utc`. The split ensures that, for a single virtual merchant on a single UTC day, you can see transactions whose `local_time_offset` jumps from −240 to +1100 minutes even though the mark‑to‑market settlement batch still cuts off at 23:59:59 America/New\_York.

Because the LGCP mean μ is calibrated per site and virtual merchants have hundreds of edge nodes, naïvely injecting a foot‑traffic scalar for every edge would explode state size. Instead the simulator scales μ by the edge weight on‑the‑fly:

$$
\mu_{\text{edge}}(t) = \mu_{\text{settlement}}(t) \times \frac{\text{edge_weight}}{\sum_e \text{edge_weight}}.
$$

No persistent state is stored per edge; the alias router converts the uniform random draw directly into an edge selection, multiplies μ accordingly and records the edge’s coordinate. This stateless trick lets the engine route tens of thousands of requests per second without caching edge‑level LGCP parameters.

Virtual merchants still need a geographic anchor for fraud detectors such as “merchant distance from shipping address.” The coordinate of the chosen edge node serves this purpose; it is exposed in the synthetic row as `ip_latitude` and `ip_longitude` rather than `latitude` and `longitude`, both nullable fields added to `schema/transaction_schema.avsc` (versioned via `semver` and `sha256_digest` in the schema registry) to cover virtual flows. Downstream feature pipelines that expect location fields simply coalesce physical and virtual columns.

Determinism is preserved via two hashes. First, the `edge_catalogue` parquet is written only once; its SHA‑256 slot `edge_digest_<merchant_id>` joins the dataset manifest. Second, the CDN alias table `<merchant_id>_cdn_alias.npz` embeds the same universe hash that the physical routing files use—concatenating `cdn_weights_digest ∥ edge_digest ∥ virtual_rules_digest`—so the router fails fast if anyone tweaks country weights but forgets to rebuild the alias table.

Validation adds two tests specific to virtual merchants. The validation thresholds are declared in `config/virtual/virtual_validation.yml` (fields: `country_tolerance`, `time_cutoff_tolerance`, `semver`, `sha256_digest`), with its SHA‑256 stored as `virtual_validation_digest` in the manifest and byte‑compared by `ci/test_virtual_validation.py` to catch any ungoverned changes. One checks that, over a 30‑day slice, the empirical distribution of `ip_country` codes lies within two percentage points of the YAML weights; another confirms that the settlement cut‑off hour alignment remains perfect by asserting that the UTC timestamp of the final transaction each day is 23:59:59 ± 5 seconds settlement‑zone time. The validation thresholds come from `config/virtual/virtual_validation.yml` (fields: `country_tolerance`, `time_cutoff_tolerance`, `semver`, `sha256_digest`), with its digest recorded as `virtual_validation_digest` in the manifest for CI drift detection.

With a single settlement site anchoring legal reality, a deterministic CDN edge catalogue representing customer geography, dual time‑zones describing operational versus settlement context, a stateless scaling of LGCP intensity that won’t blow up memory, and digest‑based guards that enforce consistency between YAML weights, edge catalogues and alias tables, the “Special treatment for purely virtual merchants” sub‑segment lets online‑only brands inhabit the synthetic ledger as convincingly—and reproducibly—as their brick‑and‑mortar peers.

After licence governance, the builder ensures crash recovery by logging progress to `logs/edge_progress.log` (rotated daily and retained 90 days per `config/logging/virtual_logging.yml`); upon restart, the builder reads this log, skips completed batches, and continues without duplicating rows.
