The moment the catalogue says “merchant X operates **N** sites in country Y,” a second engine has to materialise those sites on the globe with enough fidelity that a geospatial analyst could overlay them on open data and nod that the pattern looks real. That engine is the sub‑segment we labelled **“Placing outlets on the planet.”** Its job is to turn an unlocated site identifier into a latitude, longitude, remoteness proxies, prior weight and provenance trail, all recorded with cryptographic hashes that prove which spatial artefacts were involved. What follows is the full narrative of how I would build that engine so that every stochastic decision is traceable, every edge‑case is handled deterministically, and every modelling assumption can be overturned by editing a governed YAML file rather than touching code.

---

The first step is to prepare a **library of spatial priors** keyed by `(mcc_code, channel)`. Not every metre of national territory receives positive mass: each prior is a raster (GeoTIFF) or vector layer (ESRI shapefile or GeoPackage) whose defined cells or features contribute non‑negative weights on its **support subset** of the country, with uncovered areas implicitly weight zero and eligible for fallback if total support collapses to zero. For high‑street retail the prior is the 100‑metre resolution population density raster published by Facebook’s High Resolution Settlement Layer. **The HRSL prior is pinned by id `hrsl_pop_100m` (provider Meta/HRSL, vintage `2020_v1.2` unless updated via semver bump) with per‑country path pattern `artefacts/priors/hrsl/2020_v1.2/{ISO2}.tif` and a published SHA‑256 digest recorded in `spatial_manifest.json`; any vintage change requires a semver increment and yields a new `spatial_manifest_digest`.** For vehicle‑oriented merchants the prior is a clipped Open‑Street‑Map primary‑road network whose line segments carry an AADT attribute scraped from government traffic counts; for duty‑free and travel‑retail MCCs the prior is the IATA polygon of commercial‑airport boundaries; for big‑box categories the prior is a blended raster formed by taking a convex combination of suburban population density and road traffic density. **The blend is constructed by reprojecting each source prior to EPSG:4326, resampling continuous‑valued rasters with bilinear interpolation (categorical masks, if any, via nearest), aligning them onto a fixed 1/1200° global grid (origin −180°, −90°), filling nodata with zero weight, scaling each aligned pixel by its coefficient (weights sum to 1 within 1e−9), then summing to produce the blended array.** The blend coefficients live in `spatial_blend.yaml`; a reviewer can change a coefficient and regenerate a new catalogue to test sensitivity. **`spatial_blend.yaml` is a governed artefact carrying semver and a SHA‑256 digest; weight vectors are stored in canonical lexicographic order of component prior ids and must sum to 1 within 1e‑9 or CI fails; any coefficient change requires a semver bump that propagates into the spatial manifest digest; ad‑hoc sensitivity edits without semver increment are rejected.** Every file in the prior library is accompanied by a checksum file; the build concatenates those checksums and records a grand digest in the site catalogue so that anyone can reproduce exactly which map was used. **That grand digest is the `spatial_manifest_digest` (SHA‑256 over the lexicographically ordered list of individual artefact digests) and is written as a dedicated column in the site catalogue, distinct from the upstream 1A `manifest_fingerprint`; the overall build fingerprint later combines the upstream fingerprint with this `spatial_manifest_digest` and governed parameter digests.** **A whitelist model governs the spatial artefact directory: only paths enumerated in `spatial_manifest.json` (plus explicitly allowed patterns like `README*`) may exist; deleted artefacts require a manifest semver bump, and stray files cause an immediate build abort.** **This file is always named exactly `spatial_manifest.json`; alternative filenames are rejected to keep downstream validation deterministic.** **The catalogue exposes the column `spatial_manifest_digest` (not a free‑form label) alongside spatial fields (`lat`, `lon`, `prior_tag`, `prior_weight_raw`, `prior_weight_norm`, `artefact_digest`); downstream modules test equality of this digest against the JSON manifest before use.** **The wall‑clock build time is recorded as an ISO‑8601 UTC timestamp purely for audit readability and is explicitly excluded from all digest computations so that reruns without artefact change do not alter fingerprints; because the timestamp is excluded from hash inputs, two identical artefact sets yield identical `spatial_manifest_digest` regardless of execution time.**

With priors ready, the engine enters an **importance‑sampling loop** that is deterministic given the global RNG stream. For a given `site_id` in country `c` the engine first checks whether a category‑specific prior exists for that country. If it does, the engine opens the raster header, reads the grid of weights, and constructs a cumulative‑distribution function over pixel indices. **Fenwick trees are built eagerly the first time any site in a country references a given prior: a double‑checked lock guards construction so only one thread materialises the tree; subsequent threads wait and then reuse the immutable structure (event `fenwick_build` logs prior\_id, country, n, total\_weight, build\_ms).** **Float weights are scaled to uint64 deterministically: let W\_f = Σ w\_i; S = (2^64−1 − n)/W\_f; store w\_i' = max(1, floor(w\_i \* S)) ensuring every positive w\_i has at least unit mass; cumulative sums are little‑endian and never overflow by construction; W = Σ w\_i' is logged.** Because the raster may contain millions of pixels, the CDF is stored in a Fenwick tree supporting O(log n) queries and O(n) memory for each distinct (country, prior) tree, built at most once per pair and reused thereafter. The engine samples a pixel index proportional to its weight, then converts the pixel to a single deterministic point at its center (no intra‑pixel jitter in governed builds). If the prior is a vector layer instead of a raster, the engine first samples a feature with probability proportional to its associated weight (segment length times AADT for roads, polygon area for airports) where **(AADT values are floored at 500 vehicles/day before multiplication to avoid zero‑weight segments and retain sparse rural roads in sampling; units are vehicles per day)**, then chooses a random point uniformly within the feature’s geometry: **if the geometry is a polyline the point is sampled uniformly in geodesic arc length by selecting a segment via cumulative length search and interpolating along it (lengths approximated by projecting to EPSG:3857; multi‑part features concatenated); if a polygon it is sampled uniformly in surface area by pre‑triangulating the (possibly holed) polygon, weighting triangles by area, selecting one through an alias table, and drawing barycentric coordinates inside that triangle (no enclosing‑rectangle rejection).** **Concurrent requests for the same (country, prior) acquire a lock; if a build is already in progress they block until completion (idempotent build verified by comparing logged total\_weight and digest of the raw weight vector).**

Once a coordinate candidate has been drawn, a **land‑water sanity pass** runs. The candidate is tested against the 1:10 m Natural‑Earth land polygon via point‑in‑polygon; **the land mask is Natural Earth 1:10m version 5.1.2 (`natural_earth_land_10m_v5.1.2.geojson`, SHA‑256 recorded in `spatial_manifest.json`, CRS EPSG:4326, no simplification applied).** If it is in water, or if it lies more than fifty metres from the parent road when the prior is a road network, the point is rejected and the sampling loop repeats. This ensures that all sites end up on dry land or precisely on the intended transport corridor. Because the spatial‑prior weights can occasionally put mass directly on the shoreline, the expected number of iterations is still low; the loop terminates almost always on the first or second try. **A hard termination cap now bounds the placement loop: no site may exceed the lesser of 500 total spatial resample attempts or 10× the expected per‑site success count derived from recent acceptance monitoring; hitting the cap triggers a `placement_failure` (reason=`acceptance_cap_exceeded`) and aborts the build, eliminating theoretical non‑termination.** **Nightly CI draws 10,000 candidate points per prior to estimate acceptance; Wilson 95% lower bound must exceed 0.90 or the build fails, and acceptance statistics (mean, lower\_bound) are logged for trend monitoring.**

Every accepted coordinate is tagged with a **`prior_tag`** string that records the exact prior artefact (for example, `hrsl_pop_100m`, `osm_primary_road_aadt_202503`, a content‑addressed blend id, or `FALLBACK_POP`) and the numeric weight value that was used in the CDF. **`prior_weight` in this context is the raw blended float weight at the sampled pixel/feature before integer scaling; the catalogue also stores `prior_weight_norm` = prior\_weight / Σ raw weights over the prior’s domain for interpretability; the uint64 scaled weight used inside the Fenwick tree is not persisted as the canonical weight and is recomputable from the logged raw weight plus the recorded scale factor in the `fenwick_build` event.** **Tagging now also persists the precise sampling indices: for rasters `pixel_index` (row‑major), for vectors either `feature_index` plus `segment_index` and `segment_frac` (polylines) or `feature_index` plus `triangle_id` and barycentric `(u,v)` (polygons), and always the scaled uniform `cdf_threshold_u` that located the index; together these fields allow exact replay even if internal ordering is revalidated.** The tag is written into the site catalogue so that a GIS audit can sample rows stratified by tag and overlay them on the underlying map to verify plausibility.

Elevation is deliberately omitted at this stage (no DEM lookups); adding it would require extending the manifest with a DEM artefact digest and is deferred until a later travel‑time enrichment sub‑segment. Rather than query a digital elevation model for every point, the engine stores the **Haversine distance to the country’s capital** and, when the prior is a road network, the shortest on‑network driving distance to the capital as well. Haversine distance to the country’s capital is computed; **capital coordinates come from the governed `capitals_dataset_2024.parquet` (fields: iso2, role\_type, primary\_flag, lat, lon, sha256); for countries with multiple capitals the row with `role_type='administrative'` and `primary_flag=true` is selected.** **“Driving distance” here means pure shortest path length (metres → kilometres) on a contraction‑hierarchies road graph built from a pinned OSM planet snapshot (edge weights = geometric length, snapshot provenance recorded in the manifest); no speed or travel‑time model is applied in this sub‑segment.** Both numbers are recorded in the catalogue and serve as cheap proxies for remoteness without bloating the temporal generator.

Edge cases arise when a country is so small—or an MCC so specialised—that the chosen prior has zero support inside its borders. **“Zero support” means that after building (or blending) the prior the summed positive weight over all pixels or features within the country is exactly zero (all cells nodata or all vector features filtered out).** One example is a land‑locked micro‑state with no roads that meet the primary‑road tag. To maintain determinism the build falls back to a **country‑level population raster** in those cases. **Fallback raster provenance: WorldPop population 1 km v2023Q4 (path pattern `artefacts/priors/worldpop/2023Q4/{ISO2}.tif`, nodata→0, sha256 digest in the manifest).** The fallback is not silent: the catalogue writes `prior_tag='FALLBACK_POP'` together with `fallback_reason` (`missing_prior`, `zero_support`, or `empty_vector_after_filter`) and the fallback raster digest, and CI checks that the global fallback rate stays below the governed threshold (default 1% via `fallback_policy.yml`). If a reviewer considers the fallback rate too high they can add a bespoke prior for the missing category or adjust the governed threshold with justification (semver bump).

After the coordinate is finalised, the engine calls `tz_world.lookup(lat, lon)` to retrieve the IANA time‑zone id and then consults a governed zone→ISO table (`tz_world_metadata.json`) listing the authoritative set of ISO‑alpha‑2 codes associated with that zone; verification succeeds if the site’s country code is a member of that set (not by a brittle string suffix heuristic). **Legitimate cross‑border anomalies (whitelisted enclaves / special territories enumerated in the same metadata file) short‑circuit resampling; other mismatches trigger a resample attempt (up to the global cap) with a logged `tz_mismatch` event capturing lat, lon, tzid, site\_country, candidate\_country\_set, attempt\_index, and prior\_tag. Each mismatch or exhaustion abort (`tz_mismatch_exhausted`) is written to the audit log enabling precise isolation without scanning raw coordinate dumps.** If the cap is reached the build emits a `placement_failure` event (reason=`tz_mismatch_exhausted`) and aborts—sites are never silently skipped.

Finally, the **foot‑traffic scalar** is computed. The engine multiplies a category‑specific load factor κ (read from `footfall_coefficients.yaml`) with the raw blended float weight of the raster pixel or vector feature and then with a Log‑Normal residual: `footfall = κ_(mcc,channel) × prior_weight_raw × exp(ε)`, ε \~ N(0, σ\_(mcc,channel)^2). **A dedicated Philox sub‑stream keyed `footfall_lognormal` yields one ε deviate per site at this stage (temporal expansion later); event `footfall_draw` logs merchant\_id, site\_id, kappa, sigma, epsilon, footfall\_preclip.** **Calibration uses a governed 10‑million‑row synthetic slice stratified by (mcc, channel) per a frozen 2024Q4 distribution (`calibration_slice_config.yml`), with seed `CALIB_SEED`; Brent’s method searches σ in \[0.05, 2.0] until |Fano\_sim − Fano\_target| < 1e−4 (target Fano 1.80); resulting κ, σ and convergence stats enter `footfall_coefficients.yaml`.** **Means and standard deviations (μ, σ) of log footfall used for clipping are computed in a deterministic two‑pass procedure over all sites in the (country, MCC) stratum before any clipping is applied; clipped sites are then marked (`footfall_clipped=true`) and their pre‑clip value retained separately; the clipping multiple (3) and minimum stratum size (30) are governed in `winsor.yml` (semver, sha256).**

Each completed site row is written immediately to a Parquet partition keyed by `merchant_id` and `site_id` to make the build crash‑tolerant; **each row is first written to a temp file `sites/partition_date=YYYYMMDD/merchant_id={id}/site_id={site_id}.parquet.tmp` then atomically renamed without overwrite to the final `.parquet`, guaranteeing idempotent reruns and preventing partial file visibility.** A re‑run with the same seed picks up only missing partitions. When all merchants are processed the build writes a **manifest JSON** that records the seed, the composite hash of every spatial artefact, and the wall‑clock build time. That manifest is itself checksummed and appended to the top‑level catalogue directory. Any downstream simulation step verifies the checksum before proceeding so that an out‑of‑date catalogue cannot be paired with newer artefacts by accident.

**All spatial sub‑streams derive 64‑bit stride values as the lower little‑endian half of SHA‑256(key\_string); SHA‑1 is not used; each stride is unique across modules (`site_sampling`, `polygon_interior`, `footfall_lognormal`, `fenwick_tie_break`, `tz_resample`). Jumping ahead means adding the unsigned 128‑bit stride to the current Philox counter (no leapfrog); uniqueness of strides plus monotonic addition guarantees non‑overlap of generated sub‑streams; stride collisions are asserted absent by CI. Every randomness source emits an audit event: `fenwick_build`, `pixel_draw` (pixel\_index, prior\_id, uniform\_u, site\_rng\_index), `feature_draw` (feature\_index, prior\_id, uniform\_u, site\_rng\_index), `triangle_draw` (triangle\_id, prior\_id, u1, u2, site\_rng\_index), `polyline_offset` (feature\_index, segment\_index, offset\_u, site\_rng\_index), `footfall_draw`, `tz_mismatch`, `tz_mismatch_exhausted`, and `placement_failure`; absence of a required event during replay invalidates the build. Every `(merchant_id, site_id)` combination maps deterministically to the k‑th sample drawn on its RNG sub‑stream (k = base\_offset(merchant\_id) + site\_ordinal\_within\_merchant + draw\_index\_for\_site) and values are logged per event as `site_rng_index`.**

Because every coordinate arises from a publicly documentable prior, every randomness comes from a known seed in an isolated Philox stream with exhaustive audit events, every fallback is logged with reason, every tag retains the precise sampling indices and raw weight, and every artefact and governed policy is hashed into the manifest, the “Placing outlets on the planet” engine withstands not only statistical checks but forensic audits of the entire spatial pipeline; undocumented behaviour is treated as a defect rather than permissive latitude.
