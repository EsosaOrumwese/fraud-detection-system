## Assumptions

The companion exposition for **“Routing transactions through sites”** lays bare every artefact, constant, formula and defence mechanism so that an engineer can implement the router line‑for‑line, and an auditor can challenge any premise simply by editing the declared YAML inputs and replaying the build. The document is strictly declarative: it neither abbreviates nor recasts the narrative but translates every modelling sentence into an executable rule with an identified storage location.

---

### Authoritative weight source and deterministic normalisation

Each outlet’s routing weight is the *exact* foot‑traffic scalar `F_i` persisted by the placement stage. Weights are loaded from the immutable catalogue Parquet; no transformation precedes normalisation. The router computes `p_i = F_i / Σ_j F_j` using double‑precision IEEE‑754 addition in the lexicographic order of `site_id`. Because IEEE rounding is deterministic given that order, two machines yield identical `p_i` vectors. The vector is written to a binary file `<merchant_id>_pweights.bin`; its SHA‑256 is recorded in `routing_manifest.json` under the key `weight_digest`. Any divergence in host floating‑point behaviour propagates to the digest and blocks downstream steps.

---

### Alias‑table construction as a pure function

The alias table is generated once per merchant by the Vose algorithm, but the construction uses *only* integer stack operations; it draws **no random numbers** and therefore yields the same table given the same `p_i` ordering. The table is serialised as two `uint32` numpy arrays `prob` and `alias`, concatenated and written as `<merchant_id>_alias.npz`. The `prob` array encodes fixed‑point thresholds as unsigned 32‑bit integers equal to `round(p_i * N_m)`, so that in sampling the uniform draw `f = u * N_m` is directly compared to `prob[k]` (implementing `u < p_i`). The `alias` array remains unchanged, and this convention is used by the loader to reconstruct probability thresholds without precision loss. Its digest joins the manifest: `alias_digest`. Unit tests reconstruct the table in memory, re‑serialise, re‑hash and assert equality, proving immutability.

---

### Single‑draw corporate‑day random effect

A merchant‑specific Philox 2¹²⁸ sub‑stream is generated by hashing `(global_seed, "router", merchant_id)` with SHA‑1 and taking the first 128 bits. At 00:00 UTC on each simulation day `d` the router jumps the sub‑stream by one counter block and draws a single 64‑bit uniform `u_d`. It maps `u_d` to

$$
\log\gamma_d = \mu_{\gamma} + \sigma_{\gamma}\,\Phi^{-1}(u_d),
\quad
\mu_{\gamma} = -\tfrac{1}{2}\sigma_{\gamma}^{2},
$$

so that `E[γ_d] = 1`. The variance `σ_γ²` lives in the YAML file `routing_day_effect.yml`; default `σ_γ² = 0.15`. Changing the variance changes the hash of that YAML; the manifest field `gamma_variance_digest` therefore guards the effect size.

---

### Time‑zone‑group re‑normalisation

For transaction time stamp `t_local` the router computes candidate UTC date `d = floor((t_local − 60 · o)/86 400)` where `o` is the current offset in minutes. It reads `γ_d`, multiplies every `p_i` by `γ_d`, then within the *time‑zone group* of the originating site divides by the local sum, restoring `Σ_group p_i = 1`. Because the product‑then‑divide cancels γ\_d in aggregate, site share ratios inside the group are unchanged, yet cross‑zone counts inherit a common scaling. Here, the “time‑zone group” refers specifically to all outlets of a merchant with the same IANA time‑zone identifier (`tzid`) as the originating site; each scaled `p_i` is divided by the sum of scaled `p_j` over that group to restore the normalisation invariant. The router writes `gamma_id` (32‑bit day index) and `gamma_value` (double) into a hidden column of the transaction buffer so that a replay can verify modulation retrospectively.

---

### O(1) outlet choice without table rebuild

Having a stable alias table means the router need not rebuild tables after modulation. Instead it rescales the acceptance threshold: with `u_site = u_rand · N_m`, integer part `k = floor(u_site)` and fractional part `f = u_site - k`, the site is

```
site_id = k              if f < prob[k] * scale_factor
           alias[k]      else
```

where `scale_factor = Σ_j p'_j / Σ_j p_j = 1` because modulation preserved normalisation within the group. Thus the test reduces to the original alias logic, keeping CPU cost flat.

---

### Virtual‑gateway edge selection

If a merchant row in the catalogue carries `is_virtual=1`, physical outlet count is forced to one, but the router loads `cdn_country_weights.yaml`. For each virtual merchant the YAML gives a stationary vector `q_c` across CDN edge countries. An alias table on `q_c` is built exactly as for outlets, saved to `<merchant_id>_cdn_alias.npz`, digest recorded as `cdn_alias_digest`. On every routed event the router first draws an edge country using that table and writes it into the transaction column `ip_country_code`, then continues with the single settlement outlet for `site_id`.

---

### Audit checksum and batch size

After routing every 1 000 000 events globally, the router computes

```
checksum = SHA256(merchant_id || batch_index
                  || cumulative_counts_vector)
```

where `cumulative_counts_vector` is the packed array of `uint64` per‑site totals. The hash and the wall‑clock timestamp go to `routing_audit.log`. A nightly job reruns the router deterministically on the same seed, regenerates hashes, and diffs the log line‑by‑line; the first mismatch flags reproducibility regression.

---

### Validation against long‑run share and correlation targets

Once the full synthetic day is produced the harness computes, for each merchant: (1) the empirical share vector `ŝ_i = count_i / Σ counts`, (2) the Pearson correlation of hourly site counts across time‑zones. It asserts `|ŝ_i – p_i| < 0.01` for all `i` and `|ρ_emp – 0.35| < 0.05`. Tolerance and target reside in `routing_validation.yml`; CI blocks merges if any merchant breaches them. Because γ\_d induces positive correlation, removing or altering it would instantly fail the check.

---

### Licence provenance and external‑data sufficiency

`routing_day_effect.yml` is generated by the calibration notebook `calibrate_gamma.ipynb`, which uses anonymised JPM hourly counts released under the company’s Model‑Risk sandbox licence. `cdn_country_weights.yaml` derives from the Akamai State of the Internet report, CC‑BY 4.0. The router stores licence references in `LICENSES/` and the manifest field `routing_licence_digest`; replacement of either upstream source demands conscious re‑acceptance at code‑review time.

---

## Appendix A – Mathematical Definitions & Conventions

Below are the precise formulae, units, code cross‑references and domain notes for every core computation in “Routing transactions through sites.”

---

### A.1 Weight Normalization

**Purpose:** turn raw foot‑traffic scalars into a probability distribution.
**Code:** `router/io.py:load_weights`
Let

$$
F = [F_1, F_2, \dots, F_{N_m}],\quad F_i>0
$$

be the IEEE‑754 double scalars from `artefacts/catalogue/site_catalogue.parquet`. Define total weight

$$
W = \sum_{j=1}^{N_m} F_j\quad(\text{double}).
$$

Then the normalized weight for site $i$ is

$$
p_i = \frac{F_i}{W}
\quad(\text{unitless},\;\sum_i p_i = 1).
$$

> **Domain note:** if $W = 0$, code in `router/errors.py` raises `RoutingZeroWeightError`; see A.8.

---

### A.2 Alias‑Table Construction

**Purpose:** enable O(1) sampling from the discrete distribution $\{p_i\}$.
**Code:** `router/alias.py:build_alias_table`
Given $p$ of length $N_m$:

1. Initialize two stacks:
   $\mathcal{S} = \{i : p_i < 1/N_m\},\quad  
    \mathcal{L} = \{i : p_i \ge 1/N_m\}.$
2. While $\mathcal{S}$ non‑empty: pop $s$ from $\mathcal{S}$, $l$ from $\mathcal{L}$; set
   $\mathrm{prob}[s] = p_s \cdot N_m,\quad  
    \mathrm{alias}[s] = l.$
   Update
   $p_l := p_l - (1/N_m - p_s).$
   Reassign $l$ to $\mathcal{S}$ or $\mathcal{L}$ based on $p_l$.
3. Any remaining index $i$ gets
   $\mathrm{prob}[i] = 1,\;\mathrm{alias}[i]=i.$
   Arrays `prob` (uint32) and `alias` (uint32) of length $N_m$ are then saved to `<merchant_id>_alias.npz`.

> **Domain note:** this deterministic procedure uses only integer operations and the original `p` array.

---

### A.3 Corporate‑Day Random Effect

**Purpose:** introduce daily cross‑zone co‑movement.
**Code:**

* Seed derivation: `router/seed.py:derive_philox_seed`
* Uniform draw: `router/prng.py:get_uniform(counter)`
  Let
  $\mathrm{seed} = \mathrm{SHA1}(\mathtt{global\_seed}\,\|\,\texttt{"router"}\,\|\,\mathtt{merchant\_id})$
  produce a 128‑bit Philox key. For each UTC day $d$, the code draws

$$
u_d = \mathrm{Philox}(\text{key},\;\text{counter}=0)
\quad(\text{uniform in }[0,1)).
$$

Then

$$
\gamma_d = \exp\bigl(\mu_\gamma + \sigma_\gamma\,\Phi^{-1}(u_d)\bigr),
\quad
\mu_\gamma = -\tfrac12\,\sigma_\gamma^2
$$

with $\sigma_\gamma^2$ from `config/routing/routing_day_effect.yml`.

> **Domain note:** day‑effect uses counter 0; event draws start at counter 1 (see A.4).

---

### A.4 Outlet Sampling

**Purpose:** draw a single site from the customer’s alias table in O(1) time.
**Code:** `router/sampler.py:sample_site`
Given alias arrays `prob, alias` and a uniform draw

$$
u = \mathrm{Philox}(\text{key},\;\text{counter}=d+1+i)
\quad(\text{for site index }i),
$$

compute

$$
k = \lfloor u \times N_m\rfloor,\quad
f = u \times N_m - k.
$$

Select

$$
\text{site\_index} =
\begin{cases}
k, & f < \mathrm{prob}[k],\\
\mathrm{alias}[k], & \text{otherwise},
\end{cases}
$$

and map to `site_id`.

---

### A.5 CDN‑Country Sampling

**Purpose:** choose an edge‑node country for virtual merchants.
**Code:** `router/alias.py:build_alias_table` & `router/sampler.py:sample_cdn_country`
Identical to A.2–A.4, but on the vector

$$
Q = [q_1,\dots,q_K]\quad(\sum q_k = 1)
$$

from `config/routing/cdn_country_weights.yaml`, producing `<merchant_id>_cdn_alias.npz`.

---

### A.6 Audit Checksum

**Purpose:** validate reproducibility every batch.
**Code:** `router/audit.py:emit_checksum`
After each batch of $B=10^6$ events, let

$$
C = [c_1,\dots,c_{N_m}]\quad(c_i \in \mathbb{Z}_{\ge0})
$$

be the cumulative counts per site. Compute

$$
\mathrm{checksum} = \mathrm{SHA256}\bigl(\mathtt{merchant\_id}\,\|\,\mathtt{batch\_index}\,\|\,\mathrm{BE}(C)\bigr),
$$

where $\mathrm{BE}(C)$ is the big‑endian concatenation of 8‑byte `uint64` values. Append to `logs/routing/routing_audit.log` with ISO 8601 timestamp.

---

### A.7 Validation Metrics

**Purpose:** enforce long‑run share and correlation targets.
**Code:** `router/validation.py:run_checks`
Given empirical counts $C$ and normalized weights $p$, define

$$
\hat p_i = \frac{c_i}{\sum_j c_j},\quad
\rho_{\mathrm{emp}} = \mathrm{PearsonCorr}(\mathbf{h}^{(1)},\mathbf{h}^{(2)}),
$$

where $\mathbf{h}^{(1)},\mathbf{h}^{(2)}$ are hourly count vectors for the two most populous time‑zones. Assert

$$
|\hat p_i - p_i| < \epsilon_p,\quad
|\rho_{\mathrm{emp}} - \rho^*| < \epsilon_\rho,
$$

with $\epsilon_p$ and $\rho^*$ from `routing_validation.yml`.

---

### A.8 Zero‑Weight Edge Case

**Purpose:** handle degenerate weight distributions.
**Code:** `router/errors.py:check_zero_weight`
If

$$
W = \sum_{j=1}^{N_m} F_j = 0,
$$

raise
$\mathtt{RoutingZeroWeightError}(\mathtt{merchant\_id})$,
which aborts the routing build.

---

### A.9 Performance Metrics

**Purpose:** monitor throughput and memory.
**Code:** `router/metrics.py`
Throughput

$$
\mathrm{TP} = \frac{\text{bytes_routed}}{\text{elapsed_seconds}}
\quad(\text{MB/s}),
$$

Memory

$$
\mathrm{Mem} = \mathrm{RSS}\quad(\text{GB}).
$$

Thresholds ($\mathrm{TP}\ge200$, $\mathrm{Mem}\le2$) are loaded from `config/routing/performance.yml`.

---

With this appendix, every numerical operation, random‑seed decision, file format and validation formula is explicitly defined, leaving no room for interpretation.

---

## Governed Artefact Registry

Append this table to the end of **assumptions\_2B\_Routing transactions through sites\_sub‑segment.txt**. Every entry must be listed in `routing_manifest.json` (or the main manifest) with the indicated metadata; any change to the file, its semver or its digest will produce a new manifest digest and trigger CI checks.

| ID / Key                     | Path Pattern                                 | Role                                                            | Semver Field   | Digest Field               |
| ---------------------------- | -------------------------------------------- | --------------------------------------------------------------- | -------------- | -------------------------- |
| **site\_catalogue\_parquet** | `artefacts/catalogue/site_catalogue.parquet` | Foot‑traffic weights for all sites                              | `semver`       | `site_catalogue_digest`    |
| **routing\_manifest**        | `artefacts/routing/routing_manifest.json`    | Manifest of all routing artefacts and their digests             | `semver`       | `routing_manifest_digest`  |
| **routing\_day\_effect**     | `config/routing/routing_day_effect.yml`      | Corporate‑day variance parameter σ²                             | `semver`       | `gamma_variance_digest`    |
| **cdn\_country\_weights**    | `config/routing/cdn_country_weights.yaml`    | Edge‑node country weight vector for virtual merchants           | `semver`       | `cdn_alias_digest`         |
| **routing\_validation**      | `config/routing/routing_validation.yml`      | Validation thresholds (`tolerance_share`, `target_correlation`) | `semver`       | `validation_config_digest` |
| **logging\_config**          | `config/routing/logging.yml`                 | Audit‑log path, rotation and retention policy                   | `semver`       | `audit_log_config_digest`  |
| **rng\_policy**              | `config/routing/rng_policy.yml`              | RNG seed derivation policy (SHA‑1 usage)                        | `semver`       | `rng_policy_digest`        |
| **rng\_proof**               | `docs/rng_proof.md`                          | Formal proof of RNG stream isolation                            | Git commit ref | `rng_proof_digest`         |
| **pweights\_bin**            | `<merchant_id>_pweights.bin`                 | Little‑endian `float64` weight vectors per merchant             | n/a            | `weight_digest`            |
| **alias\_npz**               | `<merchant_id>_alias.npz`                    | Uncompressed NumPy arrays (`prob`, `alias`) for alias sampling  | n/a            | `alias_digest`             |
| **cdn\_alias\_npz**          | `<merchant_id>_cdn_alias.npz`                | Uncompressed NumPy arrays (`prob`, `alias`) for CDN sampling    | n/a            | `cdn_alias_digest`         |
| **errors\_config**           | `config/routing/errors.yml`                  | Exception definitions (`RoutingZeroWeightError`, etc.)          | `semver`       | `errors_config_digest`     |
| **performance\_config**      | `config/routing/performance.yml`             | Throughput and memory SLA thresholds                            | `semver`       | `perf_config_digest`       |

**Notes:**

* The binary files (`.bin`, `.npz`) do not carry semver in sidecars; their paths and digest keys are sufficient for build‑time governance.
* Replace `<merchant_id>` with the zero‑padded site code for each merchant.
* Any addition, removal, or version change of these artefacts must follow semver rules and will automatically refresh the manifest digest via CI.
* All paths use Unix‑style forward slashes and are case‑sensitive.
