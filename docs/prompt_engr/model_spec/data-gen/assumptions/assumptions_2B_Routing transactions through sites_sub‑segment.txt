The companion exposition for **“Routing transactions through sites”** lays bare every artefact, constant, formula and defence mechanism so that an engineer can implement the router line‑for‑line, and an auditor can challenge any premise simply by editing the declared YAML inputs and replaying the build. The document is strictly declarative: it neither abbreviates nor recasts the narrative but translates every modelling sentence into an executable rule with an identified storage location.

---

#### Authoritative weight source and deterministic normalisation

Each outlet’s routing weight is the *exact* foot‑traffic scalar `F_i` persisted by the placement stage. Weights are loaded from the immutable catalogue Parquet; no transformation precedes normalisation. The router computes `p_i = F_i / Σ_j F_j` using double‑precision IEEE‑754 addition in the lexicographic order of `site_id`. Because IEEE rounding is deterministic given that order, two machines yield identical `p_i` vectors. The vector is written to a binary file `<merchant_id>_pweights.bin`; its SHA‑256 is recorded in `routing_manifest.json` under the key `weight_digest`. Any divergence in host floating‑point behaviour propagates to the digest and blocks downstream steps.

---

#### Alias‑table construction as a pure function

The alias table is generated once per merchant by the Vose algorithm, but the construction uses *only* integer stack operations; it draws **no random numbers** and therefore yields the same table given the same `p_i` ordering. The table is serialised as two `uint32` numpy arrays `prob` and `alias`, concatenated and written as `<merchant_id>_alias.npz`. Its digest joins the manifest: `alias_digest`. Unit tests reconstruct the table in memory, re‑serialise, re‑hash and assert equality, proving immutability.

---

#### Single‑draw corporate‑day random effect

A merchant‑specific Philox 2¹²⁸ sub‑stream is generated by hashing `(global_seed, "router", merchant_id)` with SHA‑1 and taking the first 128 bits. At 00:00 UTC on each simulation day `d` the router jumps the sub‑stream by one counter block and draws a single 64‑bit uniform `u_d`. It maps `u_d` to

$$
\log\gamma_d = \mu_{\gamma} + \sigma_{\gamma}\,\Phi^{-1}(u_d),
\quad
\mu_{\gamma} = -\tfrac{1}{2}\sigma_{\gamma}^{2},
$$

so that `E[γ_d] = 1`. The variance `σ_γ²` lives in the YAML file `routing_day_effect.yml`; default `σ_γ² = 0.15`. Changing the variance changes the hash of that YAML; the manifest field `gamma_variance_digest` therefore guards the effect size.

---

#### Time‑zone‑group re‑normalisation

For transaction time stamp `t_local` the router computes candidate UTC date `d = floor((t_local − 60 · o)/86 400)` where `o` is the current offset in minutes. It reads `γ_d`, multiplies every `p_i` by `γ_d`, then within the *time‑zone group* of the originating site divides by the local sum, restoring `Σ_group p_i = 1`. Because the product‐then‑divide cancels γ\_d in aggregate, site share ratios inside the group are unchanged, yet cross‑zone counts inherit a common scaling. The router writes `gamma_id` (32‑bit day index) and `gamma_value` (double) into a hidden column of the transaction buffer so that a replay can verify modulation retrospectively.

---

#### O(1) outlet choice without table rebuild

Having a stable alias table means the router need not rebuild tables after modulation. Instead it rescales the acceptance threshold: with `u_site = u_rand · N_m`, integer part `k = floor(u_site)` and fractional part `f = u_site - k`, the site is

```
site_id = k              if f < prob[k] * scale_factor
           alias[k]      else
```

where `scale_factor = Σ_j p'_j / Σ_j p_j = 1` because modulation preserved normalisation within the group. Thus the test reduces to the original alias logic, keeping CPU cost flat.

---

#### Virtual‑gateway edge selection

If a merchant row in the catalogue carries `is_virtual=1`, physical outlet count is forced to one, but the router loads `cdn_country_weights.yaml`. For each virtual merchant the YAML gives a stationary vector `q_c` across CDN edge countries. An alias table on `q_c` is built exactly as for outlets, saved to `<merchant_id>_cdn_alias.npz`, digest recorded as `cdn_alias_digest`. On every routed event the router first draws an edge country using that table and writes it into the transaction column `ip_country_code`, then continues with the single settlement outlet for `site_id`.

---

#### Audit checksum and batch size

After routing every 1 000 000 events globally, the router computes

```
checksum = SHA256(merchant_id || batch_index
                  || cumulative_counts_vector)
```

where `cumulative_counts_vector` is the packed array of `uint64` per‑site totals. The hash and the wall‑clock timestamp go to `routing_audit.log`. A nightly job reruns the router deterministically on the same seed, regenerates hashes, and diffs the log line‑by‑line; the first mismatch flags reproducibility regression.

---

#### Validation against long‑run share and correlation targets

Once the full synthetic day is produced the harness computes, for each merchant: (1) the empirical share vector `ŝ_i = count_i / Σ counts`, (2) the Pearson correlation of hourly site counts across time‑zones. It asserts `|ŝ_i – p_i| < 0.01` for all `i` and `|ρ_emp – 0.35| < 0.05`. Tolerance and target reside in `routing_validation.yml`; CI blocks merges if any merchant breaches them. Because γ\_d induces positive correlation, removing or altering it would instantly fail the check.

---

#### Licence provenance and external‑data sufficiency

`routing_day_effect.yml` is generated by the calibration notebook `calibrate_gamma.ipynb`, which uses anonymised JPM hourly counts released under the company’s Model‑Risk sandbox licence. `cdn_country_weights.yaml` derives from the Akamai State of the Internet report, CC‑BY 4.0. The router stores licence references in `LICENSES/` and the manifest field `routing_licence_digest`; replacement of either upstream source demands conscious re‑acceptance at code‑review time.

---

Every parameter, table, YAML path, random‑stream origin and statistical acceptance band is now spelled out, joined to a digest in the manifest, and guarded by nightly deterministic replay. No routing behaviour can drift without surfacing in a failed checksum, an altered hash or a breached validation threshold, thereby satisfying the implementation and audit rigor demanded by the overarching specification.
