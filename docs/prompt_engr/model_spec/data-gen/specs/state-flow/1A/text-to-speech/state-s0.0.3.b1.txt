Alright, here’s the TTS-friendly rendering of **S0.3 beginning through 0.3.3**, done in our agreed style: faithful to the content, natural spoken flow, with formulas explained rather than read literally.

---

State S0 point 3. RNG engine, substreams, samplers, and draw accounting. This is normative and fixed.

Notation rule. Whenever we write “ln of x,” that means the natural logarithm. The unqualified word “log” must never appear in kernels or acceptance tests.

Purpose.
This state pins the entire randomness contract for subsegment 1A. It establishes which pseudo-random generator we use, how we carve it into keyed, order-invariant substreams, how we map raw bits to the open interval from zero to one, how we generate standard normal Z, how we generate Gamma with parameter alpha, and how we generate Poisson with rate lambda. It also fixes how every single draw is counted, logged, and reproducible. This sub-state does consume randomness.

---

Section S0 point 3.1. Engine and event envelope.

There is a practical bound. Blocks is a sixty-four bit unsigned integer. Producers must ensure that a single event’s block consumption fits into that width. If an event would exceed this bound, it must emit the failure code “F4d colon rng budget violation” and abort the run.

The pseudo-random generator algorithm is Philox two by sixty-four with ten rounds. This is a counter-based, splittable algorithm.

Counters are one hundred and twenty-eight bits, represented as the ordered pair of two unsigned sixty-four bit integers, called counter high and counter low. All counters in envelopes use these two words. Any older four-word notation is non-normative and must not be used. Advancing the block function means incrementing the counter by one, that is, adding one to the one hundred and twenty-eight bit integer, with carry propagating from low to high.

Each substream’s state consists of a sixty-four bit key k and the one hundred and twenty-eight bit counter c.

The block function takes key k and counter c, runs Philox two by sixty-four for ten rounds, and returns two sixty-four bit words, call them x zero and x one. After that, the counter is incremented by one.

Lane policy. This is normative.
No caching. Families that require two uniforms must not reuse, pool, or cache uniforms or normals across events. Each event must fetch a fresh block.
Clarification. When we say “use low lane,” that means: read x zero and advance the counter by one block. The high lane x one is discarded and may not be reused later.
For single uniform events, use x zero, discard x one, advance the counter by one, and record draws equals one.
For two uniform events, such as Box–Muller, use both lanes from the same block, advance the counter by one, and record draws equals two.
No other reuse or caching of lanes is permitted.

Now the event envelope. This is the mandatory set of fields carried on every random event log row.
It has the UTC timestamp in RFC 3339 format with nanosecond precision.
It has the module string, for example “1A dot S6 dot gumbel.”
It has the substream label string, such as “gumbel underscore key” or “dirichlet underscore gamma underscore vector.”
It records the seed, which is the unsigned sixty-four modelling seed from state S0 point 2.
It records the parameter hash and manifest fingerprint, both as sixty-four hex strings from S0 point 2.
It records the run ID as a thirty-two character hex string.
It records the random number generator counter before and after, both high and low sixty-four bit words.
It records blocks, which is the number of Philox blocks advanced by this event.
It records draws, which is the number of uniforms actually consumed by this event, encoded as a decimal string representing a one hundred and twenty-eight bit unsigned integer.
Finally it has a payload object, whose fields are flattened into the top level by the event schema. The schema guarantees that field names are globally unique; name collisions would be compile-time schema errors.

Blocks versus draws. Blocks are computed as after minus before in unsigned one hundred and twenty-eight bit arithmetic. Draws is the number of uniforms used. For single-uniform families, blocks equals one and draws equals one. For two-uniform families such as Box–Muller, blocks equals one and draws equals two. For non-consuming events, blocks equals zero and draws equals zero. The blocks equality is checked by counters; draws is checked against family budgets.

Invariants. Blocks must equal the unsigned difference between after and before counters. Draws must equal the number of uniform zero to one variates consumed. With the lane policy, single uniform events have one block and one draw. Two uniform events have one block and two draws. Non-consuming events leave counters unchanged and set both blocks and draws to zero.

Modules and substream labels must come from the vocabulary registry defined in the shared schema “schemas dot layer1 dot yaml, hash-slash rng slash events.” Free-text labels are not allowed.

When a family level uniforms-used count is relevant for diagnostics, such as for gamma component or dirichlet gamma vector, then a field called uniforms may be included in the payload. This must equal draws. Validators must require equality. All other families must not include a uniforms field.

Encoding notes. An event’s envelope draws must equal the kernel’s computed uniform count. Counters are the authority for blocks. Discrepancies are budget violations.

The budget table that is authoritative for state S0.
Uniform one, meaning single-uniform families: one block, one draw.
Normal, meaning Box–Muller: one block, two draws.
Gamma component: variable, per section S0 point 3.6.
Dirichlet gamma vector: the sum of component gamma component budgets.
Poisson component with lambda less than ten: variable, inversion per section S0 point 3.7.
Poisson component with lambda greater or equal to ten: two uniforms per attempt, PTRS per section S0 point 3.7.

Optional duplication. Only gamma component and dirichlet gamma vector may include payload dot uniforms. If present, it must equal draws. All other families must not include this field.

Draws is stored as a JSON string carrying a base-ten representation of a one hundred and twenty-eight bit unsigned integer. Producers and consumers must parse and emit it as decimal, not as split high and low words.

Timestamps. In RNG events, ts underscore utc is an RFC 3339 UTC string with nanosecond precision. In failure records, ts underscore utc is epoch nanoseconds, stored as an unsigned integer. See section S0 point 9 for failure record timestamps.

Serialization note. Counter fields, blocks, and draws carry numeric values. Endianness applies only to derivations. JSON serialization is endianness-agnostic.

---

Section S0 point 3.2. Master seed and initial counter, per run.

Definition of LOW sixty-four of a digest. For a thirty-two byte SHA-two-fifty-six digest, interpret bytes twenty-four through thirty-one as a little-endian sixty-four bit unsigned integer. Counters are always split as big-endian sixty-fours: bytes sixteen through twenty-three, then bytes twenty-four through thirty-one.

Inputs. The seed is the user or model seed, a sixty-four bit unsigned integer, from S0 point 2. The manifest fingerprint bytes are thirty-two bytes from S0 point 2.

Define the master material. M equals SHA-two-fifty-six of the concatenation of the encoded string “mlr colon 1A dot master,” then the manifest fingerprint bytes, then the seed as little-endian sixty-four. This yields thirty-two bytes.

Domain strings under the universal encoding rule. The string “mlr colon 1A dot master” is for master material. The string “mlr colon 1A” is for substream messages. Event-family labels are ASCII, for example “hurdle underscore bernoulli” or “gumbel underscore key.” These exact byte sequences are part of the hash inputs.

Derive the root, which is used only for audit, never directly for draws. The root key k star equals LOW sixty-four of M. The root counter equals the big-endian sixty-four from bytes sixteen through twenty-three of M, and the big-endian sixty-four from bytes twenty-four through thirty-one of M.

Split sixty-four definition. For a sixteen-byte string b, return hi equals big-endian sixty-four of bytes zero through seven, and lo equals big-endian sixty-four of bytes eight through fifteen.

Envelopes carry these same numeric values as the rng underscore counter fields. All counter math is unsigned one hundred and twenty-eight bit addition, where low is incremented and carry flows into high.

Emit a single RNG audit log row before any draws. It must record the seed, manifest fingerprint, parameter hash, run ID, and the pair of root key and root counter. No event may draw from this root state. Schema separation rule. RNG audit log rows are not RNG events and must not be encoded with the event envelope. They use the audit schema only and must precede the first RNG event.

---

Section S0 point 3.3. Keyed, order-invariant substreams.

Every logical substream is keyed by a deterministic tuple, never by execution order.

Substream derivation. Under the universal encoding rule, no delimiters. Integer encodings use little-endian thirty-two for indices and little-endian sixty-four for keys.

Indices i and j are zero-based unsigned integers encoded as little-endian thirty-two. They must be between zero and two to the thirty-two minus one. Negative values are forbidden.

ISO encoding. ISO country codes must be uppercase ASCII before encoding. If a lower-case code is seen, uppercase it deterministically before encoding.

Recap. Strings are UTF-8 with length prefix. Integers are little-endian thirty-two or sixty-four. ISO codes must be uppercase. These are the only encodings allowed for hashing and substream derivation in section S0 point 3.

Given an event family label, such as hurdle bernoulli or gumbel key, and an ordered ID tuple, for example merchant underscore u sixty-four and ISO code, build the message as: the encoded string “mlr colon 1A,” then the encoded label, then the encoded IDs. Compute H equals SHA-two-fifty-six of M concatenated with that message. The key for this label and IDs equals LOW sixty-four of H. The counter equals the big-endian sixty-four from bytes sixteen through twenty-three of H, and the big-endian sixty-four from bytes twenty-four through thirty-one of H. This is the one hundred and twenty-eight bit counter with hi and lo parts.

ID encoding uses universal encoding per component, with types fixed by schema. Merchant underscore u sixty-four from S0 point 1 mapping uses little-endian sixty-four. ISO uppercase country code uses length-prefixed UTF-8. Indices i and j use little-endian thirty-two. Any other id types must be enumerated in the event schema.

All draws for that event must come from Philox with this derived key and counter, by advancing the counter monotonically.

---

That covers the introduction, the engine, the audit seed, and the derivation of order-invariant substreams. The next section, S0 point 3.4, will move into uniform generation and then Box–Muller normals.