Got it. Here are **normative, zero-semantic-change resolutions** for **Polish #1–#3**. They tell the patcher exactly what to add and where—no diffs yet, just the “ought to be.” &#x20;


# Polish-01 — One-screen **operation capsule**

**Resolution (binding placement & content):**

* **Place** a single, 5–6-bullet capsule at the **top of S2.2** (immediately before its Scope/Algorithm block).
* **Content (verbatim sequence, present tense):**

  1. compute $(\mu,\phi)$;
  2. enter attempt loop;
  3. draw Gamma → emit `gamma_component`;
  4. compute $\lambda=(\mu/\phi)\,G$; draw Poisson → emit `poisson_component`;
  5. accept on $K\ge2$ else repeat;
  6. emit **non-consuming** `nb_final`; hand off $(N,r)$.
* **Cross-refs only** (no restating math): at the end of each bullet, add a parenthetical anchor to the detailed subsection (S2.2/S2.3/S2.4/S2.5/S2.9).

**Scope:** Single insert at S2.2 top; nowhere else (avoid duplication).

**Acceptance checks:** A reviewer sees one capsule, ≤6 bullets, each bullet ends with a section anchor; no new terms/labels appear; `nb_final` is explicitly “non-consuming”.

**Non-changes:** No schemas, artefacts, RNG rules, or ordering semantics altered.

---

# Polish-02 — **Substreams & producers** mini-table (legend)

**Resolution (binding placement & columns):**

* **Primary legend** in **S2.6 §2** (right after the label list). Add a 2–4 row table with columns:
  **label** · **context** · **module** *(exact registry literal; populated once the Major fix pins it)* · **schema ref** · **partitions** (`seed, parameter_hash, run_id`).
* **Echo (slim)** in **S2.9** beside the outputs list (label · module · schema ref).

**Content rules:**

* Rows: `gamma_component (context="nb")`, `poisson_component (context="nb")`, `nb_final`.
* `module` values must match the registry **byte-for-byte** (no `1A.nb_*` placeholders).

**Acceptance checks:** Table exists in S2.6 and slim echo in S2.9; labels unique; contexts correct; module literals equal registry; partitions column shows `{seed, parameter_hash, run_id}` exactly.

**Non-changes:** Purely navigational; no change to streams, schemas, or partitions.

---

# Polish-03 — **Inline dtype hints** (mirror schema exactly)

**Resolution (binding placement & wording):**

* In **S2.2** at the first mention of parameters, append inline hints:
  `mu (float64)`, `dispersion_k (float64)`.
* In **S2.5** (“Payload (must)”), append inline hints that **mirror the schema**:
  `mu, dispersion_k, lambda: float64`; `k, n_outlets, nb_rejections: int64`.
  *(Do not introduce new types or change domains; these are readability hints that echo the schema.)*

**Acceptance checks:** Hints appear exactly at first use in S2.2 and beside the S2.5 payload keys; the types match the schema verbatim; examples remain unchanged.

**Non-changes:** No model/serialization changes; this is documentation clarity only.

---

Here are **normative, zero-semantic-change resolutions** for **Polish #4–#6**, grounded in your mapped locations. These tell the patcher exactly what to add and where—no diffs yet.

---

# Polish-04 — Cross-reference **S0.3.3** for keyed substream mapping (don’t restate)

**Resolution (binding placement & wording):**

* **Place:** In **S2.6 “Deterministic keyed mapping”** (the subsection that currently sketches the base counter derivation).
* **Add a one-liner (verbatim):**
  *“Base counter derivation is **as per S0.3.3** (not restated here).”*
* **Rationale:** Keeps a **single source of truth** for the SHA-256 keyed mapping; reduces future drift.

**Acceptance checks:** The one-liner appears once in S2.6 at the mapping block; S2 no longer re-specifies the mapping formula.&#x20;

**Non-changes:** No algorithm, RNG, or schema change—cross-reference only.

---

# Polish-05 — Note on **shortest binary64 round-trippable decimals** (example hygiene)

**Resolution (binding placement & wording):**

* **Place:**
  • **S2.2** under the invariants/echo paragraph;
  • **S2.5** immediately before the writer/example.
* **Add a one-liner (verbatim):**
  *“Examples use the **shortest binary64 round-trippable decimals**; consumers parse as binary64.”*

**Acceptance checks:** The one-liner is present in both S2.2 and S2.5; no numbers/examples are changed—this is guidance only.&#x20;

**Non-changes:** No changes to math, RNG, schemas, or types; this is documentation hygiene.

---

# Polish-06 — **Standardize example key ordering** (envelope → payload)

**Resolution (binding placement & formatting rule):**

* **Place:** **S2.5** (writer/example).

* **Formatting rule (apply consistently):** In every S2 example, list **envelope** fields first, then **payload** fields. Use this canonical envelope order:

  ```
  ts_utc, seed, parameter_hash, manifest_fingerprint, run_id,
  module, substream_label,
  rng_counter_before_lo, rng_counter_before_hi,
  rng_counter_after_lo,  rng_counter_after_hi,
  blocks, draws
  ```

  Then follow with the payload keys.

* **Secondary check:** If **S2.9** includes any example snippets, keep the same ordering.

**Acceptance checks:** All S2 examples display envelope-first ordering using the list above, followed by payload; no semantic/textual content changes beyond ordering.&#x20;

**Non-changes:** Purely presentational; no schema or contract changes.

---

These three instructions complete the Polish set and can be applied safely: they add clarity and consistency without touching algorithms, RNG, schemas, partitions, or lineage.
