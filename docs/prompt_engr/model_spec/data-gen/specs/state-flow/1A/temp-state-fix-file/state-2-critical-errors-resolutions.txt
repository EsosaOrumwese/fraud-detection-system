Understood. I opened the two ground-truth files you supplied (the **Critical list** and the **locations map**) and wrote **normative, implementation-agnostic resolutions** for **Critical #1–#3**. Each resolution below states exactly how S2 *must* read, where it applies, and the acceptance checks—without introducing any new issues.

---

# Critical #1 — Per-event law conflates counters with uniforms (“`after = before + draws`”)

**What’s wrong (per your map):** S2 equates the envelope counter delta with **`draws`** in per-event rules/examples (S2.6 §3/§6; S2.5 §5).

## Resolution (normative; place once in S2.6 “Envelope arithmetic (per event)”)

* **Event-local counter law.** For every RNG **event row**
  **`blocks := u128(after) − u128(before)`** (treat `{hi,lo}` as one unsigned 128-bit counter). `after` **MUST** equal `before + blocks` in 128-bit arithmetic.
  `blocks` **MUST** be emitted as a JSON **integer** (uint64).
* **Uniforms vs counters.** **`draws`** **MUST** equal the **actual count of U(0,1)** uniforms consumed by the event’s sampler(s) and **MUST NOT** be computed from the counter delta. `draws` **MUST** be a **decimal-encoded uint128 string**.
* **Independence.** In general **`draws ≠ blocks`**. Examples: Box–Muller uses **2 uniforms** from **1 block** → `draws="2"`, `blocks=1`. A non-consuming finaliser uses none → `draws="0"`, `blocks=0`.
* **Examples (binding).** Every **normative** example in S2 **MUST** show **both** fields with the types above. Remove/replace any text or example that equates `draws` with `u128(after)−u128(before)`.

**Definitions & units (binding).**
`blocks`: JSON **uint64**; `draws`: decimal **uint128 string**; `before/after`: each expressed as two **uint64** words (`*_hi`, `*_lo`) forming a single 128-bit counter.

**Scope in S2:** Replace the equality in **S2.6 §3** and **§6**; update **S2.5 §5** examples that annotate `"draws":"<after−before …>"`.&#x20;

**Acceptance checks:** For every event, validators compute `u128(after)−u128(before)` and match it to `blocks`; they accrue `draws` from budgets (not counters). Any equality `draws == u128(after)−u128(before)` must occur **only** when family budgets make it so by construction.&#x20;

---

# Critical #2 — “Trace rule” says **`draws = (after − before)`** (cumulative accounting conflated)

**What’s wrong (per your map):** S2.3 §6 (and S2.6 §6 echo) derives `draws` from counter deltas.

## Resolution (normative; put in S2.3 “Trace rule”, echo once in S2.6)

* **Cumulative totals.** For each `(module, substream_label)` stream, the **final** trace row **MUST** carry cumulative totals
  `blocks_total = Σ blocks_event` and `draws_total = Σ draws_event`.
* **Counters certify blocks only.** The stream’s 128-bit counter span **MUST** satisfy
  `u128(last_after) − u128(first_before) = blocks_total`.
  There is **no** identity tying `draws_total` to any counter delta.
* **Validator rule.** Validators (i) sum per-event `blocks`/`draws` to equal the trace totals, and (ii) verify `u128(last_after) − u128(first_before) == blocks_total`.

**(Types/units as in #1.)**

**Scope in S2:** Rewrite **S2.3 §6** to the cumulative form above; remove any “`draws = (after − before)`” language there and in **S2.6 §6**.&#x20;

**Acceptance checks:** Given all event rows for a label: `Σ blocks_event == blocks_total`, `Σ draws_event == draws_total`, and `u128(last_after) − u128(first_before) == blocks_total`. No text remains that derives `draws` from counters.&#x20;

---

# Critical #3 — Pseudocode instructs “`draws` computed as the 128-bit delta”

**What’s wrong (per your map):** S2.3 §9 pseudocode tells `emit_*` to compute `draws` from `(after−before)`; S2.5 examples reinforce it.

## Resolution (normative; adjust S2.3 pseudocode commentary & any “writer pattern” notes)

* **Draws come from the algorithm, not counters.** Each sampler **MUST** compute **`draws_used`** from the realized algorithm path for that event, and the emitter **MUST** copy that value into `draws` **verbatim** (decimal string).
* **Counters advance independently.** The emitter reads `before`, advances the PRNG as required by the sampler calls, then reads `after` and sets `blocks := u128(after)−u128(before)`. `blocks` is **not** used to derive `draws`.
* **Illustrative guidance (non-code).**
  *Box–Muller:* one PRNG block → **two uniforms** → `blocks=1`, `draws="2"`.
  *Gamma (Marsaglia–Tsang):* **`draws_used = 2·J + 1[α<1]`** (actual attempt count `J` realized).
  *Poisson:* inversion vs PTRS as specified; `draws_used` equals uniforms consumed by the chosen regime/attempt.
  (These are budgeting rules only; schemas/paths unchanged.)
* **No back-calculation.** Remove any text that derives `draws` from `before/after` counters.

**(Types/units as in #1.)**

**Scope in S2:** Edit **S2.3 §9** comments; ensure **S2.5 §5** examples show `draws` as an **independent** field (not “`<after−before>`”).&#x20;

**Acceptance checks:** Pseudocode sites compute `draws_used` from the sampler; examples show `blocks` as the counter delta and `draws` matching budget. Include at least one case with **`draws ≠ blocks`** (e.g., Box–Muller) to prove independence.&#x20;

---

# Critical #4 — Lane policy mis-specified (“one increment ⇒ one uniform; do not reuse spare lane”)

**What’s wrong (in S2):** S2.6 declares a global rule that **one counter increment ⇒ one uniform** and forbids using the second lane; this would make Box–Muller advance **two** blocks per normal (wrong).&#x20;

**Binding authority (S0):** For Box–Muller, **use both lanes from the same block**: budget is **`blocks=1`, `draws="2"`**; single-uniform events use low lane, discard high, **`blocks=1`, `draws="1"`**.

## Resolution (normative; place in S2.6 “Uniform & normal primitives”)

* **Lane policy.**
  • **Single-uniform events** (e.g., accept-U in MT98): consume **low lane** `x0` from one Philox block; **discard** `x1`; advance the **counter by 1 block**; set **`draws="1"`, `blocks=1`**.
  • **Two-uniform events** (Box–Muller): consume **both lanes** `x0,x1` from **one** block; advance the **counter by 1 block**; set **`draws="2"`, `blocks=1`**.
  • **No caching/pooling** of lanes across events is permitted.
* **Prose ban.** Remove any wording that states or implies **“one counter increment ⇒ one uniform”** as a global law; that identity only holds for **single-uniform** families.

## Scope of change in S2

* Replace the lane policy paragraph in **S2.6 §4**; adjust any pseudocode that currently calls `u01` **twice** from **two blocks** for Box–Muller—use **one block, two lanes** instead.&#x20;

## Acceptance checks

* In examples/tests, a Box–Muller event **must** show `blocks=1`, `draws="2"`; a single-uniform event shows `blocks=1`, `draws="1"`. No S2 text remains that asserts “one increment ⇒ one uniform” globally. (Matches S0.)&#x20;

## Non-changes

* No change to algorithms, thresholds, or schema—only normative lane usage and wording.

---

# Critical #5 — `u01` mapping uses the forbidden `(x+1)/(2^64+1)` formulation

**What’s wrong (in S2):** S2.6 defines $u=\frac{x+1}{2^{64}+1}$ and the `u01` pseudocode returns `(x+1)/(2^64+1)`.

**Binding authority (S0):** Map to (0,1) via the **binary64 hex-literal multiplier** and never compute `1/(2^64+1)` or decimal constants at runtime:
`u = ((x+1) * 0x1.0000000000000p-64)`.&#x20;

## Resolution (normative; place in S2.6 “Open-interval uniform” & reference impl block)

* **u01 mapping (strict (0,1)).** Given a 64-bit word `x`, compute
  `u := ((x + 1) * 0x1.0000000000000p-64)` (binary64 hex literal).
  Computing `1/(2^64+1)` or using decimal literals is **forbidden**.
* **Constants.** All decision-critical constants used in u01/Box–Muller **must** be provided as **binary64 hex literals**.

## Scope of change in S2

* Replace the formula and the `u01` pseudocode in **S2.6 §4/§10** with the hex-literal form.&#x20;

## Acceptance checks

* Grep of S2 shows **no** occurrences of `(2^64+1)` or decimal substitutes; u01 shows the exact hex literal `0x1.0000000000000p-64`.&#x20;

## Non-changes

* No change to PRNG, budgets, or counters—only the mandated numerical mapping expression.

---

# Critical #6 — `u01` mapping **omits** the required **1.0 clamp**

**What’s wrong (in S2):** Neither the formula nor pseudocode in S2.6 clamps the rare `u==1.0` case.&#x20;

**Binding authority (S0):** After computing `u`, if `u == 1.0` then **set** `u := 0x1.fffffffffffffp-1` (i.e., $1-2^{-53}$). Measure-zero adjustment; budgets unchanged.

## Resolution (normative; append to the u01 mapping in S2.6)

* **Clamp.** After `u := ((x + 1) * 0x1.0000000000000p-64)`, perform:
  `if u == 1.0: u := 0x1.fffffffffffffp-1`.
  This guarantees **strictly** $u\in(0,1)$ in binary64 while **not** affecting `blocks`/`draws`.

## Scope of change in S2

* Add the clamp line to both the **u01 mapping text** and the **reference pseudocode** in **S2.6 §4/§10**.&#x20;

## Acceptance checks

* Property tests show **no** `u` equals 1.0; schema/type `u01` invariants hold; budgets/counters remain identical with and without the clamp (per S0 note).&#x20;

## Non-changes

* No change to sampler math or RNG accounting; this is a numerical hygiene requirement only.

---

These three resolutions realign S2 with the S0 constitution on **lanes** and **u01**, while keeping algorithms, schemas, and budgets untouched. They’re worded so they can be dropped in verbatim and validated mechanically.

---

Locked. I opened the S2 doc and your Criticals files and wrote **normative, implementation-agnostic resolutions** for **Critical #7–#9** that you can drop into S2 verbatim. Each aligns to the frozen S0 numeric/envelope law and cannot introduce new issues.

---

# Critical #7 — Numeric profile drift (**FMA allowed** in S2.2)

**Resolution (normative; replace S2.2 step “1.” and add the policy line):**

* **Floating-point environment (binding).** All computations in S2 that can affect decisions or ordering **MUST** run under the S0 numeric policy: **IEEE-754 binary64**, **RNE** (round-to-nearest ties-even), **FMA disabled**, **FTZ/DAZ disabled**, **deterministic libm profile**, and **fixed-order serial kernels**.

* **No contraction / no reordering / no parallel reduction.** Implementations **MUST NOT** use fused-multiply-add, algebraic reordering/fusion, vectorised/auto-vectorised reductions, or parallel reductions for any dot/accumulator that feeds decisions.

* **Linear predictor evaluation (binding).** Compute
  $\eta^{(\mu)}_m=\beta_\mu^\top x^{(\mu)}_m,\quad \eta^{(\phi)}_m=\beta_\phi^\top x^{(\phi)}_m$
  using a **fixed-order Neumaier** dot in binary64 under the policy above.

* **Exponentiation.** Evaluate $\mu_m=\exp(\eta^{(\mu)}_m)$, $\phi_m=\exp(\eta^{(\phi)}_m)$ with the pinned libm profile.

**Scope in S2:** Replace S2.2 §3(1) (“fused operations permitted”) with the clauses above; add a one-line reminder: **“Numeric policy: as per S0.8 (no FMA/FTZ/DAZ; fixed-order serial kernels).”**

**Acceptance checks:**
Bit-for-bit identical $\eta,\mu,\phi$ across compilers/platforms given the same inputs; builds enabling FMA/FTZ/DAZ, contraction, or parallel reductions are **non-conformant**.

**Non-changes:** No model/feature changes; policy/wording only.

---

# Critical #8 — RNG envelope list **omits `blocks` and `draws`** (S2.5, S2.9)

**Resolution (normative; amend the envelope inventories):**

* **Envelope fields (binding, all RNG events).** Each RNG event row **MUST** include exactly these envelope fields (types shown), before any payload fields:
  `ts_utc` (RFC-3339 UTC with **exactly 6** fractional digits),
  `run_id` (**hex32**),
  `seed` (**uint64**, JSON integer),
  `parameter_hash` (**hex64**),
  `manifest_fingerprint` (**hex64**),
  `module` (registry literal),
  `substream_label` (registry literal),
  `rng_counter_before_lo` (**uint64**), `rng_counter_before_hi` (**uint64**),
  `rng_counter_after_lo` (**uint64**), `rng_counter_after_hi` (**uint64**),
  **`blocks` (**uint64**), `draws` (“uint128-dec” string)**.

* **Link to per-event law.** The envelope **MUST** satisfy the per-event law:
  `blocks = u128(after) − u128(before)`; **`draws` = actual uniforms consumed** by the sampler(s) for that event (independent of counters). (See Critical #1.)

* **Normative examples.** All **normative** S2 examples **MUST** include both `blocks` and `draws` with the exact types above.

**Scope in S2:** Update the envelope lists in **S2.5 §2** and **S2.9 §2** to include `blocks` and `draws` with these types; ensure all normative examples in S2.5/S2.9 show them.

**Acceptance checks:**
Schema/validator require both fields; event rows pass: `u128(after)−u128(before) == blocks` and `draws` present as decimal u128. A grep of S2 shows **no** envelope inventory missing `blocks`/`draws`.

**Non-changes:** No change to paths, partitions, sampler math, or budgets—envelope completeness only.

---

# Critical #9 — **`nb_final` normative example missing `blocks`**

**What’s wrong (in S2):** The **binding** “Wire-format example (normative shape)” for `nb_final` omits `blocks`.
**Binding authority:** Every RNG event envelope includes `blocks:uint64`. For `nb_final` specifically, S2 already states **non-consuming**: `rng_counter_before == rng_counter_after`. Therefore `blocks` **must be 0**.&#x20;

## Resolution (normative; amend the `nb_final` example and its notes)

* **Example requirement (binding):** The `nb_final` JSON example **MUST** include
  `"blocks": 0` **and** `"draws": "0"` *(the latter is covered in Critical #10; mention here for completeness)*, with counters unchanged (`before == after`).
* **Non-consumption law.** Reiterate in the example notes: “`nb_final` is **non-consuming**: `u128(after) == u128(before)` and therefore `blocks == 0`; since no sampler runs, `draws == "0"`.”

**Scope in S2:** Add `"blocks": 0` to the **S2.5 §5** normative `nb_final` example; keep the existing “Envelope constraint (non-consuming)” paragraph and link it to `blocks == 0`.&#x20;

**Acceptance checks:** The normative example shows both fields with correct values/types; validators enforce `before==after` and `blocks==0` for every `nb_final` row.&#x20;

**Non-changes:** No change to event cardinality, partitions, or payload; example is brought into schema conformance.

---

These three resolutions align S2 precisely with your S0/S1 constitution and S2’s own non-consumption rule—without altering algorithms, RNG budgets, partitions, or lineage.

---

Locked. I opened the S2 doc and your Criticals files and wrote **normative, implementation-agnostic resolutions** for **Critical #10–#12**. Each one states exactly how S2 *must* read, where it applies, and the acceptance checks—without introducing any new issues.

---

# Critical #10 — `nb_final` **normative example** missing **`draws`**

## Resolution (normative; amend S2.5 example + notes)

* **Envelope completeness (binding).** Every `nb_final` row **MUST** include
  **`draws`** as a **decimal-encoded uint128 string** (field name `draws`).
* **Non-consuming final (binding).** `nb_final` performs no sampling and does not advance counters; therefore the envelope **MUST** satisfy
  `u128(after) == u128(before)`, **`blocks == 0`**, and **`draws == "0"`**.
* **Example (binding).** Update the S2.5 JSON to show **both**: `"blocks": 0` **and** `"draws": "0"` (with unchanged counters).

**Scope in S2:** S2.5 §5 (**normative** example).
**Acceptance checks:** Schema sees `draws` present (string), validator confirms `before==after`, `blocks==0`, `draws=="0"` on every `nb_final`.
**Non-changes:** No path/partition/sampler changes—example completeness only.

---

# Critical #11 — `ts_utc` precision wrong in the `nb_final` **normative** example

## Resolution (normative; amend S2.5 example)

* **Timestamp format (binding).** In **all RNG event examples**, `ts_utc` **MUST** be RFC-3339 UTC with **exactly 6** fractional digits (microseconds) and trailing `Z`.
  *Example:* `"ts_utc": "2025-08-15T13:22:19.481000Z"`.

* **Surface boundary note (clarifying).** RNG **events** use RFC-3339/6-dp timestamps; **failure records** (not part of S2 RNG streams) may use epoch-ns u64 per S0—do **not** mix formats.

**Scope in S2:** Replace the literal in S2.5 §5; ensure any other **normative** RNG examples keep 6-dp.
**Acceptance checks:** Schema pattern passes for RFC-3339/6-dp; no other edits required.
**Non-changes:** Pure serialization hygiene.

---

# Critical #12 — `seed` typed as **string** in the `nb_final` **normative** example (must be `uint64`)

## Resolution (normative; amend S2.5 example + one line of prose)

* **Type & representation (binding).** `seed` **MUST** be a JSON **integer** that fits in **uint64**; show it unquoted (e.g., `42`). It **MUST NOT** be a UUID/string.
* **Path ↔ embed equality (binding).** Embedded `seed` **MUST** equal the path partition value byte-for-byte in **canonical base-10** (no leading zeros except the single `"0"`).

**Scope in S2:** Change `"seed": "…0042"` → `"seed": 42` in S2.5 §5; add the one-line equality reminder under the example.
**Acceptance checks:** Schema validates integer; dictionary/path equality check passes.
**Non-changes:** RNG/lineage semantics unchanged—example brought into conformance.

---

# Critical #13 — `run_id` not **hex32** in the `nb_final` **normative** example

## Resolution (normative; S2.5 §5 example + reminder)

* **Run-id format (binding).** `run_id` **MUST** be lower-case **hex32** (32 hex chars). It **MUST NOT** be a timestamp or UUID.
* **Path ↔ embed equality (binding).** Embedded `run_id` **MUST** equal the `run_id={…}` path segment byte-for-byte (lower-case hex).
* **Derivation (authority pointer).** The construction of `run_id` is **as per S0**; **do not restate** it here to avoid drift.

**Scope in S2:** Replace the example’s timestamp string with a valid hex32 in S2.5 §5; add the one-line equality reminder.
**Acceptance checks:** Example shows 32-char lower-case hex; schema `$defs/hex32` passes; path and embed match exactly.
**Non-changes:** No change to algorithms, counters, or partitions—serialization only.

---

# Critical #14 — Envelope counters emitted as **strings** (must be `uint64` numbers)

**What’s wrong (in S2):** The `nb_final` example quotes the counter words, e.g., `"rng_counter_before_lo": "00000002"`. These must be **numbers** (`uint64`) by schema. ; schema requires `uint64`.&#x20;

## Resolution (normative; S2.5 §5 example)

* **Counter types.** `rng_counter_before_lo`, `rng_counter_before_hi`, `rng_counter_after_lo`, `rng_counter_after_hi` **MUST** be JSON **integers** (`uint64`); **never** strings. The arithmetic model remains “form 128-bit as (hi<<64)|lo.”&#x20;

**Acceptance checks:** Example renders the four counter fields as integers; schema `uint64` passes.

**Non-changes:** No change to counter semantics or ordering (lo/hi in JSON, arithmetic as (hi,lo)).

---

# Critical #15 — `parameter_hash` / `manifest_fingerprint` truncated (must be full **hex64**)

**What’s wrong (in S2):** The example uses `"3aa1f3…c0de"` and `"a9c6…6f"` (ellipsis), but S0 fixes both as **hex64** (64 hex chars). ; authority in S0.2.2/2.3 and schema `$defs/hex64`.

## Resolution (normative; S2.5 §5 example)

* **Digest encodings.** `parameter_hash` and `manifest_fingerprint` **MUST** be full lower-case **hex64** (no ellipsis/truncation, no `0x`). Authority: **S0.2.2 / S0.2.3** and **schemas.layer1.yaml#/\$defs/hex64**.

**Acceptance checks:** Example shows 64-char hex for both fields; schema patterns pass.

**Non-changes:** No change to lineage keys or partitioning; this is example correctness only.

---

# Critical #16 — Abort semantics vs emission order (self-contradiction)

**What’s wrong (in S2):** Pseudocode **emits** `gamma_component` before computing `λ` and then may raise `ERR_S2_NUMERIC_INVALID`; yet the abort contract says **no S2 events should exist** for that merchant on this error.

## Resolution (normative; S2.3 pseudocode & notes)

* **Emit-only-after-guard.** For the **first attempt of a merchant**, the writer **MUST NOT** emit any S2 event until the numeric guard on `λ` passes. The sequence is:

  1. Draw $G\sim\Gamma(\phi,1)$ **without emitting**; cache $G$ and the **Gamma envelope** `(before, after, blocks, draws)` produced by the sampler.
  2. Compute $\lambda = (\mu/\phi)\cdot G$ in binary64; **if** `!isfinite(λ) || λ ≤ 0`, raise `ERR_S2_NUMERIC_INVALID` and **emit nothing** for that merchant (**no Gamma/Poisson/Final** and **no S2 trace rows** for that merchant).
  3. **Else**, emit `gamma_component` **using the cached envelope verbatim** (payload `(alpha=φ, gamma_value=G, context="nb", index=0)`); then draw Poisson and emit `poisson_component` in the usual order; proceed with the acceptance loop.

* **Scope of “emit-after-guard”.** The guard applies **only** to the “numeric-invalid” condition that aborts the merchant. Normal rejection attempts ($K\in\{0,1\}$) proceed as before (Gamma→Poisson emissions per attempt).

* **Coverage rule unchanged.** For any merchant that does **not** abort, validators still require ≥1 `gamma_component` **and** ≥1 `poisson_component` before the single `nb_final` (which is **non-consuming**).

**Acceptance checks:**
For any merchant that triggers `ERR_S2_NUMERIC_INVALID`, the three S2 streams (**and their traces**) contain **no rows** with that merchant key; for any successful merchant, event ordering remains `gamma`→`poisson` per attempt, with `nb_final` non-consuming at the end. When emitted, the `gamma_component` **must** use the cached `(before, after, blocks, draws)` unchanged.

**Non-changes:**
No change to samplers, budgets, acceptance logic, schemas, partitions, or lineage—only **emission timing** and the requirement to **cache-then-emit** (or discard) to preserve the “no events on abort” rule without partial traces.
