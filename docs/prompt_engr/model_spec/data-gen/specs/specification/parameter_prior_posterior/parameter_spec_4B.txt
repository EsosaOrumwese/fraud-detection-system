<<<PP‑FIX id=1>>
Name: Structural failure Parquet path  
Symbol: structural_failure_<parameter_hash>.parquet  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed artefact pattern  
hyperparameters:
  pattern: "structural_failure_<parameter_hash>.parquet"  
units: file path  
default_policy: abort on any structural error  
justification: Defines the output path for rows failing structural validation.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: structural_validator.py  
function: write_failure_parquet  
description: Emits failed‐row context into the structured Parquet file.

POSTERIOR_VALIDATION:
metric: file existence  
acceptance_range: [true, true]  
sample_size: each validation run  

PROVENANCE_TAG:
artefact_name: structural_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Parquet file path for recording structural validation failures.

TEST_PATHWAY:
test: CI structural‐validation test  
input: generator_output.parquet  
assert: file created when any structural error occurs  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=2>>
Name: Sliding window size  
Symbol: window_size  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed constant  
hyperparameters:
  value: 200000  
units: rows  
default_policy: abort if mis‑sized  
justification: Number of rows (half real, half synthetic) per classifier window.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: adversarial_validator.py  
function: run_sliding_window  
description: Streams data in windows of size `window_size` for AUROC checks.

POSTERIOR_VALIDATION:
metric: window length verification  
acceptance_range: [window_size, window_size]  
sample_size: each validation run  

PROVENANCE_TAG:
artefact_name: adversarial_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Row count per sliding window for adversarial validation.

TEST_PATHWAY:
test: CI window‐size test  
input: validation_stream.log  
assert: each window contains exactly `window_size` rows  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=3>>
Name: AUROC evaluation interval  
Symbol: auroc_interval  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed constant  
hyperparameters:
  value: 1000000  
units: rows  
default_policy: abort if interval mis‑computed  
justification: Frequency (in rows) at which AUROC is computed.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: adversarial_validator.py  
function: evaluate_auroc_periodically  
description: Triggers AUROC check every `auroc_interval` rows.

POSTERIOR_VALIDATION:
metric: check scheduling  
acceptance_range: [true, true]  
sample_size: validation run  

PROVENANCE_TAG:
artefact_name: adversarial_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Row interval for periodic AUROC evaluations.

TEST_PATHWAY:
test: CI AUROC‐interval test  
input: adversarial_stats.log  
assert: AUROC computed at every `auroc_interval`  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=4>>
Name: AUROC failure threshold  
Symbol: auroc_cut  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed constant  
hyperparameters:
  value: 0.55  
units: proportion  
default_policy: abort on breach  
justification: Maximum tolerable AUROC before CI failure.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: adversarial_validator.py  
function: check_auroc_threshold  
description: Aborts validation if AUROC ≥ `auroc_cut`.

POSTERIOR_VALIDATION:
metric: AUROC value  
acceptance_range: [0.0, auroc_cut]  
sample_size: each evaluation  

PROVENANCE_TAG:
artefact_name: adversarial_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Threshold for adversarial classifier AUROC.

TEST_PATHWAY:
test: CI AUROC‐threshold test  
input: adversarial_stats.log  
assert: AUROC < `auroc_cut`  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=5>>
Name: Semantic‑GLM dispersion corridor  
Symbol: θ_cp_bounds, θ_cnp_bounds  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed constants  
hyperparameters:
  θ_cp_lower: 1  
  θ_cp_upper: 2  
  θ_cnp_lower: 2  
  θ_cnp_upper: 4  
units: dimensionless  
default_policy: abort on breach  
justification: Acceptable over‑dispersion corridors for Poisson GLM.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: semantic_glm.py  
function: validate_dispersion  
description: Ensures fitted dispersion θ lies within specified bounds.

POSTERIOR_VALIDATION:
metric: dispersion check  
acceptance_range: [θ_lower, θ_upper]  
sample_size: per‑channel fit  

PROVENANCE_TAG:
artefact_name: semantic_glm.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
GLM dispersion bounds for card‑present and CNP channels.

TEST_PATHWAY:
test: CI dispersion‐bounds test  
input: glm_fit_stats.log  
assert: θ ∈ [bounds] for each channel  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=6>>
Name: GLM θ‑violation PDF path  
Symbol: glm_theta_violation.pdf  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed artefact pattern  
hyperparameters:
  filename: glm_theta_violation.pdf  
units: file path  
default_policy: abort on generation  
justification: Output PDF when dispersion breaches corridor.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: semantic_glm.py  
function: emit_violation_pdf  
description: Writes PDF illustrating predicted vs observed counts.

POSTERIOR_VALIDATION:
metric: file existence  
acceptance_range: [true, true]  
sample_size: each violation event  

PROVENANCE_TAG:
artefact_name: semantic_glm.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
PDF path for GLM dispersion violations.

TEST_PATHWAY:
test: CI PDF‐generation test  
input: semantic_glm.log  
assert: PDF created upon θ breach  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=7>>
Name: Barcode slope acceptance band  
Symbol: slope_bounds  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed constants  
hyperparameters:
  lower: -1.0  
  upper: -0.5  
units: minutes per hour  
default_policy: abort on breach  
justification: Acceptable slope range for Hough‐transform offset test.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: barcode_validator.py  
function: check_barcode_slope  
description: Fails if dominant slope ∉ [lower, upper].

POSTERIOR_VALIDATION:
metric: slope violation count  
acceptance_range: [0, 0]  
sample_size: each merchant  

PROVENANCE_TAG:
artefact_name: barcode_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Slope tolerance for barcode offset‑UTC test.

TEST_PATHWAY:
test: CI barcode‐slope test  
input: barcode_stats.log  
assert: no slope outside bounds  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=8>>
Name: Barcode failure PNG path  
Symbol: barcode_failure_<merchant_id>.png  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed artefact pattern  
hyperparameters:
  pattern: "barcode_failure_<merchant_id>.png"  
units: file path  
default_policy: abort on generation  
justification: Heat‐map output for barcode slope failures.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: barcode_validator.py  
function: emit_failure_image  
description: Saves failure overlay as PNG.

POSTERIOR_VALIDATION:
metric: file existence  
acceptance_range: [true, true]  
sample_size: each failure  

PROVENANCE_TAG:
artefact_name: barcode_validator.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
PNG path for barcode slope failure visualizations.

TEST_PATHWAY:
test: CI barcode‐image test  
input: barcode_stats.log  
assert: PNG created upon slope failure  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=9>>
Name: Licence‑mismatch guard  
Symbol: N/A  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed CI check  
hyperparameters:
  manifest_field: licence_digests  
units: N/A  
default_policy: abort on mismatch  
justification: Verifies manifest‑recorded SHA‑1 matches licence files.

CALIBRATION_RECIPE:
input_path: manifest.json  
objective: Not applicable  
algorithm: SHA‑1 recomputation  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: validate_licences.py  
function: check_licence_hashes  
description: Recomputes and compares licence file SHA‑1 digests.

POSTERIOR_VALIDATION:
metric: mismatch count  
acceptance_range: [0, 0]  
sample_size: all licences  

PROVENANCE_TAG:
artefact_name: validate_licences.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
CI guard for licence SHA‑1 consistency.

TEST_PATHWAY:
test: CI licence‐guard test  
input: licence_files  
assert: all SHA‑1 match manifest  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=10>>
Name: Final validation pass flag  
Symbol: validation_passed  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed manifest field  
hyperparameters:
  value: true  
units: boolean  
default_policy: abort on false  
justification: Indicates all validation checks passed.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: upload_to_hashgate.py  
function: append_validation_flag  
description: Adds `validation_passed=true` to manifest when tests succeed.

POSTERIOR_VALIDATION:
metric: manifest field check  
acceptance_range: [true, true]  
sample_size: one upload  

PROVENANCE_TAG:
artefact_name: upload_to_hashgate.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
Manifest flag for final validation success.

TEST_PATHWAY:
test: CI validation-pass test  
input: manifest.json  
assert: `validation_passed` is true  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=11>>
Name: HashGate upload directory  
Symbol: /hashgate/<parameter_hash>/<master_seed>  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed URI pattern  
hyperparameters:
  pattern: "/hashgate/<parameter_hash>/<master_seed>"  
units: URI  
default_policy: abort on failure  
justification: Endpoint for posting validation artefacts.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: upload_to_hashgate.py  
function: post_to_hashgate  
description: Uploads bundle to HashGate URI.

POSTERIOR_VALIDATION:
metric: HTTP status code  
acceptance_range: [200, 200]  
sample_size: one upload  

PROVENANCE_TAG:
artefact_name: upload_to_hashgate.py  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
HashGate REST endpoint for validation uploads.

TEST_PATHWAY:
test: CI upload‐directory test  
input: none  
assert: receive 200 OK  

Confidence=HIGH
<<<END PP‑FIX>>>

<<<PP‑FIX id=12>>
Name: CI merge‑block condition  
Symbol: N/A  
Scope: validation  
---------------------------------

PRIOR:
type: Fixed CI contract  
hyperparameters:
  workflow: GitHub Actions  
units: N/A  
default_policy: abort on contract violation  
justification: Prevents merge until byte‑for‑byte manifest match.

CALIBRATION_RECIPE:
input_path: N/A  
objective: Not applicable  
algorithm: Not applicable  
random_seed: N/A  
convergence_tol: N/A  
script_digest: N/A  

INTERFACE_CONSUMER:
artefact_name: .github/workflows/validate.yml  
function: enforce_merge_condition  
description: Polls HashGate and blocks merge until validation_passed=true.

POSTERIOR_VALIDATION:
metric: manifest match  
acceptance_range: [true, true]  
sample_size: one merge event  

PROVENANCE_TAG:
artefact_name: .github/workflows/validate.yml  
sha256: <to‑be‑populated>  

SHORT_DESCRIPTION:
CI rule enforcing immutable manifest match before merge.

TEST_PATHWAY:
test: CI merge‐guard test  
input: none  
assert: merge blocked until validation_passed  

Confidence=HIGH
<<<END PP‑FIX>>>

##### END PARAMETER_SPEC #####

id=1  | gaps_closed=none | notes=Structural failure path spec complete  
id=2  | gaps_closed=none | notes=Window size spec complete  
id=3  | gaps_closed=none | notes=AUROC interval spec complete  
id=4  | gaps_closed=none | notes=AUROC threshold spec complete  
id=5  | gaps_closed=none | notes=GLM dispersion corridor spec complete  
id=6  | gaps_closed=none | notes=Theta‐violation PDF path spec complete  
id=7  | gaps_closed=none | notes=Barcode slope band spec complete  
id=8  | gaps_closed=none | notes=Barcode failure PNG path spec complete  
id=9  | gaps_closed=none | notes=Licence mismatch guard spec complete  
id=10 | gaps_closed=none | notes=Validation pass flag spec complete  
id=11 | gaps_closed=none | notes=HashGate URI pattern spec complete  
id=12 | gaps_closed=none | notes=CI merge condition spec complete  
<<PS‑END>>