<<<PP‑FIX id=1>
Name: Polygon nudge distance (border tie-break)
Symbol: $\varepsilon$
Scope: merchant_location
---------------------------------

PRIOR:
type: Deterministic constant (YAML-governed)
hyperparameters:
nudge_distance_degrees: 0.0001
units: degrees (decimal lat/lon)
default_policy: abort
justification: Fixed scalar nudge, governed in `config/timezone/tz_nudge.yml`, enforces reproducible tie-break at borders.
CALIBRATION_RECIPE:
input_path: config/timezone/tz_nudge.yml
objective: not applicable (manual, not fitted)
algorithm: not applicable
random_seed: not applicable
convergence_tol: not applicable
script_digest: (see artefact YAML digest field)
INTERFACE_CONSUMER:
artefact_name: config/timezone/tz_nudge.yml
function: STR-tree tie-break, spatial lookup in site assignment
description: Consumed by spatial engine to resolve border cases with deterministic nudge; logged per site.
POSTERIOR_VALIDATION:
metric: CI check, nudge event audit log
acceptance_range: nudge applied as configured, all tie-breaks logged
sample_size: all tie-break events
PROVENANCE_TAG:
artefact_name: config/timezone/tz_nudge.yml
sha256: (see artefact YAML digest field)
SHORT_DESCRIPTION:
Scalar nudge in degrees to deterministically resolve tie-breaks between polygons on borders.
TEST_PATHWAY:
test: CI replay, event audit
input: site catalogue, event logs
assert: All tie-breaks resolve as specified, log matches
Confidence=HIGH
<<<END PP‑FIX>>

<<<PP‑FIX id=2>
Name: Simulation horizon (time zone timeline extraction)
Symbol: $[s, e]$
Scope: merchant_location
---------------------------------

PRIOR:
type: Deterministic interval (YAML-governed)
hyperparameters:
sim_start_iso8601: (as set in config/timezone/simulation_horizon.yml)
sim_end_iso8601: (as set in config/timezone/simulation_horizon.yml)
units: epoch milliseconds (int64)
default_policy: abort
justification: Simulation bounds are governed, parsed from YAML and enforced by CI and manifest digest.
CALIBRATION_RECIPE:
input_path: config/timezone/simulation_horizon.yml
objective: not applicable (manual interval, not fitted)
algorithm: not applicable
random_seed: not applicable
convergence_tol: not applicable
script_digest: (see artefact YAML digest field)
INTERFACE_CONSUMER:
artefact_name: config/timezone/simulation_horizon.yml
function: Truncates extracted TZ transition tables, controls build cache/memory
description: Consumed by TZ extraction to limit memory and event range; aborts on OOB access.
POSTERIOR_VALIDATION:
metric: CI horizon bounds check, memory test
acceptance_range: all transition events $\in$ $[s, e]$; memory under threshold
sample_size: all events per build
PROVENANCE_TAG:
artefact_name: config/timezone/simulation_horizon.yml
sha256: (see artefact YAML digest field)
SHORT_DESCRIPTION:
Simulation start/end for time zone rule extraction; constrains memory and validity of all timestamps.
TEST_PATHWAY:
test: CI, memory gauge, horizon check
input: site table, transition log, memory stats
assert: No event exceeds horizon, memory under cap
Confidence=HIGH
<<<END PP‑FIX>>

<<<PP‑FIX id=3>
Name: DST legality gap duration
Symbol: $\Delta$
Scope: merchant_location
---------------------------------

PRIOR:
type: Derived constant (computed from tzdata offset transitions)
hyperparameters:
Computed: $\Delta = (o_{i+1} - o_i)\times60$
units: seconds (int64)
default_policy: abort
justification: Calculated per transition, used to legalize spring-forward event times.
CALIBRATION_RECIPE:
input_path: artefacts/priors/tzdata/tzdata2025a.tar.gz
objective: not applicable (computed directly)
algorithm: not applicable
random_seed: not applicable
convergence_tol: not applicable
script_digest: (see artefact YAML digest field)
INTERFACE_CONSUMER:
artefact_name: artefacts/priors/tzdata/tzdata2025a.tar.gz
function: Used by local-to-UTC mapping and legality check in event time calculation
description: Ensures all event times are legal w.r.t. DST transitions, gap is logged and corrected as needed.
POSTERIOR_VALIDATION:
metric: DST legality audit, event log check
acceptance_range: all illegal times corrected; all corrections logged
sample_size: all affected sites/events
PROVENANCE_TAG:
artefact_name: artefacts/priors/tzdata/tzdata2025a.tar.gz
sha256: (see artefact YAML digest field)
SHORT_DESCRIPTION:
Forward gap (spring-forward) in seconds between DST offset transitions; governs time legality and event correction.
TEST_PATHWAY:
test: CI legality check, event log replay
input: event log, site table
assert: All illegal events detected and corrected per spec
Confidence=HIGH
<<<END PP‑FIX>>

<<<PP‑FIX id=4>
Name: Fold disambiguation hash
Symbol: $h = \mathrm{SHA256}(B)$, $\mathrm{fold} = h[0]\bmod2$
Scope: merchant_location
---------------------------------

PRIOR:
type: Deterministic hash function (uses global_seed)
hyperparameters:
global_seed: (from manifest, 128-bit hex)
units: integer {0, 1}
default_policy: abort
justification: Ensures fall-back DST folds are assigned deterministically and reproducibly using site+time.
CALIBRATION_RECIPE:
input_path: docs/rng_proof.md
objective: not applicable
algorithm: not applicable
random_seed: not applicable
convergence_tol: not applicable
script_digest: (see manifest digest for rng_proof_digest)
INTERFACE_CONSUMER:
artefact_name: docs/rng_proof.md
function: Assigns DST fall-back fold bit per event
description: Consumed by event time pipeline to disambiguate ambiguous local times; logged for audit.
POSTERIOR_VALIDATION:
metric: audit log, replay check, formal proof
acceptance_range: bitwise replay match, proof digest
sample_size: all fall-back events per build
PROVENANCE_TAG:
artefact_name: docs/rng_proof.md
sha256: (see manifest rng_proof_digest)
SHORT_DESCRIPTION:
Hash function for deterministic DST fall-back disambiguation; parity computed on seed+site+time.
TEST_PATHWAY:
test: Event log replay, proof check
input: event log, manifest, docs/rng_proof.md
assert: All fold bits match proof, no drift
Confidence=HIGH
<<<END PP‑FIX>>

<<<PP‑FIX id=5>
Name: Memory ceiling for in-memory zone cache
Symbol: $\mathrm{tz\_cache\_bytes} < 8 \times 2^{20}$
Scope: merchant_location
---------------------------------

PRIOR:
type: Deterministic policy constant
hyperparameters:
ceiling_bytes: 8,388,608
units: bytes (int64)
default_policy: abort
justification: Ensures full build is memory-bounded and reproducible, with overage causing abort.
CALIBRATION_RECIPE:
input_path: output/tz_cache_bytes.txt
objective: not applicable
algorithm: not applicable
random_seed: not applicable
convergence_tol: not applicable
script_digest: (see artefact digest field)
INTERFACE_CONSUMER:
artefact_name: output/tz_cache_bytes.txt
function: Consumed by build validation; manifests enforce memory contract
description: All in-memory timetables checked against threshold at build end; excess aborts and logs error.
POSTERIOR_VALIDATION:
metric: CI memory gauge, manifest check
acceptance_range: bytes < 8,388,608
sample_size: per build
PROVENANCE_TAG:
artefact_name: output/tz_cache_bytes.txt
sha256: (see artefact YAML digest field)
SHORT_DESCRIPTION:
Maximum memory size for all cached time zone timetables; aborts if exceeded.
TEST_PATHWAY:
test: CI build, memory check
input: output log, manifest
assert: Cache memory usage < ceiling, log passes
Confidence=HIGH
<<<END PP‑FIX>>

##### END PARAMETER_SPEC #####

id=1 | gaps_closed=prior|calib|post|prov | notes=Constant from YAML, all events logged and audited  
id=2 | gaps_closed=prior|calib|post|prov | notes=Interval set in YAML, all transitions CI checked  
id=3 | gaps_closed=prior|calib|post|prov | notes=Derived per transition, enforced in all DST legality checks  
id=4 | gaps_closed=prior|calib|post|prov | notes=Fully deterministic, proof in manifest  
id=5 | gaps_closed=prior|calib|post|prov | notes=Policy threshold, CI/memory log, enforced at build  
<<PS‑END>>
