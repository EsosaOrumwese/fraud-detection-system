<<<IC-FIX id=1>
Stage: DeriveIsVirtual
INPUT_ARTIFACT:
name: merchant_master
path_pattern: s3://data-engine/processed/merchant_master/merchant_master.parquet  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "merchant_master",
  "type": "record",
  "fields": [
    {"name":"merchant_id","type":"string","nullable":false},
    {"name":"is_virtual","type":"boolean","nullable":false},
    {"name":"other_attributes","type":{"type":"map","values":"string"},"nullable":true}
  ]
}
INPUT_ARTIFACT:
name: mcc_channel_rules
path_pattern: s3://data-engine/config/virtual/mcc_channel_rules.yaml  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "mcc_channel_rules",
  "type": "record",
  "fields": [
    {"name":"mcc_channel","type":"string","nullable":false},
    {"name":"is_virtual","type":"boolean","nullable":false}
  ]
}
OUTPUT_ARTIFACT:
name: merchant_master_virtual
path_pattern: s3://data-engine/processed/merchant_master/merchant_master_virtual.parquet  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "merchant_master_virtual",
  "type": "record",
  "fields": [
    {"name":"merchant_id","type":"string","nullable":false},
    {"name":"is_virtual","type":"boolean","nullable":false},
    {"name":"other_attributes","type":{"type":"map","values":"string"},"nullable":true}
  ]
}
PARTITIONING:
keys: ["merchant_id"]
order_by: ["merchant_id"]
SUCCESS_METRIC:
metric_name: is_virtual_byte_match       # flags in output == YAML lookup
expected_range: [1,1]
ERROR_POLICY:
error_code: DeriveIsVirtualError
retry_max: 1
retry_backoff_sec: 30
idempotent: true
SCHEMA_VERSION:
version: v1.0.0-draft
ACCESS_POLICY:
read_policy: analytics-team-read  # placeholder
write_policy: allocation-team-write  # placeholder
CONSUMED_BY:
module: DeriveIsVirtualModule
function: deriveIsVirtual
description: Labels merchants as virtual based on MCC-channel rules
TEST_PATHWAY:
test_type: integration
tool: pytest
script: tests/test_derive_is_virtual.py  # CI test to be implemented after pipeline is in place
assertion: is_virtual flags match mcc_channel_rules
Confidence=MEDIUM
<<<END IC-FIX>>>

<<<IC-FIX id=2>
Stage: CreateSettlementNode
INPUT_ARTIFACT:
name: virtual_settlement_coords
path_pattern: s3://data-engine/artefacts/virtual/virtual_settlement_coords.csv  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "virtual_settlement_coords",
  "type": "record",
  "fields": [
    {"name":"merchant_id","type":"string","nullable":false},
    {"name":"latitude","type":"double","nullable":false},
    {"name":"longitude","type":"double","nullable":false}
  ]
}
OUTPUT_ARTIFACT:
name: settlement_node_catalogue
path_pattern: s3://data-engine/edge_catalogue/settlement_node/{merchant_id}.parquet
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "settlement_node_catalogue",
  "type": "record",
  "fields": [
    {"name":"merchant_id","type":"string","nullable":false},
    {"name":"site_id","type":"string","nullable":false},
    {"name":"latitude","type":"double","nullable":false},
    {"name":"longitude","type":"double","nullable":false},
    {"name":"evidence_url","type":"string","nullable":false}
  ]
}
PARTITIONING:
keys: ["merchant_id"]
order_by: ["site_id"]
SUCCESS_METRIC:
metric_name: row_count
expected_range: [1,1]
ERROR_POLICY:
error_code: CreateSettlementNodeError
retry_max: 3
retry_backoff_sec: 60
idempotent: true
SCHEMA_VERSION:
version: v1.0.0-draft
ACCESS_POLICY:
read_policy: virtual-team-read  # placeholder
write_policy: processing-team-write  # placeholder
CONSUMED_BY:
module: CreateSettlementNodeModule
function: createSettlementNode
description: Generates settlement node site for each virtual merchant
TEST_PATHWAY:
test_type: integration
tool: pytest
script: tests/test_create_settlement_node.py  # CI test to be implemented after pipeline is in place
assertion: one site per virtual merchant created
Confidence=MEDIUM
<<<END IC-FIX>>>

<<<IC-FIX id=3>
Stage: BuildEdgeCatalogue
INPUT_ARTIFACT:
name: cdn_weights_config
path_pattern: s3://data-engine/config/virtual/cdn_country_weights.yaml  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "cdn_weights_config",
  "type": "record",
  "fields": [
    {"name":"country_iso","type":"string","nullable":false},
    {"name":"q_c","type":"double","nullable":false}
  ]
}
INPUT_ARTIFACT:
name: hrsl_raster
path_pattern: s3://data-engine/artefacts/rasters/hrsl_100m.tif  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{ "type": "binary" }
OUTPUT_ARTIFACT:
name: edge_catalogue
path_pattern: s3://data-engine/edge_catalogue/{merchant_id}.parquet
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "edge_catalogue",
  "type": "record",
  "fields": [
    {"name":"edge_id","type":"string","nullable":false},
    {"name":"country_iso","type":"string","nullable":false},
    {"name":"tzid","type":"string","nullable":false},
    {"name":"latitude","type":"double","nullable":false},
    {"name":"longitude","type":"double","nullable":false},
    {"name":"edge_weight","type":"int","nullable":false},
    {"name":"virtual_universe_hash","type":"string","nullable":false}
  ]
}
OUTPUT_ARTIFACT:
name: merchant_master_virtual
path_pattern: s3://data-engine/logs/edge_progress.log
sha256: <to-be-populated-on-build>  # placeholder
PARTITIONING:
keys: ["edge_id"]
order_by: ["edge_id"]
SUCCESS_METRIC:
metric_name: edge_size_bounds            # 50 ≤ rowcount ≤ 800
expected_range: [1,1]
ERROR_POLICY:
error_code: EdgeCatalogueError
retry_max: 1
retry_backoff_sec: 30
idempotent: true
SCHEMA_VERSION:
version: v1.0.0-draft
ACCESS_POLICY:
read_policy: processing-team-read  # placeholder
write_policy: allocation-team-write  # placeholder
CONSUMED_BY:
module: BuildEdgeCatalogueModule
function: buildEdgeCatalogue
description: Creates per-merchant edge-node catalogue from raster and weights
TEST_PATHWAY:
test_type: integration
tool: pytest
script: tests/test_build_edge_catalogue.py  # CI test to be implemented after pipeline is in place
assertion: edge catalogue contains expected columns and count
Confidence=MEDIUM
<<<END IC-FIX>>>

<<<IC-FIX id=Hash>>
Stage: ComputeVirtualUniverseHash
INPUT_ARTIFACT:
  name: cdn_weights_yaml
  path_pattern: s3://data-engine/config/virtual/cdn_country_weights.yaml
  sha256: <to-be-populated-on-build>
INPUT_ARTIFACT:
  name: edge_catalogue
  path_pattern: s3://data-engine/edge_catalogue/{merchant_id}.parquet
  sha256: <to-be-populated-on-build>
INPUT_ARTIFACT:
  name: virtual_rules_yaml
  path_pattern: s3://data-engine/config/virtual/mcc_channel_rules.yaml
  sha256: <to-be-populated-on-build>
OUTPUT_ARTIFACT:
  name: virtual_universe_hash_digest
  path_pattern: s3://data-engine/edge_catalogue/{merchant_id}_virtual_hash.txt
  sha256: <to-be-populated-on-build>
SUCCESS_METRIC:
  metric_name: digest_length_64
  expected_range: [1,1]
<<<END IC-FIX>>

<<<IC-FIX id=4>
Stage: BuildCdnAliasTable
INPUT_ARTIFACT:
name: edge_catalogue
path_pattern: s3://data-engine/edge_catalogue/{merchant_id}.parquet
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{ "type": "binary" }
INPUT_ARTIFACT:
  name: virtual_universe_hash_digest
  path_pattern: s3://data-engine/edge_catalogue/{merchant_id}_virtual_hash.txt
  sha256: <to-be-populated-on-build>
INPUT_ARTIFACT:
name: rng_policy
path_pattern: s3://data-engine/config/routing/rng_policy.yml  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "rng_policy",
  "type": "record",
  "fields": [
    {"name":"seed_offset","type":"long","nullable":false},
    {"name":"stride_limit","type":"int","nullable":false}
  ]
}
OUTPUT_ARTIFACT:
name: cdn_alias_npz
path_pattern: s3://data-engine/{merchant_id}_cdn_alias.npz  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{ "type": "binary" }
OUTPUT_ARTIFACT:
name: virtual_error_log
path_pattern: s3://data-engine/logs/virtual_error.log
sha256: <to-be-populated-on-build>  # placeholder
PARTITIONING:
keys: []
order_by: []
SUCCESS_METRIC:
metric_name: universe_hash_match          # NPZ attr equals digest
expected_range: [1,1]
ERROR_POLICY:
error_code: CdnAliasError
retry_max: 3
retry_backoff_sec: 60
idempotent: true
SCHEMA_VERSION:
version: v1.0.0-draft
ACCESS_POLICY:
read_policy: processing-team-read  # placeholder
write_policy: routing-team-write  # placeholder
CONSUMED_BY:
module: BuildCdnAliasTableModule
function: buildCdnAliasTable
description: Generates CDN alias tables incorporating virtual universe hash
TEST_PATHWAY:
test_type: integration
tool: pytest
script: tests/test_build_cdn_alias_table.py  # CI test to be implemented after pipeline is in place
assertion: cdn alias file exists and virtual_universe_hash recorded
Confidence=MEDIUM
<<<END IC-FIX>>>

<<<IC-FIX id=5>
Stage: ValidateVirtual
INPUT_ARTIFACT:
name: virtual_validation_config
path_pattern: s3://data-engine/config/virtual/virtual_validation.yml  # path reserved by spec.
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "virtual_validation_config",
  "type": "record",
  "fields": [
    {"name":"days","type":"int","nullable":false},
    {"name":"tolerance","type":"double","nullable":false}
  ]
}
OUTPUT_ARTIFACT:
name: validate_virtual_log
path_pattern: s3://data-engine/logs/validate_virtual.log
sha256: <to-be-populated-on-build>  # placeholder
schema: |
{
  "name": "validate_virtual_log",
  "type": "record",
  "fields": [
    {"name":"merchant_id","type":"string","nullable":false},
    {"name":"date","type":"string","nullable":false},
    {"name":"pi_diff_exceeded","type":"boolean","nullable":false},
    {"name":"details","type":"string","nullable":true}
  ]
}
PARTITIONING:
keys: []
order_by: []
SUCCESS_METRIC:
metric_name: validation_pass
expected_range: [1,1]
ERROR_POLICY:
error_code: VirtualValidationError
retry_max: 0
retry_backoff_sec: 0
idempotent: true
SCHEMA_VERSION:
version: v1.0.0-draft
ACCESS_POLICY:
read_policy: virtual-team-read  # placeholder
write_policy: audit-team-write  # placeholder
CONSUMED_BY:
module: ValidateVirtualModule
function: validateVirtual
description: Validates virtual merchant output against configured tolerance
TEST_PATHWAY:
test_type: property-based
tool: custom
script: tests/property_test_validate_virtual.py  # CI test to be implemented after pipeline is in place
assertion: no pi_diff_exceeded true beyond tolerance
Confidence=MEDIUM
<<<END IC-FIX>>

<<<IC-FIX id=PatchSchema>>
Stage: PatchTransactionSchema
INPUT_ARTIFACT:
name: transaction_schema
path_pattern: s3://data-engine/schema/transaction_schema.avsc
sha256: <to-be-populated-on-build>
OUTPUT_ARTIFACT:
name: patched_transaction_schema
path_pattern: s3://data-engine/schema/transaction_schema.avsc
sha256: <to-be-populated-on-build>
SUCCESS_METRIC:
metric_name: schema_fields_present          # confirms four new nullable fields
expected_range: [1,1]
DESCRIPTION: Adds tzid_settlement, tzid_operational, ip_latitude, ip_longitude (nullable) to AVSC.
<<<END IC-FIX>>}

##### END INTERFACE_CONTRACT_SPEC #####

id=1 | gaps_closed=partition|metric|schema_version|access|test | notes=Added partitioning, metrics, version, access, tests  
id=2 | gaps_closed=partition|metric|schema_version|access|test | notes=Defined partition, success metric, version, access, tests  
id=3 | gaps_closed=partition|metric|schema_version|access|test | notes=Closed schema, partition, metric, version, access, tests  
id=4 | gaps_closed=schema|metric|schema_version|access|test | notes=Added binary schema, metrics, version, access, tests  
id=5 | gaps_closed=output|schema|metric|schema_version|access|test | notes=Specified log output, schema, metric, version, access, tests  
<<IS-END>>  