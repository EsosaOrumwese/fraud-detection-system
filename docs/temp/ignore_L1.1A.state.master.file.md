# Layer 1 â€” 1A Master (BYTE-EXACT with unique separators)

## Table of Contents

- [state.1A.s0.expanded.txt](#state-1a-s0-expanded)
- [state.1A.s1.expanded.txt](#state-1a-s1-expanded)
- [state.1A.s2.expanded.txt](#state-1a-s2-expanded)
- [state.1A.s3.expanded.txt](#state-1a-s3-expanded)
- [state.1A.s4.expanded.txt](#state-1a-s4-expanded)
- [state.1A.s5.expanded.txt](#state-1a-s5-expanded)
- [state.1A.s6.expanded.txt](#state-1a-s6-expanded)
- [state.1A.s7.expanded.txt](#state-1a-s7-expanded)
- [state.1A.s8.expanded.txt](#state-1a-s8-expanded)
- [state.1A.s9.expanded.txt](#state-1a-s9-expanded)

[[[MASTER-SEP-1A]]]

<a id="state-1a-s0-expanded"></a>
# state.1A.s0.expanded.txt

<!-- Source file: state.1A.s0.expanded.v1.2.txt | BYTE-EXACT EMBED -->

# S0.1 â€” Universe, Symbols, Authority (normative, fixed)

## Purpose & scope

S0.1 establishes the **canonical universe** (merchant rows and reference datasets) and the **schema authority** for subsegment 1A. Its job is to make the rest of S0â€“S9 reproducible by fixing the domain symbols and where their truth comes from. **No RNG is consumed here.**

**S0.1 freezes for the run**

* The merchant universe $\mathcal{M}$ from the **normalised ingress** table `merchant_ids`.
* The immutable **reference artefacts**: ISO-3166 country set $\mathcal{I}$; GDP-per-capita vintage $G$ pinned to **2025-04-15**; a precomputed Jenks $K{=}5$ GDP bucket map $B$.
* The **schema authority**: only JSON-Schema contracts in `schemas.ingress.layer1.yaml`, `schemas.1A.yaml`, and shared RNG/event schemas in `schemas.layer1.yaml` are authoritative; Avro (if any) is **non-authoritative**.

> Downstream consequence (normative): **inter-country order is not encoded in `outlet_catalogue`**; consumers **MUST** join **`s3_candidate_set.candidate_rank`** to obtain the cross-country selection order. S0.1 records that rule as part of the authority (S3 is the sole authority for cross-country order).

---

## Domain symbols (definitions and types)

### Merchants (ingress universe)

Let $\mathcal{M}$ be the finite set of merchants from the normalised ingress table:

$$
\texttt{merchant\_ids}\subset\{(\texttt{merchant\_id},\ \texttt{mcc},\ \texttt{channel},\ \texttt{home\_country\_iso})\},
$$

validated by `schemas.ingress.layer1.yaml#/merchant_ids`.

**Field domains (authoritative and reused throughout 1A):**

* `merchant_id`: **opaque identifier** (id64 integer, per ingress schema). For all places in 1A that require a 64-bit integer key (e.g., RNG substream keys), the **only** mapping is:

  ```
  merchant_u64 = LOW64(SHA256(LE64(merchant_id)))
  ```
  where `LOW64` takes **bytes 24..31** of the 32-byte SHA-256 digest, interpreted as little-endian u64. **No string formatting** is ever used in this mapping. 

* `mcc`: 4-digit MCC code: **int32 in [0,9999]** per `merchant_ids.mcc` in the ingress schema. (If an enumerated ISO-18245 catalogue is adopted later, this spec will reference that artefact explicitly.)

* `channel âˆˆ ð•®`: card-present vs not-present. **Canonical internal symbols:** `CP`, `CNP`. **Ingress mapping (normative):**

  | Ingress value (string) | Internal symbol |
  |------------------------|-----------------|
  | `"card_present"`       | `CP`            |
  | `"card_not_present"`   | `CNP`           |

  Any other value is a schema violation at S0.1.

* `home_country_iso âˆˆ ð•€`: ISO-3166 alpha-2 code, **uppercase ASCII**. Foreign-key to ð•€ is enforced **here** (not â€œlaterâ€).

### Canonical references (immutable within the run)

* **Countries:** $\mathcal{I}$ = ISO-3166 alpha-2 country list (finite, determined by the pinned reference).
* **GDP (per-capita) map:** $G:\mathcal{I}\rightarrow\mathbb{R}_{>0}$, **pinned to 2025-04-15** (fixes both values and coverage).
* **GDP bucket map:** $B:\mathcal{I}\rightarrow{1,\dots,5}$ â€” a precomputed Jenks $K=5$ classification over $G$. (S0.4 documents the CI-only rebuild; for S0.1 this artefact is immutable input.)

### Derived per-merchant tuple

For $m\in\mathcal{M}$, define the typed quadruple used downstream:

$$
t(m):=\big(\texttt{mcc}_m,\ \texttt{channel}_m\in\{\mathrm{CP},\mathrm{CNP}\},\ \texttt{home\_country\_iso}_m,\ \texttt{merchant\_u64}_m\big)\in\mathcal{K}\times\mathcal{C}\times\mathcal{I}\times\mathbb{U}_{64}.
$$

---

## Authority & contracts (single source of truth)

### Authoritative schemas for 1A

Only **JSON-Schema** is the source of truth for 1A. All dataset contracts and RNG event contracts must refer to these paths (JSON Pointer fragments):

* Ingress: `schemas.ingress.layer1.yaml#/merchant_ids`.
* 1A model/prep/alloc/egress: `schemas.1A.yaml` (e.g., `#/model/hurdle_pi_probs`, `#/prep/sparse_flag`, `#/alloc/country_set`, `#/egress/outlet_catalogue`).
* Shared RNG events: `schemas.layer1.yaml#/rng/events/*`.

Avro (`.avsc`) is **non-authoritative** for 1A and must not be referenced by registry/dictionary entries.

### Semantic clarifications (normative)

* **Inter-country order authority:** **S3 `candidate_set.candidate_rank`** (home=0; contiguous). `country_set` is **legacy** and **non-authoritative** for order.
* **Partitioning semantics** (recorded here as authority, implemented in S0.10): parameter-scoped datasets partition by `parameter_hash`; egress/validation partition by `manifest_fingerprint`.

---

## Run-time invariants (frozen context)

S0.1 constructs a **run context** $\mathcal{U}$ and freezes it:

$$
\mathcal{U} := \big(\mathcal{M}, \ \mathcal{I}, \ G,\ B,\ \text{SchemaAuthority}\big).
$$

**Invariants (must hold for the entire run):**

1. **Immutability:** $\mathcal{M}$, $\mathcal{I}$, $G$, $B$, and the authority mapping do not change after S0.1 completes. Any observed mutation later is a hard failure.
2. **Coverage & domain conformance:**

   * $\forall m\in\mathcal{M}$: `home_country_iso_m âˆˆ ð•€` (FK enforced here).
   * `mcc_m`: **int32 in [0,9999]** (per ingress schema type).
   * `channel_m âˆˆ {"card_present","card_not_present"}` at ingress and is mapped to `{CP,CNP}` internally.
3. **Determinism:** No RNG consumption; all S0.1 outputs are pure functions of loaded bytes and schemas (S0.2 will digest/record them).
4. **Authority compliance:** Every dataset/stream referenced downstream must use the **JSON-Schema** anchors listed above; any non-authoritative reference is a policy breach.

---

## Failure semantics (abort codes)

S0.1 **MUST abort** the run if any of the following occur:

* `E_INGRESS_SCHEMA` â€” `merchant_ids` fails validation against `schemas.ingress.layer1.yaml#/merchant_ids`.
* `E_REF_MISSING` â€” any canonical reference (ISO list, GDP vintage, or bucket map) is missing or unreadable. (S0.2 separately catches digest mismatches when hashing.)
* `E_AUTHORITY_BREACH` â€” a dataset or event in registry/dictionary points to a non-JSON-Schema (e.g., an `.avsc`) for 1A.
* `E_FK_HOME_ISO` â€” some merchant has `home_country_iso` not in ð•€.
* `E_MCC_OUT_OF_DOMAIN` â€” some merchant has `mcc` outside **[0,9999]** or violates the ingress type constraints.
* `E_CHANNEL_VALUE` â€” some merchant has an ingress `channel` not in `{"card_present","card_not_present"}` (cannot map to `{CP,CNP}`).

> When S0.1 aborts, no RNG audit or parameter/fingerprint artefacts are emitted; S0.2 has not yet run.

---

## Validation hooks (what CI/runtime checks here)

* **Schema check:** validate `merchant_ids` against the ingress schema before deriving $t(m)$.
* **Reference presence & immutability:** assert that the referenced ISO set, GDP vintage (2025-04-15), and $B$ load successfully and are cached read-only for the lifetime of the run.
* **Authority audit:** scan the registry/dictionary for any 1A dataset using **non-JSON-Schema** refs and fail the build if found (policy enforcement).
* **Country FK pre-check:** `home_country_iso âˆˆ ð•€` for all merchants.
* **MCC & channel domain checks:** `mcc âˆˆ [0,9999]`; `channel âˆˆ {"card_present","card_not_present"}` with a deterministic map â†’ `{CP,CNP}`.

---

## Reference routine (language-agnostic)

```text
function S0_1_resolve_universe_and_authority():
  # 1) Load & validate merchants (strict schema)
  M = read_table("merchant_ids")
  assert schema_ok(M, "schemas.ingress.layer1.yaml#/merchant_ids"), E_INGRESS_SCHEMA

  # 2) Load canonical references (read-only for run)
  I = load_iso3166_alpha2()                               # set of country codes (uppercase ASCII)
  G = load_gdp_per_capita(vintage="2025-04-15")           # map ISO -> R_{>0}
  B = load_gdp_jenks_buckets(K=5, vintage="2025-04-15")   # map ISO -> {1..5}; precomputed artefact

  # 3) Pre-flight authority: JSON-Schema only
  assert all_registry_refs_are_jsonschema(), E_AUTHORITY_BREACH
  assert dictionary_notes_include_country_set_order_rule()

  # 4) Domain enforcement & mapping (no RNG)
  for row in M:
      iso = row.home_country_iso
      mcc = row.mcc
      ch  = row.channel
      assert iso in I, E_FK_HOME_ISO
      assert mcc_in_domain(mcc), E_MCC_OUT_OF_DOMAIN
      if   ch == "card_present":     row.channel_sym = "CP"
      elif ch == "card_not_present": row.channel_sym = "CNP"
      else:                          abort(E_CHANNEL_VALUE)
      row.merchant_u64 = LOW64(SHA256(LE64(merchant_id)))  # canonical u64 key

  # 5) Freeze run context (pure functions only)
  U = { M: M, I: I, G: G, B: B, authority: JSONSCHEMA_ONLY }
  return U
```

---

## Notes for downstream states

* S0.2 will **hash** the loaded bytes (parameters and artefacts) to derive `parameter_hash` and `manifest_fingerprint`, and log provenance. S0.1â€™s immutability guarantees make those digests stable.
* All RNG substream keying that requires a merchant u64 **must** use `merchant_u64` defined here; there is no alternate mapping.
* S3â€™s eligibility and S6â€™s `country_set` persistence rely on S0.1â€™s **country FK** and the **channel symbol** (`CP`/`CNP`) set here.

---

**Summary:** S0.1 now pins the **who** (merchants + canonical `merchant_u64`), the **where** (countries), the **context** (GDP & buckets), and the **law** (JSON-Schema authority + cross-country order rule). It consumes **no randomness**, enforces domain validity **here**, and fails fast on any schema/authority/coverage breachâ€”so everything that follows sits on a rock-solid, reproducible base.

---

# S0.2 â€” Hashes & Identifiers (Parameter Set, Manifest Fingerprint, Run ID)

## Purpose (what S0.2 guarantees)

Create the three lineage keys that make 1A reproducible and auditable:

1. **`parameter_hash`** â€” versions *parameter-scoped* datasets; changes when any governed parameter fileâ€™s **bytes** change.
2. **`manifest_fingerprint`** â€” versions *egress & validation* outputs; changes when **any opened artefact**, the **code commit**, or the **parameter bundle** changes.
3. **`run_id`** â€” partitions logs; **not** part of modelling state; never influences RNG or outputs.

**No RNG is consumed in S0.2.** These identifiers are pure functions of bytes + time (for `run_id` only as a log partitioner).

---

## S0.2.1 Hash primitives & encoding (normative)

* **Digest:** `SHA256(x)` returns a **raw 32-byte** digest.
* **Concatenation:** `||` = byte concatenation of already-encoded fields.
* **Hex encodings:**

  * `hex64(b32)`: lower-case hex of 32 bytes â†’ 64 chars, **zero-left-padded**, no `0x`.
  * `hex32(b16)`: lower-case hex of 16 bytes â†’ 32 chars, **zero-left-padded**, no `0x`.
* **Universal encoding rule (UER):**

  * **Strings:** UTF-8, prefixed by **u32 little-endian** length. *(No normalization; no path cleanup; case-sensitive.)*
  * **Integers:** **LE64**.
  * **Arrays/sets:** sort by the specified key; then encode each element in that order and concatenate; **no delimiters** besides the length-prefixes.
* **Byte domain:** Hash the **exact file bytes** as opened in binary mode; no newline translation or parsing.

> This UER applies everywhere in 1A where S0.2 says â€œconcatâ€ or â€œencodeâ€.

---

## S0.2.2 `parameter_hash` (canonical, normative)

**Governed set ð“Ÿ (canonical basenames):**
`hurdle_coefficients.yaml`, `nb_dispersion_coefficients.yaml`, `crossborder_hyperparams.yaml`, `ccy_smoothing_params.yaml`, `s6_selection_policy.yaml`.

**Algorithm (tuple-hash; includes names):**

1. Validate: basenames are **ASCII** and **unique**; error if not.
2. Sort ð“Ÿ by **basename** using bytewise ASCII lexicographic order â†’ `(pâ‚,â€¦,pâ‚™)`, where here `n=5`.
3. For each `páµ¢`:

   * `dáµ¢ = SHA256(bytes(páµ¢))`  (32 bytes)
   * `táµ¢ = SHA256( UER(nameáµ¢) || dáµ¢ )`  (32 bytes)
4. Let `C = tâ‚ || tâ‚‚ || â€¦ || tâ‚™`  (32Â·n bytes).
5. `parameter_hash_bytes = SHA256(C)`  (32 bytes).
6. `parameter_hash = hex64(parameter_hash_bytes)`.

**Properties:** deterministic; resistant to name/byte collisions; future-proof if ð“Ÿ grows.

**Storage effect (normative):** *Parameter-scoped* datasets **must** partition by `parameter_hash={parameter_hash}` (e.g., `crossborder_eligibility_flags`, optional `hurdle_pi_probs`).

> **Note:** Randomness-bearing allocations such as `country_set` and `ranking_residual_cache_1A` are **not** parameter-scoped and must partition by `seed` (and, when applicable, by `manifest_fingerprint`).




> **Physical row order (normative):** For **Parquet** parameter-scoped datasets, row and row-group order are **unspecified** and **MUST NOT** be relied upon. Consumers **must** treat equality as **row-set** equality; any dependence on physical order is non-conformant.

**Errors (abort S0):**
`E_PARAM_EMPTY` (missing), `E_PARAM_IO(name,errno)`, `E_PARAM_NONASCII_NAME`, `E_PARAM_DUP_BASENAME`.

**Audit rows:**
`param_digest_log`: `{filename, size_bytes, sha256_hex, mtime_ns}` for each `páµ¢`.
`parameter_hash_resolved`: `{parameter_hash, filenames_sorted}`.

---

## S0.2.3 `manifest_fingerprint` (egress/validation lineage)

**Purpose.** Single lineage key that flips if **anything material** to the run changes.

**Inputs (exact):**

* ð“ = set of **all artefacts actually opened** during the run up to S0.2 (parameters, ISO, GDP, bucket map, schema files you read, numeric policy, etc.).
  For each artefact `a` with basename `nameâ‚`:

  * `D(a) = SHA256(bytes(a))`  (32 bytes)
  * `T(a) = SHA256( UER(nameâ‚) || D(a) )`  (32 bytes)
* `git_32`: **32 raw bytes** representing the repo commit id:

  * If VCS uses SHA-256: take the 32 raw bytes as-is.
  * If VCS uses SHA-1 (20 bytes): **left-pad with 12 zero bytes** to 32.
  * *(Never ASCII-hex; must be raw digest/padded raw.)*
* `parameter_hash_bytes` from S0.2.2 (raw 32 bytes).

**Algorithm (sorted tuple-hash; no XOR):**

1. Validate: basenames in ð“ are **ASCII** and **unique** within the set; error on duplicates.
2. Sort ð“ by basename (ASCII).
3. Build `U = T(aâ‚) || T(aâ‚‚) || â€¦ || T(a_k) || git_32 || parameter_hash_bytes`.
4. `manifest_fingerprint_bytes = SHA256(U)`;
   `manifest_fingerprint = hex64(manifest_fingerprint_bytes)`.

**Properties:** Any change to an opened artefactâ€™s **bytes or basename**, the **commit**, or the **parameter bundle** flips the fingerprint. No XOR cancellation risk.

**Storage effect (normative):** Egress & validation datasets **must** partition by `fingerprint={manifest_fingerprint}` (often alongside `seed`).

**Errors (abort S0):**
`E_ARTIFACT_EMPTY`, `E_ARTIFACT_IO(name,errno)`, `E_ARTIFACT_NONASCII_NAME`, `E_ARTIFACT_DUP_BASENAME`, `E_GIT_BYTES`, `E_PARAM_HASH_ABSENT`.

**Audit rows:**
`manifest_fingerprint_resolved`: `{ manifest_fingerprint, artifact_count, git_commit_hex, parameter_hash }`.
*(Where `git_commit_hex` is the lower-case hex of `git_32`.)*

---

## S0.2.4 `run_id` (logs only; not modelling state)

**Goal.** Give each execution its own log partition key; **must not** affect RNG or outputs.

**Inputs:**
`manifest_fingerprint_bytes` (32), `seed` (u64; the modelling seed), start time `T_ns` = **UTC nanoseconds** (u64).

**Algorithm (UER payload):**

```
payload = UER("run:1A") || manifest_fingerprint_bytes || LE64(seed) || LE64(T_ns)
r = SHA256(payload)[0:16]      # first 16 bytes
run_id = hex32(r)
```

**Uniqueness (normative):** If a newly computed `run_id` already exists in the target log directory for `{ seed, parameter_hash }`, deterministically adjust `T_ns` by adding `+1` nanosecond and recompute. Repeat until the `run_id` is unused. This loop MUST be bounded by 2^16 steps; exceeding it is a hard failure. `run_id` never influences modelling outputs.
 
**Scope & invariants (normative):**

* Partitions **only** `rng_audit_log`, `rng_trace_log`, and `rng_event_*` as `{ seed, parameter_hash, run_id }`.
* `run_id` **never** enters RNG seeding or model state; all determinism/outputs depend **only** on `(seed, parameter_hash, manifest_fingerprint)`.
 
---

## Partitioning contract (authoritative)

| Dataset class       | Partition keys (in order)          |
|---------------------|------------------------------------|
| Parameter-scoped    | `parameter_hash`                   |
| Egress & validation | `manifest_fingerprint`             |
| RNG logs & events   | `seed`, `parameter_hash`, `run_id` |

*(Row-embedded key columns must equal their path keys byte-for-byte.)*

---

## Operational requirements

* **Streaming digests:** compute all file digests via streaming; hash exact bytes.
* **Race guard:** `stat` (size, mtime) **before/after** hashing; if changed, re-read or fail (`E_PARAM_RACE` / `E_ARTIFACT_RACE`).
* **Basename semantics:** sort by **basename** (no directories); basenames must be ASCII, unique; **abort** on duplicates.
* **Immutability:** After S0.2, treat `parameter_hash` & `manifest_fingerprint` as **final** for the run; embed them in all envelopes/partitions.

---

## Failure semantics

On any `E_PARAM_*`, `E_ARTIFACT_*`, `E_GIT_*`, race error or `E_RUNID_COLLISION_EXHAUSTED` (loop exceeded 2^16) abort the run per S0.9. On abort in S0.2, **do not** emit RNG audit/trace; S0.3 hasnâ€™t begun.

---

## Validation & CI hooks

* **Recompute:** CI recomputes `parameter_hash` from ð“Ÿ and `manifest_fingerprint` from (enumerated ð“, `git_32`, `parameter_hash_bytes`). Must match logged `*_resolved` rows.
* **Partition lint:** dictionary enforces the partition table above; RNG logs must use `{ seed, parameter_hash, run_id }`.
* **Uniqueness:** within `{ seed, parameter_hash }`, `run_id` must be unique (practically guaranteed; guards clock bugs).

---

## Reference pseudocode (language-agnostic)

```text
# --- u32/u64 encoders per UER ---
def enc_str(s): b=s.encode("utf-8"); return le32(len(b)) + b
def enc_u64(x): return le64(x)

# --- parameter_hash ---
def compute_parameter_hash(P_files):  # list of (basename, path)
    assert len(P_files) >= 1, E_PARAM_EMPTY
    assert all_ascii_unique_basenames(P_files), E_PARAM_NONASCII_NAME or E_PARAM_DUP_BASENAME
    files = sort_by_basename_ascii(P_files)
    tuples = []
    for (name, path) in files:
        d = sha256_stream(path)                   # 32 bytes
        t = sha256_bytes(enc_str(name) + d)       # 32 bytes
        tuples.append(t)
    C = b"".join(tuples)
    H = sha256_bytes(C)                           # 32 bytes
    return hex_lower_64(H), H                     # hex64 + raw

# --- manifest_fingerprint ---
def compute_manifest_fingerprint(artifacts, git32, param_bytes):
    assert artifacts, E_ARTIFACT_EMPTY
    assert len(git32) == 32, E_GIT_BYTES
    assert len(param_bytes) == 32, E_PARAM_HASH_ABSENT
    assert all_ascii_unique_basenames(artifacts), E_ARTIFACT_NONASCII_NAME or E_ARTIFACT_DUP_BASENAME
    arts = sort_by_basename_ascii(artifacts)      # list of (basename, path)
    parts = []
    for (name, path) in arts:
        d = sha256_stream(path)                   # 32 bytes
        t = sha256_bytes(enc_str(name) + d)       # 32 bytes
        parts.append(t)
    U = b"".join(parts) + git32 + param_bytes
    F = sha256_bytes(U)
    return hex_lower_64(F), F

# --- run_id ---
def derive_run_id(fingerprint_bytes, seed_u64, start_time_ns):
    payload = enc_str("run:1A") + fingerprint_bytes + enc_u64(seed_u64) + enc_u64(start_time_ns)
    r = sha256_bytes(payload)[:16]                # 16 bytes
    return hex_lower_32(r)
```

---

## Where this shows up next

S0.3 derives the master RNG seed/counters using `manifest_fingerprint_bytes` and `seed`. Therefore S0.2 **must** complete before any RNG event emission.

---

**Bottom line:** S0.2 now uses a **tuple-hash, name-aware, length-prefixed** combiner (no XOR), with universal encoding rules and raw commit bytes. The partitioning contract is crystal-clear, and `run_id` is log-only. This is ready to hand straight to an implementer.

---

# S0.3 â€” RNG Engine, Substreams, Samplers & Draw Accounting (normative, fixed)

> **Notation (normative):** `ln(x)` denotes the natural logarithm. The unqualified `log` MUST NOT appear in kernels or acceptance tests.

## Purpose

S0.3 pins the *entire* randomness contract for 1A: which PRNG we use, how we carve it into **keyed, order-invariant** substreams, how we map bits to **(0,1)**, how we generate $Z\sim\mathcal N(0,1)$, $\Gamma(\alpha,1)$, and $\text{Poisson}(\lambda)$, and how every draw is **counted, logged, and reproducible**. **S0.3 does not consume RNG events; it defines the contracts and writes the single audit row only (no draws in S0).**

---

## S0.3.1 Engine & Event Envelope
> **Practical bound (normative):** `blocks` is `uint64`. Producers MUST ensure a single eventâ€™s block consumption fits this width. If an event would exceed this bound, emit `F4d:rng_budget_violation` and abort the run.

### PRNG (fixed)

* **Algorithm:** Philox 2Ã—64 with 10 rounds (counter-based; splittable).
* **Wire token (normative):** `philox2x64-10` (lowercase). Validators MUST expect this exact token wherever the RNG algorithm is named on the wire (e.g., `rng_audit_log.algorithm`).
> **Counter (normative):** The Philox **counter is 128-bit**, represented as the ordered pair $(c_{\mathrm{hi}}, c_{\mathrm{lo}})$ of unsigned 64-bit integers. All counters in envelopes are these same two words. Any prior 4-word notation is non-normative and MUST NOT be used. The block function advances the counter by **1** (unsigned 128-bit add with carry from `lo` into `hi`).
* **State per substream:** 64-bit **key** $k$ and 128-bit **counter** $c=(c_{\mathrm{hi}},c_{\mathrm{lo}})$.
* **Block function:** $(x_0,x_1)\leftarrow \mathrm{PHILOX}_{2\times64,10}(k,c)$ returns **two** 64-bit words per counter; then increment $c\leftarrow c+1$ mod $2^{128}$.
* **Lane policy (normative):**
  * **No caching (normative):** Families that require two uniforms **must not** reuse, pool, or cache normals/uniforms across events. Each event **must** fetch a fresh block per the lane policy.
  * **Clarification:** â€œUse low laneâ€ means **read `x0` and advance the counter by 1 block**; the high lane `x1` is discarded and **may not** be reused later.
  * **Single-uniform events:** use **low lane** $x_0$, **discard** $x_1$; advance counter by 1 block; `draws="1"`.
  * **Two-uniform events (e.g., Boxâ€“Muller):** use **both lanes** from the same block; advance counter by 1 block; `draws="2"`.
  * No other reuse or caching of lanes is permitted.

### Event envelope (mandatory fields on **every** RNG event row)
> **Note:** Audit/trace logs are governed by `schemas.layer1.yaml#/rng/core/*` and **do not** embed the event envelope.


```
{
  ts_utc:                  string  # RFC 3339 / ISO-8601 UTC (exactly 6 fractional digits), e.g. "2025-08-15T10:03:12.345678Z"
  module:                  string  # e.g. "1A.gumbel_sampler" (registered producer name)
  substream_label:         string  # e.g. "gumbel_key", "dirichlet_gamma_vector"
  seed:                    uint64  # modelling seed (from S0.2)
  parameter_hash:          string  # hex64 (S0.2)
  manifest_fingerprint:    string  # hex64 (S0.2)
  run_id:                  string  # hex32 (S0.2)
  rng_counter_before_lo:   uint64
  rng_counter_before_hi:   uint64
  rng_counter_after_lo:    uint64
  rng_counter_after_hi:    uint64
  blocks:                  uint64   # PHILOX blocks advanced by this event
  draws:                   string   # decimal-encoded uint128; required; **UNIFORMS** used by this event (family budgets check against this); e.g., "0", "2").
  payload: { ... }                 # event-specific fields (flattened into top-level fields by the event schema; schema ensures global name uniqueness; name collisions are compile-time schema errors.)
}
```

> **Order note:** Fields are serialized in **lo, hi** order (`*_before_lo`, `*_before_hi`, `*_after_lo`, `*_after_hi`). For arithmetic, form 128-bit integers as the pair **(hi, lo)**, i.e. `U = (hi << 64) | lo`.

* **Module governance (normative):** `module` MUST equal one of the **registered producer names** in the dataset dictionary for 1A (e.g., `1A.hurdle_sampler`, `1A.nb_sampler`, `1A.gumbel_sampler`).
* **Label governance (normative):** `substream_label` MUST be one of the labels published in the artefact `rng_event_schema_catalog` (manifest_key `mlr.rng.events.schema_catalog`) and validators MUST enforce membership.


> **Blocks vs draws (normative):** `blocks = (after_hi,after_lo) âˆ’ (before_hi,before_lo)` in unsigned 128-bit arithmetic. `draws` = **uniforms used**. Single-uniform families: `(blocks=1, draws="1")`. Two-uniform families (e.g., Boxâ€“Muller): `(blocks=1, draws="2")`. Non-consuming: `(blocks=0, draws="0")`. The `blocks` equality is checked by counters; `draws` is checked by family budgets.

> **Invariants (normative):**
> - `blocks` = $(\texttt{after\_hi},\texttt{after\_lo}) - (\texttt{before\_hi},\texttt{before\_lo})$ in unsigned 128-bit arithmetic. (authoritative equality check).
> - `draws` = number of **uniform(0,1)** variates consumed by the event. (independent of the counter delta).
> - With the lane policy, **single-uniform** events have `(blocks=1, draws="1")`, and **two-uniform** events (Boxâ€“Muller) have `(blocks=1, draws="2")`. **Non-consuming** events have `(blocks=0, draws="0")`.

* **Non-consuming** events keep `before == after` and set `blocks = 0`.
* `module` and `substream_label` must be chosen from the 1A vocabulary registry enumerated in `schemas.layer1.yaml#/rng/events/*`; free-text labels are not allowed.

* When a family-level **uniforms-used** count is relevant **for diagnostics**, may include an optional `uniforms: string` (decimal-encoded `uint128`, same domain as `draws`) in `payload` **only for** `gamma_component` and `dirichlet_gamma_vector`; when present, validators MUST check it equals `draws`.

**Encoding notes (normative):**
* **Authority (normative):** An eventâ€™s envelope `draws` MUST equal the kernelâ€™s computed uniform count for that event. Counters remain the authority for `blocks`.
* `blocks` â‰  (`after` âˆ’ `before`) â‡’ `F4c: rng_counter_mismatch`
* `draws` â‰  budgeted/actual uniforms â‡’ `F4d: rng_budget_violation`.
> **Budget table (normative authority for S0):**
> - `uniform1` (single-uniform families): `(blocks=1, draws="1")`  
> - `normal` (Boxâ€“Muller): `(blocks=1, draws="2")`  
> - `gamma_component`: **variable**, per Â§S0.3.6 (exact actual-use)  
> - `dirichlet_gamma_vector`: **sum of component** `gamma_component` budgets  
> - `poisson_component (Î»<10)`: **variable**, inversion (Â§S0.3.7)  
> - `poisson_component (Î»â‰¥10)`: **2 uniforms/attempt**, PTRS (Â§S0.3.7)  
> - `stream_jump`: `(blocks=0, draws="0")` â€” **non-consuming** (before==after)  
> - `sequence_finalize`: `(blocks=0, draws="0")` â€” **non-consuming** (before==after)  
> - `site_sequence_overflow`: `(blocks=0, draws="0")` â€” **non-consuming** (before==after)  


* `draws` is a **JSON string** carrying a **base-10** representation of a `uint128`. Producers/consumers **must** parse/emit as decimal and **must not** split into lo/hi words in the envelope (use the decimal string everywhere, mirroring S0.9 failure payloads).
* `ts_utc` in RNG **events** is an **RFC-3339/ISO-8601 UTC string** with **exactly 6 fractional digits** (microseconds), e.g., `"2025-08-15T10:03:12.345678Z"`. `ts_utc` in **failures** is **epoch-nanoseconds** (they are **nanoseconds since epoch** as an unsigned integer). See **Â§S0.9 â€œFailure recordsâ€** for failure-record timestamps (epoch-ns u64).

* **Serialization note:** Envelope counter fields (`rng_counter_*_{hi,lo}`) and `blocks` are **numbers**; `draws` is a **decimal string** (`uint128` in base-10, per schema). Endianness (LE/BE) applies only to **derivations** (hash splits, Philox counters); JSON serialisation is endianness-agnostic.


---

## S0.3.2 Master seed & initial counter (per run)
> **LOW64(digest32) (normative):** interpret **bytes 24..31** of the 32-byte SHAâ€‘256 digest as **littleâ€‘endian u64** (same convention as Â§S0.1). **Counters** are always split as `BE64(H[16:24]), BE64(H[24:32])`.
> **Use of LOW64:** Whenever `LOW64(H)` appears (e.g., key derivation), it refers to this exact LE64 tail-bytes rule.

Let:

* `seed` = user/model seed (u64, from S0.2),
* `manifest_fingerprint_bytes` (32 bytes, from S0.2).

Define **master material** (UER = universal encoding rule from S0.2):

```
M = SHA256( UER("mlr:1A.master") || manifest_fingerprint_bytes || LE64(seed) )  # 32 bytes
```

> **UER domain strings (normative):** `b"mlr:1A.master"` for master-material; `b"mlr:1A"` for substream messages; event-family labels `â„“` are ASCII (e.g., `b"hurdle_bernoulli"`, `b"gumbel_key"`). These exact byte sequences are part of the hash inputs.

Derive **root** (audit-only; never used directly for draws):

* Root key:     $k_\star = \text{LOW64}(M)$.
* Root counter: $(c_{\star,\mathrm{hi}}, c_{\star,\mathrm{lo}}) = (\text{BE64}(M[16:24]),\ \text{BE64}(M[24:32]))$.

> **`split64` (normative):** for a 16-byte string `b`, return `hi = u64_be(b[0..8])`, `lo = u64_be(b[8..16])`.

> Envelopes carry these same numeric values as `rng_counter_*_{hi,lo}`. All counter math is **unsigned 128-bit** with addition performed as `lo += n; carry â†’ hi`.

> Emit a single `rng_audit_log` row **before** any draws with `seed`, `manifest_fingerprint`, `parameter_hash`, `run_id`, and $(k_\star,c_\star)$. **No event** may draw from $(k_\star,c_\star)$. (schema: `schemas.layer1.yaml#/rng/core/rng_audit_log`).
> **Schema separation (normative):** `rng_audit_log` rows are **not** RNG events and MUST NOT be encoded with the event envelope. They carry the audit schema only and **must** precede the first RNG event.

---

## S0.3.3 Keyed, order-invariant substreams

Every logical substream is keyed by a deterministic tuple; **never** by execution order.

### Substream derivation (UER, no delimiters) *(SER = integer encodings under UER: LE32 indices; LE64 keys)*
* **Indices (`i`,`j`, â€¦):** 0-based, unsigned, encoded as **LE32**; must satisfy `0 â‰¤ value â‰¤ 2^32âˆ’1`; negative values are forbidden.
* **ISO encoding (normative):** `iso` MUST be **uppercase ASCII** before UER. If a lower-case code is encountered, **uppercase it** deterministically prior to encoding.

> **UER/SER recap (normative):**
> - **UER (strings):** UTF-8 bytes prefixed by a 32-bit **little-endian** length; concatenation is unambiguous and order-sensitive.  
> - **SER(ids):** integers are **LE32** (indices) or **LE64** (u64 keys); all indices are **0-based** and unsigned.  
> - **ISO codes:** uppercase ASCII under UER.
> These are the only encodings allowed for hashing and substream derivation in Â§S0.3.

For an event family label `â„“` (e.g., `"hurdle_bernoulli"`, `"gumbel_key"`) and an ordered ID tuple **ids** (event-family-specific; e.g., `(merchant_u64, iso)`), build:

```
msg = UER("mlr:1A") || UER(â„“) || SER(ids)
H   = SHA256( M || msg )              # 32 bytes
k(â„“,ids) = LOW64(H)
c(â„“,ids) = ( BE64(H[16:24]), BE64(H[24:32]) )   # 128-bit counter (hi,lo)
```

* **SER(ids)** uses UER per component, with **types fixed by schema**:

  * `merchant_u64` (from S0.1 mapping): LE64
  * `iso` (uppercase ISO-3166 alpha-2): UER string (length-prefixed UTF-8)
  * indices `i`, `j`: LE32
  * any other id types must be enumerated in the event schema
* All draws for that event must come from `PHILOX(k(â„“,ids),Â·)` by advancing `c` monotonically.

---

## S0.3.4 Uniforms on the **open** interval $(0,1)$

**Normative mapping:**

```text
# x is u64; map to strictly (0,1) â€” never 0.0, never 1.0
u = ((x + 1) * 0x1.0000000000000p-64)
if u == 1.0: u := 0x1.fffffffffffffp-1   # max < 1 in binary64 (1 - 2^-53)
```

This is the required implementation of the open-interval rule. Computing `1/(2^64+1)` at runtime or using decimal literals is **forbidden**.

## S0.3.5 Standard normal $Z\sim\mathcal N(0,1)$ (Boxâ€“Muller, no cache)

**Constants (normative):** `TAU = 0x1.921fb54442d18p+2` (binary64-exact). Computing `2*pi` at runtime is **forbidden** to avoid libm drift. (See constant `TAU` defined once in Â§S0.3.5.)

To sample **one** $Z$:


1. Draw a **single** Philox block â†’ $(x_0,x_1)$.
2. Map $u_1 = u01(x_0),\ u_2 = u01(x_1)$.
3. Compute $r=\sqrt{-2\ln u_1},\ \theta=\mathrm{TAU}\cdot u_2,\ Z=r\cos\theta$.

Budget & rules:

* **Budget:** exactly **2 uniforms** per $Z$ (1 block).
* **No caching:** **discard** the companion normal $r\sin\theta$.
* **Envelope requirement (normative):** Each Boxâ€“Muller event MUST set `blocks=1` and `draws="2"`.
* **Numeric policy:** binary64, round-to-nearest-ties-even, FMA **off**, no FTZ/DAZ; evaluation order is as written (per S0.8).

* **Constants (normative):** All decision-critical constants (e.g., `TAU`) **MUST** be provided as **binary64 hex literals**. Recomputing from other constants (e.g., `2*pi`) is forbidden.

---

## S0.3.6 Gamma $\Gamma(\alpha,1)$ (Marsagliaâ€“Tsang; exact actual-use budgeting)
> **Case B (Î±<1) clarification (normative):** boosting draws `G' ~ Î“(Î±+1)` and then **+1 uniform** for `U`; **no** dummy or padding draws are permitted; envelope `draws` reflects exact actual use.

We use Marsagliaâ€“Tsang (2000). Budgets reflect the **exact number of uniforms consumed** (no padding or dummy draws). Normals come from Â§S0.3.5 (two uniforms per normal). All uniforms use Â§S0.3.4.

**Case A: $\alpha\ge 1$**  (set $d=\alpha-\tfrac13$, $c=1/\sqrt{9d}$)

Repeat:
1. Draw **one** standard normal $N$ via Boxâ€“Muller â†’ **2 uniforms**; `(blocks+=1, draws+=2)`.
2. Compute $v=(1+cN)^3$. If $v\le 0$, **reject** and go to step 1 (no extra uniforms consumed in this branch).
3. Draw $U\sim\mathrm{Uniform}(0,1)$ â†’ **+1 uniform**; `(draws+=1)`.
4. Accept iff $\ln U < \tfrac12 N^2 + d - d v + d\ln v$. If rejected, go to step 1.

On acceptance, return $G=dv$.  
**Budget per accepted sample:** $2A + B$ uniforms, where $A$ is the number of attempts and $B$ is the number of **U draws** (i.e., the attempts with $v>0$, including the final accepted attempt). There is **no fixed multiple**; the envelope `draws` records the exact count.

**Case B: $0 < \alpha < 1$**  (boosting)

1. Sample $G'\sim\Gamma(\alpha+1,1)$ via **Case A** (with its budgeting).
2. Draw $U\sim\mathrm{Uniform}(0,1)$ â†’ **+1 uniform**.
3. Set $G = G'\cdot U^{1/\alpha}$ (pure arithmetic).

**Budget per accepted sample:** `draws(G') + 1` uniforms. There are **no dummy or padding draws**; counters reflect only actual consumption.

**Dirichlet vectors:** For shapes $(\alpha_1,\dots,\alpha_K)$, draw independent components with the kernel above and normalise. The total budget is the **sum** of component budgets; there is **no** â€œmultiple of $3K$â€ rule. Envelope `draws` MUST equal that sum.

---

## S0.3.7 Poisson $\text{Poisson}(\lambda)$ & ZTP scaffolding

Two regimes; **Threshold (normative):** $\lambda^\star = 10$ (spec constant; not configurable). Changing it requires a spec revision and flips `manifest_fingerprint` per Â§S0.2.3.

**Small $\lambda<\lambda^\star$** â€” **Inversion**
Draw uniforms $u_1,u_2,\ldots$ and iterate the standard product until it falls below $e^{-\lambda}$.

* **Budget:** variable (**exactly** $K+1$ uniforms, including the stopping draw); log exactly in `draws`.

**Moderate/Large $\lambda\ge\lambda^\star$** â€” **PTRS (HÃ¶rmann-class) rejection (fully specified)**
Per-attempt draws: **two uniforms** $u,v\sim U(0,1)$ from **one Philox block** (lane policy).
**Constants (normative):**
${} \quad b = 0.931 + 2.53\sqrt{\lambda},\quad a = -0.059 + 0.02483\,b,\quad \mathrm{inv}\,\alpha = 1.1239 + \dfrac{1.1328}{b-3.4},\quad v_r = 0.9277 - \dfrac{3.6224}{b-2},\quad u_{\text{cut}}=0.86.$
**Attempt loop:**
1) Draw $(u,v)$.
2) If $u\le u_{\text{cut}}$ and $v\le v_r$: accept $k=\left\lfloor \dfrac{b\,v}{u} + \lambda + 0.43 \right\rfloor$.
3) Else set $u_s = 0.5 - |u-0.5|$, and form the candidate $k=\left\lfloor \bigl(\tfrac{2a}{u_s} + b\bigr) v + \lambda + 0.43 \right\rfloor$; if $k<0$, continue.
4) Accept iff
$\displaystyle \ln\!\Bigl(\frac{v\cdot \mathrm{inv}\,\alpha}{\,a/u_s^2 + b\,}\Bigr) \le -\lambda + k\ln\lambda - \log\Gamma(k+1).$
On acceptance return $K=k$; otherwise repeat from step 1.
**Budget:** **exactly 2 uniforms per attempt**; attempts repeat until acceptance. `draws` records the total used. All `\ln`, `\sqrt{\ }`, and `\log\Gamma` calls obey Â§S0.8 (pinned math profile).
 
**Zero-Truncated Poisson (ZTP)**
Handled by accept/reject on $\text{Poisson}(\lambda)$ conditioned on $N>0$. The `draws` field includes all uniforms across rejections.

**ZTP event budgets (normative):**
* Each `poisson_component(context="ztp")` event records the **actual** sampler consumption via the envelope counters.
* `ztp_rejection` and `ztp_retry_exhausted` are **non-consuming**: `before==after`, `blocks=0`, `draws="0"`.
* Hard cap: **64** zero outcomes; on exhaustion, emit `ztp_retry_exhausted` and branch per S4; budgets remain as above.
 
---

## S0.3.8 Gumbel key from a single uniform

For candidate ranking:

* Draw $u\in(0,1)$; compute $g=-\ln(-\ln u)$.
* **Budget:** **1 uniform** per candidate (single-lane low; event-level `draws="1"`).
* **Tie-break:** sort primarily by $g$, then by `ISO` (ASCII ascending), then by `merchant_id` if still tied.
* **Log:** one `gumbel_key` event **per candidate**.

---

## S0.3.9 Draw accounting & logs (auditable replay)
> **Run policy (normative):** Although on-disk totals are saturating counters, producers MUST detect imminent overflow and raise `F4d:rng_budget_violation` **before** any saturation would occur.


Two cross-cut logs in addition to per-event logs:

1. **`rng_audit_log`** â€” **one row at run start** (before any RNG event): `(seed, manifest_fingerprint, parameter_hash, run_id, root key/counter, code version, ts_utc)`.
   **`rng_audit_log` schema (normative minimum):** `{ ts_utc, seed, parameter_hash, manifest_fingerprint, run_id, algorithm, rng_key_hi, rng_key_lo, rng_counter_hi, rng_counter_lo, code_version }`. Field types and names are governed by `schemas.layer1.yaml#/rng/core/rng_audit_log` (authoritative). Audit rows are **core logs**, not RNG events.
2. **`rng_trace_log`** (**one row per** $(\texttt{module},\texttt{substream\_label})$; cumulative **blocks** (unsigned 64-bit), with the *current* `(counter_before, counter_after)`.  
   *(schema: `schemas.layer1.yaml#/rng/core/rng_trace_log`).*  

   **Reconciliation (normative):** For each `(module, substream_label)`, `rng_trace_log.blocks_total` MUST be monotone non-decreasing across emissions, and the **final** `blocks_total` MUST equal the **sum of per-event `blocks`** over `rng_event_*` in the same `{seed, parameter_hash, run_id}`. Budget checks use **event `draws`**, not the trace.
   **Lineage binding (normative):** Producers and consumers **MUST** bind `{ seed, parameter_hash, run_id }` from the enclosing **partition path**. In `rng_trace_log`, **`seed` and `run_id` are also embedded columns** and **must equal** the path keys byte-for-byte; **`parameter_hash` is path-only**. (Drift is a hard F5 failure.)

> **Practical bound (normative):** `rng_trace_log.blocks_total` is `uint64`; emitters MUST ensure totals fit this width or abort with `F4d:rng_budget_violation`.

**Per-event budget rules are enforced **exactly as specified in Â§S0.3.1 (Budget table)**.

**Envelope invariants:**

* Philox blocks advance consistently with lane policy: single-uniform events advance **one** block (high lane discarded); two-uniform events consume **both lanes** of one block.
* `rng_counter_after` â‰¥ `rng_counter_before` lexicographically; non-consuming events keep them equal.

---

## S0.3.10 Determinism & failure semantics

**Must hold:**

1. **Order-invariant:** keyed substreams make outputs independent of execution order/sharding.
2. **Open-interval uniforms:** $u\in(0,1)$ strictly (S0.3.4).
3. **Budget correctness:** per-event budgets satisfied (Normals Â§S0.3.5; Gamma Â§S0.3.6; Poisson/ZTP Â§S0.3.7).
4. **Numeric profile:** binary64, no FMA, serial reductions (S0.8).

**Abort the run if:**

* An eventâ€™s `blocks` disagrees with the 128-bit counter delta implied by the envelope (`after âˆ’ before`).
* Any sampler yields NaN/Inf.
* A non-consuming event changes counters.
* A Gamma/Dirichlet eventâ€™s `draws` mismatches the recomputed exact budget per Â§S0.3.6.
---

## Reference pseudocode (language-agnostic)

```text
# Philox
struct Stream { key: u64, ctr: u128 }      # conceptual; envelope exposes (lo,hi) pairs
fn philox_block(s: Stream) -> (u64,u64,Stream) {
  (x0,x1) = PHILOX_2x64_10(s.key, s.ctr)
  s.ctr += 1
  return (x0,x1,s)
}

# u01 mapping (open interval)
fn u01(x: u64) -> f64 {
  # Binary64; strict (0,1) open interval â€” never 0.0, never 1.0
  const TWO_NEG_64:    f64 = 0x1.0000000000000p-64;   # 2^-64
  const ONE_MINUS_EPS: f64 = 0x1.fffffffffffffp-1;    # 1 - 2^-53 (max < 1 in binary64)
  let u = ((x as f64) + 1.0) * TWO_NEG_64;
  return (u == 1.0) ? ONE_MINUS_EPS : u
}
* **Note (normative):** The `u==1.0` remap is a **measure-zero** adjustment required by binary64 rounding and **does not** affect PRNG budgets or counter deltas. The schema type **`u01`** enforces the open interval **(0,1)**.

# Single uniform (lane policy)
fn uniform1(stream: &mut Stream) -> (f64, draws:int) {
  let (x0, _x1, s2) = philox_block(*stream)   # fetch 1 block; discard high lane
  *stream = s2
  return (u01(x0), 1)
}

# Normal Z via Boxâ€“Muller (no cache)
fn normal(stream: &mut Stream) -> (f64, draws:int) {
  let (x0, x1, s2) = philox_block(*stream)    # fetch 1 block; use both lanes
  *stream = s2
  let u1 = u01(x0); let u2 = u01(x1)
  let r  = sqrt(-2.0 * ln(u1))
  # Ï„ = 2Ï€ (binary64 hex literal to avoid libm/macro drift)
  const TAU: f64 = 0x1.921fb54442d18p+2;
  let th = TAU * u2
  return (r * cos(th), 2)
}

# Gamma(alpha,1) with budget discipline
fn gamma_mt(alpha: f64, stream: &mut Stream) -> (f64, draws:int) {
  if alpha >= 1.0 {
    let d = alpha - (1.0/3.0);
    let c = 1.0 / sqrt(9.0 * d);
    var total = 0;
    loop {
      let (z, dZ) = normal(stream);       # Boxâ€“Muller â†’ 2 uniforms (1 block)
      total += dZ;
      let v = (1.0 + c*z); v = v*v*v;
      if v <= 0.0 { continue; }
      let (u, dU) = uniform1(stream);     # +1 uniform
      total += dU;
      if ln(u) <= 0.5*z*z + d - d*v + d*ln(v) {
        return (d*v, total);              # exact actual-use budgeting
      }
    }
  } else {
    let (y, dY) = gamma_mt(alpha + 1.0, stream);  # recurse to Case A
    let (u, dU) = uniform1(stream);               # +1 uniform
    return (y * pow(u, 1.0/alpha), dY + dU);
  }
}

# Poisson scaffolding (sketch)
fn poisson(lambda: f64, stream: &mut Stream) -> (int, draws:int) {
  if lambda < 10.0 {
    L = exp(-lambda); k = 0; p = 1.0; draws = 0
    loop:
      (u, dU) = uniform1(stream); draws += dU
      p *= u
      if p <= L { return (k, draws) } else { k += 1 }
  } else {
    # PTRS attempt: (u,v) -> 2 uniforms/attempt; repeat until accept.
  }
}
```

---

## Guarantees to downstream states

* Any module declares `(substream_label, ids)` and receives a **stable, independent** substreamâ€”order/shard-invariant.
* Samplers have **pinned** budgets (constant where possible; fully logged where variable).
* Given `(seed, parameter_hash, manifest_fingerprint, run_id)` and the envelopes, every draw is **replayable exactly**.

---

**Summary:** S0.3 pins Philox 2Ã—64-10, the **low-lane policy** for single uniforms, **UER-based** substream derivation, one **open-interval** `u01`, Boxâ€“Muller (**no cache**), Gamma (Marsagliaâ€“Tsang) with **exact actual-use budgeting**, Poisson with a **fully specified** inversion/PTRS split, and strict **draw accounting** tied to counters. This is deterministic, auditable, and ready to implement. Gumbel keys break ties by ISO, then merchant_id.

---

# S0.4 â€” Deterministic GDP Bucket Assignment (normative, fixed)

## Purpose

Attach to every merchant $m$ two **deterministic**, **non-stochastic** features from pinned references:

* $g_c$ â€” GDP-per-capita level for the merchantâ€™s **home** country $c$ from the **2025-04-15** WDI extract, **at a fixed observation year** (see below), and
* $b_m\in\{1,\dots,5\}$ â€” the **Jenks** $K{=}5$ GDP bucket id for that home country from the **precomputed** mapping table.

**No RNG** is consumed here. S0.4 is a pure function of bytes fixed by S0.1â€“S0.2.

---

## Inputs & domains (read-only, pinned)

* **Ingress universe:** `merchant_ids` carrying `merchant_id`, `mcc`, `channel`, `home_country_iso`.
  `home_country_iso` is **uppercase ASCII ISO-2** and FK-validated against the runâ€™s ISO set (S0.1).

* **GDP vintage (total function $G$):** artefact `world_bank_gdp_per_capita_20250415`.
  Schema guarantees **exactly one** row per `(country_iso, observation_year)` with a strictly positive value.

  **Normative pinning (this run):**

  * `observation_year = 2024` (fixed),
  * **units/deflator**: *constant 2015 USD* (as recorded in the artefact metadata),
  * so $G:\mathcal I \to \mathbb R_{>0}$ is the map $c \mapsto \text{GDPpc}_{c,2024}^{\text{const2015USD}}$.

* **Bucket map (total function $B$):** artefact `gdp_bucket_map_2024` with PK `country_iso` and `bucket âˆˆ {1..5}`.
  **It is a precomputed Jenks $K{=}5$ classification built from the exact $G(\cdot)$ above** (same ISO set, same `observation_year`, same units). **Never recomputed at runtime.**

> Both artefacts are enumerated in the registry/dictionary as runtime, read-only inputs and therefore are included in the **manifest fingerprint** (S0.2). Any byte change flips the fingerprint.

---

## Canonical definition (what S0.4 does)

For $m\in\mathcal M$ with $c=\texttt{home\_country\_iso}(m)\in\mathcal I$,

$$
g_c \leftarrow G(c)\in\mathbb R_{>0},\qquad
b_m \leftarrow B(c)\in\{1,2,3,4,5\}.
$$

These are **lookups** only; **no** thresholds are calculated at runtime.

---

## Semantics & downstream usage

* $b_m$ (Jenks bucket) appears **only** in the hurdle design as five one-hot dummies (column order frozen by the fitting bundle).
* $\log g_c$ appears **only** in NB **dispersion** (never in the mean).
* If materialised, these features live under `â€¦/parameter_hash={parameter_hash}/` (parameter-scoped model artefacts), governed by `schemas.1A.yaml` (e.g., `#/model/hurdle_design_matrix`, `#/model/hurdle_pi_probs`). They are otherwise transient into S0.5.

---

## Determinism & numeric policy

* **No randomness;** outputs identical across shards and reruns with the same `manifest_fingerprint`.

* Any derived transforms (e.g., $\log g_c$ in S0.5) use **binary64**, no FMA, serial evaluation order (S0.8).

* **Class semantics (for CI intuition only):** if $B$ were rebuilt, thresholds $\tau_0<\dots<\tau_5$ satisfy
  $B(c)=k \iff G(c)\in(\tau_{k-1},\tau_k]$ (classes are **right-closed**). The *authoritative* truth remains the shipped table $B$.

---

## Failure semantics (abort; zero tolerance)

Abort with a clear message (including offending dataset and PK) if any holds:

* `E_HOME_ISO_FK(m,c)`: `home_country_iso` not in the runâ€™s ISO set (S0.1).
* `E_GDP_MISSING(c)`: no GDP row for `c` at `observation_year=2024`.
* `E_GDP_NONPOS(c, g_c)`: GDP value $\le 0$ (double-guard; schema forbids).
* `E_BUCKET_MISSING(c)`: no bucket row for `c` in `gdp_bucket_map_2024`.
* `E_BUCKET_RANGE(c, b)`: bucket not in $\{1..5\}$ (double-guard; schema forbids).

---

## Validation hooks (runtime & CI)

1. **Coverage:** every `home_country_iso` in `merchant_ids` has both $G(c)$ and $B(c)$.
2. **FK integrity:** all `country_iso` in GDP & bucket tables are members of the runâ€™s ISO set.
3. **Lineage evidence:** both artefacts are present in the **manifest fingerprint** enumeration (counts & digests logged by S0.2).
4. **Optional CI rebuild (non-runtime):** recompute Jenks $K{=}5$ from the pinned $G(\cdot)$ and assert equality with `gdp_bucket_map_2024`; fail with a per-ISO diff if not identical.

---

## Optional rebuild spec for $B$ (CI only; deterministic)

Goal: optimal 1-D 5-class partition (Jenks / optimal $k$-means DP) over $\{G(c)\}$.

Deterministic procedure (binary64):

1. Build sorted vector $y_1\le\dots\le y_n$ of GDP values; **stable sort by `(value, iso)`** to make ties deterministic.
2. Prefix sums $S_k=\sum_{i\le k}y_i,\ Q_k=\sum_{i\le k}y_i^2$.
3. DP: $ \text{SSE}(a..b)=Q_b-Q_{a-1}-\frac{(S_b-S_{a-1})^2}{b-a+1}$.
   $D[b,1]=\text{SSE}(1..b);\quad D[b,j]=\min_{a\in[j..b]} D[a-1,j-1]+\text{SSE}(a..b)$.
   Keep backpointers $P[b,j]$.
4. Backtrack at $(b{=}n,j{=}5)$ â†’ split indices $t_1 < \dots < t_4$.
5. Thresholds: $\tau_1=y_{t_1},\dots,\tau_4=y_{t_4}$; classes are **right-closed**.
6. **Tie handling:** if multiple optima exist in flat regions, choose the **lexicographically smallest** $(t_1,\dots,t_4)$ (prefer earlier splits).
7. Map $B(c)=k$ iff $G(c)\in(\tau_{k-1},\tau_k]$. Emit a deterministic diff if any ISOâ€™s bucket differs from `gdp_bucket_map_2024`.

---

## Reference routine (runtime path; language-agnostic)

```text
function S0_4_attach_gdp_features(M, I, G, B):
  # Inputs:
  #   M: merchant_ids (merchant_id, mcc, channel, home_country_iso)
  #   I: ISO-2 set (uppercase ASCII)
  #   G: map ISO -> R>0 for observation_year=2024 (const 2015 USD)
  #   B: map ISO -> {1..5} from gdp_bucket_map_2024
  # Output: iterator of (merchant_id, g_c, b_m)

  for row in M:
      m = row.merchant_id
      c = row.home_country_iso

      assert c in I, E_HOME_ISO_FK(m,c)

      g = G.get(c)                       # must exist; > 0
      if g is None: raise E_GDP_MISSING(c)
      if not (g > 0.0): raise E_GDP_NONPOS(c, g)

      b = B.get(c)                       # must exist; in 1..5
      if b is None: raise E_BUCKET_MISSING(c)
      if not (1 <= b <= 5): raise E_BUCKET_RANGE(c, b)

      yield (m, g, b)                    # carried transiently into S0.5 or materialised under parameter_hash
```

---

## Complexity, concurrency, partitions

* **Time:** $O(|\mathcal M|)$ hash lookups; **Space:** $O(1)$ per streamed row.
* **Parallelism:** embarrassingly parallel; determinism holds (pure lookups).
* **Lineage & partitions:** both GDP and bucket artefacts are in the **manifest fingerprint**; changing either flips egress partitions. If features are materialised into design artefacts, they are **parameter-scoped** (partitioned by `parameter_hash` only; **do not** embed `manifest_fingerprint` in parameter-scoped tables).

---

**Bottom line:** S0.4 is a strict, zero-RNG lookup that attaches $(g_c,b_m)$ from a *single*, pinned GDP vintage (obs-year 2024, const-2015-USD) and its precomputed Jenks-5 map. Rebuild rules are deterministic (CI-only), class semantics are right-closed, failure codes are explicit, and storage/lineage boundaries are clearâ€”so S0.5+ can consume these as immutable inputs.

---

# S0.5 â€” Design Matrices (Hurdle & NB), Column Discipline, and Validation (normative, fixed)

## Purpose & scope

Deterministically construct **column-aligned design vectors** for each merchant $m$ for:

* the **hurdle logistic** (single vs. multi) used in **S1**, and
* the **Negative-Binomial (NB)** branch used in **S2** (mean and dispersion links).

**Column dictionaries and ordering are frozen by the model-fitting bundle** and are **never recomputed at runtime**. **No RNG** is consumed here.

---

## Inputs (read-only; pinned by S0.1â€“S0.4)

* From **ingress/S0.1** (validated & mapped already):
  `merchant_id`, `mcc`, `channel_sym âˆˆ {CP,CNP}`, `home_country_iso`.
* From **S0.4**:
  $g_c=G(c)>0$ (GDP per-capita for home ISO $c$), and $b_m=B(c)\in\{1,\dots,5\}$ (Jenks-5 bucket). Pure lookups.
* From the **fitting bundle** (parameter-scoped artefacts whose bytes affect `parameter_hash`):

  * **Column dictionaries** (with **frozen order**):

    * MCC dummies (size $C_{\text{mcc}}$).
    * Channel dummies (size 2) with **canonical order** `["CP","CNP"]`.
    * GDP-bucket dummies (size 5) with order `[1,2,3,4,5]`.
    * *(Dictionaries are shipped together with coefficients; their byte order is authoritative.)*
  * **Coefficient vectors**:

    * **Hurdle** $\beta$ â€” a **single** YAML vector containing: intercept, MCC block, channel block, **all 5** bucket dummies.
    * **NB dispersion** coefficients â€” intercept, MCC block, channel block, and **slope on $\ln g_c$**.
      *(NB mean excludes GDP bucket by design.)*

> **Global design rule (normative):** **GDP bucket enters only the hurdle**; **$\ln g_c$** enters **only** NB **dispersion**. The builder **must** assert this at construction time.

---

## Encoders (deterministic one-hots; column-frozen)

Let the frozen dictionaries give column indices. Define one-hot encoders:

$$
\phi_{\text{mcc}}:\mathcal K\to\{0,1\}^{C_{\text{mcc}}},\quad
\phi_{\text{ch}}:\{\text{CP},\text{CNP}\}\to\{0,1\}^{2},\quad
\phi_{\text{dev}}:\{1,\dots,5\}\to\{0,1\}^{5},
$$

each returning a vector with **exactly one** 1 at the index dictated by its dictionary.
The **intercept** is always the leading scalar 1.

* **Channel vocabulary (normative):** the only internal symbols are `CP` and `CNP` (S0.1 mapping from ingress strings). The channel dictionary **must** be exactly `["CP","CNP"]`.

---

## Design vectors (definitions, dimensions, strict order)

For merchant $m$ with $c=\texttt{home\_country\_iso}(m)$, $g_c>0$, $b_m\in\{1,\dots,5\}$:

### Hurdle (logit) design

$$
\boxed{\,x_m=\big[1,\ \phi_{\text{mcc}}(\texttt{mcc}_m),\ \phi_{\text{ch}}(\texttt{channel\_sym}_m),\ \phi_{\text{dev}}(b_m)\big]^\top\,}\in\mathbb R^{1+C_{\text{mcc}}+2+5}.
$$

$$
\eta_m=\beta^\top x_m,\qquad \pi_m=\sigma(\eta_m)=\frac{1}{1+e^{-\eta_m}}.
$$

All hurdle coefficients, including the 5 bucket dummies, are in **one** ordered vector $\beta$.

### Negative-Binomial (used in S2)

$$
\boxed{\,x^{(\mu)}_m=\big[1,\ \phi_{\text{mcc}}(\texttt{mcc}_m),\ \phi_{\text{ch}}(\texttt{channel\_sym}_m)\big]^\top\,}\in\mathbb R^{1+C_{\text{mcc}}+2},
$$

$$
\boxed{\,x^{(\phi)}_m=\big[1,\ \phi_{\text{mcc}}(\texttt{mcc}_m),\ \phi_{\text{ch}}(\texttt{channel\_sym}_m),\ \ln g_c\big]^\top\,}\in\mathbb R^{1+C_{\text{mcc}}+2+1}.
$$

**Leakage guard (enforced):** bucket dummies **not** present in $x^{(\mu)}$; $\ln g_c$ present **only** in $x^{(\phi)}$.

---

## Safe logistic evaluation (notation consistent with Â§S0.3: ln = natural log) (overflow-stable, no clamp in compute path)

Use the branch-stable form:

$$
\sigma(\eta)=
\begin{cases}
\frac{1}{1+e^{-\eta}},& \eta\ge0,\\[4pt]
\frac{e^{\eta}}{1+e^{\eta}},& \eta<0.
\end{cases}
$$

* **Computation:** **no clamping**; this preserves the possibility that extreme $\eta$ underflow/overflow yields $\pi\in\{0,1\}$, which S1 will treat as a **zero-draw** Bernoulli case per S0.3.
* **Display/logging:** it is allowed to **format** $\pi$ as 0 or 1 when $|\eta|>40$, but this **must not** affect computation.

---

## Determinism & numeric policy

* **No randomness**; outputs depend only on frozen dictionaries and S0.4 features.
* IEEE-754 **binary64**; on ordering-critical paths (any later reductions/normalisations that involve these vectors), **no FMA** and **serial reductions** per S0.8. Changing these toggles changes the numeric-policy artefact and thus the fingerprint.

---

## Persistence (optional) & partitions

By default, $x_m, x^{(\mu)}_m, x^{(\phi)}_m$ are **in-memory**. If materialised:

* `hurdle_design_matrix` under `â€¦/parameter_hash={parameter_hash}/â€¦` with schema `schemas.1A.yaml#/model/hurdle_design_matrix`.
* Optional diagnostics: `hurdle_pi_probs` under `â€¦/parameter_hash={parameter_hash}/â€¦` with schema `#/model/hurdle_pi_probs` (**never** used by samplers).

**Partitioning (normative):** these caches are **parameter-scoped**.

* **Rows must embed** the same `parameter_hash` as the directory key.
* **Do not embed** `manifest_fingerprint` as a required column in parameter-scoped outputs.

---

## Validation hooks (must pass)

1. **Column alignment / shapes**

   * `len(beta_hurdle) == 1 + C_mcc + 2 + 5`.
   * The NB dispersion coefficient vector matches `1 + C_mcc + 2 + 1`.
   * The **dictionary order** used to build vectors matches the order implied by the coefficient vectors. Any drift is a hard error.
2. **One-hot correctness** â€” each encoder emits exactly one â€œ1â€.
3. **Feature domains** â€” `g_c > 0`; `b_m âˆˆ {1..5}` (from S0.4).
4. **Leakage guard (machine-checked)** â€” bucket dummies appear in `x_m` only; `ln(g_c)` appears in `x^{(Ï†)}_m` only.
5. **Partition lint (if persisted)** â€” embedded `parameter_hash` equals the path key exactly; otherwise `E_PARTITION_MISMATCH`.

---

## Failure semantics (precise aborts)

* `E_DSGN_UNKNOWN_MCC(mcc)` â€” MCC absent from the fitting dictionary.
* `E_DSGN_UNKNOWN_CHANNEL(ch)` â€” channel symbol not in `{CP,CNP}`.
* `E_DSGN_SHAPE_MISMATCH(exp_dim, got_dim)` â€” coefficient/design dimension mismatch.
* `E_DSGN_DOMAIN_GDP(g)` â€” `g_c â‰¤ 0`.
* `E_DSGN_DOMAIN_BUCKET(b)` â€” `b âˆ‰ {1..5}`.
* `E_PARTITION_MISMATCH(id, path_key, embedded_key)` â€” parameter-scoped persistence key mismatch.

---

## Reference algorithm (language-agnostic)

```text
function S0_5_build_designs(M, dict_mcc, dict_ch, dict_dev5,
                            beta_hurdle, nb_dispersion_coef, G, B):
  # dict_ch must equal ["CP","CNP"]; dict_dev5 must equal [1,2,3,4,5]
  assert dict_ch == ["CP","CNP"], E_DSGN_UNKNOWN_CHANNEL
  assert dict_dev5 == [1,2,3,4,5], E_DSGN_SHAPE_MISMATCH

  # Expected shapes (frozen by bundle)
  assert len(beta_hurdle) == 1 + len(dict_mcc) + 2 + 5, E_DSGN_SHAPE_MISMATCH
  assert len(nb_dispersion_coef) == 1 + len(dict_mcc) + 2 + 1, E_DSGN_SHAPE_MISMATCH

  for r in M:
      m  = r.merchant_id
      c  = r.home_country_iso
      ch = r.channel_sym          # already CP/CNP from S0.1 mapping
      g  = G[c];  if not (g > 0):       raise E_DSGN_DOMAIN_GDP(g)
      b  = B[c];  if b not in {1,2,3,4,5}: raise E_DSGN_DOMAIN_BUCKET(b)

      # one-hot positions are obtained from frozen dictionaries
      i_mcc = dict_mcc.index_of(r.mcc)         # throws -> E_DSGN_UNKNOWN_MCC
      i_ch  = dict_ch.index_of(ch)
      i_dev = dict_dev5.index_of(b)

      h_mcc = one_hot(i_mcc, len(dict_mcc))
      h_ch  = one_hot(i_ch, 2)
      h_dev = one_hot(i_dev, 5)

      x_hurdle = [1] + h_mcc + h_ch + h_dev
      x_nb_mu  = [1] + h_mcc + h_ch
      x_nb_phi = [1] + h_mcc + h_ch + [ln(g)]

      # Enforce leakage rule structurally (redundant but explicit)
      assert len(x_nb_mu)  == 1 + len(dict_mcc) + 2
      assert len(x_nb_phi) == 1 + len(dict_mcc) + 2 + 1

      yield (m, x_hurdle, x_nb_mu, x_nb_phi)
```

---

## Complexity & concurrency

* **Time:** $O(|\mathcal M|)$ with constant work per row.
* **Space:** streaming; one merchant at a time.
* **Parallelism:** embarrassingly parallel; determinism holds (frozen dictionaries + S0.4 lookups).

---

## Downstream connections

* **S1** consumes $(x_m,\beta)$ to compute $\eta_m$ and then the Bernoulli hurdle; S1 **aborts** on any design/coeff mismatch.
* **S2** consumes $(x^{(\mu)}_m,x^{(\phi)}_m)$ for NB mean/dispersion; all RNG usage there follows S0.3â€™s envelope/budget rules.

---

**Summary:** S0.5 now gives an implementer the exact, frozen layout for hurdle and NB designs, enforces the CP/CNP vocabulary and the â€œbucket-in-hurdle / log-GDP-in-dispersionâ€ rule, and cleanly separates parameter-scoped persistence from egress lineage. Itâ€™s deterministic, leakage-proof, and ready to wire into S1/S2.

---

# S0.6 â€” Cross-border Eligibility (deterministic gate, normative, fixed)

## Purpose

Decide, **without randomness**, whether each merchant $m$ is permitted to attempt cross-border expansion later (i.e., enter S4â€“S6). 
Persist **exactly one row per merchant** to the parameter-scoped dataset **`crossborder_eligibility_flags`** with fields `(parameter_hash, merchant_id, is_eligible, reason, rule_set)` (optionally `produced_by_fingerprint` for provenance).

* **Parameter-scoped** â‡’ partition by `parameter_hash`; **rows embed `parameter_hash`** (required by schema). `produced_by_fingerprint` (hex64) is optional and informational.

No RNG is consumed in S0.6.

---

## Inputs (read-only; pinned earlier)

* **Merchant tuple** $t(m)=(\texttt{mcc}_m,\texttt{channel\_sym}_m,\texttt{home\_country\_iso}_m)$ from `merchant_ids` (S0.1), where `channel_sym âˆˆ {CP,CNP}` (S0.1 mapping is authoritative).
* **Parameter bundle:** `crossborder_hyperparams.yaml` (governed by `parameter_hash`; contains the eligibility rule set).
* **Lineage keys:** `parameter_hash` (partition path and embedded column).
* **Schema & dictionary:** dataset `crossborder_eligibility_flags` â†’ partitioned by `{parameter_hash}`, schema `schemas.1A.yaml#/prep/crossborder_eligibility_flags`.

---

## Output (authoritative)

Write one row per merchant $m$ to:

```
.../crossborder_eligibility_flags/parameter_hash={parameter_hash}/part-*.parquet
```

**Columns (normative; per schema):**

* `parameter_hash` (hex64; **must equal** the path key),
* `produced_by_fingerprint` (hex64; optional, **informational only** â€” it is **never** part of partition keys or equality checks),
* `merchant_id` (PK; one and only one row per merchant),
* `is_eligible` (boolean),
* `reason` (nullable string: winning rule `id`, or `"default_allow"` / `"default_deny"`),
* `rule_set` (non-empty string copied from `eligibility.rule_set_id`).

---

## Domains & symbols

* Channels $\mathcal C=\{\text{CP},\text{CNP}\}$ (internal symbols only; ingress strings are mapped in S0.1).
* Countries $\mathcal I$: ISO-3166 alpha-2 set (uppercase ASCII; pinned in S0.1).
* MCC set $\mathcal K$: 4-digit codes (domain pinned in S0.1).

---

## Rule family (configuration semantics)

All eligibility rules live in **`crossborder_hyperparams.yaml`** under:

```yaml
eligibility:
  rule_set_id: "eligibility.v1.2025-04-15"
  default_decision: "deny"   # "allow" | "deny"
  rules:
    - id: "sanctions_deny"
      priority: 10           # integer [0, 2^31-1]
      decision: "deny"       # "allow" | "deny"
      mcc:     ["*"]         # "*" or list of 4-digit codes or ranges "5000-5999"
      channel: ["CP","CNP"]  # subset of {"CP","CNP"} or "*"
      iso:     ["RU","IR","KP"]  # subset of ISO-2 or "*"
      reason:  "sanctions"
    # ...
```

**Bundle validation (at load):**

* `rule_set_id`: non-empty ASCII; becomes the `rule_set` column value.
* `default_decision âˆˆ {"allow","deny"}`.
* For each rule:

  * `id`: ASCII, **unique** within the bundle.
  * `priority`: integer in $[0,2^{31}{-}1]$.
  * `decision âˆˆ {"allow","deny"}`.
  * `channel`: `"*"` or subset of **exactly** `{"CP","CNP"}`.
  * `iso`: `"*"` or subset of $\mathcal I$ (uppercase ASCII).
  * `mcc`: `"*"` or list of **4-digit strings** and/or **inclusive ranges** `"NNNN-MMMM"` with `NNNN, MMMM âˆˆ 0000..9999` and `NNNN â‰¤ MMMM`.
* Reject any MCC not in $\mathcal K$ after range expansion; reject any ISO not in $\mathcal I$.

---

## Set interpretation & matching (normative)

After expanding `"*"` and MCC ranges:

* Each rule $r$ defines sets $S_{\rm mcc}\subseteq\mathcal K$, $S_{\rm ch}\subseteq\mathcal C$, $S_{\rm iso}\subseteq\mathcal I$ and a decision $d\in\{\textsf{allow},\textsf{deny}\}$.
* **Match:** $r$ matches $m$ iff $ \texttt{mcc}_m\in S_{\rm mcc} \land \texttt{channel\_sym}_m\in S_{\rm ch} \land \texttt{home\_country\_iso}_m\in S_{\rm iso}$.

**Range semantics (MCC):** `"5000-5999"` means all integer codes $5000 \le \text{MCC} \le 5999$; codes are compared numerically after parsing 4-digit strings.

---

## Conflict resolution & determinism (total order)

When multiple rules match a merchant, choose using this **total order**:

1. **Decision tier:** `deny` outranks `allow`.
2. **Priority:** lower `priority` outranks higher (e.g., `10` beats `50`).
3. **Tie-break:** ASCII lexical order on `id`.

Let $\mathrm{best}_{\textsf{deny}}(m)$ and $\mathrm{best}_{\textsf{allow}}(m)$ be the top-ranked matching rules in their tiers (or `None`).

Decision:

* If $\mathrm{best}_{\textsf{deny}}(m)$ exists â†’ `is_eligible = false`, `reason = that.id`.
* Else if $\mathrm{best}_{\textsf{allow}}(m)$ exists â†’ `is_eligible = true`, `reason = that.id`.
* Else â†’ `is_eligible = (default_decision == "allow")`, `reason = "default_allow"` or `"default_deny"`.

This is **order-invariant** and parallel-safe.

---

## Algorithm (exact; streaming-safe)

For each merchant $m$:

1. Fetch $t(m) = (\texttt{mcc}, \texttt{channel\_sym}, \texttt{home\_iso})$.
2. Build candidate sets $D$ (deny) and $A$ (allow) by matching rules.
3. Choose per **Conflict resolution**; produce `reason`.
4. Write row (partition by `parameter_hash`):

```json
{
  "parameter_hash":           "<hex64>",
  "produced_by_fingerprint":  "<hex64>",  // optional
  "merchant_id":              "<id>",
  "is_eligible":              true|false,
  "reason":                   "<winning rule id | default_allow | default_deny>",
  "rule_set":                 "<eligibility.rule_set_id>"
}
```

**Performance notes:** Index rules by `(channel_sym, home_iso)` and keep MCC ranges in an interval set for $O(\log R)$ matching; naive $O(R)$ is acceptable at current scale.

---

## Formal spec (decision function)

With $\prec$ defined by `(decision, priority, id)` where `deny < allow`, numeric `priority` ascending, ASCII `id`:

$$
\mathrm{best}_{\textsf{deny}}(m)=\min\nolimits_\prec\{r\in\mathcal{R}_{\textsf{deny}}: r\text{ matches }m\},
$$

$$
\mathrm{best}_{\textsf{allow}}(m)=\min\nolimits_\prec\{r\in\mathcal{R}_{\textsf{allow}}: r\text{ matches }m\}.
$$

$$
e_m =
\begin{cases}
0,& \mathrm{best}_{\textsf{deny}}(m)\text{ exists},\\
1,& \mathrm{best}_{\textsf{deny}}(m)=\varnothing \land \mathrm{best}_{\textsf{allow}}(m)\text{ exists},\\
\mathbf 1\{\texttt{default\_decision}=\text{"allow"}\},& \text{otherwise.}
\end{cases}
$$

`reason` = winning rule `id`, else `"default_allow"`/`"default_deny"`.

---

## Determinism & contracts

* **No RNG.** Output depends only on $t(m)$ and the parameter bundle.
* **Schema & partitioning (normative):** rows conform to `#/prep/crossborder_eligibility_flags`; dataset is partitioned by `{parameter_hash}`; each row **embeds the same `parameter_hash`**.
  `produced_by_fingerprint` (if present) is **informational only** and **never** compared to any path key or used in partition/equality semantics.
---

## Failure semantics (precise aborts)

**At parameter load:**

* `E_ELIG_RULESET_ID_EMPTY` â€” missing/empty `rule_set_id`.
* `E_ELIG_DEFAULT_INVALID` â€” `default_decision` not in `{"allow","deny"}`.
* `E_ELIG_RULE_DUP_ID(id)` â€” duplicate rule `id`.
* `E_ELIG_RULE_BAD_CHANNEL(id,ch)` â€” channel not in `{"CP","CNP"}` or `"*"`.
* `E_ELIG_RULE_BAD_ISO(id,iso)` â€” ISO not in $\mathcal I$ or not uppercase ASCII.
* `E_ELIG_RULE_BAD_MCC(id,mcc)` â€” MCC not in $\mathcal K$ or range malformed (`"NNNN-MMMM"` with `NNNN â‰¤ MMMM` required).

**At evaluation/persist:**

* `E_ELIG_MISSING_MERCHANT(m)` â€” missing required fields in `merchant_ids`.
* `E_ELIG_WRITE_FAIL(path, errno)` â€” failed to persist a row.
* `E_PARTITION_MISMATCH(path_key, embedded_key)` â€” embedded `parameter_hash` mismatches directory key.

On any error, **abort S0**; no partial output is acceptable.

---

## Validation & CI hooks

1. **Schema conformance:** every row matches `#/prep/crossborder_eligibility_flags`.
2. **Coverage/uniqueness:** exactly one row per `merchant_id` (PK).
3. **Determinism:** rerunning S0.6 with the same inputs yields **byte-identical** rows (ignoring file order).
4. **Policy lint:** report counts by decision source (`deny`, `allow`, `default_*`) to monitor rule-set shifts when parameters change.
5. **Partition lint:** dataset path and embedded `parameter_hash` match; `produced_by_fingerprint` (if present) is ignored by validators.

---

## Reference pseudocode (language-agnostic)

```text
function S0_6_apply_eligibility_rules(merchants, params, parameter_hash, produced_by_fp=None):
  cfg   = params["eligibility"]
  rsid  = cfg["rule_set_id"]; assert rsid, E_ELIG_RULESET_ID_EMPTY
  def_allow = (cfg["default_decision"] == "allow")
  rules = parse_validate_expand(cfg["rules"])  # validates domains, ranges, duplicates, vocab

  deny_idx  = index_rules(rules, decision="deny")   # indexed by (channel_sym, home_iso), MCC intervals
  allow_idx = index_rules(rules, decision="allow")

  writer = open_partitioned_writer("crossborder_eligibility_flags",
            partition={"parameter_hash": parameter_hash})

  for m in merchants:
      key = (m.mcc, m.channel_sym, m.home_country_iso)  # channel_sym is CP/CNP from S0.1

      D = match(deny_idx,  key)   # returns list of (priority, id)
      A = match(allow_idx, key)

      if not empty(D):
          best = min_by(D, (priority, id))  # numeric asc, ASCII asc
          is_eligible = false
          reason      = best.id
      elif not empty(A):
          best = min_by(A, (priority, id))
          is_eligible = true
          reason      = best.id
      else:
          is_eligible = def_allow
          reason      = "default_allow" if def_allow else "default_deny"

      row = {
        "parameter_hash": parameter_hash,
        "merchant_id": m.merchant_id,
        "is_eligible": is_eligible,
        "reason": reason,
        "rule_set": rsid
      }
      if produced_by_fp is not None:
          row["produced_by_fingerprint"] = produced_by_fp

      writer.write(row)

  writer.close()
```

---

## Complexity, concurrency, and I/O

* **Time:** $O(|\mathcal M|\log |\mathcal R|)$ with simple indices; $O(|\mathcal M||\mathcal R|)$ naive.
* **Space:** streaming; constant memory aside from rule indices.
* **Parallelism:** embarrassingly parallel; determinism holds (pure function of $t(m)$ and versioned rule set).

---

**Bottom line:** S0.6 now writes a **parameter-scoped** authoritative gate with a stable conflict-resolution order, explicit `reason`, versioned `rule_set`, and **no fingerprint coupling**. S3 consumes it verbatim to control the cross-border branchâ€”no RNG, no ambiguity.

---

# S0.7 â€” Hurdle Ï€ Diagnostic Cache (deterministic, optional, normative, fixed)

## Purpose

Materialise a **read-only diagnostics table** with per-merchant logistic-hurdle outputs

$$
(\texttt{merchant\_id},\ \eta_m,\ \pi_m),\quad \eta_m=\beta^\top x_m,\ \pi_m=\sigma(\eta_m)\in[0,1],
$$

so monitoring/validation can inspect the hurdle surface **without** recomputing on the hot path. This artefact is **never consulted by samplers**; it is **optional** and lives under the **parameter-scoped** partition.

* **Dataset id / path / schema:** `hurdle_pi_probs` â†’
  `.../layer1/1A/hurdle_pi_probs/parameter_hash={parameter_hash}/`
  schema `schemas.1A.yaml#/model/hurdle_pi_probs`.
* **Registry role:** â€œLogistic-hurdle Ï€ (single vs multi) per merchantâ€. Depends on `hurdle_design_matrix` and `hurdle_coefficients`.

> S0.10 lists this as **optional** output of S0 (parameter-scoped). Presence/absence does not affect any downstream state.

---

## Inputs (frozen by S0.1â€“S0.5)

* **Design vector** $x_m=[1,\ \phi_{\text{mcc}},\ \phi_{\text{ch}},\ \phi_{\text{dev}}]$ from **S0.5** (column order frozen by the fitting bundle).
* **Hurdle coefficients** $\beta$ (single YAML vector matching $x_m$â€™s layout).
* **Lineage keys:** `parameter_hash`  (partition path and embedded column). `produced_by_fingerprint` (hex64) optional/informational.

**No RNG** is consumed.

---

## Output (schema, typing, keys)

A Parquet table with **one row per merchant**:

* **Primary key:** `merchant_id`.
* **Partition key:** `parameter_hash` (directory level).

**Columns (normative; per schema):**

* `parameter_hash` (hex64; **must equal** path key),
* `produced_by_fingerprint` (hex64; optional, **informational only** â€” it is **never** part of partition keys or equality checks),
* `merchant_id` (id64 per ingress schema),
* `logit` (float32) â€” narrowed $\eta_m$,
* `pi` (float32) â€” narrowed $\pi_m\in[0,1]$.
---

## Canonical definitions & numerical policy

### Linear predictor and logistic

Let $\eta_m = \beta^\top x_m$ with the **exact** column order frozen by the fitting bundle (validated in S0.5).

Evaluate the logistic with the **overflow-stable** branch form:

$$
\sigma(\eta)=
\begin{cases}
\dfrac{1}{1+e^{-\eta}}, & \eta\ge 0,\\[6pt]
\dfrac{e^{\eta}}{1+e^{\eta}}, & \eta<0.
\end{cases}
$$

* **Computation:** IEEE-754 **binary64**; no FMA; fixed evaluation order (S0.8).
* **Extremes:** $\pi_m$ may equal **exactly** 0 or 1 for large $|\eta_m|$; this is **allowed** and must be persisted faithfully.

### Storage narrowing (deterministic)

Persist `logit` and `pi` as **float32** using **round-to-nearest, ties-to-even** after computing both in binary64. Narrowing is part of the contract and is **for storage only**.

---

## Determinism & scope rules

* **No randomness.** Results depend only on $x_m$ and $\beta$.
* **Diagnostics-only.** No production sampler/allocation routine may read this table.
* **Parameter-scoped.** Changing any governed parameter byte changes `parameter_hash` and thus the partition; no implicit overwrite across partitions.
* `produced_by_fingerprint` (if present) is **informational only** and **does not** participate in partition keys or row equality.

---

## Failure semantics (abort S0; precise codes)

* `E_PI_SHAPE_MISMATCH(exp_dim, got_dim)` â€” $|\beta|\neq \dim(x_m)$ (double-guard beyond S0.5).
* `E_PI_NAN_OR_INF(m)` â€” $\eta_m$ or $\pi_m$ non-finite.
* `E_PI_PARTITION(path_key, embedded_key)` â€” embedded `parameter_hash` mismatches directory key.
* `E_PI_WRITE(path, errno)` â€” write failure.

> On any failure, **abort S0**; the cache is either wholly correct or absent.

---

## Validation & CI hooks

1. **Schema conformance** â€” matches `#/model/hurdle_pi_probs`.
2. **Coverage** â€” exactly $|\mathcal M|$ rows (1 per `merchant_id`).
3. **Recompute check** â€” rebuild $x_m$ (S0.5) and recompute $\eta_m,\pi_m$ from $\beta$; assert equality to stored **float32** values (bit-for-bit).
4. **Partition lint** â€” path includes `parameter_hash={parameter_hash}`; row `parameter_hash` equals the path key; no other required lineage fields.
5. **Downstream isolation** â€” static analysis / policy test: states S1â€“S9 must not read `hurdle_pi_probs`.

---

## Algorithm (exact; streaming-safe)

For each merchant $m\in\mathcal M$:

1. Load or deterministically construct $x_m$ (S0.5). Assert dictionary/shape alignment.
2. Compute $\eta_m=\beta^\top x_m$ in **binary64**; compute $\pi_m=\sigma(\eta_m)$ via the branch-stable definition.
3. Assert finiteness; else `E_PI_NAN_OR_INF(m)`.
4. Narrow deterministically to float32 (round-to-nearest-even):

   * `logit := f32(Î·_m)`, `pi := f32(Ï€_m)`.
5. Emit:

   ```json
   {
     "parameter_hash": "<hex64>",
     "produced_by_fingerprint":  "<hex64>",  // optional
     "merchant_id":          "<id64>",
     "logit":                "<float32>",
     "pi":                   "<float32>[0,1]"
   }
   ```
6. Persist under `.../hurdle_pi_probs/parameter_hash={parameter_hash}/â€¦` (Parquet). File ordering is unspecified.

**Complexity.** $O(|\mathcal M|)$ dot-products; $O(1)$ space; trivially parallel.

---

## Reference pseudocode (language-agnostic)

```text
function S0_7_build_hurdle_pi_cache(merchants, beta, dicts, parameter_hash, produced_by_fp=None):
  writer = open_partitioned_writer("hurdle_pi_probs",
             partition={"parameter_hash": parameter_hash})

  for m in merchants:
      x = build_x_hurdle(m, dicts)                 # deterministic, validated in S0.5
      eta64 = dot_f64(beta, x)                      # binary64 accumulation, fixed order
      pi64  = logistic_branch_stable(eta64)         # âˆˆ [0,1]; extremes allowed

      if not (is_finite(eta64) and is_finite(pi64)):
          raise E_PI_NAN_OR_INF(m.merchant_id)

      row = {
        "parameter_hash": parameter_hash,
        "merchant_id":    m.merchant_id,
        "logit":          f32(eta64),               # IEEE RNâ€“even
        "pi":             f32(pi64)
      }
      if produced_by_fp is not None:
          row["produced_by_fingerprint"] = produced_by_fp

      writer.write(row)

  writer.close()
```

---

## Downstream connections

* **S1** recomputes $\eta_m,\pi_m$ to draw the Bernoulli hurdle; it **does not** read this cache.
* **S0.10** treats this artefact as optional; presence does not affect `manifest_fingerprint` beyond the bytes of the governing parameters that already define `parameter_hash`.

---

**Summary:** S0.7 is now a **parameter-scoped**, deterministic diagnostics cache with **no** coupling to the run fingerprint, consistent logistic semantics ($\pi\in[0,1]$), explicit float32-for-storage narrowing, and strict validation. Itâ€™s safe to generate or skip, and it can never influence stochastic behaviour downstream.

---

# S0.8 â€” Numeric Policy & Determinism Controls (normative, fixed)

**Cross-reference (normative):** All samplers and transforms in Â§S0.3 use IEEE-754 **binary64**, round-to-nearest-ties-even, **FMA off**, **no FTZ/DAZ**, and the pinned deterministic libm profile (`numeric_policy.json`, `math_profile_manifest.json`). Any computation that affects a branch/order (acceptance tests, sort keys, integerisation) must execute in a **serial, fixed-order** kernel. Self-tests and attest are in Â§S0.8 and are part of the validation bundle.

## Purpose

Guarantee that numerically sensitive computations in 1A are **bit-stable** across machines, compilers, and parallelism. S0.8 defines:

* the **floating-point environment** (format, rounding, subnormals),
* a **deterministic math profile** for `exp/log/sin/cos/atan2/pow/...`,
* **compiler/runtime flags** forbidding contraction/fast-math,
* **reduction/sorting** rules (fixed order, exact tie-breaks),
* **tolerances** for validation (internal vs. external),
* runtime **self-tests** that abort the run if violated.

No RNG is consumed here.

> **Artefactisation (normative):** Two files are required and **included in the S0.2 manifest enumeration**. Changing either flips `manifest_fingerprint`.
>
> 1. `numeric_policy.json` â€” declares environment/flags and kernel policies.
> 2. `math_profile_manifest.json` â€” pins the vendored libm/profile (name, version, digest set).

---

## S0.8.1 Floating-point environment (must hold)

* **Format:** IEEE-754 **binary64** for **all** computations that can affect decisions/order. Diagnostics may downcast only when a state explicitly allows it (e.g., S0.7).
* **Rounding mode:** **Round-to-nearest, ties-to-even (RNE)**; set and verify at startup.
* **FMA (fused multiply-add):** **Disabled** on any ordering-critical path (anything that feeds decisions, rankings, acceptance tests, or integerisation). Permitted **only** in non-critical code paths that never influence a branch/order.
* **Subnormals:** **Honour** subnormals; FTZ/DAZ **off**.
* **Exceptions:** mask signals; **any** NaN/Inf in model computations is a **hard error** (S0.8.8).
* **Endianness:** little-endian; where relevant (hashing/PRNG), byte order is pinned per state.
* **Constants (normative):** All decision-critical constants (e.g., `TAU`) **MUST** be encoded as **binary64 hex literals**; recomputation from other constants (e.g., `2*pi`) is **forbidden** to avoid drift across platforms/compilers.

**`numeric_policy.json` (normative minimum):**

```json
{
  "binary_format": "ieee754-binary64",
  "rounding_mode": "rne",
  "fma_allowed": false,
  "flush_to_zero": false,
  "denormals_are_zero": false,
  "sum_policy": "serial_neumaier",
  "parallel_decision_kernels": "disallowed",
  "version": "1.0"
}
```

---

## S0.8.2 Deterministic libm profile (math functions)

**Scope:** `exp`, `log`, `log1p`, `expm1`, `sqrt`, `sin`, `cos`, `atan2`, `pow`, `tanh`, `erf` (if used), `lgamma`.

**Normative requirements**

* Selected implementations are **bit-identical** across platforms.
* `sqrt` is correctly rounded (IEEE).
* All others above are **deterministic to the last bit** under the selected profile.

**Operationalisation**

* Ship a vendored, deterministic math layer behind a sealed API (e.g., `mlr_math::exp`), or pin an exact libm build with a content digest set.
* **Disallow** toolchains from substituting system libm for these calls in decision-critical code.
* Record a **`math_profile_id`** and fold `math_profile_manifest.json` into the S0.2 artefact set.

**`math_profile_manifest.json` (example):**

```json
{
  "math_profile_id": "mlr-math-1.2.0",
  "vendor": "acme-deterministic-libm",
  "build": "glibc-2.38-toolchain-2025-04-10",
  "functions": ["exp","log","log1p","expm1","sqrt","sin","cos","atan2","pow","tanh","lgamma"],
  "artifacts": [
    {"name":"libmlr_math.so","sha256":"<64-hex>"},
    {"name":"headers.tgz","sha256":"<64-hex>"}
  ]
}
```

---

## S0.8.3 Reductions, accumulations & linear algebra

* **Sums/dots:** Use **serial, fixed-order** accumulation with **Neumaier** compensation for any total/dot feeding a decision or ordering. Never parallel-reduce such values.
* **Products/ratios:** Multiply in binary64 unless a state mandates log-sum; check denominators against zero with strict guards where required.
* **BLAS/LAPACK:** **Do not** call external BLAS/LAPACK on decision-critical paths. If ever required, pin a deterministic backend and include it in `math_profile_id`.

**Reference kernels (normative):** see Â§S0.8.10.

---

## S0.8.4 Compiler / interpreter flags (build contract)

**C/C++ (examples):**

* `-fno-fast-math -fno-unsafe-math-optimizations`
* `-ffp-contract=off` (no FMA contraction)
* `-fexcess-precision=standard -frounding-math`
* `-fno-associative-math -fno-reciprocal-math -fno-finite-math-only`
* (Legacy/x87 only) `-ffloat-store` if needed to avoid excess precision.

**LLVM/Clang IR:**
Disable `fast-math` flags; use constrained FP intrinsics with RNE and masked exceptions.

**Python/NumPy/JVM, etc.:**

* Avoid `np.sum` for decision-critical reductions; call our scalar kernels.
* Pin `MKL_NUM_THREADS=1`, `OPENBLAS_NUM_THREADS=1`.
* Disable auto-vectorisation where it can change summation order.

**GPU:** Do **not** offload decision-critical kernels unless a deterministic math profile is pinned with fused ops disabled.

> All effective flags + environment variables must be serialised into `numeric_policy_attest.json` (see Â§S0.8.9) and the attest fileâ€™s digest is included in the manifest enumeration.

---

## S0.8.5 Sorting, comparisons & total order for floats

* **Total order:** For sorting/keys, use IEEE-754 **`totalOrder`** semantics; **NaNs are forbidden** (encountering a NaN is a hard error). `-0.0 < +0.0`.
* **Tie-breakers:** If float keys compare equal, break ties **lexicographically** by a deterministic secondary key (e.g., `ISO` then `merchant_id`).
* **Equality:** Use exact equality only where guaranteed (counters, integers).
* **Nearly-equal:** Prefer **ULP-based** checks (`ulpDiff â‰¤ 1`) when used in self-tests; do **not** â€œepsilon-fudgeâ€ model decisions.

**Portable key mapping (non-NaN domain):**

```text
# bits = uint64 bit pattern of the float (IEEE-754)
# Ties then break by deterministic secondary key: ISO (ASCII) then merchant_id.
# Map to an integer key that is monotone w.r.t. totalOrder for non-NaNs:
key = (bits & 0x8000000000000000) ? (~bits) : (bits | 0x8000000000000000)
# This guarantees -0.0 sorts before +0.0 and preserves numeric order elsewhere.
```

---

## S0.8.6 Tolerances & quantisation

* **Internal (self-tests):**

  * Sums/dots: `ulpDiff â‰¤ 1`.
  * Transcendentals: **bit-exact** under the pinned profile.
* **External (reporting/comparing persisted float32):**
  `max(abs_diff, rel_diff) â‰¤ 1e-6` when comparing **float32** diagnostics to recomputed float64 values **downcast to float32**.
* **Quantisation:** Where a state requires downcasting (e.g., S0.7), use IEEE **round-to-nearest-even**. No other quantisation is allowed unless a state explicitly says so.

---

## S0.8.7 Determinism under concurrency

* **Order-invariance by construction:** RNG streams are keyed (S0.3).
* **Numeric kernels:** Any computation that feeds a sort/branch must run in a **single-threaded** scalar loop with fixed iteration order and Neumaier compensation.
* **Map-style parallelism:** Allowed when results are per-row and never aggregated into decision/order without the serial kernel.
* **I/O:** File emission order is unspecified; equality is defined by row sets. Partitions are unambiguous due to hashes/fingerprints.

---

## S0.8.8 Failure semantics (abort codes)

* `E_NUM_FMA_ON` â€” FMA contraction detected on a guarded kernel.
* `E_NUM_FTZ_ON` â€” FTZ/DAZ detected.
* `E_NUM_RNDMODE` â€” non-RNE rounding mode.
* `E_NUM_LIBM_PROFILE` â€” math profile mismatch or non-deterministic libm detected.
* `E_NUM_NAN_OR_INF(ctx)` â€” NaN/Inf produced in a model computation.
* `E_NUM_PAR_REDUCE` â€” decision-critical reduction executed in parallel or with a non-pinned topology.
* `E_NUM_TOTORDER_NAN` â€” NaN encountered in a total-order sort key.
* `E_NUM_ULP_MISMATCH(func)` â€” recomputation differs beyond ULP budget.
* `E_NUM_PROFILE_ARTIFACT_MISSING(name)` â€” required numeric artefact (policy/profile/attest) missing.

On any of the above, **abort the run**.

---

## S0.8.9 Self-tests (must run before S1)

Run after S0.2 (hashing) and before any RNG draw:

1. **Rounding & FTZ**

* Assert RNE.
* Create a subnormal (e.g., `2^-1075`) and multiply by 1; assert not flushed to 0.

2. **FMA detection**

* Evaluate a triple `(a,b,c)` with known fused vs non-fused outcomes; assert the **non-fused** result (contraction disabled).

3. **libm profile**

* Evaluate a fixed regression suite for `exp/log/sin/cos/atan2/pow/...` and compare against vendored expected **bit patterns**. Fail on any mismatch.

4. **Neumaier audited sum**

* Sum an adversarial sequence (e.g., `[1, 1e-16] Ã— N` then `[-1] Ã— N`) and assert `(sum, compensation)` matches expected values.

5. **TotalOrder sanity**

* Sort a crafted float array including `-0.0`, `+0.0`, extremes; verify ordering and tie-breakers.

**Attestation (normative output):** Write `numeric_policy_attest.json` with:

```json
{
  "numeric_policy_version": "1.0",
  "math_profile_id": "mlr-math-1.2.0",
  "platform": {"os":"linux","libc":"glibc-2.38","compiler":"clang-18.0"},
  "flags": {"ffast-math": false, "fp_contract":"off", "rounding":"rne", "ftz": false, "daz": false},
  "self_tests": {"rounding": "pass", "ftz": "pass", "fma": "pass", "libm": "pass", "neumaier": "pass", "total_order": "pass"},
  "digests": [
    {"name": "numeric_policy.json", "sha256": "<64-hex>"},
    {"name": "math_profile_manifest.json", "sha256": "<64-hex>"}
  ]
}
```

Include this fileâ€™s digest in the manifest enumeration (S0.2).

---

## S0.8.10 Reference kernels (pseudocode)

**Neumaier compensated sum (fixed order)**

```text
def sum_neumaier(xs: iterable<float64>) -> float64:
    s = 0.0; c = 0.0
    for x in xs:                 # fixed iteration order
        y = x - c
        t = s + y
        c = (t - s) - y
        s = t
    return s
```

**Dot product with Neumaier**

```text
def dot_neumaier(a: float64[], b: float64[]) -> float64:
    assert len(a) == len(b)
    s = 0.0; c = 0.0
    for i in 0..len(a)-1:
        y = a[i]*b[i] - c
        t = s + y
        c = (t - s) - y
        s = t
    return s
```

**Total-order key for non-NaN floats**

```text
def total_order_key(x: float64, secondary) -> tuple:
    assert not isNaN(x)           # NaN forbidden
    bits = u64_from_f64(x)
    key  = (~bits) if (bits & 0x8000000000000000) else (bits | 0x8000000000000000)
    return (key, secondary)       # (-0.0) sorts before (+0.0); ties broken by 'secondary'
```

---

## S0.8.11 Validation & CI hooks

* **Bitwise CI:** run self-tests on â‰¥2 platforms (e.g., glibc vs. musl) â†’ identical results.
* **Rebuild sensitivity:** any change that alters decision-critical outputs must also change `numeric_policy.json` or `math_profile_manifest.json`, thus flipping the fingerprint.
* **Partition lint:** ensure `numeric_policy_attest.json` is present in the validation bundle and its digest is in the manifest enumeration.

---

## S0.8.12 Interaction with other states

* **S0.3 (RNG):** Boxâ€“Muller, gamma acceptance tests, PTRS, and Gumbel keys use the pinned math profile and branch-stable formulas.
* **S0.5â€“S2 (design & GLM):** Dots/logistics use Neumaier + overflow-stable logistic; results are bit-stable.
* **S6 (ranking):** All sorts over float keys use the **total order** + deterministic tie-breakers.

---

**Bottom line:** S0.8 is now a **first-class, fingerprinted numeric contract**: binary64 + RNE, **no FMA**, **no FTZ/DAZ**, deterministic libm, fixed-order Neumaier reductions, total-order sorting, and mandatory self-tests. With `numeric_policy.json`, `math_profile_manifest.json`, and `numeric_policy_attest.json` wired into lineage, downstream states can rely on bit-stable arithmetic everywhere.

---

# S0.9 â€” Failure Modes & Abort Semantics (normative, fixed)

## Purpose

Define a **single, deterministic** failure contract for 1A so that any violation of schema, lineage, numeric policy, RNG envelope, or partitioning halts the run the **same way every time**, with an actionable forensic payload.

**Scope.** S0.9 governs **all of 1A** (S0â€“S7). Failures detected anywhere are classified by **S0.9 failure classes (F1â€“F10)** and surfaced through a **uniform failure record**.

---

## 0) Definitions & severity

* **Run-abort (hard):** Stop the **entire** 1A run immediately; no further states execute.
* **Merchant-abort (soft):** Allowed **only** where a state explicitly specifies it (e.g., S4 corridor policy). Soft aborts are logged to a **merchant-abort log** (see Â§2.4) and **never** used to bypass S0.9 run-abort conditions.

---

## 1) Failure catalog (F1â€“F10)

### F1 â€” Ingress schema violation (`merchant_ids`)

**Predicate:** fails `schemas.ingress.layer1.yaml#/merchant_ids` (types, required fields, PK, ISO). **Run-abort.**
**`failure_code` examples:** `ingress_schema_violation`, `ingress_pk_duplicate`, `ingress_iso_bad`.

---

### F2 â€” Parameter / fingerprint formation failure (S0.2)

Covers `parameter_hash` & `manifest_fingerprint`. **Run-abort.**

* **F2a Parameters:** missing/duplicate/unreadable governed file; hash race.
  `failure_code`: `param_file_missing|duplicate|unreadable|changed_during_hash`.
* **F2b Fingerprint:** empty artefact set; artefact unreadable; bad commit bytes.
  `failure_code`: `fingerprint_empty_artifacts|artifact_unreadable|git_bytes_invalid|bad_hex_encoding`.

---

### F3 â€” Non-finite or out-of-domain features / model outputs

**Run-abort.**

* **F3a S0.4:** `nonpositive_gdp`, `bucket_out_of_range`.
* **F3b S0.5/S0.7:** `hurdle_nonfinite` (non-finite `Î·`/`Ï€`).

---

### F4 â€” RNG bootstrap / envelope / draw-accounting failures

**Run-abort.**

* **F4a:** `rng_audit_missing_before_first_draw`.
* **F4b:** `rng_envelope_violation` (missing required fields).
* **F4c:** `rng_counter_mismatch` (`afterâˆ’before != blocks`).
* **F4d:** `rng_budget_violation` (per S0.3 budgets).

---

### F5 â€” Partitioning / lineage mismatch (dictionary-backed)

Wrong partition **or** row lineage doesnâ€™t match path. **Run-abort.**
`failure_code`: `partition_mismatch`, `log_partition_violation`.

---

### F6 â€” Schema-authority breach

1A authority is **JSON-Schema** only. Any non-authoritative ref (e.g., Avro) â†’ **Run-abort.**
`failure_code`: `non_authoritative_schema_ref`.

---

### F7 â€” Numeric policy violation (S0.8)

Binary64+RNE, no FMA, no FTZ/DAZ, deterministic libm, serial reductions. **Run-abort.**
`failure_code`: `numeric_rounding_mode|fma_detected|ftz_or_daz_enabled|libm_profile_mismatch|parallel_reduce_on_ordering_path`.

---

### F8 â€” Event coverage / corridor guarantees (state-specific)

Required event families missing/inconsistent; corridor breached. **Run-abort** for structural gaps; state may additionally log **merchant-abort** when allowed.
`failure_code`: `event_family_missing`, `corridor_breach`.

---

### F9 â€” Dictionary / path drift

Dataset path or lineage semantics deviates from dictionary. **Run-abort.**
`failure_code`: `dictionary_path_violation`.

---

### F10 â€” I/O integrity & atomics

Short writes, partial instances, non-atomic commit. **Run-abort.**
`failure_code`: `io_write_failure`, `incomplete_dataset_instance`.

---

## 1.1 Crosswalk: state-level `E_*` â†’ S0.9 classes

To keep prior `E_*` codes, attach both:

| Example `E_*` (state)                 | S0.9 class | Canonical `failure_code`                  |
| ------------------------------------- | ---------- | ----------------------------------------- |
| `E_INGRESS_SCHEMA` (S0.1)             | F1         | `ingress_schema_violation`                |
| `E_PARAM_EMPTY`, `E_GIT_BYTES` (S0.2) | F2         | `param_file_missing`, `git_bytes_invalid` |
| `E_PI_NAN_OR_INF` (S0.7)              | F3         | `hurdle_nonfinite`                        |
| `E_AUTHORITY_BREACH` (S0.1)           | F6         | `non_authoritative_schema_ref`            |
| `E_NUM_FMA_ON` (S0.8)                 | F7         | `fma_detected`                            |
| `E_PARTITION_MISMATCH` (several)      | F5         | `partition_mismatch`                      |
| `E_RUNID_COLLISION_EXHAUSTED` (S0.2.4) | F2 | `runid_collision_exhausted` |

**Rule:** a failure record **must** carry both `failure_class` (F1â€¦F10) and the concrete `failure_code` (snake_case).

---

## 2) Abort artefacts, paths, and atomics

### 2.1 Where the failure record lives (validation bundle)

Validation outputs are **fingerprint-scoped**. On the first failure:

```
data/layer1/1A/validation/failures/
  fingerprint={manifest_fingerprint}/
    seed={seed}/
      run_id={run_id}/
        failure.json                  # mandatory, single file
        _FAILED.SENTINEL.json         # duplicate of the forensic header (for quick scans)
```

* The directory is created and committed **atomically** (temp dir â†’ rename).
* Re-runs that hit the **same** failure with the **same** lineage overwrite the temp but **not** the committed `failure.json`.

### 2.2 Failure record (normative JSON schema)

```json
{
  "type": "object",
  "required": ["failure_class","failure_code","state","module",
               "parameter_hash","manifest_fingerprint","seed","run_id",
               "ts_utc","detail"],
  "properties": {
    "failure_class": {"type":"string","enum":["F1","F2","F3","F4","F5","F6","F7","F8","F9","F10"]},
    "failure_code":  {"type":"string"},              // snake_case
    "state":         {"type":"string"},              // e.g., "S0.3"
    "module":        {"type":"string"},              // e.g., "1A.gumbel_sampler"
    "dataset_id":    {"type":"string"},              // optional
    "merchant_id":   {"type":["string","null"]},
    "parameter_hash":{"type":"string","pattern":"^[0-9a-f]{64}$"},
    "manifest_fingerprint":{"type":"string","pattern":"^[0-9a-f]{64}$"},
    "seed":          {"type":"integer","minimum":0},
    "run_id":        {"type":"string","pattern":"^[0-9a-f]{32}$"},
    "ts_utc":        {"type":"integer","minimum":0},
    "detail":        {"type":"object"}               // typed per failure_code (see below)
  }
}
```

**Timestamp encoding note (normative):**
* In **failure records**, `ts_utc` is an **unsigned integer**: **nanoseconds since the Unix epoch (UTC)**.
* In **RNG event envelopes** (S0.3.1), `ts_utc` is an **RFC-3339/ISO-8601 UTC string**.

**Typed `detail` payloads** (normative minima):

* `rng_counter_mismatch`: `{ "before":{"hi":u64,"lo":u64}, "after":{"hi":u64,"lo":u64}, "blocks": uint64, "draws": "uint128-dec" }`
* `partition_mismatch`: `{ "dataset_id":str, "path_key":str, "embedded_key":str }`
* `ingress_schema_violation`: `{ "row_pk":str, "field":str, "message":str }`
* `artifact_unreadable`: `{ "path":str, "errno":int }`
* `dictionary_path_violation`: `{ "expected":str, "observed":str }`
* `hurdle_nonfinite`: `{ "merchant_id":str, "field": "logit|pi", "value":"str" }`

### 2.3 Abort procedure (deterministic)

1. **Stop** emitting new events/datasets immediately.
2. **Flush & seal** validation bundle (path above) with `failure.json` (+ `_FAILED.SENTINEL.json`).
3. **Mark incomplete outputs**: delete temp dirs; if any partial partition escaped temp, write a sibling `_FAILED.json` sentinel **inside that partition** with `{dataset_id, partition_keys, reason}`.
4. **Freeze RNG**: no further RNG events; last counters remain as in the failing envelope.
5. **Exit non-zero**; orchestrator halts downstream.

### 2.4 Merchant-abort log (when a state allows soft aborts)

When a state defines **merchant-abort**, write (parameter-scoped):

```
.../prep/merchant_abort_log/parameter_hash={parameter_hash}/part-*.parquet
  { merchant_id, state, module, reason, ts_utc }
```

This log **never** replaces a run-abort; it records permitted soft fallbacks only.

---

## 3) Validator responsibilities (hardened)

* **Ingress schema** (F1).
* **Lineage recomputation** of `parameter_hash` & `manifest_fingerprint` (F2).
* **RNG envelope & counter conservation** for **every** event; budgets per family (F4).
* **Partition equivalence** (F5): parameter-scoped `{parameter_hash}`, logs `{seed,parameter_hash,run_id}`, egress/validation `{fingerprint}` (and often `seed`).
* **Numeric attestation** (F7): run S0.8 self-tests; verify `numeric_policy_attest.json` and reject mismatches.
* **Coverage/corridors** per state (F8).
* **Dictionary paths** (F9).
* **Instance completeness & atomics** (F10).

---

## 4) Where each failure is first detected

| Failure                         | First detector (preferred)        | Secondary                 |
| ------------------------------- | --------------------------------- | ------------------------- |
| F1 ingress schema               | S0.1 loader                       | Validator pass 1          |
| F2 params/fingerprint           | S0.2 hashing                      | Validator recompute       |
| F3 features / hurdle non-finite | S0.4 / S0.5 / S0.7 evaluators     | Validator recompute       |
| F4 envelope / counters          | Event emitters (runtime guards)   | Validator envelope pass   |
| F5 partitioning/lineage         | Dataset writer (path+embed check) | Validator partition lint  |
| F6 schema authority             | Registry/dictionary linter        | Validator schema refs     |
| F7 numeric policy               | S0.8 self-tests                   | Validator re-attest       |
| F8 coverage/corridor            | State invariants (S1/S2/S4/â€¦)     | Validator family coverage |
| F9 dictionary/path drift        | Writer + dictionary linter        | Validator path lint       |
| F10 I/O atomics                 | Writer commit phase               | Validator completeness    |

---

## 5) Examples (concrete)

* **Missing audit row (F4a):** first RNG event is `hurdle_bernoulli` but `rng_audit_log` has no `run_id=â€¦` â†’ `rng_audit_missing_before_first_draw` â†’ **Run-abort**.
* **Partition mismatch (F5):** write `outlet_catalogue` under `â€¦/fingerprint=X` but embed row fingerprint `Y` â†’ `partition_mismatch` â†’ **Run-abort**.
* **Non-finite hurdle (F3b):** `Î·_m` becomes NaN due to malformed coefficients â†’ `hurdle_nonfinite` â†’ **Run-abort**.

---

## 6) Reference abort routine (language-agnostic)

```text
function abort_run(failure_class, failure_code, ctx):
  stop_emitters()                                  # no new RNG/events
  payload = build_failure_payload(failure_class, failure_code, ctx)  # includes lineage keys
  path = val_path(fingerprint=ctx.fp, seed=ctx.seed, run_id=ctx.run_id)
  write_atomic(path+"/failure.json", json(payload))
  write_atomic(path+"/_FAILED.SENTINEL.json", json(payload_header(payload)))
  mark_incomplete_partitions(ctx.inflight_outputs)
  exit_nonzero()
```

---

## 7) Determinism & idempotency guarantees

* Given identical inputs & environment, a failing run produces the **same** `failure_class`, `failure_code`, and **bit-identical** `failure.json`.
* Re-running without changing `manifest_fingerprint`/`parameter_hash` yields the **same** abort artefacts.
* Only the **first** detected failure is recorded; subsequent symptoms are suppressed to keep forensics clean.

---

**Bottom line:** S0.9 is now a precise, fingerprinted **fail-fast** contract: one vocabulary (F1â€“F10 + `failure_code`), one failure record schema, atomic/validated placement under `{fingerprint, seed, run_id}`, a clear Eâ†”F crosswalk for state errors, and a deterministic abort routine. With this in place, **any** deviation from schema, lineage, RNG, numeric policy, or partitioning terminates the run loudlyâ€”with everything you need to reproduce and fix it.

---

# S0.10 â€” Outputs, Partitions & Validation Bundle (normative, fixed)

## S0.10.1 Lineage keys (recap; scope of use)
> **Consumer note (normative):** Egress `outlet_catalogue` does **not** encode cross-country order; consumers **MUST** join **`s3_candidate_set.candidate_rank`** (S3 is the sole authority; recorded in S0.1) to obtain rank (0=home; foreigns by Gumbel order).

> **Tie-break (LRR, normative):** sort by quantised residual (desc), then **ISO code (ASCII) asc**. Do **not** use Gumbel rank as a secondary key.


* **`parameter_hash` (hex64):** partitions **parameter-scoped** artefacts. (S0.2.2)
* **`manifest_fingerprint` (hex64):** partitions **egress & validation** artefacts. (S0.2.3)
* **`seed` (u64):** modelling seed; used in RNG log partitions and S0.3 derivations.
* **`run_id` (hex32):** **logs only**; partitions RNG audit/trace/events. (S0.2.4)

**Embedding rule (row-level):**
* If a schema includes a **`parameter_hash`** column, its value **must equal** the directory key (`parameter_hash`).
* If a schema includes a **`manifest_fingerprint`** column, its value **must equal** the runâ€™s `manifest_fingerprint`.
  For **egress/validation** datasets (fingerprint-scoped), it **must also equal** the directory key `fingerprint={manifest_fingerprint}`.
* For datasets with **both** columns present, both constraints must hold simultaneously.

Any mismatch triggers **S0.9/F5 run-abort**.

---

## S0.10.2 Artefact classes produced by S0

1. **Parameter-scoped model inputs/caches** (deterministic; reusable across runs with the same `parameter_hash`)

* `crossborder_eligibility_flags` (S0.6).
* `hurdle_pi_probs` (S0.7, **optional** diagnostics).
* *(Optionally transient; not authoritative)*: `hurdle_design_matrix`.

2. **Lineage & attestation files** (**fingerprint-scoped**)

* `validation_bundle_1A` directory (see Â§S0.10.5), containing:

  * `MANIFEST.json`
  * `parameter_hash_resolved.json`
  * `manifest_fingerprint_resolved.json`
  * `param_digest_log.jsonl`
  * `fingerprint_artifacts.jsonl`
  * `numeric_policy_attest.json` (S0.8)
  * optional: `DICTIONARY_LINT.txt`, `SCHEMA_LINT.txt`
  * `_passed.flag` (gate)

3. **RNG logs (for partition contract completeness; produced at S0.3+)**

* `rng_audit_log`, `rng_trace_log`, `rng_event_*` (see Â§S0.10.3 â€œLog-scopedâ€).

---

## S0.10.3 Partitioning & paths (authoritative)

**Naming rule (normative):** Any path segment named `fingerprint={â€¦}` **always** carries the value of `manifest_fingerprint`. The column name is `manifest_fingerprint`; the path label remains `fingerprint=â€¦`.

**RNG logs (normative paths & keys):**
`rng_audit_log` â†’ `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl`
`rng_trace_log` â†’ `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl`
`rng_event_*` â†’ `logs/rng/events/{family}/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
Partitioning for all three: `["seed","parameter_hash","run_id"]`. The dataset dictionary remains authoritative for any additional fields.

### Parameter-scoped (partition by `parameter_hash`)

**Dataset:** `crossborder_eligibility_flags`
**Path:** `data/layer1/1A/crossborder_eligibility_flags/parameter_hash={parameter_hash}/part-*.parquet`
**Schema:** `schemas.1A.yaml#/prep/crossborder_eligibility_flags`
**Row keys:** `merchant_id` (PK)
**Embedded lineage (normative):** `parameter_hash` (required; equals path key). Optional: `produced_by_fingerprint` (hex64), **informational only** and **never** part of partition keys/equality.

**Dataset (optional):** `hurdle_pi_probs`
**Path:** `data/layer1/1A/hurdle_pi_probs/parameter_hash={parameter_hash}/part-*.parquet`
**Schema:** `schemas.1A.yaml#/model/hurdle_pi_probs`
**Row keys:** `merchant_id` (PK)
**Embedded lineage (normative):** `parameter_hash` (required; equals path key). Optional: `produced_by_fingerprint` (hex64), **informational only** and **never** part of partition keys/equality.

> **Write semantics (both):** **overwrite-atomic** per partition (stage in `â€¦/_tmp.{uuid}` â†’ single `rename(2)`). Partial contents must never become visible (S0.9/F10).

### Fingerprint-scoped (partition by `fingerprint`)

**Directory:** `validation_bundle_1A`
**Path:** `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`
**Contents:** Â§S0.10.5.

### Log-scoped (RNG)

**Logs:** `rng_audit_log`, `rng_trace_log`, each `rng_event_*`
**Path template:** `logs/rng/<stream>/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
> **Authority (normative):** Actual **paths and partition columns** are authoritative in the **dataset dictionary**. Strings shown here are examples to illustrate shape.

> **Physical line order (normative):** For RNG **JSONL** logs, line order is append order **within a file**; there are **no ordering guarantees across files/parts**. Equality is by **row set**; any consumer that depends on physical order is non-conformant.

**Envelope (per S0.3):** `{seed, parameter_hash, manifest_fingerprint, run_id, module, substream_label, counter_before/after, blocks, draws, ts_utc, payloadâ€¦}`.
`rng_trace_log` aggregates **blocks**.
---

## S0.10.4 Immutability, idempotence & retention

* **Immutability:** A concrete partition directory is **immutable**. Re-runs with the same keys either no-op or atomically replace with **byte-identical** content.
* **Idempotence:** With identical inputs and numeric policy, outputs are **bit-identical** (file order within a Parquet partition is out-of-contract).
* **Retention:**

  * Parameter-scoped: keep last **N=5** `parameter_hash` generations (policy).
  * Validation bundles: keep **all** `manifest_fingerprint` generations.
  * RNG logs: retain per compliance (e.g., 90 days).

---

## S0.10.5 Validation bundle (structure, hashing, gate)

```
validation/
  fingerprint={manifest_fingerprint}/
    MANIFEST.json
    parameter_hash_resolved.json
    manifest_fingerprint_resolved.json
    param_digest_log.jsonl
    fingerprint_artifacts.jsonl
    numeric_policy_attest.json
    DICTIONARY_LINT.txt          # optional
    SCHEMA_LINT.txt              # optional
    _passed.flag
```

**`MANIFEST.json` (normative fields)**

```json
{
  "version": "1A.validation.v1",
  "manifest_fingerprint": "<hex64>",
  "parameter_hash": "<hex64>",
  "git_commit_hex": "<hex40-or-64>",
  "artifact_count": 123,
  "math_profile_id": "mlr-math-1.2.0",
  "compiler_flags": {"fma": false, "ftz": false, "rounding": "RNE", "fast_math": false, "blas": "none"},
  "created_utc_ns": 1723700000123456789
}
```

**`parameter_hash_resolved.json`**

```json
{"parameter_hash":"<hex64>","filenames_sorted":["crossborder_hyperparams.yaml","hurdle_coefficients.yaml","nb_dispersion_coefficients.yaml","ccy_smoothing_params.yaml","s6_selection_policy.yaml"],"artifact_count":5}
```

**`manifest_fingerprint_resolved.json`**

```json
{"manifest_fingerprint":"<hex64>","git_commit_hex":"<hex40-or-64>","parameter_hash":"<hex64>","artifact_count":123}
```

**`param_digest_log.jsonl`** â€” one JSON line per governed parameter file: `{filename,size_bytes,sha256_hex,mtime_ns}`.
**`fingerprint_artifacts.jsonl`** â€” one JSON line per opened artefact: `{path,sha256_hex,size_bytes}`.
**`numeric_policy_attest.json`** â€” S0.8 self-tests/flags & IDs.

**Gate `_passed.flag` (mandatory):**
Contains one line: `sha256_hex = <hex64>`, where `<hex64>` is **SHA-256 over the raw byte concatenation** of **all other bundle files** in **ASCII lexicographic filename order**. `_passed.flag` itself is **excluded** from the hash.
Downstream **must** verify this; mismatch â‡’ treat run as invalid (S0.9/F10).

---

## S0.10.6 Writer behavior (atomicity & lints)

* **Atomic publish:** write bundle into `â€¦/validation/_tmp.{uuid}`; compute `_passed.flag`; single atomic `rename(2)` to `fingerprint=â€¦/`. On failure, delete tmp.
* **Optional lints:**

  * `DICTIONARY_LINT.txt`: diff of dictionary vs observed writer paths/schema refs.
  * `SCHEMA_LINT.txt`: results of schema validation of produced datasets.
    By default these **are included** in the gate hash; you may exclude them only if documented (then also omit them from the hash computation consistently).

---

## S0.10.7 Idempotent re-runs & equivalence

Two bundles are **equivalent** if:

* `MANIFEST.json` matches byte-for-byte.
* all other files match byte-for-byte and `_passed.flag` hashes match.

---

## S0.10.8 Pseudocode (reference)

```text
function S0_10_emit_outputs_and_bundle(ctx):
  # Assert parameter-scoped partitions exist (S0.6/S0.7 may have written them)
  assert partition_exists("crossborder_eligibility_flags", ctx.parameter_hash)
  if ctx.emit_hurdle_pi_probs:
      assert partition_exists("hurdle_pi_probs", ctx.parameter_hash)

  # Build bundle in temp dir
  tmp = mktempdir()
  write_json(tmp+"/MANIFEST.json", {
    "version":"1A.validation.v1",
    "manifest_fingerprint":ctx.fingerprint,
    "parameter_hash":ctx.parameter_hash,
    "git_commit_hex":ctx.git_commit_hex,
    "artifact_count":len(ctx.artifacts),
    "math_profile_id":ctx.math_profile_id,
    "compiler_flags":ctx.compiler_flags,
    "created_utc_ns":now_ns()
  })
  write_json(tmp+"/parameter_hash_resolved.json", {
    "parameter_hash":ctx.parameter_hash,
    "filenames_sorted":ctx.param_filenames_sorted
  })
  write_json(tmp+"/manifest_fingerprint_resolved.json", {
    "manifest_fingerprint":ctx.fingerprint,
    "git_commit_hex":ctx.git_commit_hex,
    "parameter_hash":ctx.parameter_hash,
    "artifact_count":len(ctx.artifacts)
  })
  write_jsonl(tmp+"/param_digest_log.jsonl", ctx.param_digests)
  write_jsonl(tmp+"/fingerprint_artifacts.jsonl", ctx.artifact_digests)
  write_json(tmp+"/numeric_policy_attest.json", ctx.numeric_attest)

  # Gate: hash all files except the flag
  files = list_ascii_sorted(tmp)           # lexicographic ASCII
  H = sha256_concat_bytes([read_bytes(f) for f in files if basename(f) != "_passed.flag"])
  write_text(tmp+"/_passed.flag", "sha256_hex = " + hex64(H) + "\n")

  # Atomic publish under fingerprint partition
  publish_atomic(tmp, "data/layer1/1A/validation/fingerprint="+ctx.fingerprint)
```

---

## S0.10.9 Validation (CI/runtime must assert)

* **Partition lint:** parameter-scoped datasets live under `parameter_hash=â€¦`; rows embed the same `parameter_hash`; RNG logs use `{seed,parameter_hash,run_id}`; validation bundle under `fingerprint=â€¦`.
* **Bundle integrity:** presence of all required files and `_passed.flag` hash match.
* **Schema conformance:** produced datasets validate against their JSON-Schema anchors.
* **Lineage recomputation:** `parameter_hash` and `manifest_fingerprint` recomputed equal the `*_resolved.json` values.
* **Numeric attestation:** `numeric_policy_attest.json` indicates **all** S0.8 self-tests passed.

---

## S0.10.10 Downstream consumption rules

* **Parameter-scoped readers** (S1/S2/S3): key by **`parameter_hash`** only; ignore `run_id`.
* **Egress/validation consumers:**

  1. locate `fingerprint={manifest_fingerprint}`,
  2. verify `_passed.flag`,
  3. (optional) re-hash `fingerprint_artifacts.jsonl` & `param_digest_log.jsonl`.
     Any failure â‡’ treat run as invalid and halt per S0.9.

---

**Bottom line:** S0.10 locks S0â€™s outputs into clear, non-overlapping partitions: parameter-scoped datasets embed **only `parameter_hash`** (with optional `produced_by_fingerprint`), RNG logs are `{seed,parameter_hash,run_id}`, and the **validation bundle** is fingerprint-scoped and **gate-protected**. Everything is atomic, idempotent, and CI-provable.

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s1-expanded"></a>
# state.1A.s1.expanded.txt

<!-- Source file: state.1A.s1.expanded.txt | BYTE-EXACT EMBED -->

# S1.1 â€” Inputs, Preconditions, and Write Targets (normative)

## Purpose (what S1 does and does **not** do)

S1 evaluates a **logistic hurdle** per merchant and emits a **Bernoulli outcome** (â€œsingle vs multiâ€). Here we pin **inputs**, **context/lineage**, and **write targets** required to do that deterministically. The logistic, RNG use, and payload specifics are defined in **S1.2â€“S1.4**.
S1 does **not** specify downstream sampling (NB, ZTP, Dirichlet, etc.) nor CI/monitoring; those live in their respective state specs and the validation harness.

---

## Inputs (available at S1 entry)

### 1) Design vector $x_m$ (column-frozen from S0.5)

**Feature vector (logistic):**

* **Block order (fixed):** $[\,\text{intercept}\,] \;\Vert\; \text{onehot(MCC)} \;\Vert\; \text{onehot(channel)} \;\Vert\; \text{onehot(GDP_bucket)}$.
* **Channel encoder (dim=2):** labels/order exactly $[\,\mathrm{CP},\,\mathrm{CNP}\,]$ (from S0).
* **GDP bucket encoder (dim=5):** labels/order exactly $[\,1,2,3,4,5\,]$ (S0 Jenks-5).
* **MCC encoder (dim $=C_{\text{mcc}}$):** **column order is frozen by S0.5** (the fitting bundle). S1 never derives order from map iteration.
* **Shape invariant:** $|x_m| = 1 + C_{\text{mcc}} + 2 + 5$.

S1 **receives** $x_m$ (already constructed by S0.5) as

$$
x_m = \big[\,1,\ \phi_{\text{mcc}}(\texttt{mcc}_m),\ \phi_{\text{ch}}(\texttt{channel}_m),\ \phi_{\text{dev}}(b_m)\,\big]^\top,
$$

with $b_m\in\{1,\dots,5\}$. These are the **only** hurdle features. (NB dispersionâ€™s $\log g_c$ is **not** used here.)

> S0 guarantees domain validity and â€œone-hot sums to 1â€ for all encoder blocks. S1 relies on that; it does **not** re-validate domains.

### 2) Coefficient vector $\beta$ (single YAML, atomic load)

Load $\beta$ **atomically** from the hurdle coefficients bundle. The vector contains **all coefficients** aligned to $x_m$: intercept, MCC block, channel block, and the **five** GDP-bucket dummies. Enforce

$$
|\beta| \;=\; 1 + C_{\text{mcc}} + 2 + 5 \quad\text{else abort (design/coeff mismatch).}
$$

*(Design rule context from S0.5: hurdle uses bucket dummies; NB mean excludes them; NB dispersion uses $\log g_c$.)*

### 3) Lineage & RNG context (fixed before any draw)

S0 has already established the **run identifiers** and RNG environment S1 uses:

* `parameter_hash` (hex64) â€” partitions parameter-scoped artefacts.
* `manifest_fingerprint` (hex64) â€” lineage key; **not** a path partition here.
* `seed` (uint64) â€” master Philox seed.
* `run_id` (hex32) â€” logs-only partition key.
* An `rng_audit_log` exists for this `{seed, parameter_hash, run_id}`. S1 must **not** emit the first hurdle event if that audit row is absent.

**PRNG use model (order-invariant).** All RNG use in 1A is via **label-keyed substreams**. The **base counter** for a given label/merchant pair is derived by S0â€™s keyed-substream mapping from the tuple

$$
(\texttt{seed},\ \texttt{manifest_fingerprint},\ \texttt{substream_label},\ \texttt{merchant_id}),
$$

independent of execution order or other labels. There is **no** cross-label counter chaining in S1.

---

## Envelope contract (shared fields carried by every hurdle event)

Each hurdle record **must** include the layer envelope fields (names and types per the layer schema):

* `ts_utc` â€” RFC-3339 UTC with `Z` and **exactly 6 fractional digits** (microseconds).
* `run_id`, `seed`, `parameter_hash`, `manifest_fingerprint`.
* `module` â€” **literal** `"1A.hurdle_sampler"`.
* `substream_label` â€” **literal** `"hurdle_bernoulli"`.
* Counter words (uint64):
  `rng_counter_before_lo`, `rng_counter_before_hi`, `rng_counter_after_lo`, `rng_counter_after_hi`.
(Object key order is **non-semantic**; names are authoritative. **Producers MAY emit in any order; consumers bind by name.** Compose u128 as `(hi<<64) | lo`.)
* **`draws`** â€” **required** decimal u128 **string**: the number of uniforms consumed by **this** event.

**Budget identity (unsigned 128-bit):**

$$
\Delta \;\equiv\; \mathrm{u128}(\text{after_hi},\text{after_lo}) - \mathrm{u128}(\text{before_hi},\text{before_lo})
\;=\; \texttt{parse_u128(draws)}.
$$

This identity is **scoped to the hurdle family only**. For hurdle, `draws âˆˆ {"0","1"}`; `blocks âˆˆ {0,1}` and **must equal** `parse_u128(draws)`. Other RNG families may have `draws â‰  blocks` while still satisfying S0â€™s counter rules.


For hurdle, $\texttt{draws} \in \{"0","1"\}$.
* Additionally, emit `blocks:uint64` as **required** by S0; for hurdle, `blocks âˆˆ {0,1}` and **must equal** `parse_u128(draws)`.*

---

## Preconditions (hard invariants at S1 entry)

1. **Shape & alignment:** $|\beta|=\dim(x_m)$ and encoder block orders match S0.5â€™s fitting bundle; else abort (design/coeff mismatch).
2. **Numeric environment:** S0â€™s math policy is in force: IEEE-754 **binary64**, RNE, **no FMA**, **no FTZ/DAZ**; fixed-order reductions. S1 uses the overflow-safe **two-branch logistic** (no ad-hoc clamp threshold) in S1.2.
3. **RNG audit present:** audit row for `{seed, parameter_hash, run_id}` exists **before** the first hurdle emission; else abort.

---

## Event stream target (authoritative id, partitions, schema)

S1 emits **exactly one** hurdle record per merchant to:

```
logs/rng/events/hurdle_bernoulli/
  seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl
```

* **Partitions:** `["seed","parameter_hash","run_id"]` (no `module`/`substream_label`/`manifest_fingerprint` in the path).
* **Schema:** `schemas.layer1.yaml#/rng/events/hurdle_bernoulli` (envelope + payload).

**Uniqueness & completeness (per run).** Within `{seed, parameter_hash, run_id}`, there is **exactly one** hurdle event per `merchant_id`, and the hurdle row count equals the merchant universe count for the run (from S0 ingress for the same `manifest_fingerprint`).

**Trace (totals; no merchant dimension).** The RNG **trace** is per `(module, substream_label)` and records cumulative totals keyed by `{seed, parameter_hash, run_id}`. `blocks_total` is the **normative** counter of cumulative consumption; `draws_total` is **required** and **diagnostic** (it must equal the saturating sum of per-event `draws`).

---

## Forward contracts S1 must satisfy (declared here so inputs are complete)

* **Probability (S1.2).** Compute $\eta_m=\beta^\top x_m$ (fixed-order dot in binary64) and $\pi_m$ via the **two-branch** logistic. $\pi_m \in [0,1]$; the row is **deterministic** iff $\pi_m$ equals exactly `0.0` or `1.0` in binary64 (extreme underflow/overflow of `exp`), otherwise $0<\pi_m<1$.
* **RNG substream & $u\in(0,1)$ (S1.3).** Use the keyed substream mapping from **S0**. If $0<\pi_m<1$, consume exactly one open-interval uniform via S0â€™s `u01` mapping (binary64): $u=((x+1)\times 2^{-64})$, then **if** $u==1.0$ set $u=\mathrm{nextafter}(1.0,\text{below})$; if $\pi_m\in\{0,1\}$, draw **zero**. Envelope counters must satisfy the budget identity.
* **Payload discipline (S1.4).** Payload is `{merchant_id, pi, is_multi, deterministic, u}` where `u` is **required** and **nullable**:

  * if $0<\pi<1$: `u âˆˆ (0,1)`, `deterministic=false`, `is_multi = 1{u<pi}`;
  * if $\pi\in\{0,1\}$: `u=null`, `deterministic=true`, `is_multi = (pi == 1.0)`.

---

## Failure semantics (at the S1.1 boundary)

Abort the run if any precondition fails: shape/alignment mismatch; missing audit; envelope/schema or path/partition mismatch. Detailed failure codes and validator behaviour are specified in S1.6 and S1.V.

---

## Why this matters (determinism & replay)

By fixing $x_m$, $\beta$, the run identifiers, the **order-invariant substream mapping**, and the envelope/budget law **before** any draw, S1â€™s Bernoulli outcomes and counters are **bit-replayable** under any sharding or scheduling. This gives the validator a single, unambiguous contract to reproduce S1 decisions.

---

**Bottom line:** S1 starts only when $x_m$, $\beta$, and the lineage/RNG context are immutable and schema-backed; it writes to the single authoritative hurdle stream with fixed envelope and partitions. With these inputs and preconditions, S1.2â€“S1.4 compute $\eta,\pi$, consume at most one uniform (as required), and emit an event that validators can reproduce exactly.

---

# S1.2 â€” Probability map (Î· â†’ Ï€), deterministic & overflow-safe (normative)

## Purpose

Given the frozen design vector $x_m$ and the single-YAML coefficient vector $\beta$ (from S1.1), compute

$$
\eta_m=\beta^\top x_m,\qquad
\pi_m=\sigma(\eta_m)\in[0,1],
$$

then pass $(\eta_m,\pi_m)$ forward to S1.3 (RNG) and S1.4 (event). All numeric environment rules come from **S0.8** (binary64, RN-even, no FMA/FTZ/DAZ, deterministic libm; fixed-order reductions).

---

## Inputs (recap; validated in S1.1)

* **Design vector** $x_m\in\mathbb{R}^{1+C_{\mathrm{mcc}}+2+5}$, column order frozen by the fitting bundle (S0.5).
* **Coefficients** $\beta\in\mathbb{R}^{1+C_{\mathrm{mcc}}+2+5}$ loaded atomically; shape/order equals $x_m$.

(Shape/order failures are handled at S1.1 / S0.9.)

---

## Canonical definitions (math)

### Linear predictor (fixed-order Neumaier reduction)

$$
\eta_m=\beta^\top x_m
$$

Compute in IEEE-754 **binary64** using the **frozen column order** and the **Neumaier compensated summation** mandated by S0.8. No BLAS reordering or parallel reduction is permitted on any ordering-critical path.

### Logistic map and **overflow-safe evaluation** (normative)

Baseline logistic:

$$
\sigma:\mathbb{R}\to(0,1),\qquad
\sigma(\eta)=\frac{1}{1+e^{-\eta}}.
$$

**Evaluation contract (binary64, deterministic):** Use the **two-branch, overflow-safe form**; do **not** introduce any ad-hoc clamp/threshold:

$$
\pi\;=\;
\begin{cases}
\dfrac{1}{1+e^{-\eta}}, & \eta \ge 0,\\[8pt]
\dfrac{e^{\eta}}{1+e^{\eta}}, & \eta < 0.
\end{cases}
$$

Under the S0.8 math profile, this keeps $\pi\in[0,1]$ in binary64 and avoids spurious overflow/underflow in intermediate terms. For **extreme** $|\eta|$, binary64 underflow/overflow of the exponentials may yield $\pi$ exactly `0.0` or `1.0`â€”this is the **only** source of exact saturation.

**Determinism flag (derived):**
`deterministic := (pi == 0.0 || pi == 1.0)` using **binary64 equality**. If `deterministic=true` then S1.3 will consume **zero** uniforms; else S1.3 consumes **exactly one** (see S1.3).

---

## Serialization & bounds (normative I/O rules)

* **Binary64 round-trip:** Producers **MUST** serialize `pi` as the **shortest round-trippable decimal** (â‰¤17 significant digits; scientific notation allowed) so that parsing yields the **exact** original binary64. Consumers **MUST** parse as binary64.
* **Legal range:** Enforce `0.0 â‰¤ pi â‰¤ 1.0` (binary64). If $\pi$ is exactly `0.0` or `1.0`, it came from the two-branch evaluation under binary64; otherwise `0.0 < pi < 1.0`.
* **Diagnostics:** `eta` is **not** part of the normative hurdle event payload; if recorded, it belongs to a **diagnostic** dataset only (non-authoritative).

---

## Deterministic vs stochastic and consequences for S1.3

* **Stochastic case** $(0<\pi<1)$: S1.3 will draw **one** $u\in(0,1)$ from the keyed substream, then decide `is_multi = (u < pi)`; budget `draws=1`. (Open-interval mapping and substreaming per S0.3.)
* **Deterministic case** $(\pi\in\{0.0,1.0\})$: S1.3 performs **no draw**; budget `draws=0`; downstream decision is implied by $\pi$ (`is_multi=true` iff `pi==1.0`).

---

## Numeric policy (must hold; inherited)

S0.8 applies in full: **binary64**, RN-even, **no FMA**, **no FTZ/DAZ**, deterministic libm; fixed-order Neumaier reductions; any NaN/Inf in $\eta$ or $\pi$ is a **hard error** under S0.9.

---

**Bottom line:** S1.2 fixes a single, portable way to compute $(\eta,\pi)$: a **fixed-order Neumaier** dot product followed by a **two-branch logistic** with **no ad-hoc clamp**. Exact `0.0/1.0` arises only from binary64 behavior, and $\pi$ then cleanly determines whether S1.3 consumes **one** uniform or **zero**. **MUST-NOT:** Implementations may **not** clamp $\eta$ or $\pi$ at any threshold (e.g., $|\eta|>40$) during S1 computation or emission; event payload `pi` is the exact logistic result.

---

## Output of S1.2 (to S1.3/S1.4)

For each merchant $m$, S1.2 produces the numeric pair

$$
(\eta_m,\ \pi_m),\qquad \eta_m\in\mathbb{R}\ \text{(finite)},\ \ \pi_m\in[0,1]\ \text{(binary64)}.
$$

These values are **not persisted by S1.2**. They flow directly into:

* **S1.3 (RNG & decision):** determines whether **one** uniform is consumed $(0<\pi<1)$ or **zero** $(\pi\in\{0,1\})$, andâ€”if stochasticâ€”evaluates `is_multi = (u < pi)`.
* **S1.4 (event payload):** `pi` is a required payload field. `eta` is **not** a normative payload field; if recorded, it belongs to a diagnostic dataset (non-authoritative). S1.4 derives `deterministic` from `pi` and applies the `u` presence rule: `u=null` iff `piâˆˆ{0.0,1.0}`, else `uâˆˆ(0,1)`.

---

## Failure semantics (abort S1 / run)

S1.2 must **abort the run** if any of the following hold:

1. **Numeric invalid:** either $\eta$ or $\pi$ is non-finite (NaN/Â±Inf) after evaluation.
2. **Out-of-range:** $\pi \notin [0,1]$ (should not occur with the two-branch logistic).
3. **Shape/order mismatch:** already handled at S1.1; if encountered here, treat as a hard precondition failure.

(Full failure taxonomy, codes, and CI handling live outside S1; this section defines only the operational abort triggers.)

---

## Validator hooks (what the S1 checklist asserts for S1.2)

The single S1 Validator Checklist (referenced once from S1) must be able to **reproduce** S1.2 exactly:

* **Recompute:** Rebuild $x_m$ (from S0â€™s frozen encoders) and re-evaluate $\eta,\pi$ using the fixed-order binary64 dot product and the **two-branch logistic**. Assert:

  * $\eta$ is finite;
  * $\pi \in [0.0,1.0]$;
  * the recomputed $\pi$ matches the emitted `pi` **bit-for-bit** (binary64).
* **Determinism equivalences:**
  $\pi\in\{0.0,1.0\} \iff \text{deterministic}=\text{true} \iff \text{draws}=0 \iff u=\text{null}$.
  Otherwise $0<\pi<1 \iff \text{deterministic}=\text{false} \iff \text{draws}=1 \iff u\in(0,1)$.
* **Budget prediction link (with S1.3):** From $\pi$, predict `draws` as above and reconcile with the event envelope and the cumulative trace totals for the hurdle substream.

---

## Reference algorithm (language-agnostic, ordering-stable)

1. **Dot product:** Compute $\eta=\beta^\top x$ in binary64 using the **frozen column order** and **Neumaier** compensation (no reordering/BLAS on ordering-critical paths).
2. **Logistic (two-branch):**

   * if $\eta \ge 0$ â‡’ $\pi = 1/(1+\exp(-\eta))$;
   * else â‡’ $\pi = \exp(\eta)/(1+\exp(\eta))$.
3. **Guards:** $\eta$ and $\pi$ must be finite; $\pi$ must satisfy $0.0 \le \pi \le 1.0$.
4. **Hand-off:** Emit $(\eta,\pi)$ to S1.3/S1.4. The RNG budget and `u` presence follow directly from $\pi$ as stated above.

*(This is a procedural specification, not implementation code; S0 remains the authority for the FP environment and PRNG primitives.)*

---

## How S1.2 interacts with adjacent sections

* **Feeds S1.3:** $\pi$ sets the **uniform budget**: exactly **one** uniform if $0<\pi<1$, else **zero**. If stochastic, S1.3 evaluates `is_multi = (u < pi)` using the open-interval mapping from S0.
* **Feeds S1.4:** `pi` is serialized with **binary64 round-trip** fidelity. `deterministic` is derived from `pi`; `u` is **required** and **nullable** (`null` iff $\pi\in\{0,1\}$, otherwise a number in $(0,1)$). `is_multi` is **boolean** only.

---

**Bottom line:** S1.2 defines a single, portable procedure for $(\eta,\pi)$: **fixed-order** binary64 dot product and a **two-branch logistic** with **no ad-hoc clamp**. That yields $\pi\in[0,1]$ deterministically, and $\pi$ cleanly drives the exact RNG budget and payload semantics required by S1.3â€“S1.4.

---

# S1.3 â€” RNG substream & Bernoulli trial (normative)

## Purpose

Given $\pi_m$ from S1.2, consume **at most one** uniform $u_m\in(0,1)$ from the merchant-keyed substream labeled `"hurdle_bernoulli"`, decide

$$
\text{is_multi}(m)\;=\;[\,u_m < \pi_m\,],
$$

and emit exactly one hurdle event (payload in S1.4). The keyed-substream mapping, lane policy, and open-interval $U(0,1)$ are owned by **S0.3** and are referenced here without redefinition.

---

## Inputs (available at S1.3 entry)

* $\pi_m\in [0,1]$ from S1.2.
* Run lineage identifiers: `seed`, `parameter_hash`, `manifest_fingerprint`, `run_id`, and `module` (registry literal for this producer).
* `merchant_id` (type `$defs/id64`, carried as a JSON **integer** in events; treated as u64 by the S0 keying primitive).
* Dataset/registry anchors for hurdle events and RNG trace are established elsewhere (S1.1 / dictionary); S1.3 does **not** restate paths.

---

## Canonical substream (order-invariant; per merchant)

### Label

$$
\ell := \text{"hurdle_bernoulli"} \quad\text{(registry literal; appears verbatim in the event envelope).}
$$

### Base counter & independence (via S0 primitive)

The **base counter** for each $(\ell, m)$ and the **keyed substream** are obtained **only** through S0â€™s mapping (pure in $(\texttt{seed}, \texttt{manifest_fingerprint}, \ell, m)$) and therefore **order-invariant** across partitions/shards. S1.3 **does not** chain counters across labels or merchants.

---

## Envelope budgeting (counter law)

For hurdle events, the envelope must satisfy the S0 budgeting identity:

$$
\mathrm{u128}(\texttt{after_hi},\texttt{after_lo}) - \mathrm{u128}(\texttt{before_hi},\texttt{before_lo})
\;=\; \texttt{parse_u128(draws)},
$$

with unsigned 128-bit arithmetic on counters. In the hurdle stream, `draws âˆˆ {"0","1"}` (the number of uniforms consumed).
**`blocks` is required**; for hurdle (uint64) it **must** be `0` or `1` and **must equal** `parse_u128(draws)`.

> **Trace model (reconciliation):** The RNG trace is **cumulative** per `(module, substream_label)` within the run (no merchant dimension) and includes `rng_counter_before_{lo,hi}` and `rng_counter_after_{lo,hi}`. 
> For the **final** row per key in a run (selection rule per `schemas.layer1.yaml#/rng/core/rng_trace_log`):
>
> * `draws_total == Î£ parse_u128(draws)` (**required**; diagnostic; saturating uint64),
> * `blocks_total == Î£ blocks` (normative; saturating uint64),
> * `events_total ==` hurdle event count.
>
> (Note: `u128(after) âˆ’ u128(before)` on the final row is the **delta for that last emission only**; do **not** equate it to cumulative totals.)
> Trace **rows are emitted per event**; consumers select the **final** row per key (selection per `schemas.layer1.yaml#/rng/core/rng_trace_log`).

**Field-order convention (names are authoritative):** JSON carries
`rng_counter_before_lo`, `rng_counter_before_hi`, `rng_counter_after_lo`, `rng_counter_after_hi`. Parsers compose u128 as `(hi<<64) | lo`.

---

## Uniform $u\in(0,1)$ & lane policy

* **Engine:** Philox 2Ã—64-10 (fixed in S0). Each block yields two 64-bit words; **single-uniform** events use the **low lane** (`x0`) and **discard** the high lane (`x1`). One counter increment â‡’ one uniform.
* **Mapping to $U(0,1)$:** Use S0â€™s **open-interval** `u01` mapping from a 64-bit unsigned word to binary64 â€” **identical to S0â€™s `u01`**. Exact 0 and exact 1 are **never** produced. (S1.3 **references** this mapping; it **does not** redefine it.)

---

## Draw budget & decision

Let $\pi=\pi_m$.

* **Deterministic branch** ($\pi\in\{0.0,1.0\}$).
  `draws="0"`; **no** Philox call; set `blocks=0`; envelope has `after == before`.
  Outcome is implied by $\pi$: `is_multi = true` iff `pi == 1.0`; else `false`.
  Payload rules (S1.4): `deterministic=true`, `u=null`.

* **Stochastic branch** ($0<\pi<1$).
  Draw **one** uniform $u\in(0,1)$ using the keyed substream and lane policy; `draws="1"`; set `blocks=1`; envelope has `after = before + 1`.
  Decide `is_multi = (u < pi)`; payload: `deterministic=false` and `u` present and numeric.

All of the above are enforced by the S0/S1 budgeting invariants and the S1 validator checklist (determinism equivalences and gating).

---

**Bottom line:** S1.3 consumes **zero or one** uniform from the merchant-keyed `"hurdle_bernoulli"` substream, applies the **open-interval** mapping, decides with `u < pi`, and records a budget-correct envelope. No cross-label chaining; **trace rows are emitted per event** and consumers select the **final** row per keyâ€”everything is S0-aligned and replayable.

---

## Envelope & streams touched here (recap; S1.4 formalises payload)

Each hurdle event **must** carry the **complete** layer RNG envelope:

`{ ts_utc, run_id, seed, parameter_hash, manifest_fingerprint, module, substream_label, rng_counter_before_lo, rng_counter_before_hi, rng_counter_after_lo, rng_counter_after_hi, draws, blocks }`

* `module` and `substream_label` are **registry-closed literals** (schema-typed as strings; closure enforced by validators/registry).
* `draws` is a non-negative **u128 encoded as decimal string**; budget identity: `u128(after) âˆ’ u128(before) = parse_u128(draws)`.
* `blocks` is a non-negative uint64; for hurdle, `blocks âˆˆ {0,1}` and **must equal** `parse_u128(draws)` **(hurdle-only; other RNG families may have `draws â‰  blocks` while still satisfying S0â€™s counter rules)**.

**Single flat JSON object.** Each hurdle record is **one** top-level JSON object; â€œenvelopeâ€ and â€œpayloadâ€ are **conceptual groupings only** (no nested objects). This wording eliminates any ambiguity about structure.

S1.3 writes **one** hurdle event per merchant.  The RNG trace is **cumulative** per `(module, substream_label)` within the run (no merchant dimension). Its totals reconcile to the **sum of event budgets**. **Trace rows are emitted per event; validators select the final row per** `schemas.layer1.yaml#/rng/core/rng_trace_log`.

---

## Failure semantics (abort class bindings)

Abort the run on any of the following:

* **Envelope/label violation.** Missing required envelope fields; wrong `module`/`substream_label` literal; malformed counter fields (`*_hi/*_lo`).
* **Budget identity failure.** `u128(after) âˆ’ u128(before) â‰  parse_u128(draws)`; or `blocksâˆ‰{0,1}` for hurdle.
* **Uniform out of range.** In a stochastic branch, `u â‰¤ 0` or `u â‰¥ 1` (violates open-interval `u01`).
* **Determinism inconsistency.** `Ï€âˆˆ{0,1}` but `u` present or `deterministic=false`; or $0<\pi<1$ but `u` absent or `deterministic=true`.

(Shape/order and non-finite numeric faults are owned by S1.1â€“S1.2 preconditions.)

---

## Validator hooks (must pass)

For each hurdle record in the run, the validator performs:

1. **Rebuild base counter (order-invariant).** Using the S0 keyed-substream primitive with `(seed, manifest_fingerprint, substream_label="hurdle_bernoulli", merchant_id)`, recompute the **base counter** and assert envelope `before` equals it. (No cross-label chaining is permitted.)

2. **Branch-specific checks from $\pi$ (from S1.2):**

   * If `draws="0"`: assert $\pi\in{0.0,1.0}$, `u==null`, `deterministic=true`, and `after==before`.
   * If `draws="1"`: generate **one** 64-bit word from the keyed substream at `before` using S0â€™s lane policy (low lane), map via S0â€™s **open-interval** `u01`, assert `0<u<1`, assert `(u<pi) == is_multi`, and assert `after = before + 1`.

3. **Trace reconciliation (cumulative).** Let `H` be all hurdle events in the run. For the **final** trace row for `(module, substream_label)`:
   * Assert `trace.draws_total == Î£ parse_u128(e.draws)` (**required**; diagnostic; saturating uint64),
   * Assert `trace.blocks_total == Î£ e.blocks` (normative; saturating uint64),
   * Assert `trace.events_total ==` hurdle event count (saturating uint64).
   * (No assertion that `u128(trace.after) âˆ’ u128(trace.before)` on the final row equals any cumulative total; that delta is **per-row**.)

4. **Partition/embedding equality.** Path partitions `{seed, parameter_hash, run_id}` match the embedded envelope fields; `module` / `substream_label` match the registry literals exactly.

---

## Procedure (ordering-invariant, language-agnostic)

1. **Obtain base counter** for `(label="hurdle_bernoulli", merchant_id)` via the S0 keyed-substream primitive; set `before` accordingly.
2. **Branch on $\pi$:**

   * If $\pi\in\{0.0,1.0\}$: set `draws="0"`, `blocks=0`, `after=before`, `u=null`, `is_multi=(pi==1.0)`. 
   * If $0<\pi<1$: fetch **one** uniform $u\in(0,1)$ using the S0 lane policy and `u01`; set `draws="1"`, `blocks=1`, `after=before+1`, `is_multi=(u<pi)`. 
3. **Emit hurdle event** (S1.4): envelope includes all required fields above; payload includes `merchant_id`, `pi`, `u` (nullable), `is_multi` (boolean), `deterministic` (derived from `pi`).
4. **Emit one trace row for this event** with updated cumulative totals for `(module, substream_label)`: add `parse_u128(draws)` to `draws_total` (diagnostic; saturating uint64), add `blocks` to `blocks_total` (normative; saturating uint64), and `+1` to `events_total`. Validators **select the final row** using the rule in `#/rng/core/rng_trace_log`.

*(This is a procedural spec; S0 remains the authority for PRNG keying, counter arithmetic, lane policy, and `u01` mapping.)*

---

## Invariants (S1/H) guaranteed here

* **Bit-replay:** Fixing $(x_m,\beta,\texttt{seed},\texttt{parameter_hash},\texttt{manifest_fingerprint})$, both the envelope counters and the pair $(u,\text{is_multi})$ are **bit-identical** under replay.
* **Consumption:** `draws="1"` **iff** $0<\pi<1$; else `"0"`.
* **Schema conformance:** `u` and `deterministic` comply with the hurdle event schema: `u=null` iff $\pi\in\{0.0,1.0\}$; `is_multi` is **boolean** only.
* **Order-invariance:** `before` equals the keyed **base counter** for `(label, merchant)`â€”never a prior labelâ€™s `after`.
* **Gating (forward contract):** Downstream 1A RNG streams appear **iff** `is_multi=true`. **Discover the stream set programmatically** from the dataset dictionary (`dataset_dictionary.layer1.1A.yaml`) via entries with `owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"`. If a legacy dictionary lacks `gating`, **fall back** to the artefact-registry enumeration. S1 does **not** enumerate names inline.

---

**Bottom line:** S1.3 produces a single-uniform Bernoulli decision on a **merchant-keyed**, **label-stable** substream, with a budget-correct envelope and a **cumulative** (per-substream) trace model. Everything is S0-compatible, order-invariant, and validator-checkable without guesswork.

---

# S1.4 â€” Event emission (hurdle Bernoulli), with **exact** envelope/payload, partitioning, invariants, and validation

### 1) Where the records go (authoritative dataset id, partitions, schema)

Emit **one JSONL record per merchant** to the hurdle RNG dataset:

* **Dataset id:** registry entry for `rng_event_hurdle_bernoulli`.
* **Partitions (path):**

  ```
  logs/rng/events/hurdle_bernoulli/
    seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl
  ```

  *(No `manifest_fingerprint`, `module`, or `substream_label` in the path; those are embedded in the envelope.)*
* **Schema:** layer schema anchor `schemas.layer1.yaml#/rng/events/hurdle_bernoulli`.

> **Partition keys are exactly** `{seed, parameter_hash, run_id}` as bound in the dictionary/registry.
> **Path â†” embed equality:** for every row, the embedded `{seed, parameter_hash, run_id}` **must equal** the folder values byte-for-byte.

---

### 2) Envelope (shared; required for **all** RNG events)

Every hurdle record **must** carry the complete layer RNG envelope (single source of truth in the layer schema).

**Required fields**

* `ts_utc`, `run_id`, `seed`, `parameter_hash`, `manifest_fingerprint`, `module`, `substream_label`,
* `rng_counter_before_lo`, `rng_counter_before_hi`, `rng_counter_after_lo`, `rng_counter_after_hi`,
* `draws` (**required**, u128 as a decimal string),
* `blocks` (**required**, uint64).

**Semantics**

* `ts_utc` â€” RFC-3339 UTC with **exactly 6 fractional digits** and `Z` (microseconds).
* `module`, `substream_label` â€” **registry-closed literals** (schema-typed as strings; closure enforced by validators/registry); for this stream `substream_label == "hurdle_bernoulli"`.
* `rng_counter_*` â€” 128-bit counters represented as two u64 words; names define the pairing `(lo, hi)`. Object key **order is non-semantic**; producers **must** use the exact field names shown (â€¦`_lo` and â€¦`_hi`). Compose u128 as `(hi<<64) | lo`.
* `draws` â€” non-negative **u128 encoded as a base-10 string** (no sign; no leading zeros except `"0"`). It is the **authoritative** per-event uniform count.
* **Budget identity (must hold):**

  ```
  u128(after_hi,after_lo) âˆ’ u128(before_hi,before_lo) = parse_u128(draws)
  ```

  For the hurdle stream specifically: `draws âˆˆ {"0","1"}`; `blocks âˆˆ {0,1}` and **must equal** `parse_u128(draws)`.
* **Identifier serialization:** 64-bit identifiers in the envelope (e.g., `seed`) are **JSON integers** per the layer schema (not strings).

> **Merchant scope (envelope vs event).** The shared RNG **envelope schema** admits an optional/nullable `merchant_id` for merchant-scoped streams (see layer schema). For the **hurdle** stream specifically, the **event schema requires** top-level `merchant_id`. Validators check presence under the event schema (and, if present, under the envelope anchor). This remains a **single flat JSON object**; â€œenvelopeâ€ and â€œpayloadâ€ are conceptual groupings only.

---

### 3) Payload (event-specific; minimal and authoritative)

Fields and types (per the hurdle schema):

* `merchant_id` â€” **id64 JSON integer** (canonical u64).
* `pi` â€” JSON number, **binary64 round-trip** to the exact value computed in S1.2; must satisfy `0.0 â‰¤ pi â‰¤ 1.0`.
* `is_multi` â€” **boolean** outcome.
* `deterministic` â€” **boolean**, **derived**: `true` iff `pi âˆˆ {0.0, 1.0}` (binary64 equality).
* `u` â€” **required** with type **number | null**:

  * `u = null` iff `pi âˆˆ {0.0, 1.0}` (deterministic).
  * `u âˆˆ (0,1)` iff `0 < pi < 1` (stochastic); `u` must also round-trip to the same binary64.

**Outcome semantics (canonical, predicate form)**

* If `0 < pi < 1`: `is_multi := (u < pi)`.
* If `pi âˆˆ {0.0, 1.0}`: `is_multi := (pi == 1.0)`.

**Branch invariants**

Deterministic â‡’ `u == null` and a **non-consuming event** (`draws="0"`, `blocks=0`, `after == before`).
* Stochastic â‡’ `0 < u < 1`, `is_multi == (u < pi)`, and **exactly one uniform consumed** (`draws="1"`, `blocks=1`).

> The payload is **minimal** and authoritative for the decision; `eta` and any diagnostics are **not** part of this stream (they belong in non-authoritative diagnostic datasets, if present at all).

---

### 4) Canonical examples (normative JSON; object key order non-semantic)

**Numeric policy for examples.** All numeric values below MUST be the **shortest round-trippable** IEEE-754 binary64 decimals. (Integer-typed ids remain JSON **integers** per schema.)

**Stochastic example (`0 < pi < 1`)**

```json
{
  "ts_utc": "2025-08-15T10:03:12.345678Z",
  "run_id": "0123456789abcdef0123456789abcdef",
  "seed": 1234567890123456789,
  "parameter_hash": "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
  "manifest_fingerprint": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
  "module": "1A.hurdle_sampler",
  "substream_label": "hurdle_bernoulli",

  "rng_counter_before_lo": 9876543210,
  "rng_counter_before_hi": 42,
  "rng_counter_after_lo": 9876543211,
  "rng_counter_after_hi": 42,

  "draws": "1",
  "blocks": 1,

  "merchant_id": 184467440737095,
  "pi": 0.3725,
  "is_multi": true,
  "deterministic": false,
  "u": 0.1049
}
```

**Deterministic example (`pi âˆˆ {0.0,1.0}`)**

```json
{
  "ts_utc": "2025-08-15T10:03:12.345678Z",
  "run_id": "0123456789abcdef0123456789abcdef",
  "seed": 1234567890123456789,
  "parameter_hash": "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
  "manifest_fingerprint": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
  "module": "1A.hurdle_sampler",
  "substream_label": "hurdle_bernoulli",

  "rng_counter_before_lo": 9876543210,
  "rng_counter_before_hi": 42,
  "rng_counter_after_lo": 9876543210,
  "rng_counter_after_hi": 42,

  "draws": "0",
  "blocks": 0,

  "merchant_id": 184467440737095,
  "pi": 1.0,
  "is_multi": true,
  "deterministic": true,
  "u": null
}
```

---

**Bottom line:** This section pins the **single authoritative** hurdle event stream: **where itâ€™s written**, the **complete envelope** (with budget identity), the **minimal payload** with **boolean** `is_multi` and **required** `u:number|null`, and the **branch invariants** that tie `pi`, `u`, `deterministic`, and the **uniform budget** togetherâ€”no ambiguity, no order-dependence, and no drift from S0.

---

### 5) Write discipline, idempotency, and ordering

* **Exactly one hurdle row per merchant (per run).** Within `{seed, parameter_hash, run_id}` there is **exactly one** hurdle event for each `merchant_id`, and the hurdle row count equals the merchant universe cardinality **for the runâ€™s `manifest_fingerprint`** (from ingress). Writes are **append-only** to `part-*` shards.
* **Stable partitioning.** The hurdle event dataset is partitioned **only** by `{seed, parameter_hash, run_id}`; **do not** include `manifest_fingerprint`, `module`, or `substream_label` in the path (they are embedded in the envelope).
* **Module/label stability.** `module` and `substream_label` are **registry-closed literals** (schema-typed as strings; closure enforced by validators/registry). For this stream, `substream_label == "hurdle_bernoulli"`; `module` **MUST** equal `"1A.hurdle_sampler"`.
* **Trace linkage (cumulative, substream-scoped).** Maintain a **cumulative** `rng_trace_log` per `(module, substream_label)` (no merchant dimension) within the run, including `rng_counter_before_{lo,hi}` and `rng_counter_after_{lo,hi}`. Totals are **saturating uint64** and equal the **sums** over all hurdle events in the run:

  * `draws_total == Î£ parse_u128(draws)` (diagnostic; **required**; saturating uint64),
  * `blocks_total == Î£ blocks` (normative; saturating uint64),
  * `events_total ==` hurdle event count (saturating uint64).
  *(No assertion that `u128(after)âˆ’u128(before)` equals `blocks_total` on the final row; that delta is **per-row**.)*

---

### 6) Validation hooks (what replay must assert)

* **Schema conformance.** Every row validates against `#/rng/events/hurdle_bernoulli` (payload) and `$defs.rng_envelope` (envelope).
* **Budget identity & replay.** Let `d_m := 1` iff `0 < pi_m < 1`, else `0`. Assert:

  * `u128(after) âˆ’ u128(before) = parse_u128(draws)`,
  * for hurdle: `parse_u128(draws) âˆˆ {0,1}` and `blocks = parse_u128(draws) = d_m`.
* **Decision predicate.**

  * If `d_m=0` (deterministic): `piâˆˆ{0.0,1.0}`, `u==null`, `deterministic=true`, `after==before`, and `is_multi == (pi==1.0)`.
  * If `d_m=1` (stochastic): regenerate **one** uniform from the keyed substream at `before` (low-lane policy), map via open-interval `u01`, assert `0<u<1` and `(u<pi) == is_multi`; assert `after = before + 1`.
* **Trace reconciliation (cumulative, substream-scoped).** For the run, aggregate hurdle events and assert on the **final** trace row (selected per `#/rng/core/rng_trace_log`):
  * `trace.draws_total == Î£ parse_u128(draws)` (**required**; diagnostic; saturating uint64),
  * `trace.blocks_total == Î£ blocks` (normative; saturating uint64),
  * `trace.events_total ==` hurdle event count,
  * (no assertion on `u128(trace.after) âˆ’ u128(trace.before)`; that difference is per-row, not cumulative).
* **Gating invariant.** Downstream **1A RNG streams** must appear for a merchant **iff** that merchantâ€™s hurdle event has `is_multi=true`. **Build the set programmatically** from the dataset dictionary by selecting entries with `owner_subsegment == "1A"` and `gating.gated_by == "rng_event_hurdle_bernoulli"`. If the dictionary is legacy and lacks `gating`, **fall back** to the artefact-registry enumeration. S1 does **not** enumerate names inline.
* **Cardinality & uniqueness.** Hurdle row count equals the ingress merchant count for the **run** (same `manifest_fingerprint`); uniqueness key is `merchant_id` scoped by `{seed, parameter_hash, run_id}`.

---

### 7) Failure semantics (surface at S1.4)

* **E_SCHEMA_HURDLE.** Record fails schema: missing required envelope fields; wrong types (e.g., `is_multi` not boolean, `u` not `number|null`); `u` violates open interval when stochastic; counters field names malformed.
* **E_COUNTER_MISMATCH.** Budget identity fails: `u128(after) âˆ’ u128(before) â‰  parse_u128(draws)`; or hurdle emits values outside `{drawsâˆˆ{"0","1"}}`; or `blocks â‰  parse_u128(draws)`.
* **E_GATING_VIOLATION.** Any downstream 1A RNG event exists for a merchant **without** a conformant hurdle event with `is_multi=true`. (Order is irrelevant; this is a **presence** invariant on the finalized datasets.)
* **E_PARTITION_MISMATCH.** Path partitions `{seed, parameter_hash, run_id}` differ from the same fields embedded in the envelope; or `module`/`substream_label` donâ€™t match registry literals **exactly**.

(Shape/order and non-finite numeric faults are owned by S1.1â€“S1.2 preconditions.)

---

### 8) Reference emission procedure (ordering-invariant; language-agnostic)

1. **Base counter.** Obtain the **base counter** for `(label="hurdle_bernoulli", merchant_id)` using the S0 keyed-substream primitive; set `before`.
2. **Branch from `pi`.**

   * If `pi âˆˆ {0.0,1.0}`: set `draws="0"`, `blocks=0`, `after=before`, `u=null`, `deterministic=true`, `is_multi=(pi==1.0)`.
   * If `0 < pi < 1`: draw **one** uniform `uâˆˆ(0,1)` (low-lane, open-interval `u01`); set `draws="1"`, `blocks=1`, `after=before+1`, `deterministic=false`, `is_multi=(u<pi)`.
3. **Emit hurdle event.** Envelope includes all required fields (`*_lo` and `*_hi` naming; object key order is non-semantic); payload includes `merchant_id` (JSON integer), `pi` (binary64 round-trip), `u:number|null`, `is_multi:boolean`, `deterministic:boolean`.
4. **Update cumulative trace (substream-scoped).** Increase `draws_total` and `blocks_total` as above and increment `events_total` by 1. *Producers update per event; validators select the final row using the rule in `#/rng/core/rng_trace_log`.*

*(Procedure is normative; S0 remains the authority for PRNG keying, counter arithmetic, lane policy, and `u01`.)*

---

**Bottom line:** S1.4 nails the **write discipline** (one row per merchant; stable `{seed, parameter_hash, run_id}` partitions), the **complete envelope** with an authoritative `draws` field and budget identity, the **minimal authoritative payload** (`is_multi` boolean; `u:number|null`), the **substream-scoped cumulative** trace model, and a validator-oriented hook set (budget, decision, gating, cardinality)â€”all order-invariant and S0-consistent.

---

# S1.5 â€” Determinism & Correctness Invariants (normative)

## Purpose

Freeze the invariants that must hold for every merchantâ€™s hurdle decision so downstream states can **trust** and **replay** S1 exactly. The I-H invariants below are stated as precise predicates with the validator obligations that prove them.

---

## I-H0 â€” Environment & schema authority (precondition)

* **Numeric policy (S0):** IEEE-754 **binary64**, round-to-nearest-even, **no FMA**, **no FTZ/DAZ**; fixed-order reductions; deterministic `exp`.
* **Schema authority:** Every RNG record conforms to the **layer envelope** (single anchor) and its **event-specific schema**. The hurdle stream uses the registered dataset id and the schema anchor for `rng/events/hurdle_bernoulli`.

---

## I-H1 â€” Bit-replay (per merchant, per run)

**Statement.** For fixed inputs
$(x_m,\ \beta,\ \texttt{seed},\ \texttt{parameter_hash},\ \texttt{manifest_fingerprint})$, the pair $(u_m,\ \text{is_multi}(m))$ and the envelope counters $(C^{\text{pre}}_m,\ C^{\text{post}}_m)$ are **bit-identical** across replays and **independent of emission order** or sharding.

**Why it holds.** The keyed-substream primitive derives a **base counter** for $(\ell=\text{"hurdle_bernoulli"}, m)$ that depends only on the run keys and $(\ell,m)$. The draw budget is a pure function of $\pi_m$. The uniform $u_m$ is obtained by the S0 **open-interval** mapping from the substream (low-lane) and therefore deterministic.

**Validator.** Rebuild the base counter from `(seed, manifest_fingerprint, substream_label="hurdle_bernoulli", merchant_id)`; assert envelope `before` matches.
If `draws="1"`, regenerate $u$ and assert `(u < pi) == is_multi`. Assert counters match exactly.

---

## I-H2 â€” Consumption & budget (single-uniform law)

**Statement.** Let $d_m = \mathbf{1}\{0 < \pi_m < 1\}$. The hurdle consumes exactly `draws = d_m` uniforms and:

* If $0<\pi_m<1$: `after = before + 1`.
* If $\pi_m \in \{0.0,1.0\}$: `after = before`.

**Law.** Envelope budgeting must satisfy
`u128(after) âˆ’ u128(before) = parse_u128(draws)` (unsigned 128-bit arithmetic). For the hurdle, `draws âˆˆ {"0","1"}`; blocks is required and must equal `parse_u128(draws)`.

**Trace model (cumulative).** RNG trace is **cumulative per `(module, substream_label)`** within the run (no merchant dimension). Its totals equal the **sums across all hurdle events** for that substream.

**Validator.** Check the envelope identity above; aggregate event budgets over all hurdle rows for `(module, substream_label)` and assert equality with the trace totals.

---

## I-H3 â€” Schema-level payload discipline

**Statement.** The hurdle payload is **minimal and authoritative** with fields:
`merchant_id` (**id64 integer**), `pi` (binary64 round-trip), `is_multi` (**boolean**), `deterministic` (**boolean**), `u` (**number|null**, **required**).

**Equivalences (binary64 semantics).**

* `deterministic â‡” (pi âˆˆ {0.0, 1.0}) â‡” draws="0" â‡” u == null`.
* `Â¬deterministic â‡” (0 < pi < 1) â‡” draws="1" â‡” u âˆˆ (0,1)` and `is_multi == (u < pi)`.

`is_multi` is **boolean only** (never `{0,1}`); any other encoding is non-conformant.

---

## I-H4 â€” Branch purity (downstream gating)

**Statement.** Downstream **1A RNG streams** for a merchant appear **iff** that merchantâ€™s hurdle event has `is_multi=true`.

**Authority.** Validators **MUST** derive the gated set **programmatically** from the dataset dictionary (`owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"`). If the dictionary is legacy and lacks `gating`, they **MUST** fall back to the artefact-registry enumeration. S1 does **not** enumerate stream names inline.

**Validator.** For each merchant, check presence/absence of all gated streams per the registry list against the merchantâ€™s hurdle `is_multi` value.

---

**Bottom line:** S1.5 fixes the invariant surface: a deterministic, order-invariant substream; a single-uniform budget with a strict envelope law and **cumulative** trace; a minimal, typed payload with `u:number|null` and boolean `is_multi`; and a registry-driven gating rule. These invariants give downstream states and validators a single, unambiguous contract for replay and auditing.

---

## I-H5 â€” Cardinality & uniqueness (per run)

* Exactly **one** hurdle record per merchant within `{seed, parameter_hash, run_id}`. **No duplicates.**
* **Presence gate, not order:** downstream 1A RNG streams are validated **by presence** relative to the hurdle decision (see I-H4). Emission order is **unspecified** and not validated.

**Validator.** Count hurdle rows and assert equality with the ingress `merchant_ids` for the run; assert uniqueness of `merchant_id` within the hurdle partition.

---

## I-H6 â€” Envelope completeness & equality with path keys

* Every record contains the **full** RNG envelope required by `$defs.rng_envelope`. `draws` is **required**; `blocks` must equal `parse_u128(draws)` and for hurdle be `0` or `1`.
* Embedded `{seed, parameter_hash, run_id}` **equal** the same keys in the dataset path. `module` and `substream_label` are registry literals checked **in the envelope** (they do **not** appear in the path).
* **Flat record.** Hurdle records are a **single flat JSON object**. `merchant_id` is declared on the shared RNG envelope (nullable in the envelope) and is **required by the hurdle event schema**; listing it under â€œpayloadâ€ is purely a conceptual grouping.

---

## I-H7 â€” Order-invariance & concurrency safety

* Emission **order is unspecified**; correctness depends only on per-row content. Replays with different shard orders yield byte-identical counters and decisions (I-H1).
* Writers may produce multiple `part-*` files; **set equivalence** of rows defines dataset equivalence.

---

## I-H8 â€” Independence across merchants & substreams

* Base counters are derived **per (label, merchant_id)** via the keyed mapping, so distinct pairs receive **disjoint** substreams under a fixed `{seed, manifest_fingerprint}`.
* `substream_label` in the envelope is **exactly** `"hurdle_bernoulli"`, preventing accidental reuse of counters intended for other labels.

---

## I-H9 â€” Optional diagnostics remain out of band

* If any diagnostic cache (e.g., `hurdle_pi_probs`) exists, it is **non-authoritative**. S1 decisions must match an **independent recomputation** of $(\eta,\pi)$ from $(x_m,\beta)$. Validators may compare for sanity; disagreements never override the event.

---

## I-H10 â€” Replay equations (what the validator recomputes)

For each hurdle row $r$ with merchant $m$:

1. **Recompute $\eta,\pi$.** Using S1.2 rules (fixed-order dot + two-branch logistic (no clamp)), assert `finite(Î·)` and `0.0 â‰¤ pi â‰¤ 1.0`.
2. **Rebuild base counter.** Using `(seed, manifest_fingerprint, substream_label="hurdle_bernoulli", merchant_id)`, assert `rng_counter_before == base_counter`.
3. **Budget identity.** From $\pi$, set `draws = "1"` iff $0<\pi<1$, else `"0"`. Assert
   `u128(after) âˆ’ u128(before) = parse_u128(draws)` and, blocks is required and must equal `parse_u128(draws)`.
   **Trace reconciliation:** join to the **cumulative** trace record for `(module, substream_label)` and assert its totals equal the **sum of hurdle event budgets**.
4. **Outcome consistency.**

   * If `draws="1"`: regenerate a single uniform via the S0 lane policy & open-interval mapping; assert `0<u<1` and `(u < pi) == is_multi`.
   * If `draws="0"`: assert `pi âˆˆ {0.0,1.0}`, `u == null`, `deterministic == true`, and `is_multi == (pi == 1.0)`.

> **Determinism equivalence (normative recap):** `Ï€âˆˆ{0.0,1.0}` (binary64-exact) â‡” `deterministic==true` â‡” `draws=="0"` â‡” `u==null` â‡” `is_multi==(Ï€==1.0)`.

---

## Failure bindings (S0.9 classes surfaced by these invariants)

* **Envelope/label/counter failures** â†’ RNG envelope & accounting failure (**F4**) â†’ **abort run**.
* **Partition mismatch (path vs embedded)** â†’ lineage/partition failure (**F5**) â†’ **abort run**.
* **Schema breach** (e.g., missing required envelope fields; `is_multi` not boolean; `u` not `number|null`; `u` out of (0,1) when stochastic) â†’ schema failure (treated as **F4**).
* **Gating violation** (downstream event exists when hurdle `is_multi=false` or no hurdle event) â†’ coverage/gating failure (validator; event-family coverage class, e.g., **F8**).

---

## What this guarantees downstream

* **Deterministic hand-off (by content, not cursor).** Each merchant has a single authoritative hurdle decision (`is_multi`) and a **self-contained** envelope. **Downstream states derive their own base counters** from the keyed mapping for their **own labels**; there is **no** requirement that `before(next) == after(hurdle)`.
* **Auditable lineage.** Hurdle events are partitioned by `{seed, parameter_hash, run_id}`; validation/egress bundles are fingerprint-scoped. Consumers can verify they are reading the intended parameterization using the embedded `manifest_fingerprint`.

---

**Bottom line:** S1.5 (complete) nails the invariants that make S1 reproducible and safe to build on: uniqueness/cardinality, full envelope with budget identity, order-invariance, cross-label independence, gated downstream presence, diagnostics out-of-band, and validator-ready replay equationsâ€”mapped to S0.9 failure classes for actionable aborts.

---

# S1.6 â€” Failure modes (normative, abort semantics)

**Scope.** Failures here are specific to S1 (hurdle): design/Î² misuse, numeric invalids, schema/envelope breaches, RNG counter/accounting errors, partition drift, and downstream gating. This section formalizes **all predicates, detection points, and run-abort semantics** that S1 may surface.

**Authoritative references:**
Layer schema (envelope anchor + hurdle event schema), dataset dictionary/registry (dataset id, partitions, enums), and S1 invariants (I-H1..I-H10).

---

## Family A â€” Design / coefficients misuse (compute-time hard abort)

**A1. `beta_length_mismatch`**
**Predicate.** `len(Î²) â‰  1 + C_mcc + 2 + 5` when forming $\eta = \beta^\top x$.
**Detect at.** S1.1/S1.2 entry. **Abort run.**
**Forensics.** `{expected_len, observed_len, mcc_cols, channel_cols, bucket_cols}`.

**A2. `unknown_category`**
**Predicate.** `mcc_m` not in MCC dictionary, or `channel_m âˆ‰ {CP,CNP}`, or `b_m âˆ‰ {1..5}`.
**Detect at.** Precondition breach (inputs from S0). **Abort run.**
**Forensics.** `{merchant_id, field, value}`.

**A3. `column_order_mismatch`**
**Predicate.** Frozen encoder column order does **not** match Î²â€™s bundle order.
**Detect at.** S1.1 design load. **Abort run.**
**Forensics.** `{block:"mcc|channel|bucket", dict_digest, beta_digest}`.

---

## Family B â€” Numeric invalids (compute-time hard abort)

**B1. `hurdle_nonfinite_eta`**
**Predicate.** $\eta$ non-finite after fixed-order binary64 dot product.
**Detect at.** S1.2. **Abort run.**
**Forensics.** `{merchant_id, eta}`.

**B2. `hurdle_nonfinite_or_oob_pi`**
**Predicate.** $\pi$ non-finite **or** $\pi \notin [0,1]$ after the two-branch logistic (no clamp).
**Detect at.** S1.2. **Abort run.**
**Forensics.** `{merchant_id, eta, pi}`.

---

## Family C â€” Envelope & accounting (RNG/logging hard abort)

**C1. `rng_envelope_schema_violation`**
**Predicate.** Missing/mistyped **envelope** field required by the anchor:
`{ts_utc, run_id, seed, parameter_hash, manifest_fingerprint, module, substream_label, rng_counter_before_lo, rng_counter_before_hi, rng_counter_after_lo, rng_counter_after_hi, draws, blocks}`.

**Detect at.** Writer + validator schema checks. **Abort run.**
**Forensics.** `{dataset_id, path, missing_or_bad:[...]}`.

**C2. `substream_label_mismatch`**
**Predicate.** Envelope `substream_label` â‰  registry literal `"hurdle_bernoulli"`.
**Detect at.** Writer assertion; validator. **Abort run.**

**C3. `rng_counter_mismatch`**
**Predicate.** `u128(after) âˆ’ u128(before) â‰  parse_u128(draws)`; or `blocks â‰  parse_u128(draws)`. For hurdle, it must also satisfy `blocks âˆˆ {0,1}` and `draws âˆˆ {"0","1"}`.
**Detect at.** Writer (optional) and validator reconciliation. **Abort run.**
**Forensics.** `{before_hi, before_lo, after_hi, after_lo, blocks, draws}`.

**C4. `rng_trace_missing_or_totals_mismatch`**
**Predicate.** Missing **final cumulative** `rng_trace_log` record for `(module, substream_label)` within the run, **or** its totals â‰  **sum of event budgets** for that key.
**Detect at.** Validator aggregate. **Abort run.**
**Final-row selection rule.** Selection per schema anchor `schemas.layer1.yaml#/rng/core/rng_trace_log`.

**C5. `u_out_of_range`**
**Predicate.** In a stochastic branch, payload `u` not in `(0,1)` (open-interval violation).
**Detect at.** Writer check; validator schema + re-derivation. **Abort run.**
**Forensics.** `{merchant_id, u, pi}`.

---

## Family D â€” Payload/schema discipline (hurdle event)

**D1. `hurdle_payload_violation`**
**Predicate.** Record fails the hurdle event schema: missing any of `{merchant_id, pi, is_multi, deterministic, u}`; `is_multi` not **boolean**; `u` not `number|null`; `pi` not binary64-round-trippable (or out of `[0,1]`).
**Detect at.** Writer schema validation; CI/validator. **Abort run.**

**D2. `deterministic_branch_inconsistent`**
**Predicate.** Payload contradicts branch rules:

* `0<pi<1` but `u` absent/`null` or `deterministic=true`, **or**
* `piâˆˆ{0.0,1.0}` but `u` numeric or `deterministic=false`.
  **Detect at.** Writer; validator. **Abort run.**

---

## Family E â€” Partitioning & lineage coherence (paths vs embedded)

**E1. `partition_mismatch`**
**Predicate.** Path partitions `{seed, parameter_hash, run_id}` do **not** equal the same embedded envelope fields; or path includes unexpected partitions (e.g., `module`, `substream_label`, `manifest_fingerprint`).
**Detect at.** Writer; validator lint. **Abort run.**

**E2. `wrong_dataset_path`**
**Predicate.** Hurdle events written under a path that does not match the dictionary/registry binding (dataset id â†” path template).
**Detect at.** Writer; validator path lint. **Abort run.**

---

## Family F â€” Coverage & gating (cross-stream structural)

**F1. `gating_violation_no_prior_hurdle_true`**
**Predicate.** Any downstream **1A RNG stream** appears for merchant $m$ **without** a conformant hurdle event with `is_multi=true` in the run. (Presence rule; emission order irrelevant.)
**Detect at.** Validator cross-stream join using the set **derived programmatically** from the dataset dictionary (`owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"`); **fallback** to the artefact-registry enumeration if the dictionary lacks `gating`. **Run invalid (hard).**

**F2. `duplicate_hurdle_record`**
**Predicate.** More than one hurdle event for the same merchant within `{seed, parameter_hash, run_id}`.
**Detect at.** Validator uniqueness check. **Abort run.**

**F3. `cardinality_mismatch`**
**Predicate.** `count(hurdle_events) â‰  count(merchant_ids)` for the run.
**Detect at.** Validator count check. **Abort run.**

---

**Scope recap:** S1.6 enumerates **all abortable predicates** for the hurdle: design/Î² misuse, numeric invalids, complete envelope with strict **budget identity**, cumulative trace reconciliation, payload typing/branch rules, exact partition/embedding equality, and registry-driven gating. Each failure includes a precise detection point and forensics so the run can halt with actionable evidence.

---

## Error object (forensics payload; exact fields)

Every S1 failure MUST emit a JSON object (alongside the validation bundle / `_FAILED.json` sentinel) carrying lineage + precise forensics:

```json
{
  "failure_class": "F4",
  "failure_code": "rng_counter_mismatch",
  "state": "S1",
  "module": "1A.hurdle_sampler",
  "substream_label": "hurdle_bernoulli",
  "dataset_id": "rng_event_hurdle_bernoulli",
  "path": "logs/rng/events/hurdle_bernoulli/seed=1234567890123456789/parameter_hash=abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789/run_id=0123456789abcdef0123456789abcdef/part-0001.jsonl",
  "merchant_id": "184467440737095",
  "detail": {
    "before": {"hi": 42, "lo": 9876543210},
    "after":  {"hi": 42, "lo": 9876543211},
    "draws": "1",
    "expected_delta": "1",
    "blocks": 1,
    "trace_blocks_total": 0
  },
  "seed": 1234567890123456789,
  "parameter_hash": "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
  "manifest_fingerprint": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
  "run_id": "0123456789abcdef0123456789abcdef",
  "ts_utc": 1752555123123456000
}
```

* `dataset_id` is the **registry id** (not a path).
* **Types per S0 failure schema:** `seed` is a JSON **integer**; `merchant_id` is a JSON **string** (or `null` when not applicable); `ts_utc` is a JSON **integer** = nanoseconds since Unix epoch (UTC). The `detail` payload for counter mismatches must include `before`, `after`, `blocks:uint64`, and `draws:"uint128-dec"`. 

---

## Where to detect (first line) & who double-checks

| Family / Code                  | First detector (runtime)         | Secondary (validator / CI)                                                                                                                                                                                                        |
|--------------------------------|----------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| A1â€“A3 design/Î²                 | S1.1/S1.2 guards                 | (optional) build lints                                                                                                                                                                                                            |
| B1â€“B2 numeric invalid          | S1.2 evaluation guards           | Re-eval Î·, Ï€                                                                                                                                                                                                                      |
| C1 envelope schema             | Writer JSON-Schema check         | Validator schema pass                                                                                                                                                                                                             |
| C2 label mismatch              | Writer assertion                 | Validator                                                                                                                                                                                                                         |
| C3 counter mismatch            | Writer assertion                 | Validator counter math (`u128(after)âˆ’u128(before)` vs **blocks**, and **`blocks == parse_u128(draws)`**); trace `blocks_total` reconciliation                                                                                     |
| C4 trace missing/totals mis    | â€”                                | Trace aggregate vs Î£(event budgets)                                                                                                                                                                                               |
| C5 u out of range              | Writer check                     | `u01` + recompute                                                                                                                                                                                                                 |
| D1 payload schema              | Writer JSON-Schema check         | Validator schema pass                                                                                                                                                                                                             |
| D2 deterministic inconsistency | Writer assertion                 | Recompute branch from Ï€                                                                                                                                                                                                           |
| E1 partition mismatch          | Writer path/embed equality check | Path lint (only `{seed, parameter_hash, run_id}`)                                                                                                                                                                                 |
| E2 wrong dataset path          | â€”                                | Dictionary/registry binding lint                                                                                                                                                                                                  |
| F1 gating violation            | â€”                                | Cross-stream presence check using **dataset dictionary `gating:` blocks** (`owner_subsegment == "1A"` and `gating.gated_by == "rng_event_hurdle_bernoulli"`); **fallback** to artefact-registry enumeration if `gating` is absent |
| F2 duplicate record            | â€”                                | Uniqueness check                                                                                                                                                                                                                  |
| F3 cardinality mismatch        | â€”                                | Row count vs ingress merchant set                                                                                                                                                                                                 |

> **Gating note:** Enforcement is **presence-based**: downstream gated streams must exist **iff** hurdle `is_multi=true`. No temporal â€œpriorâ€ requirement. **Literal:** `gating.gated_by == "rng_event_hurdle_bernoulli"`.

---

## Validator assertions (executable checklist)

Using the dictionary/registry bindings and schema anchors:

1. **Schema:** validate hurdle events **and** cumulative trace against the layer anchors (envelope + event + trace).
2. **Counters & budget:** enforce the **budget identity** (see **S1.4 â€” Envelope**) and, for **hurdle**, the branch constraints `draws âˆˆ {"0","1"}` and `blocks âˆˆ {0,1}`.
   **Trace reconciliation:** per `(module, substream_label)`, `blocks_total` equals **Î£(event blocks)** (saturating to uint64; normative) and `draws_total` equals **Î£(event draws)** (saturating to uint64; **required**, diagnostic); and `events_total` equals the **event count** (saturating to uint64; normative).
   **Note:** Do **not** assert any relationship between `u128(key.after) âˆ’ u128(key.before)` on the **final trace row** and these cumulative totals; that per-row delta is not equal to a cumulative sum.
3. **Decision:** recompute $\eta,\pi$ (S1.2 rules); if stochastic (`draws="1"`), regenerate one uniform from the keyed **base counter** (low-lane, open-interval `u01`) and assert `0<u<1` and `(u<pi) == is_multi`.
   *Doc note:* Whether one writes `(u < \pi)` or `(u \le \pi)` is **immaterial** hereâ€”`u` is drawn from an **open interval** (schema `$defs/u01`) so the equality case has probability 0, and the **deterministic branch** (`\pi âˆˆ {0,1}`) carries `u = null` by schema. See S0 open-interval and S1 envelope/payload rules.
4. **Deterministic regime:** if `draws="0"`, assert `pi âˆˆ {0.0,1.0}` **(binary64 *bit-exact*)**, `deterministic=true`, and `u == null`.
5. **Partition lint:** path partitions `{seed, parameter_hash, run_id}` equal the embedded envelope; path **must not** include `module`, `substream_label`, or `manifest_fingerprint`.
6. **Gating:** build the set of **gated 1A RNG streams** from the **dataset dictionary/registry** using `owner_subsegment="1A"` and the enumerated **gated** dataset ids; for each merchant, presence/absence of those streams is **iff** hurdle `is_multi=true`. S1 does **not** enumerate names inline.
7. **Uniqueness & cardinality:** within the run partition, **exactly one** hurdle row per `merchant_id`; hurdle row count equals the ingress merchant cardinality.

---

## Minimal examples (concrete)

* **Numeric invalid (B2).** `pi` is NaN after logistic â‡’ `hurdle_nonfinite_or_oob_pi` â‡’ **abort**.
* **Envelope gap (C1).** Missing `rng_counter_after_hi` â‡’ `rng_envelope_schema_violation` â‡’ **abort**.
* **Gating failure (F1).** A gated stream (from the **dataset dictionary/registry**) exists for merchant `m` while hurdle `is_multi=false` or no hurdle event exists â‡’ `gating_violation_no_prior_hurdle_true` â‡’ **run invalid**.

---

**Bottom line:** S1.6 (complete) specifies the **failure predicates**, **where theyâ€™re detected**, the **forensics object** (with registry ids, lineage, counters, and budgets), and the **validator checklist**â€”all consistent with S0 and the locked S1 contracts (nullable `u`, boolean `is_multi`, full envelope with required `draws`, stable `{seed, parameter_hash, run_id}` partitions, cumulative trace per substream, and registry-driven gating).

---

# S1.7 â€” Outputs of S1 (state boundary, normative)

## A) Authoritative event stream that S1 **must** persist

For every merchant $m\in\mathcal{M}$, S1 writes **exactly one** JSONL record to the hurdle RNG dataset:

```
logs/rng/events/hurdle_bernoulli/
  seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl
```

* **Dataset id (registry):** `rng_event_hurdle_bernoulli`.
* **Partitions (path):** `{seed, parameter_hash, run_id}` only.
  *(Do **not** include `manifest_fingerprint`, `module`, or `substream_label` in the path; those live in the envelope.)*
* **Schema:** `schemas.layer1.yaml#/rng/events/hurdle_bernoulli`.

**Envelope (shared; required for all RNG events):**
{ ts_utc, run_id, seed, parameter_hash, manifest_fingerprint, module, substream_label, rng_counter_before_lo, rng_counter_before_hi, rng_counter_after_lo, rng_counter_after_hi, draws, blocks }

`module`, `substream_label` are **registry-closed literals** (schema-typed as strings; closure enforced by validators/registry).
* **Budget identity (must hold):**
  `u128(after) âˆ’ u128(before) = parse_u128(draws)` (unsigned 128-bit arithmetic).
  For the hurdle stream (a **single-uniform family**), `draws âˆˆ {"0","1"}` (unit = one 64-bit uniform) and `blocks âˆˆ {0,1}` and **must equal** `parse_u128(draws)`â€”**hurdle-specific**. Other families may record `blocks=1` with `draws>1`.

**Identifier serialization:** fields typed as `uint64/id64` in the schema (e.g., `seed`, counter words, `merchant_id`) are emitted as **JSON integers** (not strings).

**Payload (authoritative, minimal):**
`{ merchant_id, pi, is_multi, deterministic, u }`
(Note: `merchant_id` is **required** by the hurdle event schema and appears as a **top-level** field in the event; it is optional in the shared envelope but **mandatory** here by the event schema.)

* `merchant_id` â€” **id64 integer**.
* `pi` â€” JSON number, **binary64 round-trip**, `0.0 â‰¤ pi â‰¤ 1.0`.
* `is_multi` â€” **boolean**.
* `deterministic` â€” **boolean**, derived: `true` iff `pi âˆˆ {0.0, 1.0}` (binary64).
* `u` â€” **required** `number|null`: `u=null` iff `pi âˆˆ {0.0,1.0}`, else `uâˆˆ(0,1)` (open interval).

> **Diagnostics policy.** Diagnostic/context fields (e.g., `eta`, `mcc`, `channel`, `gdp_bucket_id`) are **allowed by the schema as optional/nullable**, but they are **non-authoritative**: producers **SHOULD NOT** emit them, and validators **MUST ignore** them if present.

**Companion trace (cumulative; per-substream, no merchant dimension):**
Maintain a **cumulative** `rng_trace_log` row per `(module, substream_label)` within the run; its totals equal the **sum of event budgets** for that substream. (Trace **rows are emitted per event**; consumers pick the **final** row per key. No merchant dimension in trace.)

* **Totals semantics (normative):**
  - `events_total` = **count of event rows** for that `(module, substream_label)` in the run (saturating `uint64`);
  - `blocks_total` = **Î£(event.blocks)** for that key in the run (saturating `uint64`);
  - `draws_total`  = **Î£(event.draws)** for that key in the run (saturating `uint64`).
  (Matches `schemas.layer1.yaml#/rng/core/rng_trace_log` and dictionary text for the trace dataset.) 

* **Final-row selection rule.** Selection per schema anchor `schemas.layer1.yaml#/rng/core/rng_trace_log`.
 
> The hurdle event is the **only authoritative source** of the decision and its **own** counter evolution.

**Trace path â†” embed (subset):** For `rng_trace_log`, the embedded envelope fields present (**`seed`, `run_id`**) **equal** the same path keys; **`parameter_hash` is path-only**.

---

## B) In-memory **handoff tuple** to downstream (typed, deterministic)

S1 does not persist a â€œstate tableâ€; it yields a **typed tuple** per merchant to the orchestrator:

$$
\boxed{\ \Xi_m \;=\; \big(\ \text{is_multi}:\mathbf{bool},\ N:\mathbb{N},\ K:\mathbb{N},\ \mathcal{C}:\text{set[ISO_3166-1 alpha-2]},\ C^{\star}:\text{u128}\ \big)\ }.
$$

**Field semantics (normative):**

* `is_multi` â€” hurdle outcome (**boolean**) from the event payload.
* `N` â€” **target outlet count** for S2 when `is_multi=true`; set `N:=1` on the single-site path.
* `K` â€” **non-home country budget**; initialize `K:=0` on the single-site path; multi-site assigns later.
* `ð“’ : \text{set[ISO_3166-1 alpha-2]}` â€” **country set accumulator**;  
  _Ordering invariant:_ maintain `ð“’` as a **deterministic ordered set** with **rank 0 reserved for `home_iso(m)`**. Any later country allocations **append** in a deterministic order; downstream materializations **must preserve** this order (pinned later in `alloc/country_set`).
* $C^{\star}$ â€” the hurdle eventâ€™s **post** counter as u128, carried **only for audit**. Represent as either:
  (i) a **decimal** `u128` string (`rng_counter_after_dec_u128`), or
  (ii) a labelled struct `{after_hi:uint64, after_lo:uint64}` (no positional tuples).

**Persistence note:** $C^{\star}$ is **not persisted** as a column in any dataset; it travels only in the in-memory handoff tuple for audit/replay and **must not** be used for downstream counter chaining.

**Crucial counter rule:**
Downstream states **do not** chain from $C^{\star}$. Each downstream RNG stream derives its **own base counter** from S0â€™s keyed-substream mapping using its **own** `(module, substream_label, merchant_id)`; there is **no cross-label counter chaining**.

**Branch semantics:**

* If `is_multi == false`: set `N:=1`, `K:=0`, `ð“’ := { home_iso(m) }`, and route to **S7** (single-home placement). No NB/ZTP/Dirichlet/Gumbel streams may appear.
* If `is_multi == true`: route to **S2** (NB branch). `N`, `K` are assigned downstream; `ð“’` starts as `{ home_iso(m) }`.

---

## C) Downstream visibility (for validation & joins)

Validators discover **gated** 1A RNG streams **programmatically** in the dataset dictionary via `gating:` blocks (`owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"`). If the dictionary is legacy and lacks `gating`, they **fall back** to the artefact-registry enumeration. Those streams must be **present iff** `is_multi=true` for a merchant. S1 does **not** enumerate names inline.

---

## D) Optional diagnostic dataset (parameter-scoped; not consulted by samplers)

If enabled, a diagnostic table may be persisted (often produced in S0.7):

```
data/layer1/1A/hurdle_pi_probs/parameter_hash={parameter_hash}/â€¦
```

**Schema:** `#/model/hurdle_pi_probs` (authoritative; see S0.7). **Contents (per merchant):**
`{ parameter_hash (embedded; must equal path key), merchant_id, logit:float32, pi:float32, produced_by_fingerprint? }`.
`manifest_fingerprint` is **not** part of this parameter-scoped dataset. This table is **read-only** and **non-authoritative**; samplers never consult it.

---

## E) Boundary invariants (must hold when S1 ends)

1. **Single emit:** exactly one hurdle record per merchant per `{seed, parameter_hash, run_id}` and exactly one $\Xi_m$.
2. **Cross-label independence:** downstream RNG events **derive** their base counters via S0â€™s keyed mapping for their **own** labels; there is **no** requirement that `before(next) == C^{\star}`.
3. **Branch purity (gating):** gated downstream 1A RNG streams are **present iff** `is_multi=true`.
4. **Lineage coherence:** dataset paths use `{seed, parameter_hash, run_id}`; embedded envelope keys equal the path keys (**see V2: Path â†” embed equality**); egress/validation later uses `fingerprint={manifest_fingerprint}`.
5. **Numeric consistency:** hurdle `pi` equals the S1.2 recomputed value (fixed-order dot + two-branch logistic (no clamp)).

---

## F) Minimal handoff construction (reference)

```text
INPUT:
  hurdle_event for merchant m (envelope + payload), home_iso(m)

OUTPUT:
  Xi_m = (is_multi, N, K, C_set, C_star)

1  is_multi := hurdle_event.payload.is_multi                 # boolean
2  C_star   := envelope.rng_counter_after_dec_u128  # or {after_hi, after_lo}; audit only

3  if is_multi == false:
4      N := 1
5      K := 0
6      C_set := { home_iso(m) }
7      next_state := S7
8  else:
9      N := <unassigned>   # set in S2
10     K := <unassigned>   # set in cross-border/ranking
11     C_set := { home_iso(m) }
12     next_state := S2

13  return Xi_m, next_state
```

*(This is a handoff contract, not persisted state. Downstream states derive their **own** base counters; `C_star` is for audit.)*

---

**Scope recap:** S1 outputs **one** authoritative hurdle event per merchant (complete envelope + minimal payload) and a **typed, deterministic handoff tuple**. The boundary guarantees **gated presence**, **cross-label RNG independence** (no counter chaining), stable 3-key partitions, and numeric consistencyâ€”giving downstream states and validators a clean, replayable interface.

---

# S1.V â€” Validator & CI (normative)

## V0. Purpose & scope

Prove that every hurdle record is (a) **schema-valid**, (b) **numerically correct** under the pinned math policy, (c) **RNG-accounted** (counters â†” uniform budget), (d) **partition-coherent**, and (e) **structurally consistent** with downstream streams via **presence-based gating**.
Validator logic is **order-invariant** (shard/emit order is irrelevant) and uses the **dataset dictionary/registry** plus S1 invariants.
*Doc note:* Path/partition rules are **normative** in **V2**; any repeats elsewhere are **reminders** that defer to V2.

---

## V1. Inputs the validator must read
**Notation.** For any counter pair `{lo:uint64, hi:uint64}` (matching the envelope names `*_lo`, `*_hi`), define `u128(x) := (x.hi << 64) | x.lo` and `Î”ctr := u128(after) âˆ’ u128(before)`. We use `Î”ctr` below for per-event counter deltas and reconciliation rules.

1. **Locked specs:** the S1 state text (this document) and the combined journey spec (for cross-state joins).
2. **Event datasets (logs):**

   * **Hurdle events** â€” dataset id `rng_event_hurdle_bernoulli`, schema `#/rng/events/hurdle_bernoulli`, partitions

     ```
     logs/rng/events/hurdle_bernoulli/
       seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl
     ```
   * **RNG trace (cumulative)** â€” dataset id `rng_trace_log`; per (module='1A.hurdle_sampler', substream_label='hurdle_bernoulli') totals (saturating `uint64`) **and** `rng_counter_before/after` for the run (no merchant dimension; append-safe; take the **final** row per key â€” **selection rule per** `schemas.layer1.yaml#/rng/core/rng_trace_log`).  
     *(S1 uses a single fixed substream label: `hurdle_bernoulli`.)*
   * **Downstream gated streams** â€” discoverable **programmatically** in the dataset dictionary (`dataset_dictionary.layer1.1A.yaml`) via the `gating:` blocks. Concretely: select entries with `owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"` (e.g., `rng_event_gamma_component`, `rng_event_poisson_component`). 
     If a legacy dictionary lacks `gating`, fall back to the artefact-registry enumeration for the same set. S1 does **not** enumerate names inline.
3. **Design/Î² artefacts:** frozen encoders/dictionaries and the single-YAML hurdle coefficients bundle (Î²).
4. **Lineage keys:** `{seed, parameter_hash, manifest_fingerprint, run_id}` from path + envelope; the **shared RNG envelope** is mandatory for each event.

---

## V2. Discovery & partition lint (dictionary-backed)

* **Locate** the hurdle partition for the run using the dictionary/registry binding.
* **Path â†” embed equality:** for **every row**, the embedded envelope keys
  `{seed, parameter_hash, run_id}` **equal** the same path keys.
  `module` and `substream_label` are checked **in the envelope only** as registry literals (they do **not** appear in the path).
  `manifest_fingerprint` is **embedded only** (never a path partition).
* **Canonical path representation (normative):** partition values must be **string-identical** to their canonical formats:
  - `seed` â†’ base-10 **unsigned** with **no leading zeros** (except the single digit `"0"` when zero);
  - `parameter_hash` â†’ **lowercase** 64-hex (`hex64`);
  - `run_id` â†’ **lowercase** 32-hex (`hex32`).
  The equality check in the previous bullet is performed **byte-for-byte** on these canonical strings (path segment vs embedded field).
* **Trace path â†” embed (subset):** For `rng_trace_log`, the embedded envelope fields present (`seed`, `run_id`) **equal** the same path keys; `parameter_hash` is path-only.
* **Schema anchors** are fixed by the layer schema set. Payload keys are exactly
  `{merchant_id, pi, is_multi, deterministic, u}`; the envelope is the layer-wide anchor.
  For S1 hurdle events, the envelope literal **`module` MUST equal `"1A.hurdle_sampler"`** and
  **`substream_label` MUST equal `"hurdle_bernoulli"`** (registry literals; validated against the layer schema).
* **Merchant scope & dual validation.** For merchant-scoped streams the envelope anchor admits `merchant_id` (nullable), while the hurdle **event schema requires** `merchant_id`. Validators treat the record as **one flat object** and enforce presence per the event schema (plus envelope conformance where applicable).

> The **allowed literal set** for `module` and `substream_label` is resolved from the **dataset dictionary/registry**; S1 does **not** maintain a local enumerated list.

> **Diagnostics policy (schema-aligned).** Optional diagnostic fields permitted by the layer schema (e.g., `eta`, or categorical predictors such as `mcc`, `channel`, `gdp_bucket_id`) are **non-authoritative** for S1.
> Producers **SHOULD NOT** emit them in `rng_event_hurdle_bernoulli`; validators **MUST ignore** such fields if presentâ€”they have no effect on outcome, gating, or validation predicates.

> **Numeric policy (examples reminder):** 64-bit counters/ids remain **JSON integers**; the u128 **`draws`** field is a **decimal string**; probabilities are IEEE-754 binary64; `u` uses S0â€™s **open-interval** `u01` mapping.

**Discovery checks:**

* **P-1:** partition exists; **P-2:** at least one `part-*` file;
* **P-3:** hurdle row count equals the ingress merchant count for the run;
* **P-4:** uniqueness of `merchant_id` within `{seed, parameter_hash, run_id}`.

---

## V3. Schema conformance (row-level)

Validate **every** hurdle record against:

* **Envelope (complete):**
  `ts_utc, run_id, seed, parameter_hash, manifest_fingerprint, module, substream_label, rng_counter_before_lo, rng_counter_before_hi, rng_counter_after_lo, rng_counter_after_hi, draws, blocks`.
  (`module`/`substream_label` are **registry-closed literals**; `draws` is **u128 as a decimal string**).
* **Payload (minimal, authoritative):**
  `merchant_id` (**id64 JSON integer**), `pi` (**binary64 round-trip**, `0.0 â‰¤ pi â‰¤ 1.0`),
  `is_multi` (**boolean**), `deterministic` (**boolean**, derived from `pi`),
  `u` (**required** with type **number|null**: `null` iff `pi âˆˆ {0.0,1.0}`, else `uâˆˆ(0,1)`).

**Flat record reminder.** There is **one** top-level JSON object per row; the â€œenvelopeâ€ vs â€œpayloadâ€ lists above are **not** separate nested objects.

**Authority.** The envelope/payload key sets above are the **single normative inventory** for S1 hurdle. Any other lists (e.g., in S1.4 or examples) are **non-authoritative recaps** and must not diverge from V3.

**Counter fields.** `rng_counter_*_{lo,hi}` are **named** words; JSON object key order is **non-semantic**.

> **Diagnostics policy.** Diagnostic/context fields (e.g., `eta`, `mcc`, `channel`, `gdp_bucket_id`) are **allowed by the schema as optional/nullable**, but they are **non-authoritative**: producers **SHOULD NOT** emit them, and validators **MUST ignore** them if present.

---

## V4. Recompute Î· and Ï€ (numeric truth)

For each merchant $m$:

1. Rebuild $x_m$ using the **frozen encoders** (one-hot sums = 1; column order equals the fitting bundle).
2. Load Î² atomically; assert $|Î²| = 1 + C_{\text{mcc}} + 2 + 5$ (**counts come from the frozen encoders/dictionaries pinned for this run**) and **exact column alignment** with $x_m$
3. Compute $\eta_m = Î²^\top x_m$ in binary64 (fixed-order Neumaier).
4. Compute $\pi_m$ with the **two-branch logistic (no clamp)**: assert finiteness and `0.0 â‰¤ pi â‰¤ 1.0`.

**Fail fast:** any non-finite $\eta$/$\pi$ or shape/order mismatch is a **hard abort**.

---

## V5. RNG replay & counter accounting (per row)

Let the label be the registry literal `substream_label="hurdle_bernoulli"`.

1. **Base counter reconstruction:** using `(seed, manifest_fingerprint, substream_label, merchant_id)` and the S0 keyed-substream primitive, recompute the **base counter** and assert it equals the envelope `rng_counter_before`.
2. **Budget from Ï€:** set `draws_expected = 1` iff `0 < pi < 1`, else `0`.
3. **Budget identity:** compute `delta = u128(after) âˆ’ u128(before)` and assert
   `delta == parse_u128(draws) == draws_expected`.
   Also assert `blocks == parse_u128(draws)` (specific to `rng_event_hurdle_bernoulli`) and `blocks âˆˆ {0,1}`.
4. **Lane policy:** assert `delta âˆˆ {0,1}`.
5. **Stochastic vs deterministic:**

   * If `draws_expected == 0`: assert `pi âˆˆ {0.0,1.0}` (binary64 *bit-exact*), `u == null`, `deterministic == true`, and `is_multi == (pi == 1.0)`.
   * If `draws_expected == 1`: regenerate **one** uniform from the keyed substream at `before` (low lane), map via **open-interval** `u01`, assert `0<u<1` and `(u < pi) == is_multi`.

**Trace reconciliation (cumulative):** For the **final** trace row per `(module, substream_label)`:
`draws_total == Î£ parse_u128(draws)` (**required**; diagnostic; saturating `uint64`) and `blocks_total == Î£ blocks` (normative; saturating `uint64`). *(No assertion on `u128(after) âˆ’ u128(before)` for the final row.)*

> Naming: use `draws_expected` (from Ï€), `blocks`/`draws` (from envelope), and `delta` for counter difference.

---

## V6. Cross-stream gating (branch purity)

Let $\mathcal{H}_1=\{m\mid \text{hurdle.is_multi}(m)=\text{true}\}$.
Build the **set of gated 1A RNG streams** **programmatically** from the dataset dictionary (`owner_subsegment == "1A"` **and** `gating.gated_by == "rng_event_hurdle_bernoulli"`); if the dictionary is legacy and lacks `gating`, **fall back** to the artefact-registry enumeration. For **every** row in any gated stream, assert `merchant_id âˆˆ ð“—â‚`. For merchants **not** in $ð“—_1$, assert **no** gated rows exist. *(Presence-based; no temporal ordering requirement.)*

---

## V7. Cardinality & uniqueness

* **Uniqueness:** exactly **one** hurdle record per `merchant_id` within `{seed, parameter_hash, run_id}`.
* **Coverage:** hurdle row count equals the ingress merchant count for the run.

---

**Bottom line:** This validator spec proves each hurdle event is schema-conformant, numerically correct, budget-conserving, partition-coherent, and correctly gates downstream streamsâ€”using **base-counter reconstruction**, **open-interval** replay, **cumulative per-substream trace totals** (grouped by (`module`, `substream_label`)), and registry-driven discovery.

---

## V8. Partition equality & path authority

For **every** hurdle row:

* **Path â†” embed equality:** Embedded envelope keys
  `{seed, parameter_hash, run_id}` **must equal** the same keys in the dataset path.
  *(The hurdle dataset partitions by `{seed, parameter_hash, run_id}` only.)*
* **Literal checks (envelope):** `substream_label == "hurdle_bernoulli"` (registry literal) and `module` **MUST** equal `"1A.hurdle_sampler"`.
* **No fingerprint in path:** `manifest_fingerprint` is **embedded only** (lineage), never a path partition.

Mismatch is a lineage/partition failure.

---

## V9. Optional diagnostics (non-authoritative)

If the diagnostic table `â€¦/hurdle_pi_probs/parameter_hash={parameter_hash}` exists, **do not** use it to verify decisions. At most, compare its `(eta, pi)` to recomputed values for sanity. Decisions are proven **only** by replaying S1.2 + S1.3.

---

## V10. Failure objects (forensics payload; exact keys)

Emit **one JSON object per failure** with envelope lineage and a precise code:

```json
{
  "state": "S1",
  "dataset_id": "rng_event_hurdle_bernoulli",
  "module": "1A.hurdle_sampler",
  "substream_label": "hurdle_bernoulli",
  "failure_code": "rng_counter_mismatch",
  "failure_class": "F4",

  "merchant_id": "184467440737095",
  "detail": {
    "before": { "hi": 42, "lo": 9876543210 },
    "after":  { "hi": 42, "lo": 9876543211 },
    "blocks": 1,
    "draws": "1",
    "expected_delta": "1",
    "trace_blocks_total": 0,
    "trace_draws_total": 0
  },

  "seed": 1234567890123456789,
  "parameter_hash": "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
  "manifest_fingerprint": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
  "run_id": "0123456789abcdef0123456789abcdef",
  "ts_utc": 1752555123123456000
}
```

* `dataset_id` is the **registry id** (not a path).
* **Types per S0 failure schema:** `seed` is a JSON **integer**; `merchant_id` is a JSON **string** (or `null` when not applicable); `ts_utc` is a JSON **integer** = nanoseconds since Unix epoch (UTC). The `detail` payload for counter mismatches must include `before`, `after`, `blocks:uint64`, and `draws:"uint128-dec"`.
* `failure_code` maps **1:1** to S1.6 predicates.

---

## V11. End-of-run verdict & artifact

* If **any** check fails â‡’ **RUN INVALID**. Emit a `_FAILED.json` sentinel with aggregated stats and the list of failure objects; CI blocks the merge.
* If all checks pass â‡’ **RUN VALID**. Optionally record summary metrics (row counts, draw histograms, min/max/mean `pi`, `u` bounds). *(Downstream layers may re-check gating; S1.V is the first hard gate.)*

---

## CI integration (blocking gate)

### CI-1. Job matrix

* All **changed parameter bundles** (distinct `parameter_hash`) and a **seed matrix** (e.g., 3 fixed seeds per PR).
* At least one **prior manifest fingerprint** (regression guard vs last known good).

### CI-2. Steps

1. **Schema:** validate hurdle + trace rows against schema anchors; fail fast.
2. **Partition:** path â†” embedded equality on `{seed, parameter_hash, run_id}`; then check envelope literals (`module`, `substream_label`); ensure **no fingerprint in path**.
3. **Replay:** Recompute `Î·=Î²áµ€x` and `Ï€=Ïƒ(Î·)` (two-branch logistic, no clamps). For rows with `0<Ï€<1`, regenerate **one** uniform from the keyed substream at `rng_counter_before` (low-lane, open-interval `u01`) and assert the Bernoulli outcome matches the event record. Then reconcile cumulative per-substream **trace totals** and the **final trace row** as specified in **S1.V (Trace reconciliation)**.
4. **Gating:** enforce **presence-based** rule: gated streams exist **iff** `is_multi=true`.
5. **Cardinality/uniqueness:** exactly one hurdle row per merchant; counts match ingress.

### CI-3. What blocks the merge

Any: schema violation, partition mismatch, counter/trace mismatch, non-finite numeric, deterministic-branch inconsistency, **gating presence failure**, or cardinality/uniqueness failure. (Codes per S1.6.)

### CI-4. Provenance in the validation bundle

Record a compact summary in the fingerprint-scoped validation payload: counts, pass/fail, and optional lint artifacts (`SCHEMA_LINT.txt`, `DICTIONARY_LINT.txt`) for human inspection. *(Bundles are fingerprint-scoped; logs remain log-scoped.)*

---

## Reference validator outline (language-agnostic)

```text
INPUT:
  paths from registry; encoders; beta; run keys (seed, parameter_hash, run_id)

LOAD:
  H := read_jsonl(hurdle partition)
  T := read_jsonl(trace partition)
  S := discover_gated_streams_via_registry()

# 1) schema
assert_all_schema(H, "#/rng/events/hurdle_bernoulli")
assert_all_schema(T, "#/rng/core/rng_trace_log")

# 2) partition equality
for e in H: assert path_keys(e) == embedded_keys(e)   # {seed, parameter_hash, run_id}
assert all(e.module == "1A.hurdle_sampler" and e.substream_label == "hurdle_bernoulli" for e in H)

# 3) recompute (Î·, Ï€) and budget
beta := load_beta_once()
for e in H:
  x_m := rebuild_design(m)                 # frozen encoders; one-hot sums; column order
  eta, pi := fixed_order_dot_and_safe_logistic(x_m, beta)
  draws := 1 if 0 < pi < 1 else 0

  # 4) base counter + counters & trace
  before := reconstruct_base_counter(seed, manifest_fingerprint, "hurdle_bernoulli", m)
  assert e.rng_counter_before == before
  delta := u128(e.after) - u128(e.before)
  assert delta == parse_u128(e.draws) == draws
  assert e.blocks == parse_u128(e.draws)

  # 5) branch checks
  if draws == 0:
     assert (pi == 0.0 and !e.is_multi) || (pi == 1.0 and e.is_multi)
     assert e.deterministic and e.u == null
  else:
     u := regenerate_u01(seed, before)     # (0,1), low-lane policy
     assert 0.0 < u and u < 1.0
     assert (u < pi) == e.is_multi

# 6) trace reconciliation (final per (module, substream_label))
for each key in final_rows(T):
  assert key.draws_total == sum(parse_u128(e.draws) for e in H if e.module==key.module and e.substream_label==key.substream_label)   # required; diagnostic; saturating uint64
  assert key.blocks_total == sum(e.blocks for e in H if e.module==key.module and e.substream_label==key.substream_label)             # normative; saturating uint64
  # no assertion relating (afterâˆ’before) on the final row to cumulative totals

# 7) gating (presence-based)
H1 := { m | H[m].is_multi == true }
for each row in each gated stream s âˆˆ S:
  assert row.merchant_id in H1
for each m âˆ‰ H1:
  assert no rows exist in any s âˆˆ S

# 8) uniqueness & cardinality
assert |H| == |ingress_merchant_ids|
assert unique(H.merchant_id)
```

---

**Bottom line:** This chunk locks the **partition/lineage checks**, the **forensics error object**, and the **CI gate** to the exact S1 contracts: complete envelope, base-counter reconstruction, budget identity + cumulative trace, presence-based gating via the registry, and strict uniqueness/cardinalityâ€”so any drift trips a named, actionable failure.

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s2-expanded"></a>
# state.1A.s2.expanded.txt

<!-- Source file: state.1A.s2.expanded.txt | BYTE-EXACT EMBED -->

# S2.1 â€” Scope, Preconditions, and Inputs (implementation-ready)

## 1) Scope & intent

S2 generates the **total pre-split multi-site outlet count** $N_m$ for merchants that passed the hurdle as **multi-site** in S1. It is a *stochastic* state (NB via Poissonâ€“Gamma), but **S2.1 itself** is deterministic: it gates who enters S2 and assembles the numeric inputs needed for S2.2â€“S2.5. Only merchants with `is_multi=1` (per S1â€™s authoritative event) may enter S2; single-site merchants bypass S2 entirely.
Note that examples are informative; behaviour is defined by the normative rules in this spec

---

## 2) Entry preconditions (MUST)

For a merchant $m$ to enter S2 (where $m$ is the S0 canonical $merchant_{u64}$ key):

1. **Hurdle provenance.** There exists exactly one S1 event record under
   `logs/rng/events/hurdle_bernoulli/â€¦` with the merchant key and payload containing `is_multi=true`. This is the canonical gate from S1. **Absence** or `is_multi=false` â‡’ S2 MUST NOT run for $m$. (Branch purity.)
2. **Branch purity guarantee.** For `is_multi=0`, **no S2 events** may exist for $m$ in any stream; any presence constitutes a structural failure detected by validation.
3. **Lineage anchors available.** The run exposes `run_id`, `seed`, `parameter_hash`, and `manifest_fingerprint` (used in RNG envelopes and joins). S2.1 **does not** recompute any lineage keys.

**Abort codes (preflight):**

* `ERR_S2_ENTRY_NOT_MULTI` â€” hurdle present but `is_multi=false`.
* `ERR_S2_ENTRY_MISSING_HURDLE` â€” no S1 hurdle record for $m$.
* On either, S2 is **skipped** for $m$ (no S2 emission); the global validator will also enforce branch purity.

---

## 3) Mathematical inputs (MUST)

For each $m$ that satisfies the preconditions:

### 3.1 Design vectors (from S0/S1 encoders; column order frozen)

Form the **fixed** design vectors using the frozen one-hot encoders and column dictionaries established in S0/S1 (no re-definition here):

$$
\boxed{x^{(\mu)}_m=\big[1,\ \Phi_{\mathrm{mcc}}(\texttt{mcc}_m),\ \Phi_{\mathrm{ch}}(\texttt{channel\_sym}_m)\big]^\top},\quad
\boxed{x^{(\phi)}_m=\big[1,\ \Phi_{\mathrm{mcc}}(\texttt{mcc}_m),\ \Phi_{\mathrm{ch}}(\texttt{channel\_sym}_m),\ \ln g_c\big]^\top}.
$$

* $g_c$ is the GDP-per-capita scalar for the **home country** $c=\texttt{home_country_iso}_m$; the GDP term is **excluded** from the mean and **included** in the dispersion. Its sign and magnitude are exactly those encoded in the governed $\beta_\phi$ (Â§3.2).

**Domain & shapes:** $\Phi_{\mathrm{mcc}},\ \Phi_{\mathrm{ch}}$ are fixed-length **one-hot blocks** (sum to 1; column order frozen by the fitting bundle). $g_c>0$ so that $\ln g_c$ is defined. *(Here and below, $\ln$ denotes the natural log.)*

**FKs (deterministic):**
`mcc_m` and `channel_sym_m` come from ingress/S0 feature prep; $g_c$ is keyed by `home_country_iso`. (S0 established these and the parameter lineage via `parameter_hash`.)

### 3.2 Coefficient vectors (governed artefacts)

Load the **approved** coefficient vectors $\beta_\mu$ and $\beta_\phi$ from governed artefacts referenced by the runâ€™s `parameter_hash`. Concretely: NB-mean coefficients from `hurdle_coefficients.yaml` (**key:** `beta_mu`), and NB-dispersion coefficients from `nb_dispersion_coefficients.yaml` (**key:** `beta_phi`). These are the only sources used to compute $\mu_m,\phi_m$ in S2.2.

### 3.3 RNG discipline & authoritative schemas (for later S2 steps)

Pin the RNG/stream contracts that S2.3â€“S2.5 will rely on:

* **RNG:** Philox $2\times 64$-10 with the **shared RNG envelope** (`run_id`, `seed`, `parameter_hash`, `manifest_fingerprint`, `substream_label`, counters). Open-interval uniforms $U(0,1)$ and normals follow S0 primitives.
  The **full envelope** (including `module`, `substream_label`, `rng_counter_before_*`, `rng_counter_after_*`, `draws` as decimal u128, and `blocks` as u64) is governed by the layer schema and is the one S2.3â€“S2.5 will use when writing events.
  For S2 streams in 1A, the `module` literal is **registry-closed per stream** (data dictionary): `gamma_component` â†’ "1A.nb_and_dirichlet_sampler", `poisson_component` â†’ "1A.nb_poisson_component", `nb_final` â†’ "1A.nb_sampler".

* **Event streams (authoritative, JSONL):**
  `gamma_component` (context=`"nb"`), `poisson_component` (context=`"nb"`), and `nb_final` â€” each with schema refs in `schemas.layer1.yaml#/rng/events/...` and paths partitioned by `{seed, parameter_hash, run_id}`. These will be **written later** (S2.3â€“S2.5), not in S2.1.

---

## 4) Numeric evaluation requirements (MUST)

* **Policy:** Numeric policy is **exactly S0â€™s** (binary64, RNE, FMA-OFF, fixed-order Neumaier dot; deterministic libm surface).
* **Sanity guards:** After exponentiation in S2.2, $\mu_m>0,\ \phi_m>0$. If either is non-finite or $\le 0$, abort for $m$ with `ERR_S2_NUMERIC_INVALID`. (S2.2 will restate this as part of the link spec; S2.1 ensures the inputs exist to compute them.)

---

## 5) Pseudocode (normative preflight & assembly)

```pseudo
# Preflight gate + input assembly; emits no RNG events (draws=0)

function s2_1_prepare_inputs(m):
    # 1) Entry gate from S1
    hb := read_hurdle_event(m)                     # select within {seed, parameter_hash, run_id}, then merchant_id=m
                                                   # and verify the in-row envelope `manifest_fingerprint`
                                                   # equals the current run's `manifest_fingerprint` (explicit lineage check).
    if hb is None:           raise ERR_S2_ENTRY_MISSING_HURDLE
    if hb.is_multi != true:  raise ERR_S2_ENTRY_NOT_MULTI   # branch purity

    # 2) Load deterministic features
    c  := ingress.home_country_iso[m]
    g  := gdp_per_capita[c]                        # > 0 (checked when loaded in S0)
    xm := [1, enc_mcc(ingress.mcc[m]), enc_ch(ingress.channel_sym[m])]   # channel_sym âˆˆ {CP,CNP}
    xk := [1, enc_mcc(ingress.mcc[m]), enc_ch(ingress.channel_sym[m]), ln(g)]  # ln = natural log

    # 3) Load governed coefficients (parameter-scoped by parameter_hash)
    beta_mu  := artefacts.hurdle_coefficients.beta_mu           # from hurdle_coefficients.yaml
    beta_phi := artefacts.nb_dispersion_coefficients.beta_phi   # from nb_dispersion_coefficients.yaml

    # 4) Produce the S2 context (consumed by S2.2+)
    return NBContext{
        merchant_id: m,
        x_mu: xm, x_phi: xk,
        beta_mu: beta_mu, beta_phi: beta_phi,
        lineage: {seed, parameter_hash, manifest_fingerprint, run_id}
    }
```

**Emissions:** S2.1 emits **no** event records and consumes **no** RNG draws (draws=0).

---

## 6) Invariants & MUST-NOTs (checked locally, and again by the validator)

* **I-S2.1-A (Entry determinism).** S2 only runs for merchants with an S1 hurdle record where `is_multi=true`. Any S2 event for `is_multi=false` is a **structural failure**.
* **I-S2.1-B (Inputs completeness).** $x_m^{(\mu)},\ x_m^{(\phi)},\ \beta_\mu,\ \beta_\phi$ MUST all be available (encoders used to form $x$ are the frozen S0/S1 one-hots). Missing â†’ abort for $m$ with `ERR_S2_INPUTS_INCOMPLETE`. (The expanded docâ€™s validator also enforces this via schema/path checks downstream.)
* **I-S2.1-C (No persistence yet).** S2.1 MUST NOT write any of the S2 event streams nor any sidecar tables; persistence happens only in S2.3â€“S2.5 (events) and the state boundary in S2.9.

---

## 7) Errors & abort semantics (merchant-scoped)

* `ERR_S2_ENTRY_MISSING_HURDLE` â€” no S1 hurdle record for $m$.
* `ERR_S2_ENTRY_NOT_MULTI` â€” S1 shows `is_multi=false`.
* `ERR_S2_INPUTS_INCOMPLETE:{key}` â€” missing design feature or coefficient.
* `ERR_S2_NUMERIC_INVALID` â€” later, if $\mu$ or $\phi$ evaluate non-finite/â‰¤0 (S2.2).
  **Effect:** For any of the above, **skip S2** for $m$ (no S2 events written). The run-level validator will additionally fail branch-purity or coverage if contradictions appear.

---

## 8) Hand-off contract to S2.2+

If S2.1 succeeds for $m$, the engine must expose an **NB context** containing:

$$
(x^{(\mu)}_m,\ x^{(\phi)}_m,\ \beta_\mu,\ \beta_\phi,\ \text{seed},\ \text{parameter_hash},\ \text{manifest_fingerprint},\ \text{run_id})
$$

for use in S2.2 (NB link evaluation), S2.3 (Gamma/Poisson samplers), and S2.4 (rejection loop). **No additional mutable state** may be consulted when sampling.

---

## 9) Conformance spot-checks (writer & validator)

* **Gate correctness:** pick a known single-site merchant (`is_multi=0`); confirm **no** S2 streams contain its key. (Structural fail otherwise.)
* **Inputs reproducibility:** recompute $x^{(\mu)},x^{(\phi)}$ for a sample of merchants and verify byte-exact equality with the values used to compute `nb_final.mu` / `nb_final.dispersion_k` later.
* **Lineage presence:** ensure the S2 context carries `(seed, parameter_hash, manifest_fingerprint, run_id)` so later events can include a consistent envelope.

> **S2 in 6 steps (informative overview)**  
> 1) Compute links: $\mu=\exp(\beta_\mu^\top x^{(\mu)}),\ \phi=\exp(\beta_\phi^\top x^{(\phi)})$. *(Â§S2.2)*
> 2) Start attempt loop: draw $G\sim\Gamma(\phi,1)$, set $\lambda=(\mu/\phi)\,G$. *(Â§S2.3)*
> 3) Draw $K\sim\mathrm{Poisson}(\lambda)$; accept iff $K\ge 2$. *(Â§S2.3)*
> 4) On reject, repeat step 2; count rejections $r$. *(Â§S2.4)*
> 5) On acceptance, **emit** non-consuming `nb_final` with `n_outlets = K` and `nb_rejections = r`. *(Â§S2.5)*
> 6) **Hand off** $(N=K,r)$ in-memory to the next state (no egress here). *(Â§S2.9)*
> *(See Â§S2.2, Â§S2.3â€“S2.5, and Â§S2.9 for the normative details.)*

# S2.2 â€” NB2 parameterisation (links, domains, guards)

## 1) Scope & intent

Compute the **Negative-Binomial (NB2)** parameters for merchant $m$ that passed S2.1 preflight:

$$
\boxed{\ \mu_m=\exp(\beta_\mu^\top x^{(\mu)}_m)\;>\;0\ },\qquad
\boxed{\ \phi_m=\exp(\beta_\phi^\top x^{(\phi)}_m)\;>\;0\ }.
$$

This step is **deterministic** (no RNG), yields the **mean** $\mu_m$ and **dispersion** $\phi_m$ used by S2.3â€“S2.5, and must be **binary64-stable** and auditable. The NB2 moments are $\mathbb{E}[N_m]=\mu_m$ and $\operatorname{Var}[N_m]=\mu_m+\mu_m^2/\phi_m$. (The $r,p$ parametrisation $r=\phi_m,\ p=\phi_m/(\phi_m+\mu_m)$ is derivational only, not persisted.)

---

## 2) Inputs (MUST)

Provided by **S2.1** and artefacts keyed by `parameter_hash`:

* **Design vectors** (from S0/S2.1):

  $$
  x^{(\mu)}_m=\big[1,\ \Phi_{\mathrm{mcc}}(\texttt{mcc}_m),\ \Phi_{\mathrm{ch}}(\texttt{channel\_sym}_m)\big]^\top,\quad
  x^{(\phi)}_m=\big[1,\ \Phi_{\mathrm{mcc}}(\texttt{mcc}_m),\ \Phi_{\mathrm{ch}}(\texttt{channel\_sym}_m),\ \ln g_c\big]^\top,
  $$

  where $g_c > 0$ is the GDP-per-capita scalar for the home ISO $c$. (NB mean **excludes** GDP; dispersion **includes** $\ln g_c$.)
  *Notation:* $\Phi_{\mathrm{mcc}}(\cdot)$ and $\Phi_{\mathrm{ch}}(\cdot)$ denote **frozen one-hot encoder functions** from S0/S1; they are **not** the NB dispersion $\phi_m$ used below.
* **Coefficient vectors:** $\beta_\mu,\ \beta_\phi$ from governed artefacts **keyed by `parameter_hash`**:
  * `hurdle_coefficients.yaml` â†’ key **`beta_mu`** (maps to $\beta_\mu$),
  * `nb_dispersion_coefficients.yaml` â†’ key **`beta_phi`** (maps to $\beta_\phi$).
* **Lineage:** `seed`, `parameter_hash`, `manifest_fingerprint`, `run_id` (for later event joins and partition equality).

**Preconditions (MUST):**

1. All elements of $x^{(\mu)}_m$, $x^{(\phi)}_m$, $\beta_\mu$, $\beta_\phi$ are **finite** binary64 numbers.
2. $g_c > 0$ so that $\ln g_c$ is defined.  (Here and below, $\ln$ denotes the natural log.)
3. Vector lengths match (inner products defined).

---

## 3) Algorithm (normative, deterministic)

Let $\eta^{(\mu)}_m=\beta_\mu^\top x^{(\mu)}_m$ and $\eta^{(\phi)}_m=\beta_\phi^\top x^{(\phi)}_m$.

1. **Evaluate linear predictors** in **binary64** with **FMA disabled** and **fixed-order, serial Neumaier accumulation** for dot products. Do **not** reorder summands or use non-deterministic BLAS paths; this mirrors S0â€™s numeric contract (binary64, RNE, FMA-OFF; deterministic libm).
2. **Exponentiate** safely in binary64:

   $$
   \mu_m=\exp\!\big(\eta^{(\mu)}_m\big),\qquad \phi_m=\exp\!\big(\eta^{(\phi)}_m\big).
   $$
3. **Numeric guards (MUST):** if either exponentiation yields **non-finite** (NaN/Â±Inf) or $\le 0$, raise `ERR_S2_NUMERIC_INVALID` (merchant-scoped abort). No clamping; failure is explicit.

**Notes.**
â€¢ This step **does not** create or consume RNG draws and emits **no** S2 events. $\mu_m,\phi_m$ are *handed forward* in-memory; they will be echoed byte-exactly later in `nb_final` (see Â§6).

---

## 4) Output contract (to S2.3â€“S2.5)

On success, expose the immutable NB2 context:

$$
\big(m,\ x^{(\mu)}_m,\ x^{(\phi)}_m,\ \beta_\mu,\ \beta_\phi,\ \mu_m,\ \phi_m,\ \text{seed},\ \text{parameter_hash},\ \text{manifest_fingerprint},\ \text{run_id}\big).
$$

S2.3 (Gamma/Poisson attempt), S2.4 (rejection rule), and S2.5 (finalisation) **must** use **exactly** these $\mu_m,\phi_m$ values (binary64 bit-pattern) without re-computation from different inputs.

---

## 5) Invariants (MUST)

* **I-NB2-POS:** $\mu_m > 0$ and $\phi_m > 0$.
* **I-NB2-B64:** $\mu_m,\phi_m$ are representable as IEEE-754 binary64 and remain unchanged when round-tripped through the eventual JSONL `nb_final` record. (Validator re-parses numbers and compares the binary64 bit pattern.)
* **I-NB2-SER (binding):** Producers **MUST** serialize `mu` and `dispersion_k` using the **shortest round-trip decimal for binary64** (same rule as S1; L0 helper `f64_to_json_shortest`), so that parsing yields the **exact** original bit pattern.
* **I-NB2-ECHO:** The `nb_final` payload **must echo** these exact values in fields `mu` and `dispersion_k`. Any mismatch is a structural failure at validation.

* **Numeric examples (formatting only):** Example numbers use the **shortest binary64 round-trippable decimals**; consumers parse as binary64.
---

## 6) Downstream echo (binding reference)

When S2.5 emits the single `nb_final` event for $m$, it **MUST** include:

```
{ mu: <binary64>, dispersion_k: <binary64>, n_outlets: N_m, nb_rejections: R_m, ... }
```

with `mu == Î¼_m` and `dispersion_k == Ï†_m` as produced here. Here **$R_m$** denotes the integer **rejection tally** (number of rejected attempts), distinct from the dispersion/shape $\phi_m$. (Event schema: `schemas.layer1.yaml#/rng/events/nb_final`; partitioning `{seed, parameter_hash, run_id}` per dictionary.)

---

## 7) Errors & abort semantics (merchant-scoped)

* `ERR_S2_NUMERIC_INVALID` â€” any of: non-finite $\eta$; non-finite or $\le 0$ $\mu_m$ or $\phi_m$; missing/mismatched vector sizes.
  **Effect:** skip S2 for $m$ (no S2 events written); validator also checks coverage so no `nb_final` may appear for this merchant.

---

## 8) Reference pseudocode (deterministic; no RNG; no emissions)

```pseudo
function s2_2_eval_links(ctx: NBContext) -> NBContext:
    # Inputs from S2.1
    xm   := ctx.x_mu          # vector
    xk   := ctx.x_phi         # vector includes ln(gdp_pc)
    bmu  := ctx.beta_mu       # vector
    bphi := ctx.beta_phi      # vector

    # 1) Linear predictors in binary64 (fixed-order Neumaier; FMA disabled)
    eta_mu  := dot64_no_fma(bmu,  xm)      # deterministic Neumaier reduction
    eta_phi := dot64_no_fma(bphi, xk)      # deterministic Neumaier reduction

    # 2) Exponentiate safely (no clamping on overflow)
    mu  := exp64(eta_mu)
    phi := exp64(eta_phi)

    # 3) Guards
    if not isfinite(mu) or mu <= 0:   raise ERR_S2_NUMERIC_INVALID
    if not isfinite(phi) or phi <= 0: raise ERR_S2_NUMERIC_INVALID

    # 4) Hand-off; no RNG draws, no event persistence here
    ctx.mu  = mu
    ctx.phi = phi
    return ctx
```

---

## 9) Conformance tests (KATs)

**Positive (round-trip & echo).**

1. Select $m$, compute $\mu_m,\phi_m$ with high-precision reference; confirm the engineâ€™s binary64 exactly matches and later `nb_final.mu`/`dispersion_k` numerically round-trip to the same binary64.

**Negative (guard trips).**

1. Force $\eta^{(\mu)}$ above \~709.78 (binary64 overflow threshold for `exp`) â†’ `ERR_S2_NUMERIC_INVALID`.
2. Force $\eta^{(\phi)}\to -\infty$ via extreme negative coefficients â†’ $\phi\to 0^+$ underflow; if non-finite or $\le 0$, error.
3. Remove GDP $g_c$ (so $\ln g_c$ undefined) or set $g_c\le 0$ in features â†’ `ERR_S2_NUMERIC_INVALID`.

**Structural.**

1. Deliberately change coefficients between S2.2 and S2.5 echo â†’ validator should fail `I-NB2-ECHO`.

---

## 10) Complexity

* Time: $O(d_\mu + d_\phi)$ per merchant (vector dot products).
* Memory: $O(1)$.
* This step is embarrassingly parallel across merchants.

---

# S2.3 â€” Poissonâ€“Gamma construction (one attempt), samplers, substreams

## 1) Scope & intent

Given deterministic $(\mu_m,\phi_m)$ from **S2.2**, perform **one attempt** of the NB mixture:

$$
G\sim\mathrm{Gamma}(\alpha{=}\phi_m,1),\quad \lambda=(\mu_m/\phi_m)\,G,\quad K\sim\mathrm{Poisson}(\lambda).
$$

Emit exactly **one** `gamma_component` and **one** `poisson_component` event (context=`"nb"`) for this attempt, with **authoritative RNG envelope** and draw accounting.
**Envelope must include:** `seed`, `parameter_hash`, `run_id`, `manifest_fingerprint`, `module`, `substream_label`, `ts_utc`, `rng_counter_before_hi/lo`, `rng_counter_after_hi/lo`, and per-event `blocks` (u64) and `draws` (decimal u128). Acceptance of the attempt is decided in **S2.4** (accept if $K\ge2$).

**Index semantics:** For `gamma_component`, set `index=0` for the NB mixture; for Dirichlet (elsewhere in 1A) `index=iâ‰¥1` denotes the i-th category component.

---

## 2) Mathematical foundation (normative)

**Theorem (composition).** If $G\sim\Gamma(\alpha{=}\phi_m,\text{scale}=1)$ and $K\mid G\sim\mathrm{Poisson}(\lambda{=}\tfrac{\mu_m}{\phi_m}G)$, then marginally $K\sim\mathrm{NB2}(\mu_m,\phi_m)$ with $\mathbb{E}[K]=\mu_m$, $\mathrm{Var}(K)=\mu_m+\mu_m^2/\phi_m$. (Parametrisation used in S2.2.)

---

## 3) Samplers (normative, pinned)

### 3.1 Gamma $\Gamma(\alpha,1)$ â€” Marsagliaâ€“Tsang MT1998

Use the **MT1998** algorithm with **open-interval uniforms** (S0.3.4) and **Boxâ€“Muller** normals (S0.3.5). **No normal caching**. Draw budgets are **variable per attempt** (actual-use; see counters).

* **Case $\alpha\ge 1$**
  Let $d=\alpha-\frac{1}{3}$, $c=(9d)^{-1/2}$. Repeat:

  1. $Z\sim\mathcal{N}(0,1)$ (Boxâ€“Muller â†’ **2 uniforms**).
  2. $V=(1+cZ)^3$; if $V\le0$ reject.
  3. $U\sim U(0,1)$ (**1 uniform**).
  4. Accept if $\ln U < \tfrac{1}{2}Z^2 + d - dV + d\ln V$; return $G=dV$.
     Uniform consumption (one Gamma variate): **2Ã—J + A**, where **Jâ‰¥1** is the number of MT98 iterations and **A** is the count of iterations with $V>0$ (only those iterations draw the accept-$U$).
     If $0<\alpha<1$, add **+1** uniform for the power step $U^{1/\alpha}$.

* **Case $0 < \alpha < 1$**

  1. Draw $G'\sim\Gamma(\alpha+1,1)$ via the $\alpha\ge1$ branch (variable MT98 iterations; 2 uniforms per iteration; accept-$U$ only when $V>0$).
  2. Draw $U\sim U(0,1)$ (**1 uniform**).
  3. Return $G = G'\, U^{1/\alpha}$.
     **Additional uniform:** **+1 per variate** for the power step U^{1/Î±}

* **Eventing (Gamma):** emit **one** `gamma_component` with `context="nb"`; payload includes `alpha=Ï†_m` and `gamma_value=G`.
* **Draw accounting (per event):** for attempt $t$, $\mathrm{draws}_\gamma(t)=2J_t + A_t + \mathbf{1}[\phi_m<1]$, where $J_t\ge1$ is the number of MT1998 iterations and $A_t$ is the count of iterations with $V>0$ (only those iterations draw the accept-$U$).

### 3.2 Poisson $\mathrm{Poisson}(\lambda)$ â€” S0.3.7 (deterministic regimes)

Use **S0.3.7** regime split: **inversion** for $\lambda<10$; **PTRS** (HÃ¶rmann transformed-rejection) for $\lambda\ge 10$. Constants in PTRS are **normative**; they are *not* tunables. Uniform consumption is **variable** and is measured by the envelope counters. Emit `poisson_component` with `context="nb"`.

* **Inversion ($\lambda<10$)**: multiplicative $p$ until $p\le e^{-\lambda}$.
* **PTRS ($\lambda\ge10$)**: use $b=0.931+2.53\sqrt\lambda$, $a=-0.059+0.02483\,b$, $\text{inv}\alpha=1.1239+1.1328/(b-3.4)$, $v_r=0.9277-3.6224/(b-2)$; draw $u,v\sim U(0,1)$; apply the squeeze/acceptance tests from S0.3.7.
* **Uniforms:** **variable** â€” each PTRS **iteration** uses 2 uniforms; the number of iterations is geometric; total per event is measured by envelope counters.
* **Logging:** `poisson_component` with `context="nb"` and `attempt:intâ‰¥1` (1-based).

---

## 4) RNG substreams & labels (MUST)

* **Module (registry-closed per stream):**
  * `gamma_component`  â†’ `module="1A.nb_and_dirichlet_sampler"`
  * `poisson_component` â†’ `module="1A.nb_poisson_component"`
  * `nb_final` â†’ `module="1A.nb_sampler"`
* **NB substreams (disjoint from ZTP):**
  * Gamma: `substream_label="gamma_nb"`
  * Poisson: `substream_label="poisson_nb"`
* **Order per attempt:** emit exactly two component events: `gamma_component` â†’ `poisson_component`.
Counters advance deterministically within each `(merchant, substream_label)` stream; there is **no cross-label counter chaining**. All uniforms use S0.3.4 `u01`; all normals use Boxâ€“Muller.

---

## 5) Construction (one attempt) & event emission (normative)

Given merchant $m$ with $(\mu_m,\phi_m)$ from S2.2:

* **Numeric examples (formatting only):** Example numbers use the **shortest binary64 round-trippable decimals**; consumers parse as binary64.

1. **Gamma step (context=`"nb"`)**
   Draw $G\sim\Gamma(\alpha{=}\phi_m,1)$ via **3.1** on `substream_label="gamma_nb"`.
   Emit:

   ```json
   {
          "seed": "...",
          "parameter_hash": "...",
          "run_id": "...",
          "manifest_fingerprint": "...",
          "ts_utc": "2025-01-01T00:00:00.000000Z",
          "module": "1A.nb_and_dirichlet_sampler",
          "substream_label": "gamma_nb",
          "rng_counter_before_hi": "...",
          "rng_counter_before_lo": "...",
          "rng_counter_after_hi":  "...",
          "rng_counter_after_lo":  "...",
          "blocks": 1,
          "draws": "2",

          "merchant_id": "<m>",
          "index": 0,
          "context": "nb",
          "alpha": <phi_m as binary64>,
          "gamma_value": <G as binary64>
   }
   ```

   Schema (authoritative): `schemas.layer1.yaml#/rng/events/gamma_component`. **Partition:** `logs/rng/events/gamma_component/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/...`. **Draws:** per Â§3.1 above.

2. **Poisson step (context=`"nb"`)**
   Compute $\lambda=\frac{\mu_m}{\phi_m}\,G$ in binary64. Draw $K\sim\mathrm{Poisson}(\lambda)$ via **3.2** on `substream_label="poisson_nb"`.
   Emit:

   ```json
   {
          "seed": "...",
          "parameter_hash": "...",
          "run_id": "...",
          "manifest_fingerprint": "...",
          "ts_utc": "2025-01-01T00:00:00.000000Z",
          "module": "1A.nb_poisson_component",
          "substream_label": "poisson_nb",
          "rng_counter_before_hi": "...",
          "rng_counter_before_lo": "...",
          "rng_counter_after_hi":  "...",
          "rng_counter_after_lo":  "...",
          "blocks": 1,
          "draws": "1",

          "merchant_id": "<m>",
          "context": "nb",
          "lambda": <lambda as binary64>,
         "k": <K as int>,
         "attempt": <t:intâ‰¥1>
   }
   ```

   Schema (authoritative): `schemas.layer1.yaml#/rng/events/poisson_component`. **Partition:** `logs/rng/events/poisson_component/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/...`. **Draws:** variable; reconciled by envelope counters.

> **Note (types).** All floating-point payloads are **IEEE-754 binary64** and must round-trip exactly. Integers are signed 64-bit (`kâ‰¥0`).

---

## 6) Draw accounting & reconciliation (MUST)

**Trace rule (cumulative).** Persist one **trace** row per `(module, substream_label)` carrying *(see also S4 Â§2A)*
`blocks_total = Î£ blocks_event` and `draws_total = Î£ draws_event`. The streamâ€™s 128-bit
counter span **must** satisfy `u128(last_after) âˆ’ u128(first_before) = blocks_total`.
There is **no** identity deriving `draws` (or `draws_total`) from counter deltas.
Validators compare `draws_total` to the sampler budgets (Gamma/Poisson as specified),
and verify the counter-span equality for `blocks_total`. `nb_final` is non-consuming.
---

## 7) Determinism & ordering (MUST)

* **Emission cardinality:** Emit exactly one `gamma_component` (with `substream_label="gamma_nb"`, `context="nb"`) then one `poisson_component` (with `substream_label="poisson_nb"`, `context="nb"`) per attempt for the merchant (no parallelization per merchant). Both events must carry the same lineage and the authoritative RNG envelope (before/after counters; `draws` computed).
* **Label order:** Gamma **precedes** Poisson; ordering is determined solely by each eventâ€™s **envelope counter interval** (`rng_counter_before_*` â†’ `rng_counter_after_*`). An `attempt:intâ‰¥1` field **is present** (per schema) but is **non-authoritative**; validators must derive order from counters.
* **Bit-replay:** For fixed $(x_m^{(\mu)},x_m^{(\phi)},\beta_\mu,\beta_\phi,\texttt{seed},\texttt{parameter_hash},\texttt{manifest_fingerprint})$, the entire $(G_t,K_t)$ attempt stream is **bit-identical** across replays. (Counter-based Philox + fixed labels + variable, actual-use budgets)
* (Reminder) NB substream **labels are closed**: `gamma_nb` / `poisson_nb` with `context="nb"`.
* Producers are registry-closed per stream (see Â§4):
  - `gamma_component â†’ "1A.nb_and_dirichlet_sampler"`,
  - `poisson_component â†’ "1A.nb_poisson_component"`,
  - `nb_final â†’ "1A.nb_sampler"`.
---

## 8) Preconditions & guards (MUST)

* Inputs $\mu_m>0,\ \phi_m>0$ (from S2.2).
* Compute $\lambda$ in binary64; if $\lambda$ is **non-finite** or $\le0$ due to numeric error, raise `ERR_S2_NUMERIC_INVALID` (merchant-scoped abort of S2). (This is rare given $\mu,\phi>0$, but it is pinned.)

---

## 9) Reference pseudocode (one attempt; emissions included)

```pseudo
function s2_3_attempt_once(ctx: NBContext, t: int) -> AttemptRecord:
    # Inputs
    mu  := ctx.mu      # >0, binary64
    phi := ctx.phi     # >0, binary64

    # --- Gamma step on substream "gamma_nb"
    G := gamma_mt1998(alpha=phi)              # uses S0.3.4/5; variable attempts internally
    # --- Compute Î» and guard numeric validity BEFORE any emission (compute once; reuse below)
    lambda := (mu/phi) * G
    if (!isfinite(lambda) or lambda <= 0.0):
        raise ERR_S2_NUMERIC_INVALID          # no S2 events should exist for this merchant
        return

    # --- Now emit gamma (envelope from the substream at this point)
    emit_gamma_component(
        merchant_id=ctx.merchant_id,
        context="nb", index=0, alpha=phi, gamma_value=G,
        envelope=substream_envelope(module="1A.nb_and_dirichlet_sampler", label="gamma_nb")
    )

    # --- Poisson step on substream "poisson_nb"
    # Î» was already computed and validated above; reuse it here (no recompute drift).
    K := poisson_s0_3_7(lambda)               # regimes per S0.3.7
    emit_poisson_component(
        merchant_id=ctx.merchant_id,
        context="nb", lambda=lambda, k=K, attempt=t,
        envelope=substream_envelope(module="1A.nb_poisson_component", label="poisson_nb")
    )

    return AttemptRecord{G: G, lambda: lambda, K: K}
```

* `gamma_mt1998` implements Â§3.1 including Î±<1 power-step and **draw budgets**.
* `poisson_s0_3_7` implements Â§3.2 (inversion / PTRS; **normative constants**).
* `emit_*` attach the **rng envelope** with `blocks = u128(after)âˆ’u128(before)` and`draws` equal to the **actual uniforms consumed** by that event (decimal uint128 string).

---

## 10) Errors & abort semantics (merchant-scoped)

* `ERR_S2_NUMERIC_INVALID` â€” non-finite or $\le0$ $\lambda$.
  **Effect:** abort S2 for $m$; **no further** S2 events are emitted for that merchant (validator will also enforce coverage).

---

## 11) Conformance tests (KATs)

* **Gamma budgets.** Let `attempts` be the number of Gamma variates emitted for the merchant. For $\phi\ge1$, assert the **sum of `draws` across all `gamma_component` events for the merchant** equals $\sum_{t=1}^{\text{attempts}} \big(2 J_t + A_t\big)$; for $0<\phi<1$, assert the **sum of `draws` across all `gamma_component` events** equals $\sum_{t=1}^{\text{attempts}} \big(2 J_t + A_t + 1\big)$.
  Here $J_t$ is the number of Boxâ€“Muller iterations for attempt $t$, and $A_t$ is the number of those iterations with $V>0$ (i.e., the iterations that consume the accept-$U$). The validator recomputes $J_t$ and $A_t$ by bit-replay and compares them to the **sum of per-event `draws`** reported by `gamma_component`.
* **Poisson regimes.** Choose $\lambda=5$ (inversion) and $\lambda=50$ (PTRS); confirm `poisson_component` bit-replays and that the counters advance with variable consumption.
* **Ordering.** Verify each attempt produces **two** events in the `gamma`â†’`poisson` order for the same merchant and that `nb_final` (later) appears once at acceptance.

---

## 12) Complexity

* Gamma MT1998: expected constant iterations (depends on $\alpha$); per-attempt uniforms are **variable**: Boxâ€“Muller uses 2 uniforms per iteration; accept-$U$ is drawn only when $V>0$; add **+1** if $0<\alpha<1$.
* Poisson S0.3.7: inversion costs $\approx \lambda$ uniforms; PTRS has constant expected attempts but **variable** uniform consumption; budgets are measured by envelope counters.
* One attempt is $O(1)$ expected time and $O(1)$ memory.

---

## 13) Interactions (binding where stated)

* Draw budgets and counters must follow **S0.3.6**; `nb_final` (S2.5) will be **non-consuming** (`draws=0`).
* The **rejection rule** ($K\in\{0,1\}\Rightarrow$ resample) and corridor monitoring are specified in **S2.4** (do not duplicate here).

---

# S2.4 â€” Rejection rule (enforce multi-site $N\ge 2$)

## 1) Scope & intent

Turn the stream of NB mixture **attempts** from S2.3 into a single **accepted** domestic outlet count

$$
\boxed{\,N_m\in\{2,3,\dots\}\,}
$$

by **rejecting** any attempt whose Poisson draw is $K\in\{0,1\}$. Count deterministic retries

$$
\boxed{\,r_m\in\mathbb{N}_0\ \text{ = #rejections before acceptance}\,}.
$$

S2.4 **emits no events**; it controls acceptance and the loop. Finalisation (`nb_final`) is S2.5. Corridor checks on rejection behaviour are enforced by the validator (not here).

---

## 2) Inputs (MUST)

From prior substates:

* **Deterministic parameters:** $(\mu_m,\phi_m)$ from S2.2, already validated $(>0)$.
* **Attempt generator:** S2.3 provides an i.i.d. attempt stream; each attempt yields $(G_t,\lambda_t,K_t)$ and **logs exactly one** `gamma_component` (context=`"nb"`) **then** **one** `poisson_component` (context=`"nb"`), with the authoritative RNG envelope. S2.4 itself consumes **no RNG**.
* **Lineage envelope:** `seed`, `parameter_hash`, `manifest_fingerprint`, `run_id`, `substream_label`, counters (for coverage checks later).

**Preconditions (MUST):** $\mu_m>0$, $\phi_m>0$; S2.3 must adhere to per-attempt cardinality (1 Gamma + 1 Poisson).

---

## 3) Acceptance process (formal, normative)

Let attempts be indexed $t=0,1,2,\dots$. For each $t$:

$$
G_t\sim\Gamma(\phi_m,1),\quad
\lambda_t=\tfrac{\mu_m}{\phi_m}G_t,\quad
K_t\sim\mathrm{Poisson}(\lambda_t)
$$

(as produced/logged by S2.3). Accept the **first** $t$ with $K_t\ge 2$, and set

$$
\boxed{\,N_m:=K_t,\quad r_m:=t\,}.
$$

If $K_t\in\{0,1\}$, **reject** and continue with the same merchantâ€™s substreams; envelope counters advance deterministically per attempt. **No hard cap** is imposed here; drift/instability is policed by the corridor gates in validation.

---

## 4) Per-attempt acceptance probability & distribution of rejections (binding math)

Each attempt is an NB2 draw with mean $\mu_m$ and dispersion $\phi_m$. With $r=\phi_m,\,p=\frac{\phi_m}{\mu_m+\phi_m}$ (derivational), the pmf is

$$
\Pr[K=k]=\binom{k+r-1}{k}(1-p)^k\,p^r.
$$

Hence

$$
\Pr[K=0]=p^{\phi_m}=\Bigl(\tfrac{\phi_m}{\mu_m+\phi_m}\Bigr)^{\phi_m},\quad
\Pr[K=1]=\phi_m\cdot(1-p)\,p^{\phi_m}=\phi_m\frac{\mu_m}{\mu_m+\phi_m}\Bigl(\tfrac{\phi_m}{\mu_m+\phi_m}\Bigr)^{\phi_m}.
$$

Define the **success** (acceptance) probability per attempt

$$
\boxed{\,\alpha_m=1-\Pr[K=0]-\Pr[K=1]\,}.
$$

Then $r_m$ (the number of rejections before acceptance) is **geometric** with success probability $\alpha_m$:

$$
\Pr[r_m=r]=(1-\alpha_m)^r\alpha_m,\qquad
\mathbb{E}[r_m]=\frac{1-\alpha_m}{\alpha_m},\qquad
r_{m,q}=\Bigl\lceil\frac{\ln(1-q)}{\ln(1-\alpha_m)}\Bigr\rceil-1.
$$

(These expressions underpin the validatorâ€™s corridor metrics; they are not computed in S2.4.)

---

## 5) Event coverage & ordering (binding evidence requirements)

Although S2.4 emits nothing, acceptance **requires** the following to exist for merchant $m$ (evidence checked later):

* $\ge 1$ `gamma_component` (context=`"nb"`) **and** $\ge 1$ `poisson_component` (context=`"nb"`) with matching envelope keys **preceding** the single `nb_final` (S2.5).
* Per attempt, exactly **two** component events in order: Gamma â†’ Poisson.
* `nb_final` is **non-consuming** (its envelope counters do **not** advance).

---

## 6) Determinism & invariants (MUST)

* **I-NB-A (bit replay).** For fixed inputs and lineage, the attempt sequence $(G_t,K_t)_{t\ge0}$, acceptance $(N_m,r_m)$, and the component event set are **bit-reproducible** across replays (Philox counters + fixed per-attempt cardinality + label-scoped substreams).
* **I-NB-B (consumption discipline).** Within each substream, envelope counter intervals are **non-overlapping** and **monotone**; `nb_final` later shows **before == after**. Exactly two component events per attempt; exactly one finalisation at acceptance.
* **I-NB-C (context correctness).** All S2 component events carry `context="nb"` (S4 uses `"ztp"`).

---

## 7) Outputs (to S2.5 and to the validator)

* **Hand-off to S2.5 (in-memory):** $(N_m,\ r_m)$ with $N_m\ge 2$. S2.5 will emit the **single** `nb_final` row echoing $\mu_m,\phi_m$ and recording `n_outlets=N_m`, `nb_rejections=r_m`.
* **Evidence for validation:** Component events as above; validator computes $\widehat{\rho}_{\text{rej}}$ (overall rejection rate), $\widehat{Q}_{0.99}$ (p99 of $r_m$), and a one-sided CUSUM trace. Breaches **abort the run** (no `_passed.flag`).

---

## 8) Failure semantics (merchant-scoped vs run-scoped)

* **Merchant-scoped numeric invalid** (should not arise here if S2.2/2.3 passed): non-finite or $\le0$ $\lambda_t$ â‡’ `ERR_S2_NUMERIC_INVALID` (skip merchant).
* **Structural/coverage failure** (run-scoped): Any `nb_final` without at least one prior `gamma_component` **and** one prior `poisson_component` with matching envelope keys; more than one `nb_final` for the same key; counter overlap/regression. Validators **abort** the run.
* **Corridor breach** (run-scoped): If overall rejection rate $>0.06$, or $p99(r_m)>3$, or the configured one-sided CUSUM gate trips, validators **abort** the run and persist metrics.

---

## 9) Reference pseudocode (language-agnostic; no RNG; no emissions)

```pseudo
# S2.4 rejection loop; S2.3 performs the draws and emits events.
# Returns (N >= 2, r = #rejections)

function s2_4_accept(mu, phi, merchant_id, lineage) -> (N, r):
    t := 0
    loop:
        # One attempt (S2.3): emits gamma_component then poisson_component
        (G, lambda, K) := s2_3_attempt_once(mu, phi, merchant_id, lineage)

        if K >= 2:
            N := K
            r := t
            return (N, r)                # S2.5 will emit nb_final(N, r, mu, phi)
        else:
            t := t + 1                   # rejection; continue loop
```

**Notes.** Attempt indices are not persisted; reconstructions **must** be by **counter intervals** per sub-stream
only (no reliance on time/file order). S2.4 itself **consumes 0 RNG**, writes **no** rows.

---

## 10) Conformance tests (KATs)

1. **Coverage & ordering.** For a sample merchant, use **envelope counter intervals only** to show a pair of `gamma_component`â†’`poisson_component` followed by **one** `nb_final`; reconstruct `r_m=a-1`; verify `nb_final.nb_rejections == r_m`.
2. **Numeric consistency.** For each attempt $t$, confirm `poisson_component.lambda == (Î¼/Ï†)*gamma_value` as binary64; for the accepted attempt, confirm `nb_final.n_outlets == k` from the corresponding Poisson event.
3. **Corridor metrics.** On a synthetic run, compute overall rejection rate and empirical p99; intentionally increase low-Î¼ merchants to trigger a breach and verify the validator aborts.

---

## 11) Complexity

Expected constant attempts (geometric). S2.4 adds **no** compute beyond control-flow; all cost is in S2.3â€™s samplers. Memory $O(1)$.

---

# S2.5 â€” Finalisation event `nb_final` (non-consuming, authoritative)

## 1) Scope & intent

Emit **one and only one** authoritative JSONL event per accepted multi-site merchant $m$ that records:

$$
\boxed{\,\mu_m>0,\ \phi_m>0,\ N_m\in\{2,3,\dots\},\ r_m\in\mathbb{N}_0\,}
$$

where $(\mu_m,\phi_m)$ come **verbatim** from S2.2 and $(N_m,r_m)$ from S2.4â€™s acceptance. This event is **non-consuming** (RNG counters unchanged) and is the sole persisted echo of S2â€™s accepted NB draw.

---

## 2) Inputs (MUST)

* From **S2.2**: $\mu_m$, $\phi_m$ as IEEE-754 binary64, both $>0$.
* From **S2.4**: $N_m \ge 2$, $r_m \ge 0$ (integers). S2.4 has already ensured acceptance $K\ge2$.
* **RNG envelope** (from S0 infra): `ts_utc, seed, parameter_hash, manifest_fingerprint, run_id, module, substream_label, rng_counter_before_{lo,hi}, rng_counter_after_{lo,hi}, blocks, draws`.
Types: `blocks` is **uint64**; `draws` is **"uint128-dec"** (decimal string).
For `nb_final`, **before == after** (non-consuming) â‡’ `blocks = 0`, `draws = "0"`.

---

## 3) Event stream & partitioning (normative)

Persist **exactly one row** per $(\texttt{seed},\texttt{parameter_hash},\texttt{run_id},\texttt{merchant_id})$ to:

```
logs/rng/events/nb_final/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl
```

* **Schema (authoritative):** `schemas.layer1.yaml#/rng/events/nb_final`.
* **Partitions:** `["seed","parameter_hash","run_id"]` (no other partition keys).
* **Stream status:** approved, retention 180 days, consumed by `validation`.

---

## 4) Payload (required fields & domains)

The event **MUST** carry the following payload (beyond the common envelope):

$$
\boxed{\ \{\ \texttt{merchant_id},\ \mu=\mu_m,\ \texttt{dispersion_k}=\phi_m,\ \texttt{n_outlets}=N_m,\ \texttt{nb_rejections}=r_m\ \}\ }.
$$

* `mu`, `dispersion_k`: **positive** binary64 scalars; must bit-match S2.2 outputs.
* `n_outlets`: signed 64-bit integer, **$\ge 2$**.
* `nb_rejections`: signed 64-bit integer, **$\ge 0$**.
* `context` is **not** present here (it exists on component streams); `module`/`substream_label` remain in the envelope for consistency, with **no** RNG consumption.

**Envelope constraint (non-consuming):** `rng_counter_before == rng_counter_after` (both 128-bit fields treated as a pair). The validator asserts this equality for **every** `nb_final` row.

---

## 5) Wire-format example (normative shape)

```json
{
    "ts_utc": "2025-08-15T13:22:19.000000Z",
    "seed": 42,
    "parameter_hash": "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
    "manifest_fingerprint": "fedcba9876543210fedcba9876543210fedcba9876543210fedcba9876543210",
    "run_id": "6e1f3a5b9d0c2e7f3d4a1b2c3e4f5a6b",
    "module": "1A.nb_sampler",
    "substream_label": "nb_final",
    "rng_counter_before_lo": 2,
    "rng_counter_before_hi": 0,
    "rng_counter_after_lo":  2,
    "rng_counter_after_hi":  0,
    "blocks": 0,
    "draws": "0",

    "merchant_id": "M12345",
    "mu": 7.0,
    "dispersion_k": 2.25,
    "n_outlets": 5,
    "nb_rejections": 1
}
```

* Schema anchor: `#/rng/events/nb_final`.
* Counters unchanged â†’ **non-consuming** evidence.

---

## 6) Determinism & invariants (MUST)

* **I-FINAL-ECHO.** `mu` and `dispersion_k` **exactly equal** the S2.2 values (binary64). Any mismatch is a structural consistency failure.
* **I-FINAL-ACCEPT.** `n_outlets == N_m` and `nb_rejections == r_m` from S2.4; there is **exactly one** `nb_final` per merchant key; no other NB events after finalisation.
* **I-FINAL-NONCONSUME.** `rng_counter_before == rng_counter_after` (non-consuming event).
* **I-FINAL-COVERAGE.** Presence of `nb_final` **implies** â‰¥1 prior `gamma_component` **and** â‰¥1 prior `poisson_component` with matching envelope keys and `context="nb"`; validator enforces coverage & cardinality.

---

## 7) Failure semantics

* **Schema violation** (missing/typed wrong fields, absent envelope) â‡’ `schema_violation` (row-level), run fails validation.
* **Coverage gap** (final with no prior NB components) â‡’ **structural failure**, run aborts.
* **Duplicate finals** for same key â‡’ **structural failure**; validator reports duplicates and aborts.
* **Non-consumption breach** (counters differ) â‡’ **structural failure**; nb_final must not advance Philox.

---

## 8) Writer algorithm (normative; no RNG; single emission)

```pseudo
# Inputs from S2.2 and S2.4:
#   mu>0 (binary64), phi>0 (binary64), N>=2 (int64), r>=0 (int64)
#   envelope with counters and lineage; counters must already be equal.

function s2_5_emit_nb_final(m, mu, phi, N, r, envelope):
    # 0) Domain checks
    if not (isfinite(mu) and mu > 0):        raise ERR_S2_NUMERIC_INVALID
    if not (isfinite(phi) and phi > 0):      raise ERR_S2_NUMERIC_INVALID
    if not (is_integer(N) and N >= 2):       raise ERR_S2_FINAL_INVALID_N
    if not (is_integer(r) and r >= 0):       raise ERR_S2_FINAL_INVALID_R

    # 1) Non-consuming proof
    if not counters_equal(envelope.before, envelope.after):
        raise ERR_S2_FINAL_CONSUMPTION_DRIFT

    # 2) Construct payload (echo Î¼, Ï† exactly; attach in-memory N, r)
    payload := {
        merchant_id: m,
        mu: mu, dispersion_k: phi,
        n_outlets: N, nb_rejections: r
    }

    # 3) Persist one JSONL row to the nb_final stream (dictionary path/partitions)
    emit_event(
        stream="nb_final", schema="#/rng/events/nb_final",
        partition_keys={seed, parameter_hash, run_id},
        envelope=envelope, payload=payload
    )

    # 4) Return (no further S2 emissions)
    return
```

* Emission count: **exactly one** per merchant; **no RNG draws** consumed.

---

## 9) Validator joins & downstream usage (binding)

* **Joins:** Validator left-joins `nb_final` to NB **component** streams by $(\texttt{seed},\texttt{parameter_hash},\texttt{run_id},\texttt{merchant_id})$ to (i) prove coverage/cardinality, (ii) verify $\lambda_t = (\mu/\phi)\cdot\texttt{gamma_value}$ per attempt, and (iii) compute corridors (overall rejection rate, $p_{99}(r_m)$, CUSUM). On any hard failure, the validation bundle is written **without** `_passed.flag`.
* **Hand-off:** $N_m,r_m$ continue **in-memory** to S3+; S2 writes **no** Parquet/Delta tables.

---

## 10) Conformance tests (KATs)

1. **Echo test.** For sampled merchants, recompute $\mu,\phi$ from S2.2 and assert `nb_final.mu` and `nb_final.dispersion_k` **bit-match**; fail run on mismatch.
2. **Non-consuming test.** Assert `rng_counter_before == rng_counter_after` in every `nb_final` row.
3. **Coverage & cardinality.** For every `nb_final`, assert â‰¥1 prior `gamma_component` and â‰¥1 prior `poisson_component` (`context="nb"`), and assert **exactly one** `nb_final` per key.
4. **Dictionary path test.** Ensure all `nb_final` rows appear **only** under the dictionary path/partitions & schema anchor.
5. **No side-effects.** Confirm S2 does **not** emit any Parquet data products; only the three JSONL streams exist (Gamma, Poisson, Final).

---

## 11) Complexity

O(1) time and memory per merchant (field checks + single JSONL write). No RNG, no retries.

---

# S2.6 â€” RNG substreams & consumption discipline (keyed mapping; budgeted/reconciled draws)

## 1) Scope & intent

Guarantee **bit-replay** and **auditability** of the NB sampler by fixing (i) which **Philox** sub-streams are used for each NB attempt component, (ii) how **counters** advance and are exposed, and (iii) what **evidence** is emitted so the validator can prove replay and detect any consumption drift. S2.6 itself draws **no** randomness; it **governs** how S2.3/S2.4/S2.5 consume and log it.

---

## 2) Inputs & label set (must)

* **Labels (NB):** `â„“_Î³ = "gamma_nb"`, `â„“_Ï€ = "poisson_nb"`. Exactly these two substreams are used by S2 attempts; `nb_final` is **non-consuming**.

    > **Legend (informative; mirrors registry & schemas)**
    >
    > | substream_label | producer `module` (registry)  | schema ref                       | partitions                     |
    > |-----------------|-------------------------------|----------------------------------|--------------------------------|
    > | `gamma_nb`      | `1A.nb_and_dirichlet_sampler` | `#/rng/events/gamma_component`   | `seed, parameter_hash, run_id` |
    > | `poisson_nb`    | `1A.nb_poisson_component`     | `#/rng/events/poisson_component` | `seed, parameter_hash, run_id` |
    > | `nb_final`      | `1A.nb_sampler`               | `#/rng/events/nb_final`          | `seed, parameter_hash, run_id` |
    >
    > *Note:* This table is a convenience only; authoritative semantics remain in S2 text + S0/S1 + schema/dictionary.
* **Schemas (authoritative):** `schemas.layer1.yaml#/rng/events/gamma_component`, `#/rng/events/poisson_component`, `#/rng/events/nb_final`. Each includes the **rng envelope** with pre/post 128-bit counters.
* **Dictionary paths/partitions:**

  * `logs/rng/events/poisson_component/...` (approved; `["seed","parameter_hash","run_id"]`),
  * `logs/rng/events/nb_final/...` (approved; same partitions).
    (Gamma stream path is pinned similarly; consumers/partitions mirror Poisson.)

**Trace duty (pointer):** After **each** RNG event append, emit **exactly one** cumulative `rng_trace_log` row (saturating totals) â€” same 'one trace row per event' duty as S4 Â§2A; see S4 Â§10.8 for the canonical wording.

---

## 3) Deterministic keyed mapping (normative)

All sub-streams are derived by the **S0.3.3 keyed mapping** from run lineage + label + merchant, order-invariant across partitions:

1. **Base counter for a (label, merchant)**
   *Where:* `m := merchant_u64` (**from S0.1 mapping**); `â„“` is the exact substream label literal.

    $$
    (c^{\mathrm{base}}_{\mathrm{hi}},c^{\mathrm{base}}_{\mathrm{lo}})
    =\mathrm{split64}\!\Big(\mathrm{SHA256}\big(\text{"ctr:1A"}\,\|\,\texttt{manifest_fingerprint_bytes}\,\|\,\mathrm{LE64}(\texttt{seed})\,\|\,\ell\,\|\,\mathrm{LE64}(m)\big)[0{:}16]\Big).
    $$

2. **b-th block** for that pair uses

    $$
    (c_{\mathrm{hi}},c_{\mathrm{lo}})=(c^{\mathrm{base}}_{\mathrm{hi}},\,c^{\mathrm{base}}_{\mathrm{lo}}+b),
    $$

    with 64-bit carry into $c_{\mathrm{hi}}$; this block yields two lanes $(x_0,x_1)$.
    **Single-uniform events** consume $x_0$ and **discard** $x_1$ ($\texttt{blocks}=1$, $\texttt{draws}="1"$);
    **two-uniform events** (e.g., Boxâ€“Muller) consume **both** $x_0,x_1$ from the **same** block
    ($\texttt{blocks}=1$, $\texttt{draws}="2"$). Mapping is **pure** in $(\texttt{seed},\texttt{fingerprint},\ell,m,b)$.

**Envelope arithmetic (per event):**

$$
\boxed{\texttt{blocks}\;:=\;u128(\texttt{after})-u128(\texttt{before})}
$$

in **unsigned 128-bit** arithmetic. The envelope **must** carry both:
`blocks` (**uint64**) and `draws` (decimal **uint128** string).
Here `draws` records the **actual count of U(0,1)** uniforms consumed by
the eventâ€™s sampler(s) and is **independent** of the counter delta.

Examples: Boxâ€“Muller â†’ `blocks=1`, `draws="2"`; single-uniform â†’ `blocks=1`,
`draws="1"`; non-consuming finaliser â†’ `blocks=0`, `draws="0"`.
---

## 4) Uniform & normal primitives (normative)

* **Open-interval uniform** (exclusive bounds):

$$
\boxed{\,u = ((x+1)\times 0x1.0000000000000p-64)\ \in (0,1)\,},\quad x\in\{0,\dots,2^{64}\!-\!1\}.
$$

The multiplier **must** be written as the **binary64 hex literal** `0x1.0000000000000p-64`
(no decimal substitutes).
**Clamp to strict open interval.** After computing `u`, perform:
`if u == 1.0: u := 0x1.fffffffffffffp-1` (i.e., $1-2^{-53}$).
This does not affect `blocks`/`draws`; it guarantees $u\in(0,1)$ in binary64.

**Lane policy.** A Philox **block** yields two 64-bit lanes `(x0,x1)` then advances by **1**.
* **Single-uniform events:** use `x0`, **discard** `x1` â†’ `blocks=1`, `draws="1"`.
* **Two-uniform events (e.g., Boxâ€“Muller):** use **both** `x0,x1` from the **same** block
â†’ `blocks=1`, `draws="2"`; **no caching** across events.

* **Standard normal** $Z$ via Boxâ€“Muller: exactly **2 uniforms per $Z$**; **no caching** of the sine deviate.

> **Scope rule:** All uniforms in S2 (Gamma & Poisson) **must** use this `u01`. Validators donâ€™t log uniforms but prove discipline via counters.

---

## 5) Event cardinality & ordering (attempt-level)

For attempt index $t=0,1,2,\dots$ of merchant $m$:

* Emit **exactly one** `gamma_component` on $\ell_\gamma$ **then** **exactly one** `poisson_component` on $\ell_\pi$.
* On acceptance (first $K_t\ge2$), emit **exactly one** `nb_final` (non-consuming).
  No other NB events are allowed for that merchant.

---

## 6) Draw budgets & reconciliation (normative)

For each `(module, substream_label)`, validators reconcile **two independent totals**:
`blocks_total = Î£ blocks_event` (which equals the streamâ€™s 128-bit counter span) and
`draws_total = Î£ draws_event` (which equals the uniforms implied by the sampler budgets).
No identity ties `draws` to the counter delta.
* **`gamma_component` (context="nb")**

  $$
  \text{draws}=\sum_t\big(2\,J_t + A_t + \mathbf{1}[\phi_m<1]\big),
  $$
  where the sum is over NB attempts $t$; $J_t\ge1$ is the number of MT1998 iterations for that variate, and $A_t$ counts those iterations with $V>0$ (only those draw the accept-$U$).

  **Rationale.** Each MT98 iteration consumes **2 uniforms** for the Boxâ€“Muller normal; it consumes **+1 uniform** only on iterations with $V>0$. If $0<\phi_m<1$, add **+1 uniform per variate** for the power step $U^{1/\alpha}$.
* **`poisson_component` (context="nb")**
  **Variable** (inversion for $\lambda<10$; PTRS otherwise). Envelope counters measure actual consumption; there is **no fixed budget**.
* **`nb_final`**
  **Non-consuming**: `before == after`; `draws = 0`. (Validator enforces.)

Additionally, a run may emit **`rng_trace_log`** rows (per `(module, substream_label)`) carrying cumulative counters for fast aggregation; validators reconcile `draws` by summing event budgets.

---

## 7) Counter discipline (interval semantics)

Within each $(m,\ell)$ stream, event intervals must be **non-overlapping and monotone**:

$$
[c^{(e)}_{\text{before}},c^{(e)}_{\text{after}}) \cap [c^{(e+1)}_{\text{before}},c^{(e+1)}_{\text{after}})=\varnothing,\quad
c^{(e+1)}_{\text{before}}\ge c^{(e)}_{\text{after}}.
$$

For `nb_final`, enforce **non-consumption** (`before == after`).

---

## 8) Validator contract (replay & discipline proof)

**Replay proof (per merchant):**

1. Collect all `gamma_component` and `poisson_component` rows for the key $(\texttt{seed},\texttt{parameter_hash},\texttt{run_id},\texttt{merchant_id})$. Enforce **monotone, non-overlapping** intervals per sub-stream.
2. Reconstruct attempt pairs (Gammaâ†’Poisson) **solely by counter intervals**:
   per merchant, sort each substream strictly by `rng_counter_before` (lexicographic on
   `(before_hi,before_lo)`), then pair the *t*-th Gamma with the *t*-th Poisson subject to
   `u128(before)_Î“[t] < u128(after)_Î“[t] â‰¤ u128(before)_Î [t] < u128(after)_Î [t]`.
   **No reliance on time/file order.** Derive the first $t$ with $K_t\ge2$.
3. Join to the single `nb_final`; assert `n_outlets` and `nb_rejections` match the reconstruction; assert `mu, dispersion_k` **echo** S2.2. **Pass iff identical.**

**Discipline checks (hard):**

* **Cardinality:** exactly 1 Gamma and 1 Poisson per attempt; exactly 1 `nb_final` per merchant key.
* **Budgets:** Gamma draw totals equal $\sum_t \big(2\,J_t + A_t + \mathbf{1}[\phi_m<1]\big)$; Poisson totals reconcile by counters; `nb_final` has `draws=0`.
* **Coverage:** if `nb_final` exists, there is â‰¥1 `gamma_component` **and** â‰¥1 `poisson_component` with `context="nb"` and matching envelopes.

---

## 9) Failure semantics (run-scoped unless noted)

* **Structural/counter failure** (overlap, non-monotone, or `nb_final` consumption) â‡’ validator **aborts** the run; bundle is written without `_passed.flag`.
* **Schema/coverage/cardinality failure** (missing envelope fields; missing component event; duplicate `nb_final`) â‡’ **abort**.
* **Corridor breach** (overall NB rejection rate or p99 gate trippedâ€”defined in S2.4/S2.7) â‡’ **abort** with metrics; out of scope of S2.6 but enforced in the same validation pass.

---

## 10) Reference implementation pattern (non-allocating; per merchant)

```pseudo
# Substream state (derived, not stored):
# base_gamma, base_pois: (hi, lo) from S0.3.3; i_gamma, i_pois: u64 counters (block index)
struct Substream {
  base_hi: u64; base_lo: u64; i: u128
}

function substream_begin(s: Substream) -> (before_hi, before_lo):
    return add128((s.base_hi, s.base_lo), s.i)   # 128-bit

function substream_end(s: Substream, blocks: u128) -> (after_hi, after_lo):
    return add128((s.base_hi, s.base_lo), s.i + blocks)

# Each Philox block yields two 64-bit lanes (x0,x1); s.i advances by **1 block** per call.
# Single-uniform events use the **low lane** and **discard** the high lane; two-uniform families use **both lanes from one block**.

# Map lane to u in (0,1) using the hex-float multiplier (Crit #5).
function u01_map(x: u64) -> f64:
    u = ((x + 1) * 0x1.0000000000000p-64)
    if u == 1.0:
        u = 0x1.fffffffffffffp-1
    return u

# Advance by **one block**, return both lanes.
function philox_block(s: inout Substream) -> (x0:u64, x1:u64):
    ctr = add128((s.base_hi, s.base_lo), s.i)
    (x0, x1) = philox64x2(ctr)
    s.i += 1
    return (x0, x1)

# Two uniforms from **one** block (e.g., Boxâ€“Muller).
function u01_pair(s: inout Substream) -> (u0:f64, u1:f64, blocks_used:u128, draws_used:u128):
    (x0, x1) = philox_block(s)                   # consumes 1 block
    return (u01_map(x0), u01_map(x1), 1, 2)     # blocks=1, draws=2

# Single uniform: use **low lane** from a fresh block; **discard** the high lane.
function u01_single(s: inout Substream) -> (u:f64, blocks_used:u128, draws_used:u128):
    (x0, _x1) = philox_block(s)                  # consumes 1 block; high lane discarded
    return (u01_map(x0), 1, 1)                   # blocks=1, draws=1

# Event emission for Gamma component (per attempt):
# The sampler returns actual budgets; the emitter stamps counters independently.
function emit_gamma_component(ctx, s_gamma: inout Substream, alpha_phi: f64):
    (before_hi, before_lo) = substream_begin(s_gamma)
    (G, blocks_used, draws_used) = gamma_mt98_with_budget(alpha_phi, s_gamma)  # uses u01_single/u01_pair internally
    (after_hi,  after_lo)  = substream_end(s_gamma, blocks_used)
    assert u128((after_hi,after_lo)) - u128((before_hi,before_lo)) == blocks_used
    write_jsonl("gamma_component",
        envelope={
          ...,
          "rng_counter_before_lo": before_lo, "rng_counter_before_hi": before_hi,
          "rng_counter_after_lo":  after_lo,  "rng_counter_after_hi":  after_hi,
          "blocks": blocks_used, "draws": stringify_u128(draws_used),
          "substream_label": "gamma_nb"
        },
        payload={ merchant_id, context:"nb", index:0, alpha:alpha_phi, gamma_value:G }
    )

# Poisson component is analogous, using its samplerâ€™s (blocks_used, draws_used) and payload {lambda, k, attempt:intâ‰¥1}.
# nb_final is non-consuming: before == after, blocks=0, draws="0".
```

**Notes.**
- The samplers do **not** see counters; they only call `u01(s)`; the event writer collects `draws_used` and stamps the envelope.
- For Gamma with $\phi_m < 1$, add **one** `u01(s_gamma)` for the $U^{1/\alpha}$ power step **per variate (i.e., per attempt)**, not once per merchant. Hence the total budget aggregates as **$\sum_t \big( 2 J_t + A_t + \mathbf{1}[\phi_m < 1] \big)$**, where $A_t$ counts iterations with $V>0$.

---

## 11) Invariants (MUST)

* **I-NB1 (bit replay).** Fixed inputs + S0 mapping â‡’ the sequence $(G_t,K_t)_{t\ge0}$ and the accepted pair $(N_m,r_m)$ are **bit-identical** across replays.
* **I-NB3 (open-interval).** All uniforms satisfy $u\in(0,1)$.
* **I-NB4 (consumption).** Exactly two component events per attempt; one `nb_final`; downstream counters match the trace; `nb_final` non-consuming.

---

## 12) Conformance tests (KATs)

1. **Budget check (Gamma).** Reconstruct $J_t$ and $A_t$ by **bit-replay** of the MT1998 loop; assert `Î£ draws(gamma_component) == Î£_t (2Â·J_t + A_t)`; if $0<\phi<1$, assert `== Î£_t (2Â·J_t + A_t + 1)`.
2. **Variable Poisson.** Choose $\lambda=5$ (inversion) and $\lambda=50$ (PTRS); verify envelope deltas are positive, monotone, and **not** fixed.
3. **Non-consumption final.** Every `nb_final` has `before == after`.
4. **Interval discipline.** Per $(m,\ell)$, counters are **non-overlapping** and **monotone**; reconstruct attempts (Gammaâ†’Poisson) then join to `nb_final`; fail on any deviation.
5. **Coverage.** If a `nb_final` exists, assert presence of â‰¥1 prior Gamma and â‰¥1 prior Poisson with `context="nb"`.

---

## 13) Complexity

* **Runtime:** negligible overhead beyond sampler draws (constant-time arithmetic + one JSONL write per event).
* **Memory:** $O(1)$ per merchant (two sub-streams with 128-bit indices).

---

# S2.7 â€” Monitoring corridors & thresholds (run gate)

## 1) Scope & intent

Compute run-level statistics of the S2 rejection process and **abort the run** if any corridor is breached. Corridors cover:

* the **overall rejection rate** across all attempts,
* the **99th percentile** of per-merchant rejections $r_m$,
* a **one-sided CUSUM** detector for upward drift in rejections relative to model-expected behaviour.

**This step consumes no RNG, writes no NB events, and is evaluated by validation** immediately after S2 completes (it may persist its own validation bundle/metrics as per your validation harness; persistence details live in the validation spec).

---

## 2) Inclusion criteria (MUST)

Only merchants with a **valid S2 finalisation** are included. Formally, define the set

$$
\mathcal{M}=\{\,m:\ \text{exactly one } \texttt{nb_final}\ \text{exists for }m\ \text{and coverage tests pass}\,\}.
$$

For each $m\in\mathcal{M}$, read from `nb_final`:

* $r_m = \texttt{nb_rejections}\in\mathbb{N}_0$,
* $N_m=\texttt{n_outlets}\in\{2,3,\dots\}$.

Merchants without `nb_final` (e.g., numeric aborts in S2.2/2.3) are **excluded** from corridor statistics but counted under separate health metrics (not part of the corridors). Coverage must already have verified â‰¥1 `gamma_component` and â‰¥1 `poisson_component` (context=`"nb"`) for each `nb_final`.

---

## 3) Per-merchant acceptance parameter $\alpha_m$ (used by CUSUM)

For each $m\in\mathcal{M}$, compute the **model-predicted** attempt acceptance probability $\alpha_m$ from the S2.2 parameters $(\mu_m,\phi_m)$ (binary64):

Let

$$
p_m=\frac{\phi_m}{\mu_m+\phi_m},\quad
q_m=1-p_m=\frac{\mu_m}{\mu_m+\phi_m}.
$$

Then the NB2 probabilities for $K=0$ and $K=1$ are

$$
P_0 = p_m^{\phi_m},\qquad
P_1 = \phi_m\,q_m\,p_m^{\phi_m}.
$$

Define

$$
\boxed{\ \alpha_m=1-P_0-P_1\ } \quad\text{(success = accept on an attempt)}.
$$

### 3.1 Numerically stable evaluation (MUST)

Evaluate in **binary64** with log-domain guards:

* $\log p_m=\log\phi_m-\log(\mu_m+\phi_m)$.
* $\log P_0=\phi_m\log p_m$; $P_0=\exp(\log P_0)$.
* $P_1 = P_0 \cdot \phi_m \cdot q_m$ (re-use $P_0$ to avoid an extra exponentiation).
* $\alpha_m = 1 - P_0 - P_1$.

**Guards:**

* If any intermediate is non-finite, or if $\alpha_m\notin(0,1]$, the merchant is flagged `ERR_S2_CORRIDOR_ALPHA_INVALID` and **excluded** from corridor statistics (still recorded under health metrics). This should not occur if S2.2 guards held; making it explicit keeps the corridor math well-posed.

---

## 4) Corridor metrics (normative)

Let $a_m = r_m+1$ be the total attempts for merchant $m$. Define $M=|\mathcal{M}|$ and totals

$$
R=\sum_{m\in\mathcal{M}} r_m,\qquad
A=\sum_{m\in\mathcal{M}} a_m = \sum_{m\in\mathcal{M}} (r_m+1).
$$

### 4.1 Overall rejection rate $\widehat{\rho}_{\text{rej}}$

$$
\boxed{\ \widehat{\rho}_{\text{rej}} = \frac{R}{A}\ } \in [0,1).
$$

Equivalently, $\widehat{\rho}_{\text{rej}} = 1 - M/A$. **MUST** be computed exactly as above (attempt-weighted).

**Threshold (hard):** $\widehat{\rho}_{\text{rej}} \le 0.06$. Exceedance â‡’ run fails.

### 4.2 99th percentile of rejections $Q_{0.99}$

Let $r_{(1)}\le \dots \le r_{(M)}$ be the ascending order. Use **nearest-rank** quantile (normative):

$$
\boxed{\ Q_{0.99} = r_{(\lceil 0.99\,M\rceil)}\ }.
$$

**Threshold (hard):** $Q_{0.99} \le 3$. Exceedance â‡’ run fails.

**Notes:**

* If $M=0$ (no merchants reached S2 final), corridors are **not evaluable**: return `ERR_S2_CORRIDOR_EMPTY` and fail the run (no evidence to assert health).
* For $M<100$, nearest-rank is still well-defined; this is intentional for determinism.

### 4.3 One-sided CUSUM for upward drift (standardised residuals)

We monitor the sequence $\{r_m\}_{m\in\mathcal{M}}$ ordered by **merchant key** (deterministic total order; e.g., ascending `merchant_id`). For each $m$, form a standardised residual against the geometric expectation implied by $\alpha_m$:

$$
\mathbb{E}[r_m] = \frac{1-\alpha_m}{\alpha_m},\qquad
\mathrm{Var}(r_m) = \frac{1-\alpha_m}{\alpha_m^2}.
$$

Define

$$
z_m = \frac{r_m - \mathbb{E}[r_m]}{\sqrt{\mathrm{Var}(r_m)}}.
$$

Let the **one-sided positive CUSUM** be

$$
S_0=0,\qquad S_t=\max\{0,\ S_{t-1} + (z_{m_t} - k)\},\quad t=1,\dots,M,
$$

with **reference value** $k>0$ and **threshold** $h>0$.

**Gate (hard):** If $\max_{1\le t\le M} S_t \ge h$ â‡’ run fails.

**Governance of $k,h$:** These are **policy parameters** (not algorithmic constants). They MUST be supplied by the validation policy artefact for the run (e.g., `validation_policy.yaml`):
`cusum.reference_k` (default 0.5), `cusum.threshold_h` (default 8.0). If absent, validation must **fail closed** (`ERR_S2_CORRIDOR_POLICY_MISSING`).

**Notes:**

* Using standardised $z_m$ accounts for heterogeneity in $\alpha_m$ across merchants.
* CUSUM is computed **once** per run over the ordered merchant sequence; there is no windowing in this spec.

---

## 5) Pass/fail logic (normative)

Compute the three statistics. The run **passes the S2 corridors** iff **all** hold:

1. $\widehat{\rho}_{\text{rej}} \le 0.06$,
2. $Q_{0.99} \le 3$,
3. $\max S_t < h$.

Else, the run **fails**: the validator **must not** write `_passed.flag` for this fingerprint; it must persist a metrics object (see Â§8) documenting the breach(es).

---

## 6) Numerical & data handling requirements (MUST)

* All computations are **binary64**; no integer overflow risks since $r_m$ are small.
* Sorting uses **bytewise ascending** on the merchant key (deterministic).
* Duplicate `nb_final` rows for the same key â‡’ structural failure upstream; corridors are not computed until structure is clean.
* Exclusions: merchants with invalid $\alpha_m$ (see Â§3.1) are **not** in $\mathcal{M}$ for corridor stats; they are reported separately.

---

## 7) Errors & abort semantics

* `ERR_S2_CORRIDOR_EMPTY` â€” $M=0$; corridors not evaluable. â‡’ **Fail run**.
* `ERR_S2_CORRIDOR_POLICY_MISSING` â€” missing $k,h$ in policy. â‡’ **Fail run**.
* `ERR_S2_CORRIDOR_ALPHA_INVALID:{m}` â€” bad $\alpha_m$ for merchant `m`; merchant is excluded; proceed if $M>0$.
* **Breach** of any corridor â‡’ **Fail run** with `reason âˆˆ {"rho_rej","p99","cusum"}` (multi-reason allowed).

---

## 8) Validator algorithm (reference; no RNG; O(M log M))

```pseudo
function s2_7_corridors(nb_finals, policy) -> Result:
    # nb_finals: iterable of records with {merchant_id, mu, phi, n_outlets, nb_rejections}
    # policy: { cusum: { reference_k: f64, threshold_h: f64 } }

    if policy.cusum is None: return FAIL(ERR_S2_CORRIDOR_POLICY_MISSING)

    # 1) Construct inclusion set with Î±_m
    Mset := []
    for row in nb_finals:
        m  := row.merchant_id
        r  := int64(row.nb_rejections)
        mu := f64(row.mu);  phi := f64(row.dispersion_k)
        # Î±_m from Î¼, Ï† (binary64), numerically stable
        p  := phi / (mu + phi)
        logP0 := phi * log(p)         # phi>0, pâˆˆ(0,1)
        P0 := exp(logP0)
        q  := 1.0 - p
        P1 := P0 * phi * q
        alpha := 1.0 - P0 - P1
        if not isfinite(alpha) or alpha <= 0.0 or alpha > 1.0:
            record_warn(ERR_S2_CORRIDOR_ALPHA_INVALID, m)
            continue
        Mset.append({m, r, alpha})

    M := len(Mset)
    if M == 0: return FAIL(ERR_S2_CORRIDOR_EMPTY)

    # 2) Overall rejection rate
    R := sum(r for each in Mset)
    A := sum(r + 1 for each in Mset)
    rho_hat := R / A

    # 3) p99 of r_m (nearest-rank)
    r_sorted := sort([r for each in Mset])           # ascending
    idx := ceil(0.99 * M)
    p99 := r_sorted[idx - 1]                         # 1-based to 0-based

    # 4) One-sided CUSUM over standardised residuals
    k := policy.cusum.reference_k     # e.g., 0.5
    h := policy.cusum.threshold_h     # e.g., 8.0
    Ms := sort(Mset by merchant_id bytes ascending)
    S := 0.0; Smax := 0.0
    for each in Ms:
        alpha := each.alpha; r := each.r
        Er := (1.0 - alpha) / alpha
        Vr := (1.0 - alpha) / (alpha * alpha)
        z  := (r - Er) / sqrt(Vr)
        S  := max(0.0, S + (z - k))
        Smax := max(Smax, S)

    # 5) Decide
    breaches := []
    if rho_hat > 0.06: breaches.append("rho_rej")
    if p99 > 3:        breaches.append("p99")
    if Smax >= h:      breaches.append("cusum")

    if breaches is empty:
        return PASS({rho_hat, p99, Smax, M, R, A})
    else:
        return FAIL({rho_hat, p99, Smax, M, R, A, breaches})
```

**Complexity:** $O(M\log M)$ due to sorting; memory $O(M)$.

---

## 9) Invariants & evidence (MUST)

* **I-S2.7-ATTEMPT:** $A=\sum_m (r_m+1)$ equals the **total count of Poisson component events** across all S2 merchants; validator **must** reconcile these tallies (attempt-weighted rate correctness).
* **I-S2.7-ECHO:** For every $m$, the `nb_final`â€™s `mu`/`dispersion_k` match S2.2; `n_outlets` matches acceptance in S2.4; these are preconditions for inclusion.
* **I-S2.7-ORDER:** CUSUM ordering uses a deterministic total order on merchant keys (bytewise asc.); the order MUST be recorded in the bundle to ensure reproducibility of $S_{\max}$.

---

## 10) Conformance tests (KATs)

**Determinism.**

1. Shuffle the input `nb_final` rows: $\widehat{\rho}_{\text{rej}}$ and $Q_{0.99}$ unchanged; $S_{\max}$ unchanged **iff** the order reconstruction is the same â€” hence the order is explicitly defined as merchant key bytes ascending.

**Threshold triggers.**
2. Synthetic dataset with $r_m=0$ for all $m$: expect $\widehat{\rho}_{\text{rej}}=0$, $Q_{0.99}=0$, $S_{\max}=0$ â‡’ **pass**.
3. Inject 7% of attempts as rejections uniformly (increase many $r_m$ by 1): expect $\widehat{\rho}_{\text{rej}}>0.06$ â‡’ **fail** with breach `rho_rej`.
4. Make $1\%$ of merchants have $r_m=4$ and the rest â‰¤3: expect $Q_{0.99}=4$ â‡’ **fail** with breach `p99`.
5. Create a drift scenario: progressively inflate $r_m$ above $\mathbb{E}[r_m]$ late in the ordered sequence so that $S_{\max}\ge h$ â‡’ **fail** with breach `cusum`.

**Numerical guard.**
6. Force extreme $\mu$/$\phi$ to yield $\alpha$ near 0 or 1; verify computation remains finite; if not, those merchants are excluded and flagged `ERR_S2_CORRIDOR_ALPHA_INVALID`, but run proceeds if $M>0$.

---

## 11) Outputs

* **Pass:** Return metrics `{rho_hat, p99, Smax, M, R, A}`; the overall validation may then stamp `_passed.flag` (outside this section).
* **Fail:** Return metrics + `breaches`; the overall validation **must not** stamp `_passed.flag` and must surface the reasons.

---

# S2.8 â€” Failure modes (abort semantics, evidence, actions)

## 1) Scope & intent

Define **all** conditions under which the S2 NB sampler (multi-site outlet count) must **abort** (merchant-scoped) or **fail validation** (run-scoped), and the **exact evidence** required to prove and diagnose each failure. This section binds to:

* S2.1 (entry gate, inputs), S2.2 (NB2 links), S2.3 (Gamma/Poisson samplers), S2.4 (rejection loop), S2.5 (finalisation), S2.6 (RNG discipline), S2.7 (corridors).

**Authoritative streams & schema anchors** (must be used by validator):
`logs/rng/events/gamma_component/â€¦  #/rng/events/gamma_component`
`logs/rng/events/poisson_component/â€¦  #/rng/events/poisson_component`
`logs/rng/events/nb_final/â€¦  #/rng/events/nb_final`  (all partitioned by `["seed","parameter_hash","run_id"]`).

---

## 2) Error classes, codes, and actions (normative)

We categorize failures as **merchant-scoped aborts** (S2 stops for that merchant; no further S2 output) and **run-scoped validation fails** (the validator **aborts the run** and does not write `_passed.flag`).

### A) Merchant-scoped aborts (during S2 execution)

**F-S2.1 â€” Non-finite / non-positive NB2 parameters** (S2.2)
**Condition.** $\mu_m\le 0$ or $\phi_m\le 0$, or either linear predictor/exponential is NaN/Inf in binary64.
**Code.** `ERR_S2_NUMERIC_INVALID`.
**Action.** **Abort S2 for m**; **no** S2.3 events should be emitted for that merchant.
**Evidence.** Validator recomputes $(\mu_m,\phi_m)$ from S2.1 inputs + governed artefacts (by `parameter_hash`) and flags `invalid_nb_parameters(m)`.

**F-S2.2 â€” Sampler numeric invalid** (S2.3)
**Condition.** `gamma_component.alpha â‰¤ 0` or `gamma_value â‰¤ 0`, or `poisson_component.lambda â‰¤ 0` / non-finite. (Should not occur if S2.2 passed.)
**Code.** `ERR_S2_SAMPLER_NUMERIC_INVALID`.
**Action.** **Row-level schema failure** â†’ merchant effectively fails; validator will abort the run (see C-class).
**Evidence.** Offending JSONL row fails `schemas.layer1.yaml` numeric/domain checks.

**F-S2.0 â€” Entry gate violations** (S2.1)
**Condition.** Missing S1 hurdle record or `is_multi=false` attempting to enter S2.
**Code.** `ERR_S2_ENTRY_MISSING_HURDLE` / `ERR_S2_ENTRY_NOT_MULTI`.
**Action.** **Skip S2** for the merchant; any S2 events later will be caught as structural (D-class).
**Evidence.** Hurdle stream is authoritative gate for S2.

### B) Run-scoped schema/structure/discipline failures (validator)

**C-S2.3 â€” Schema violation (any S2 event)**
**Condition.** Missing envelope fields; missing required payload keys; wrong `context` (`"nb"` required for Gamma/Poisson; `nb_final` has **no** `context` field); bad domains (e.g., `k<0`).
**Action.** **Hard schema failure** â†’ **abort run**.
**Evidence.** Per-row schema checks on the three streams.

**C-S2.4 â€” Coverage & cardinality gap**
**Condition.** Any `nb_final` **without** at least one prior `gamma_component` **and** one prior `poisson_component` (both with `context="nb"`), or **duplicate** `nb_final` for the same `(seed, parameter_hash, run_id, merchant_id)`.
**Action.** **Structural failure** â†’ **abort run**.
**Evidence.** Coverage join across the three streams indicates absence/duplication.

**C-S2.5 â€” Consumption discipline breach** (S2.6 invariants)
**Condition.** Any of: `after < before`; overlapping intervals within a sub-stream; `nb_final` advances counters (`beforeâ‰ after`); per-attempt cardinality differs from **exactly one** Gamma + **exactly one** Poisson.
**Action.** **Structural failure** â†’ **abort run**.
**Evidence.** Envelope counter scans on Gamma/Poisson/Final prove the violation.

**C-S2.6 â€” Composition mismatch (Gammaâ†’Poisson)**
**Condition.** For attempt $t$:

$$
\lambda_t \stackrel{!}{=} (\mu/\phi)\cdot \texttt{gamma_value}_t
$$

with `mu, dispersion_k` taken from `nb_final`; mismatch under strict binary64 equality (or 1-ULP, per policy).
**Action.** **Consistency failure** â†’ **abort run**.
**Evidence.** Validator pairs attempts by counters/time and checks equality.

**C-S2.8 â€” Partition/path misuse**
**Condition.** Any S2 event written outside its dictionary path or missing required partitions `["seed","parameter_hash","run_id"]`.
**Action.** **Structural failure** â†’ **abort run**.
**Evidence.** Dictionary path/partition check.

**C-S2.9 â€” Single-site hygiene breach (branch purity)**
**Condition.** A merchant with S1 `is_multi=0` has **any** S2 NB event.
**Action.** **Structural failure** â†’ **abort run**.
**Evidence.** Cross-check hurdle stream vs S2 streams; hurdle is authoritative first RNG stream.

### C) Run-scoped corridor failures (validator, S2.7)

**D-S2.7 â€” Corridor breach**
**Condition.** Any of: overall rejection rate $\widehat{\rho}_{\text{rej}}>0.06$; p99 of $r_m$ exceeds 3; one-sided CUSUM exceeds threshold $h$ (policy).
**Action.** **Validation abort** â†’ **no** `_passed.flag`; metrics & plots in bundle.
**Evidence.** `metrics.csv` + CUSUM trace in the validation bundle.

---

## 3) Consolidated error code table (normative)

| Code                                | Scope     | Trigger                                                     | Detection locus               | Action          |
|-------------------------------------|-----------|-------------------------------------------------------------|-------------------------------|-----------------|
| `ERR_S2_ENTRY_MISSING_HURDLE`       | merchant  | no hurdle record for $m$                                    | S2.1                          | skip S2 for $m$ |
| `ERR_S2_ENTRY_NOT_MULTI`            | merchant  | hurdle `is_multi=false`                                     | S2.1                          | skip S2 for $m$ |
| `ERR_S2_NUMERIC_INVALID`            | merchant  | $\mu\le0$ or $\phi\le0$ or NaN/Inf                          | S2.2 (+defensive in S2.3/2.5) | abort $m$       |
| `ERR_S2_SAMPLER_NUMERIC_INVALID`    | run (row) | gamma/poisson numeric domains violated                      | Validator (schema)            | abort run       |
| `schema_violation`                  | run (row) | envelope/payload/context missing/invalid                    | Validator                     | abort run       |
| `event_coverage_gap`                | run       | `nb_final` lacks prior Gamma & Poisson; or duplicate finals | Validator                     | abort run       |
| `rng_consumption_violation`         | run       | counter overlap/regression; `nb_final` consumes             | Validator                     | abort run       |
| `composition_mismatch`              | run       | $\lambda\neq (\mu/\phi)\cdot \texttt{gamma_value}$          | Validator                     | abort run       |
| `partition_misuse`                  | run       | wrong path/partitions                                       | Validator                     | abort run       |
| `branch_purity_violation`           | run       | single-site merchant has S2 events                          | Validator                     | abort run       |
| `corridor_breach:{rho\|p99\|cusum}` | run       | corridor thresholds trip                                    | Validator                     | abort run       |

---

## 4) Detection loci and evidence (binding)

1. **During S2** (writer-side, merchant-scoped): S2.2/S2.3/S2.5 must **raise** their errors and **avoid emitting** downstream S2 events for the merchant. (No partial S2 trails.)
2. **After S2** (validator): perform, at minimum, the following checks in orderâ€”schema, coverage/cardinality, counter discipline, composition, corridors, path partitions, branch purity. A failure in **any** step â‡’ run fails; bundle still written without `_passed.flag`.

---

## 5) Validator reference algorithm (S2 failure screening; O(N log N))

A minimal but normative checklist appears below (expands your draft into an enforceable pass/fail).

```pseudo
function validate_S2(nb_gamma, nb_pois, nb_final, hurdle, dictionary, policy):
    # 0) Schema & path/partition checks for all three S2 streams
    for row in nb_gamma: schema_check(row, "#/rng/events/gamma_component")
    for row in nb_pois:  schema_check(row, "#/rng/events/poisson_component")
    for row in nb_final: schema_check(row, "#/rng/events/nb_final")
    assert_dictionary_paths_partitions({nb_gamma, nb_pois, nb_final})
    # 1) Branch purity: any S2 event for is_multi=0 => branch_purity_violation
    assert_branch_purity(hurdle, {nb_gamma, nb_pois, nb_final})
    # 2) By (seed, parameter_hash, run_id, merchant_id):
    for key in keys:
        A := nb_gamma[key]; B := nb_pois[key]; F := nb_final[key]
        # coverage/cardinality
        assert ((len(A)>=1 && len(B)>=1 && len(F)==1) or merchant_is_not_multi(key))
        # counters: monotone intervals; nb_final non-consuming
        assert_counters_monotone(A); assert_counters_monotone(B); assert_final_nonconsuming(F)
        # parameter echo & composition
        (mu,phi) := (F[0].mu, F[0].dispersion_k)
        for a in A: assert_ulps_equal(a.alpha, phi, 1)
        pairwise_by_counter_intervals(A, B, (a, b) => assert_ulps_equal(b.lambda, (mu/phi)*a.gamma_value, 1))
        # acceptance reconstruction
        t := first i with B[i].k >= 2
        assert t exists && F[0].n_outlets == B[t].k && F[0].nb_rejections == t
    # 3) Corridors (S2.7)
    (rho_hat, p99, Smax) := corridors(nb_final, policy)
    assert rho_hat <= 0.06 && p99 <= 3 && Smax < policy.cusum.threshold_h
```

**Fail fast:** Any violated assertion returns a typed failure with the corresponding code in Â§3.

---

## 6) Invariants (re-stated as validator obligations)

* **I-NB2 echo.** `nb_final.mu`/`dispersion_k` must **equal** S2.2 outputs (binary64).
* **Coverage invariant.** If `nb_final` exists, there must be â‰¥1 prior Gamma and â‰¥1 prior Poisson (`context="nb"`) with matching envelope keys.
* **Consumption discipline.** Exactly two component events/attempt; `nb_final` non-consuming; counters monotone, non-overlapping.

---

## 7) Conformance tests (KATs)

1. **Parameter invalid KAT.** Force $\eta$ to overflow/underflow so $\mu$ or $\phi$ becomes non-finite or $\le0$ â‡’ writer raises `ERR_S2_NUMERIC_INVALID`; validator shows **no** S2 events for that merchant and flags `invalid_nb_parameters`.
2. **Schema KAT.** Drop `context` in a Gamma row â‡’ schema failure; run aborts with `schema_violation`.
3. **Coverage KAT.** Emit `nb_final` without a Poisson component â‡’ `event_coverage_gap` and abort.
4. **Counters KAT.** Make `nb_final` advance counters â‡’ `rng_consumption_violation` and abort.
5. **Composition KAT.** Perturb `lambda` by 1 ULP â‡’ `composition_mismatch` and abort.
6. **Partitions KAT.** Write Poisson to a wrong path or missing `parameter_hash` partition â‡’ `partition_misuse` and abort.
7. **Branch purity KAT.** Create S2 events for a known `is_multi=0` merchant â‡’ `branch_purity_violation`.
8. **Corridors KAT.** Inflate low-$\mu$ merchants to push $\widehat{\rho}_{\text{rej}}>0.06$ â‡’ `corridor_breach:rho`.

---

## 8) Run outcome & artifacts

* **Any single hard failure** causes the S2 block to **fail validation**, so **1A fails** for that `manifest_fingerprint`. The validator still writes a **bundle** to
  `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`
  containing: `index.json`, `schema_checks.json`, `rng_accounting.json`, `metrics.csv`, diffs; `_passed.flag` is **omitted**. 1Aâ†’1B hand-off is **disallowed** until fixed.

---

## 9) Practical guidance (non-normative but recommended)

* Treat schema failures and counter violations as **CI blockers**â€”catch them on small test shards.
* Keep a **golden KAT suite** exercising each failure class (Â§7) with tiny fixtures.
* When corridor breaches occur, surface **Î±-diagnostics** (expected attempts from $\alpha_m$) to highlight modelling drift vs. data shift.

---

# S2.9 â€” Outputs (state boundary) & hand-off to S3

## 1) Scope & intent (normative)

S2 closes by (i) **persisting only the authoritative RNG event streams** for the NB sampler and (ii) exporting the accepted domestic outlet count $N_m$ (and rejection tally $r_m$) **in-memory** to S3. **No Parquet data product** is written by S2. All persistence is via three JSONL **event** streams defined in the dictionary and validated against canonical schema anchors.

---

## 2) Persisted outputs (authoritative RNG event streams)

Write **exactly** these streams, **partitioned** by `["seed","parameter_hash","run_id"]`, with the indicated **schema refs**. Cardinalities are **hard** contracts:

1. **Gamma components (NB mixture)**
   Path: `logs/rng/events/gamma_component/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
   Schema: `schemas.layer1.yaml#/rng/events/gamma_component`
   Cardinality per multi-site merchant: **â‰¥ 1** (one row **per attempt**).

2. **Poisson components (NB mixture)**
   Path: `logs/rng/events/poisson_component/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
   Schema: `schemas.layer1.yaml#/rng/events/poisson_component`
   Cardinality: **â‰¥ 1** (one row **per attempt**). (This stream id is **reused by S4** with a different `context`, hence the dictionary description `NB composition / ZTP`.)

3. **NB final (accepted outcome)**
   Path: `logs/rng/events/nb_final/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
   Schema: `schemas.layer1.yaml#/rng/events/nb_final`
   Cardinality: **exactly 1** row **per merchant** (echoes `mu`, `dispersion_k`, `n_outlets`, `nb_rejections`).

**Envelope (must on every row).** `ts_utc, seed, parameter_hash, manifest_fingerprint, run_id, module, substream_label, rng_counter_before_lo, rng_counter_before_hi, rng_counter_after_lo, rng_counter_after_hi, blocks (uint64), draws ("uint128-dec")`. (`nb_final` is **non-consuming**: `before == after`, so `blocks=0`, `draws="0"`.)

**Payload (must).**

* `gamma_component`: `{ merchant_id, context="nb", index=0, alpha=Ï†_m, gamma_value }`.
* `poisson_component`: `{ merchant_id, context="nb", lambda, k, attempt:intâ‰¥1 }`.
* `nb_final`: `{ merchant_id, mu=Î¼_m, dispersion_k=Ï†_m, n_outlets=N_m, nb_rejections=r_m }`.
  Types & domains per schema (positivity for `mu`,`dispersion_k`; `n_outletsâ‰¥2`; `nb_rejectionsâ‰¥0`).

**Index semantics (binding).** For `gamma_component` with `context="nb"`, the Gamma is **scalar** per attempt; therefore
`index` is the fixed value **`0`** (scalar placeholder), not a component selector.

**Retention & lineage.** These streams are **not final in layer**, carry 180-day retention, and are produced by registry-closed producers (dictionary lineage): `gamma_component` â†’ "1A.nb_and_dirichlet_sampler", `poisson_component` â†’ "1A.nb_poisson_component", `nb_final` â†’ "1A.nb_sampler".

---

## 3) In-memory export to S3 (contract)

For each merchant $m$ that **finalised** in S2:

$$
\boxed{\,N_m\in\{2,3,\dots\}\,}\quad\text{and}\quad \boxed{\,r_m\in\mathbb{Z}_{\ge 0}\,}.
$$

* $N_m$ = **authoritative** domestic outlet count for downstream branches; it **must not be re-sampled** downstream.
* $r_m$ = diagnostic only (corridor metrics); no modelling effect beyond validation.

**Downstream use.**

* **S3 (eligibility gate)** consumes $N_m$ to determine if the merchant may attempt cross-border (policy flags live in `crossborder_eligibility_flags`). S3 runs **only** for multi-site merchants that left S2.
* **S4 (ZTP)**, if eligible, will typically inject $\log N_m$ into its intensity for foreign count; S4 writes its **own** events but reuses the **Poisson component stream id** with `context="ztp"`.

---

## 4) Boundary invariants (must-hold at S2 exit)

1. **Coverage invariant.** If a merchant has an `nb_final`, there exist **â‰¥1** `gamma_component` **and** **â‰¥1** `poisson_component` rows (both with `context="nb"`) under the same envelope keys. Absence is a **structural failure**.

2. **Consumption discipline.** Per merchant and label, event counter intervals are **monotone & non-overlapping**; `nb_final` is **non-consuming** (`before==after`). (Checked in S2.6 and by the validator.)

3. **Composition identity.** For each attempt $t$: $\lambda_t = (\mu_m/\phi_m)\cdot \texttt{gamma_value}_t$ (ULP-tight). The `nb_final`â€™s `mu, dispersion_k` **equal** the S2.2 values.

4. **Cardinality.** Exactly **one** `nb_final` per `(seed, parameter_hash, run_id, merchant_id)`. **â‰¥1** component rows per attempt; exactly **one** Gamma + **one** Poisson per attempt.

5. **Partitions & paths.** All three streams are written **only** under their dictionary paths and partitions; any deviation is a hard failure (`partition_misuse`).

---

## 5) Hand-off to S3 (operational)

**Eligibility of a merchant to enter S3:**

* Must have `is_multi=1` from S1 and a valid S2 `nb_final`. (Branch purity is enforced globally; single-site merchants must have **no** S2/S4â€“S6 events.)
* S3 receives $(N_m,r_m)$ **in-memory** and reads `crossborder_eligibility_flags(parameter_hash)` to determine the branch. **S3 persists nothing**; it fixes the policy branch that later must be reflected when `country_set` is materialised.

> **Note.** The **1Aâ†’1B hand-off** (egress consumption) is governed later by S9: `_passed.flag` must match `SHA256(validation_bundle_1A)` for the same fingerprint before 1B can read `outlet_catalogue`. S2 does not write egress and therefore cannot authorise 1B directly.

---

## 6) Writer reference pattern (idempotent; per merchant)

```pseudo
# Preconditions: merchant m is multi-site from S1; (mu, phi) evaluated in S2.2; RNG substreams established per S2.6.

# Attempt loop (S2.3/2.4) emits gamma_component then poisson_component per attempt (not repeated here).

# On acceptance:
N := accepted K_t   # K_t >= 2
r := t              # number of rejections

# Emit final (non-consuming) event:
envelope := current_envelope_with_counters()   # before == after (no extra draws here)
row := {
  merchant_id: m,
  mu: mu, dispersion_k: phi,
  n_outlets: N, nb_rejections: r
}
write_jsonl(
  path="logs/rng/events/nb_final/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl",
  envelope=envelope, payload=row
)

# Idempotency: the (seed, parameter_hash, run_id, merchant_id) key must not appear twice.
# Writers must dedupe on that composite key; validators hard-fail duplicate finals.
```

**Why non-consuming?** S2.5 records the acceptance and echoes parameters; all randomness was consumed in the attempts. Envelope equality proves it.

---

## 7) Validator obligations (S2-specific at boundary)

Before S3 consumes $(N_m,r_m)$ in-memory, the S2 validator must have already:

* **Schema-validated** all three streams.
* Checked **coverage & cardinality** and **consumption discipline**; verified **composition** identity per attempt.
* Computed **corridor metrics** $\widehat{\rho}_{\text{rej}}$, $p_{99}(r_m)$, and **CUSUM**; **hard-fail** on any breach.

---

## 8) Conformance tests (KATs for S2.9)

1. **Streams present & partitioned.** For a shard, assert that for every merchant with `nb_final`, there exist matching `gamma_component` and `poisson_component` rows under the same `(seed, parameter_hash, run_id)` partitions; no rows exist under any other path.

2. **Final echo & non-consumption.** For a sample of merchants, check `nb_final.mu == S2.2.mu` and `nb_final.dispersion_k == S2.2.phi`, and envelope counters are equal (`before==after`).

3. **Reconstruction of $(N_m,r_m)$.** Rebuild attempts by **counter-interval pairing** as above; confirm `nb_final.n_outlets == k` and the attempt index equals `nb_final.nb_rejections`.

4. **S3 readiness.** Ensure all `is_multi=1` merchants with `nb_final` also have a row in `crossborder_eligibility_flags(parameter_hash)`; single-site merchants have **no** S2 events.

---

## 9) Complexity & operational notes

* **I/O:** three append-only JSONL streams; per-merchant output is O(#attempts).
* **Memory:** O(1) for the writer at finalisation; S3 consumes only $(N_m,r_m)$.
* **Reuse:** The Poisson component stream id is deliberately shared with S4 (ZTP) via `context`, simplifying audit tooling.[[[MASTER-SEP-1A]]]

<a id="state-1a-s3-expanded"></a>
# state.1A.s3.expanded.txt

<!-- Source file: state.1A.s3.expanded.txt | BYTE-EXACT EMBED -->

# 0) One-page quick map (for implementers)

## 0.1 What S3 does (one breath)

Given a gated **multi-site** merchant with accepted outlet count **N** from S2, **S3 deterministically builds the cross-border candidate country universe and its total order** (an ordered list with reasons/tags and, if enabled, deterministic base-weight priors). **S3 uses no RNG.** If your design keeps integerisation in S3, it converts priors to **integer per-country counts** that sum to **N** using the fixed largest-remainder discipline.

---

## 0.2 Inputs â†’ Outputs (at a glance)

```
Ingress (read-only)                       S3 core (deterministic)                          Egress (authoritative)

S1 hurdle  â”€â”
            â”œâ”€â–º Gate: is_multi == true â”€â”€â”€â”
S2 nb_final â”‚                             â”‚
(N)         â”‚   Policy artefacts &        â”‚
            â”‚   static refs (IDs only)    â”‚
Merchant    â”˜                             â–¼
context  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  S3.1 Rule ladder (deny â‰» allow â‰» class â‰» legal/geo â‰» thresholds)
                                     â”‚
                                     â–¼
                      S3.2 Candidate universe (home + admissible foreigns; tags/reasons)
                                     â”‚
                                     â–¼
                      S3.3 Ordering & tie-break (total order; candidate_rank(home)=0)
                                     â”‚
                      â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â–¼                             â–¼
        (optional) S3.4 Base-weight priors   (optional) S3.5 Integerisation to counts (sum = N)

                                             â–¼
                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                  â”‚ Outputs (dictionary-partitioned):    â”‚
                                  â”‚ â€¢ s3_candidate_set (ordered)         â”‚
                                  â”‚ â€¢ (opt) s3_base_weight_priors        â”‚
                                  â”‚ â€¢ (opt) s3_integerised_counts        â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

*Downstream reads the **ordered** candidate set; inter-country order lives **only** in `candidate_rank`.*

---

## 0.3 Bill of Materials (IDs only; no paths)

| Kind               | ID / Anchor                                 | Purpose                                         | Notes (semver / digest) |
|--------------------|---------------------------------------------|-------------------------------------------------|-------------------------|
| Dataset (upstream) | `schemas.layer1.yaml#/rng/events/nb_final`  | Source of **N** (accepted outlet count)         | From S2 run             |
| Dataset (upstream) | `schemas.ingress.layer1.yaml#/merchant_ids` | Merchant scope & keys                           | From S0                 |
| Policy artefact    | `policy.s3.rule_ladder.yaml`                | Ordered rules, precedence, reason codes         | Semver + SHA-256        |
| Static ref         | `iso3166_canonical_2024`                 | ISO3166 canonical list/order                    | Versioned snapshot      |
| Static ref         | `static.currency_to_country.map.json`       | Deterministic currency-to-country mapping       | Versioned snapshot      |
| (Optional) Params  | `policy.s3.base_weight.yaml`                | Deterministic prior formula/coeffs + dp         | Semver + SHA-256        |
| Output table       | `schemas.1A.yaml#/s3/candidate_set`         | Ordered candidates with `candidate_rank` & tags | New schema              |
| (Optional) Output  | `schemas.1A.yaml#/s3/base_weight_priors`    | Deterministic priors per candidate              | New schema              |
| (Optional) Output  | `schemas.1A.yaml#/s3/integerised_counts`    | Integer counts per country (sum=N)              | New schema              |

> All IO resolves via the **dataset dictionary**. **No hard-coded paths** in S3.

---

## 0.4 Control gates & invariants (must hold to run)

* **Presence gate:** exactly one S1 hurdle row and **`is_multi == true`** for the merchant.
* **S2 gate:** exactly one **`nb_final`** with **`N â‰¥ 2`** for the same `{seed, parameter_hash, run_id, merchant}`.
* **Artefact gates:** rule ladder + static refs **loaded atomically** with pinned versions/digests.
* **No RNG:** S3 defines **no RNG families** (no labels, no budgets, no envelopes).
* **Ordering law:** **`candidate_rank(home) = 0`**, ranks are **total** and **contiguous**; **no duplicates**.

---

## 0.5 Outputs (authoritative, dictionary-partitioned)

**Required**

* `s3_candidate_set` â€” rows:
  `merchant_id`, `country_iso`, **`candidate_rank`**, `reason_codes[]`, `filter_tags[]`, lineage fields.
  **Partition:** `{parameter_hash}`. Embedded lineage: `parameter_hash`; `produced_by_fingerprint?` (optional provenance).
  **Row order guarantee:** `(merchant_id, candidate_rank, country_iso)`.

**Optional (enable only if S3 owns them)**

* `s3_base_weight_priors` â€” deterministic, quantised priors (dp is fixed in Â§12; **not probabilities**).
* `s3_integerised_counts` â€” integer counts per country with `residual_rank` if S3 performs integerisation (else defer downstream).

---

## 0.6 Definition of Done (tick before leaving S3)

* [ ] Every input/output cites a **JSON-Schema anchor** (no prose names).
* [ ] Rule ladder is **ordered** with explicit precedence and closed **reason codes**.
* [ ] Candidate construction is **deterministic**; **tie-break** and **quantisation dp** (if any) are stated.
* [ ] **Total order** proven: `candidate_rank(home)=0`, contiguous ranks, no duplicates.
* [ ] If priors exist: formula, units, bounds, **evaluation order**, and **dp** fixed.
* [ ] If integerising: **largest-remainder**, **lexicographic ISO** tie-break, and `residual_rank` persisted; **Î£ counts = N**.
* [ ] Partitions & embedded lineage fixed for each dataset; **no path literals**.
* [ ] Non-emission failure shapes listed (`ERR_S3_*`, merchant-scoped).
* [ ] Two tiny **worked examples** included (illustrative row shapes).

---

# 1) Interfaces (hard contracts)

## 1.1 Upstream interface (read-only)

**Purpose:** define the **closed** set of inputs S3 may read. No alternative sources; no re-deriving.

| Source                                 | JSON-Schema anchor (authoritative)                      | Required columns (name : type)                                                                                          | Invariants & notes                                                        | Cardinality (per merchant, within `{seed, parameter_hash, run_id}`) |
|----------------------------------------|---------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------|---------------------------------------------------------------------|
| Merchant scope                         | `schemas.ingress.layer1.yaml#/merchant_ids`             | `merchant_id:u64`, `home_country_iso:string(ISO-3166-1)`, `mcc:string`, `channel:(ingress schemaâ€™s closed vocabulary)`  | `home_country_iso` must be ISO; `channel` in the closed vocabulary        | **Exactly 1**                                                       |
| Hurdle decision (S1)                   | `schemas.layer1.yaml#/rng/events/hurdle_bernoulli`      | `merchant_id:u64`, `is_multi:bool` plus standard envelope/lineage fields                                                | Presence **required**; **gate:** `is_multi==true`                         | **Exactly 1**                                                       |
| Accepted outlet count (S2)             | `schemas.layer1.yaml#/rng/events/nb_final`              | `merchant_id:u64`, `n_outlets:i64 (â‰¥2)` plus standard envelope/lineage fields                                           | Finaliser is **non-consuming**; `n_outlets â‰¥ 2` to enter S3               | **Exactly 1**                                                       |
| Policy: S3 rule ladder                 | `artefact_registry_1A.yaml:policy.s3.rule_ladder.yaml`  | `rules[]` (ordered), `precedence`, `reason_codes[]` (**closed set**), validity window                                   | Load **atomically**; precedence is **total**; reason codes are **closed** | **Exactly 1** artefact                                              |
| Static refs (ISO, etc.)                | `iso3166_canonical_2024`                                | `iso_alpha2:string`, `iso_alpha3:string`, canonical ISO ordering                                                        | Versioned snapshot; no mutation                                           | **Exactly 1** artefact                                              |
| Currencyâ†’country map (if used)         | `static.currency_to_country.map.json`                   | `currency_code:string` â†’ `countries:[iso_alpha2]`                                                                       | Deterministic map; **no RNG** smoothing                                   | **Exactly 1** artefact                                              |
| (Optional) deterministic weight params | `policy.s3.base_weight.yaml`                            | explicitly named coefficients/thresholds; **units & bounds**                                                            | Only authority if S3 computes deterministic priors                        | **0 or 1** artefact                                                 |

**Path resolution:** via the **dataset dictionary** only; **no hard-coded paths**.

**Partition equality (read side):** embedded `{seed, parameter_hash, run_id}` in S1/S2 events must **byte-equal** their path partitions.

**RNG note:** S3 defines **no RNG families** (no labels, no budgets, no envelopes).

---

## 1.2 Downstream interface (egress S3 produces)

**Purpose:** define exactly what S3 emits and how consumers must read it. Consumers **must not** infer or reinterpret beyond this.

### 1.2.1 Required: ordered candidate set

| Dataset id         | JSON-Schema anchor                  | Partitions (path)    | Embedded lineage (columns)                                | Row order                                                                                      | Columns (name : type : semantics)                                                                                                                                                                                                                                                                                                 |
|--------------------|-------------------------------------|----------------------|-----------------------------------------------------------|------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `s3_candidate_set` | `schemas.1A.yaml#/s3/candidate_set` | `parameter_hash={â€¦}` | `parameter_hash:hex64`, `produced_by_fingerprint?:hex64`  | **Row ordering guarantee (logical):** `(merchant_id ASC, candidate_rank ASC, country_iso ASC)` | `merchant_id:u64` â€” key; `country_iso:string(ISO-3166-1)` â€” candidate; **`candidate_rank:u32`** â€” **total, contiguous order** with `candidate_rank==0` for home; `reason_codes:array<string>` â€” **closed set** from policy; `filter_tags:array<string>` â€” deterministic tags (**closed set** defined by policy); lineage as above |

**Contract:**

* **Total order:** `candidate_rank` is total and contiguous per merchant; **no duplicates**; **`candidate_rank(home)=0`**.
* **No priors here:** deterministic priors (if enabled) are emitted only in **`s3_base_weight_priors`** (Â§12.3).
* **Single authority for inter-country order:** downstream **must use `candidate_rank` only** (never file order or ISO).

### 1.2.2 Optional: deterministic base-weight priors (if enabled)

| Dataset id              | JSON-Schema anchor                       | Partitions           | Embedded lineage                             | Row order                    | Columns                                                                                                           |
|-------------------------|------------------------------------------|----------------------|----------------------------------------------|------------------------------|-------------------------------------------------------------------------------------------------------------------|
| `s3_base_weight_priors` | `schemas.1A.yaml#/s3/base_weight_priors` | `parameter_hash={â€¦}` | `parameter_hash`, `produced_by_fingerprint?` | `(merchant_id, country_iso)` | `merchant_id:u64`, `country_iso:string`, `base_weight_dp:decimal(string)`, `dp:u8` (quantisation places), lineage |

**Contract:** evaluation order and quantisation **dp** fixed in Â§12; consumers treat as **deterministic scores** only.

### 1.2.3 Optional: integerised counts (if S3 performs integerisation)

| Dataset id              | JSON-Schema anchor                       | Partitions           | Embedded lineage                             | Row order                    | Columns                                                                                                              |
|-------------------------|------------------------------------------|----------------------|----------------------------------------------|------------------------------|----------------------------------------------------------------------------------------------------------------------|
| `s3_integerised_counts` | `schemas.1A.yaml#/s3/integerised_counts` | `parameter_hash={â€¦}` | `parameter_hash`, `produced_by_fingerprint?` | `(merchant_id, country_iso)` | `merchant_id:u64`, `country_iso:string`, `count:i64 (â‰¥0)`, `residual_rank:u32` (largest-remainder tie rank), lineage |

**Contract:**

* Per merchant, `Î£ count = N` from S2.
* `residual_rank` captures the exact bump order (quantised residuals + ISO tiebreak) and is **persisted**.

---

## 1.3 Immutability & non-reinterpretation (binding)

**What S3 must not reinterpret**

* **Upstream decisions:** S1 hurdle (`is_multi`) and S2 `nb_final.n_outlets` are **authoritative**; S3 **must not** recompute or override them.
* **Upstream numerics:** inherit S0 numeric policy (binary64, RNE, FMA-off, no FTZ/DAZ).

**What downstream must not reinterpret**

* **Inter-country order:** lives **only** in `s3_candidate_set.candidate_rank`.
* **Priors (if any):** `base_weight_dp` are deterministic **priors**, not probabilities; consumers must not normalise or treat them as stochastic unless a later state explicitly says so.
* **Integerised counts (if emitted):** are **final for S3**; later stages treat them as read-only unless a new fingerprint changes.

**Partition â†” embed equality (write side)**

* Each S3 row **embeds** `parameter_hash` (must **byte-equal** the path). If present, `produced_by_fingerprint` is informational and has no equality/partition role.

**No paths in code**

* All IO resolves via the **dataset dictionary**. This spec names **dataset IDs and schema anchors only**.

---

# 2) Bill of Materials (BOM)

> **Goal:** freeze *exactly* what S3 may open and the versioning/lineage rules that make runs reproducible. If it isnâ€™t listed here, S3 must not read it.

## 2.1 Governed artefacts (authorities S3 must open atomically)

| Artefact (registry id)                | Purpose in S3                                                                                                          | SemVer | Digest (SHA-256, hex64) | Evidence / Notes                                           |
|---------------------------------------|------------------------------------------------------------------------------------------------------------------------|-------:|-------------------------|------------------------------------------------------------|
| `policy.s3.rule_ladder.yaml`          | Ordered deterministic rules (deny â‰» allow â‰» class â‰» legal/geo â‰» thresholds), precedence law, **closed** `reason_codes` |  x.y.z | â€¦                       | Must be **total order**; reason codes are a **closed set** |
| `iso3166_canonical_2024`              | ISO-3166-1 alpha-2/alpha-3 canonical list + canonical ISO order                                                        |  x.y.z | â€¦                       | Versioned snapshot; no mutation                            |
| `static.currency_to_country.map.json` | Deterministic **currency-to-country** mapping (if used by rules)                                                       |  x.y.z | â€¦                       | Deterministic only; **no RNG** smoothing                   |
| `schemas.layer1.yaml`                 | **JSON-Schema source of truth** (includes all `#/s3/*` anchors)                                                        |  x.y.z | â€¦                       | Schema authority; Avro (if any) is build-artefact only     |
| `schema.index.layer1.json` *(opt)*    | **Derived** schema index for faster lookups (non-authoritative)                                                        |  x.y.z | â€¦                       | Convenience only                                           |
| `dataset_dictionary.layer1.1A.yaml`   | Dataset IDs â†’ partition spec â†’ physical path template                                                                  |  x.y.z | â€¦                       | Resolves *all* IO; **no hard-coded paths**                 |
| `artefact_registry_1A.yaml`           | Full registry (this BOM appears in it)                                                                                 |  x.y.z | â€¦                       | Names, semver, digests must match this table               |

**Atomic open:** S3 **must** open all artefacts above *before* any processing and record their `(id, semver, digest)` into the runâ€™s `manifest_fingerprint`.

---

## 2.2 Datasets consumed from prior states (read-only)

| Dataset id                        | JSON-Schema anchor                                 | Partition keys (path)            | Embedded lineage (must equal)    | Used fields                                         |
|-----------------------------------|----------------------------------------------------|----------------------------------|----------------------------------|-----------------------------------------------------|
| `rng_event_hurdle_bernoulli` (S1) | `schemas.layer1.yaml#/rng/events/hurdle_bernoulli` | `{seed, parameter_hash, run_id}` | `{seed, parameter_hash, run_id}` | `merchant_id`, payload `is_multi`                   |
| `rng_event_nb_final` (S2)         | `schemas.layer1.yaml#/rng/events/nb_final`         | `{seed, parameter_hash, run_id}` | `{seed, parameter_hash, run_id}` | `merchant_id`, payload `n_outlets` (â‰¥2)             |
| `merchant_ids` (S0)               | `schemas.ingress.layer1.yaml#/merchant_ids`        | registry-defined                 | â€”                                | `merchant_id`, `home_country_iso`, `mcc`, `channel` |

**Read-side law:** for S1/S2 events, **embedded** `{seed, parameter_hash, run_id}` must **byte-equal** the path partitions.

---

## 2.3 Optional parameter bundles (only if S3 computes deterministic priors)

| Artefact (registry id)       | Purpose                                               | SemVer | Digest (SHA-256) | Notes                                            |
|------------------------------|-------------------------------------------------------|-------:|------------------|--------------------------------------------------|
| `policy.s3.base_weight.yaml` | Deterministic prior formula, constants/coeffs, **dp** |  x.y.z | â€¦                | **No RNG**; evaluation order & **dp** in Â§12     |
| `policy.s3.thresholds.yaml`  | Deterministic cutoffs (GDP floors, market limits)     |  x.y.z | â€¦                | If used by the rule ladder; closed numbers+units |

If you **do not** compute deterministic priors in S3, omit this subsection (do **not** keep unused knobs).

---

## 2.4 Outputs S3 produces (tables â€” shape authorities)

| Output dataset                | JSON-Schema anchor                       | Partition keys (path) | Embedded lineage                             | Consuming notes                                                                                      |
|-------------------------------|------------------------------------------|-----------------------|----------------------------------------------|------------------------------------------------------------------------------------------------------|
| `s3_candidate_set`            | `schemas.1A.yaml#/s3/candidate_set`      | `parameter_hash`      | `parameter_hash`, `produced_by_fingerprint?` | **Inter-country order lives only in `candidate_rank`**; `candidate_rank(home)=0`; total & contiguous |
| (opt) `s3_base_weight_priors` | `schemas.1A.yaml#/s3/base_weight_priors` | `parameter_hash`      | `parameter_hash`, `produced_by_fingerprint?` | Deterministic, quantised **priors** (not probabilities); join on `(merchant_id, country_iso)`        |
| (opt) `s3_integerised_counts` | `schemas.1A.yaml#/s3/integerised_counts` | `parameter_hash`      | `parameter_hash`, `produced_by_fingerprint?` | Counts per country; **Î£ count = N (from S2)**; persist `residual_rank`                               |

> **Single source of truth for priors:** We keep priors in **`s3_base_weight_priors`** only (no `base_weight_dp` column in `s3_candidate_set`) to avoid duplication and drift.

**Write-side law:** path partitions and embedded lineage must **match byte-for-byte**. **No `seed`** in S3 partitions.

---

## 2.5 Lineage & fingerprint rules (binding)

* **Dataset-level sidecar (required):** each S3 write MUST emit `_manifest.json` with `{manifest_fingerprint, parameter_hash, row_count, files_sorted, dataset_digest}`.
* **Rows (parameter-scoped):** MUST embed `parameter_hash`; MAY include `produced_by_fingerprint` (informational only; equals the runâ€™s `manifest_fingerprint` if present).
* **Skip-if-final:** producers compare the intended `manifest_fingerprint` to the sidecar; if equal and `dataset_digest` matches, the write MAY be skipped.
* **Consumers:** assert the sidecarâ€™s `manifest_fingerprint` equals the selected run; do not filter on a row column.
* **Inclusion rule (explicit):** the following **must** contribute to `manifest_fingerprint`:
  `policy.s3.rule_ladder.yaml`, `iso3166_canonical_2024`, `static.currency_to_country.map.json` (if used),
  `schemas.layer1.yaml` (and `schema.index.layer1.json` if used), `dataset_dictionary.layer1.1A.yaml`, `artefact_registry_1A.yaml`, and any artefact in Â§2.3.
  Missing inclusion â‡’ **abort**.
* **No path literals:** all IO resolves via the dataset dictionary; paths never appear in code or outputs.

---

## 2.6 Validity windows & version pinning

| Artefact                              | Valid from | Valid to   | Action on out-of-window      |
|---------------------------------------|------------|------------|------------------------------|
| `policy.s3.rule_ladder.yaml`          | YYYY-MM-DD | YYYY-MM-DD | **Abort** (binding policy)   |
| `iso3166_canonical_2024`              | YYYY-MM-DD | YYYY-MM-DD | **Warn + abort** if mismatch |
| `static.currency_to_country.map.json` | YYYY-MM-DD | YYYY-MM-DD | **Abort** if version drifts  |

If no validity windows are governed for an artefact, state: **â€œNo validity window â€” pinned by digest only (binding).â€**

---

## 2.7 Licensing & provenance (must be auditable)

| Artefact                              | Licence                                | Provenance URL / descriptor | Notes                                       |
|---------------------------------------|----------------------------------------|-----------------------------|---------------------------------------------|
| `iso3166_canonical_2024`              | e.g., â€œISO data under licence â€¦â€       | â€¦                           | Attach licence text in repo if required     |
| `policy.s3.rule_ladder.yaml`          | Project licence (e.g., MIT/Apache-2.0) | internal                    | Generated artefact; provenance = commit SHA |
| `static.currency_to_country.map.json` | e.g., ODbL / CC-BY / internal          | â€¦                           | Ensure redistribution rights are clear      |

If external licences restrict redistribution, record the policy you follow (e.g., embed digests, not full copies).

---

## 2.8 Open/verify checklist (run-time gates)

* [ ] **Open all governed artefacts** in Â§2.1 and record `(id, semver, digest)`.
* [ ] **Resolve datasets via dictionary**; **no literal paths**.
* [ ] **Equality check** path partitions â†” embedded lineage for S1/S2 inputs.
* [ ] **Fingerprint inclusion test:** all artefact digests listed in Â§2.5 are included in `manifest_fingerprint`.
* [ ] **Closed vocab check:** `reason_codes` (policy), `filter_tags` (policy), channels (ingress schema closed vocabulary), ISO set.
* [ ] **Version pin check:** artefacts within validity windows (if defined) or explicitly â€œdigest-pinned onlyâ€.
* [ ] **No RNG in S3:** confirm **no RNG families/labels** are referenced anywhere in S3 (events, budgets, envelopes).
* [ ] **Abort vocabulary loaded:** `ERR_S3_*` symbols available to callers.

---

> **Practical note:** This BOM is intentionally minimal but binding. If later sections call for an artefact or parameter not listed here, either (a) add it here with semver/digest, or (b) remove the dependency. No â€œghost inputs.â€

---

# 3) Determinism & numeric policy (carry-forward)

## 3.1 Scope (what this section fixes)

These rules are **definition-level**. If any item below is violated, S3â€™s outputs are **out of spec** (even if the program â€œworksâ€).

* Applies to **all** numeric work in S3 (feature transforms, thresholds, base-weight priors, ordering keys, integerisation residuals).
* **S3 uses no RNG.** If a future variant introduces RNG, it **must** adopt L0â€™s RNG/trace surfaces verbatim (see Â§3.7).

---

## 3.2 Floating-point environment (binding)

* **Format:** IEEE-754 **binary64** (`f64`) for all real computations and emitted JSON numbers.
* **Rounding mode:** **Round-to-Nearest, ties-to-Even (RNE)**.
* **FMA:** **disabled** (no fused multiply-add).
* **Denormals:** **no FTZ/DAZ** (do not flush subnormals to zero).
* **Shortest-round-trip emission:** emit `f64` as JSON **numbers** (not strings) using shortest round-trip formatting.

> Implementation: pin a math/runtime profile that guarantees the above; do not rely on host defaults.

---

## 3.3 Evaluation order & reductions

* **Evaluation order is normative.** Evaluate formulas in the **spelled order**; no algebraic reordering or â€œfast-mathâ€.
* **Reductions:** when summing/aggregating, use **serial Neumaier** in the **documented iteration order** (explicitly: the order defined by the section that invokes the reduction).
* **Clamp / winsorise / quantise:** apply **exactly** in the written sequence (e.g., compute â†’ clamp â†’ **quantise**)â€”never fused.

---

## 3.4 Total-order sorting (stable & reproducible)

Whenever S3 requires ordering (e.g., candidate ordering, residual ranking), apply a **total order**:

1. Primary key(s) as specified for that step. **For candidate ordering, see Â§9 (admission-order key; priors are not used).** Other sorts (e.g., residual ranking) follow the keys stated in their sections.
2. If equal **after any required quantisation**, fall back to **ISO code** (`iso_alpha2`, ASCII Aâ€“Z).
3. If still tied: break by `merchant_id` â†‘ then **original index** (stable: input sequence index in that stepâ€™s source list).

All sorts must be **stable** when keys compare equal.

---

## 3.5 Quantisation & dp policy

* If S3 computes deterministic **priors/scores**, it must **quantise** them to a fixed **decimal dp** **before** they are used for numeric steps (e.g., residual ordering in Â§10)â€”**not** for candidate ordering (see Â§9).
* The **dp value** for each context is declared once in that contextâ€™s section (e.g., Â§12 if priors exist).
* Quantise via `round_to_dp(value, dp)` under RNE, then use the **quantised** number for downstream sort/ties.

**Decimal rounding algorithm (binding):**
Let `s = 10^dp`. Compute `q = round_RNE(value * s) / s` in binary64, where `round_RNE` is ties-to-even on the **binary64** value of `value * s`. The emitted field is the binary64 `q` (or its shortest JSON representation if serialized).

*If a value is emitted as a **prior**, its on-disk representation is the **fixed-dp decimal string** defined in Â§12.3; the binary64 `q` above is for in-memory computation only.*

---

## 3.6 Integerisation residuals (only if S3 allocates counts)

* **Residuals:** compute residuals **after dp-quantisation** of any priors used for fractional shares.
* **Residual ranking:** sort **descending** by residual; tiebreak by **ISO code** (alpha-2, ASCII Aâ€“Z). Persist `residual_rank` if integerisation is emitted.
* **Bump discipline:** add +1 to the top `R` residuals until integer totals sum to **N** (from S2). (State where `R` comes from in the integerisation section.)

---

## 3.7 Optional RNG clause (future-proof, off by default)

* **Default:** **No RNG families** in S3. No event envelopes, no `draws/blocks`, no trace rows.
* **If (and only if) S3 ever adds RNG:**

  * Use L0â€™s writer/trace surface; events under `{seed, parameter_hash, run_id}`; embed `manifest_fingerprint`.
  * Fix `substream_label` names; document **budget law** (draws vs blocks) and **consuming status** for each family.
  * **Guard-before-emit**: compute all predicates that can invalidate an attempt **before** emitting any event.

*(This subsection is a guardrail; today itâ€™s a no-op.)*

---

## 3.8 Pathâ†”embed equality & lineage keys

* Every S3 output row **embeds** `parameter_hash` (must equal the path); if present, `produced_by_fingerprint` equals the runâ€™s `manifest_fingerprint`. The manifest itself is always recorded in the dataset-level sidecar. S3 outputs are **parameter-scoped** (no `seed` in partitions).
* **No path literals**: all IO resolves via the **dataset dictionary**.

---

## 3.9 Compliance self-check (tick at build/run)

* [ ] Process uses **binary64, RNE, FMA-off, no FTZ/DAZ**.
* [ ] Formulas follow **spelled evaluation order**; Neumaier used where specified.
* [ ] All ordering uses the **total-order stack** in Â§3.4; sorts are **stable**.
* [ ] Any priors/scores used in **numeric steps** (e.g., integerisation shares) were **quantised to dp** first (dp declared). *(Candidate ordering does **not** use priors; see Â§9.)*
* [ ] If integerising: residuals computed **after** dp; **ISO alpha-2** tiebreak; `residual_rank` persisted (if emitted).
* [ ] Outputs embed lineage matching path partitions; **no path literals** anywhere.
* [ ] RNG: **absent** in S3 (or, if later enabled, L0 surfaces + guard-before-emit are in place).

---

# 4) Symbols & vocab (legend)

## 4.1 Scalar symbols (used throughout S3)

| Symbol             | Type                                   | Meaning                                                                                        | Bounds / Notes                                                                                                                                                |
|--------------------|----------------------------------------|------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `N`                | `i64`                                  | Total outlets accepted for the merchant from S2 `nb_final.n_outlets`                           | `N â‰¥ 2`                                                                                                                                                       |
| `K`                | `u32`                                  | Number of **foreign** countries admitted into the candidate set (after rules)                  | `K â‰¥ 0` (if cross-border not eligible â‡’ `K = 0`)                                                                                                              |
| `w_i`              | `f64`                                  | Deterministic base score/weight for country `i` (if Â§12 enabled) **before quantisation**       | Units & evaluation order fixed in Â§12                                                                                                                         |
| `w_i^â‹„`            | `f64` (quantised) or `decimal(string)` | `w_i` **after** quantisation to `dp` decimal places (see Â§3.5, Â§12)                            | Used for **integerisation/residual ordering** (Â§10); **not** used for candidate ordering (Â§9). If emitted (priors table), use decimal string with fixed `dp`. |
| `Ï_i`              | `f64`                                  | Residual for country `i` in integerisation (if Â§13 used) computed **after** quantising weights | Used only for residual ranking                                                                                                                                |
| `candidate_rank_i` | `u32`                                  | Total order position for country `i` in the candidate set                                      | `candidate_rank(home) = 0`; contiguous; no ties                                                                                                               |
| `dp`               | `u8`                                   | Decimal places used to quantise `w` (if priors exist)                                          | Declared once in Â§12                                                                                                                                          |
| `Îµ`                | `f64`                                  | Small closed-form constants if needed (e.g., clamp)                                            | Declared where used; hex literal                                                                                                                              |

**Type conventions:** `u64` unsigned 64-bit, `i64` signed 64-bit, `u32/u8` unsigned, `f64` IEEE-754 binary64 (RNE, FMA-off; Â§3).

---

## 4.2 Sets, indices, and keys

| Symbol         | Type                          | Meaning                                                        | Notes                      |
|----------------|-------------------------------|----------------------------------------------------------------|----------------------------|
| `C`            | set of ISO country codes      | The admissible **country universe** for a merchant after rules | `home âˆˆ C` always          |
| `home`         | `string` (ISO-3166-1 alpha-2) | Merchantâ€™s home country from ingress                           | Uppercase `Aâ€“Z`            |
| `i, j`         | index                         | Index over countries in `C`                                    | Used consistently in loops |
| `merchant_id`  | `u64`                         | Canonical merchant identifier (from ingress)                   | Key in all S3 outputs      |
| `merchant_u64` | `u64`                         | Derived key per S0 (read-only)                                 | Not recomputed here        |

---

## 4.3 Deterministic priors / weights (if enabled)

* **Symbols:** `w_i` (pre-quantisation), `w_i^â‹„` (post-quantisation).
* **Evaluation order:** exactly as written in Â§12 (no re-ordering).
* **Quantisation:** `w_i^â‹„ = round_to_dp(w_i, dp)` under binary64 RNE (see Â§3.5).
* **Emission:** if persisted, emit `w_i^â‹„` in **`s3_base_weight_priors`** as a **decimal string** with exactly `dp` places; do **not** emit raw `w_i`.

> **No stochastic meaning:** `w` are **deterministic priors/scores**, **not probabilities**.

---

## 4.4 Ordering & tie-breaker keys (total order contract)

When S3 requires a total order over countries:

1. **Primary key(s)** as specified in the relevant section. **For candidate ordering, Â§9 applies (admission-order key; priors not used).** For residual ranking see Â§10.5.
2. **Secondary (stable) key:** `country_iso` **lexicographic Aâ€“Z**.
3. **Tertiary (stable) key:** `merchant_id` then original input index (stable: input sequence index).

This yields a **total, contiguous ranking** `candidate_rank_i âˆˆ {0,1,â€¦,|C|âˆ’1}`, with **`candidate_rank(home) = 0`**. (See **Â§9.4** proof obligation.)

---

## 4.5 Closed vocabularies & identifiers

| Vocabulary       | Values (closed set)                                                                                 | Where used                  | Notes                                                  |
|------------------|-----------------------------------------------------------------------------------------------------|-----------------------------|--------------------------------------------------------|
| `channel`        | `(closed vocabulary from ingress schema)`                                                           | Read from ingress in Â§2     | Case-sensitive; order fixed                            |
| `reason_codes`   | e.g., `["DENY_SANCTIONED","ALLOW_WHITELIST","CLASS_RULE_XYZ","LEGAL_EXCLUSION","THRESHOLD_LT_GDP"]` | Emitted with candidate rows | **Closed set** defined by `policy.s3.rule_ladder.yaml` |
| `rule_id`        | e.g., `"RL_DENY_SANCTIONED"`, `"RL_CLASS_MCC_XXXX"`                                                 | Rule ladder trace & tags    | Stable identifiers; no spaces                          |
| `filter_tags`    | e.g., `"SANCTIONED"`, `"GEO_OK"`, `"ADMISSIBLE"`                                                    | Candidate tagging           | Deterministic, documented list                         |
| `country_iso`    | ISO-3166-1 alpha-2                                                                                  | All S3 tables               | Uppercase `Aâ€“Z`; canonical ISO list from artefact      |
| `candidate_rank` | non-negative integer                                                                                | `s3_candidate_set`          | `candidate_rank(home)=0`; no gaps                      |

> The exact **enumerations** for `reason_codes`, `rule_id`, and `filter_tags` are defined in the policy artefact (Â§2.1). S3 treats them as **closed**; encountering an unknown code is a **failure**.

---

## 4.6 Encodings & JSON types

| Field                                        | JSON type         | Encoding details                                                                                     |
|----------------------------------------------|-------------------|------------------------------------------------------------------------------------------------------|
| `f64` payload numbers                        | **number**        | Shortest round-trip decimal (never strings)                                                          |
| `base_weight_dp` (in priors table)           | **string**        | Decimal string with exactly `dp` places (deterministic)                                              |
| `produced_by_fingerprint?`, `parameter_hash` | **string**        | Lowercase hex (`Hex64`); row provenance is optional; the run **manifest** is recorded in the sidecar |
| `country_iso`                                | **string**        | Uppercase ISO-3166-1 alpha-2                                                                         |
| `reason_codes`, `filter_tags`                | **array<string>** | Each element in **closed set**; order preserved (stable)                                             |
| `candidate_rank`, `residual_rank`            | **integer**       | Non-negative; `candidate_rank` contiguous from 0                                                     |

---

## 4.7 Units, bounds, and invariants (quick checks)

* `N` from S2: integer, **`N â‰¥ 2`**.
* `K`: integer, `K â‰¥ 0`; if cross-border not eligible â‡’ `K = 0`.
* Candidate set: **non-empty**; contains `home`.
* `candidate_rank`: contiguous per merchant; **no duplicates**, **no ties**.
* If integerising in S3: `âˆ‘_i count_i = N`; `count_i â‰¥ 0`; `residual_rank` persisted (unique per merchantâ€“country).
* If priors exist: `dp` stated; **quantise before** any ordering or residual logic.

---

## 4.8 Shorthand functions (names used later)

| Name                    | Signature                         | Meaning                                                     |
|-------------------------|-----------------------------------|-------------------------------------------------------------|
| `round_to_dp`           | `(x:f64, dp:u8) -> f64`           | Quantise to `dp` decimals under RNE (binary64)              |
| `iso_lex_less`          | `(a:string, b:string) -> bool`    | `true` iff `a` < `b` in Aâ€“Z lexicographic order             |
| `assign_candidate_rank` | `(C:list) -> list<u32>`           | Produce contiguous ranks using Â§4.4 total-order             |
| `residual_rank_sort`    | `(Ï:list, iso:list) -> list<u32>` | Sort residuals desc; ISO-lex tie-break; return stable ranks |

*(Symbolic names; concrete implementations live in L0/L1 as appropriate.)*

---

# 5) Control flow (S3 only)

## 5.1 Mini-DAG (one merchant, deterministic)

```
Ingress (read-only)                 S3 pipeline (deterministic)                          Egress (authoritative)

S1 hurdle â”€â”
           â”œâ”€ is_multi == true ? â”€â”€â–º [ENTER S3]
S2 nb_finalâ”‚
(N â‰¥ 2)    â”‚
Merchant   â”˜
context         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚ S3.0 Load ctx  â”‚ â†’  â”‚ S3.1 Rule ladder (denyâ€¦) â”‚ â†’ â”‚ S3.2 Candidate universe   â”‚
                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                                                    â”‚
                                                                                    â–¼
                                                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                                        â”‚ S3.3 Order & rank (total) â”‚
                                                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                                       â”‚
                        (optional, if enabled)                         â–¼
                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                   â”‚ S3.4 Base-weight priors   â”‚  â†’     â”‚ S3.5 Integerise to counts  â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                  â”‚                                     â”‚
                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                                 â–¼
                                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                                      â”‚ S3.6 Emit tables             â”‚
                                      â”‚ (candidate_set, opt. priors/ â”‚
                                      â”‚  opt. integerised_counts)    â”‚
                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Writes:** only in **S3.6** (tables). **No RNG**; no event streams.

---

## 5.2 Step-by-step (inputs â†’ outputs â†’ side-effects)

### S3.0 Load context (deterministic)

* **Inputs:** merchant row (ingress), S1 hurdle (`is_multi == true`), S2 `nb_final` (`N â‰¥ 2`), governed artefacts opened atomically (BOM Â§2).
* **Outputs:**
  `Ctx = { merchant_id, home_country_iso, mcc, channel, N, artefact_versions, parameter_hash, manifest_fingerprint }`.
* **Side-effects:** none (read-only).
* **Fail:** missing/invalid artefact or gates â‡’ `ERR_S3_AUTHORITY_MISSING` (stop merchant).

### S3.1 Rule ladder (deterministic policy)

* **Inputs:** `Ctx`, rule-ladder artefact.
* **Algorithm:** evaluate **ordered** rules (deny â‰» allow â‰» class â‰» legal/geo â‰» thresholds) per precedence; record `rule_id` & `reason_code`.
* **Outputs:** `RuleTrace` (ordered list) and `eligible_crossborder: bool`.
* **Side-effects:** none.
* **Fail:** unknown `rule_id`/`reason_code` â‡’ `ERR_S3_RULE_LADDER_INVALID`.

### S3.2 Candidate universe construction (deterministic)

* **Inputs:** `Ctx`, `RuleTrace`, static refs (ISO; currency-to-country map if used).
* **Algorithm:** start set `{home}`; if `eligible_crossborder`, add admissible foreign ISO codes; de-dup; tag with deterministic `filter_tags` & `reason_codes`.
* **Outputs:** `C` = list of candidate rows (unordered yet) with tags per row.
* **Side-effects:** none.
* **Fail:** empty `C` or missing `home` â‡’ `ERR_S3_CANDIDATE_CONSTRUCTION`.

### S3.3 Order & rank (total order; deterministic)

* **Inputs:** `C`.
* **Algorithm:** apply the **admission-order comparator** of Â§9 (priors are **not** used for ranking), then **ISO lexicographic** tie-break, then stability. Produce contiguous **`candidate_rank`** with **`candidate_rank(home) = 0`**.
* **Outputs:** `C_ranked = C + candidate_rank`.
* **Side-effects:** none.
* **Fail:** duplicate ranks â‡’ **`ERR_S3_ORDERING_NONCONTIGUOUS`**;
  missing `candidate_rank(home)=0` â‡’ **`ERR_S3_ORDERING_HOME_MISSING`**.

> If S3 **does not** compute priors, **skip S3.4**.

### S3.4 Base-weight priors (deterministic; optional)

* **Inputs:** `C_ranked`, `policy.s3.base_weight.yaml`.
* **Algorithm:** compute `w_i` per Â§12 in **spelled evaluation order**; **quantise** to `dp` â‡’ `w_i^â‹„`; attach to each candidate (for the priors table).
* **Outputs:** `C_weighted = C_ranked + w_i^â‹„` (for emission only; priors live in their own table).
* **Side-effects:** none.
* **Fail:** unknown coeff/param or missing `dp` â‡’ `ERR_S3_WEIGHT_CONFIG`.

> If S3 **does not** integerise, **skip S3.5**.

### S3.5 Integerise to counts (optional; sum to N)

* **Inputs:** `C_weighted` (or `C_ranked` if no priors), `N`.
* **Algorithm:** largest-remainder: floor, compute residuals **after** dp (if any), sort residuals **desc** with ISO tie-break, bump +1 until Î£ count = `N`; persist `residual_rank`.
* **Outputs:** `C_counts` = per-country `count` (â‰¥0) summing to `N`, plus `residual_rank`.
* **Side-effects:** none.
* **Fail:** Î£ `count` â‰  `N` â‡’ `ERR_S3_INTEGER_SUM_MISMATCH`;
  any `count < 0` â‡’ `ERR_S3_INTEGER_NEGATIVE`.

### S3.6 Emit tables (authoritative)

* **Inputs:** whichever of `C_ranked` / `C_weighted` / `C_counts` applies; `Ctx` lineage keys.
* **Algorithm:** write **tables** via dictionary-resolved paths, partitioned by **`parameter_hash`**; embed `parameter_hash` (must byte-equal the path); MAY embed `produced_by_fingerprint` (informational).
* **Outputs (tables):**

  * **Required:** `s3_candidate_set` (ranked, tagged candidates with `candidate_rank`).
  * **Optional:** `s3_base_weight_priors` (if S3.4 ran; emit `w_i^â‹„` as **decimal string** with exactly `dp` places) and/or `s3_integerised_counts` (if S3.5 ran; includes `residual_rank`).
* **Side-effects:** none beyond writes (no RNG events).
* **Fail:** pathâ†”embed mismatch or schema violation â‡’ `ERR_S3_EGRESS_SHAPE`.

---

## 5.3 Looping & stopping conditions

* **Per merchant:** S3 runs **once**; there are **no stochastic attempts**.
* **Stop-early:** if rule ladder denies cross-border, candidate set is `{home}` with `candidate_rank=0`; optional steps (priors, integerisation) still obey invariants.

---

## 5.4 Concurrency & idempotence

* **Read joins:** keyed by `{seed, parameter_hash, run_id, merchant_id}` for S1/S2 inputs (equality on pathâ†”embed).
* **Outputs:** **parameter-scoped** only (partitioned by `parameter_hash`); S3 has **no finaliser**.
* **Parallelism invariance:** deterministic, no RNG â‡’ re-partitioning/concurrency **cannot** change bytes.

---

## 5.5 Evidence cadence (what is written where)

* **Events:** none in S3.
* **Tables (only in S3.6):** fully-qualified JSON-Schema anchors; numbers as JSON numbers; **priors** (if emitted) as **decimal strings** with fixed `dp` in **`s3_base_weight_priors`**.

---



# 6) S3.0 â€” Load scopes (deterministic)

## 6.1 Purpose (binding)

Establish the **closed** set of inputs S3 may read, verify **gates and vocabularies**, and assemble a single, immutable **Context** record for subsequent S3 steps. S3.0 performs **no writes** and uses **no RNG**.

---

## 6.2 Inputs (authoritative anchors; read-only)

* **Merchant scope:** `schemas.ingress.layer1.yaml#/merchant_ids`
  Required: `merchant_id:u64`, `home_country_iso:string(ISO-3166-1 alpha-2)`, `mcc:string`, `channel âˆˆ (ingress schemaâ€™s closed vocabulary)`.
* **S1 hurdle:** `schemas.layer1.yaml#/rng/events/hurdle_bernoulli`
  Required: payload `is_multi:bool`, embedded `{seed, parameter_hash, run_id}`.
* **S2 finaliser:** `schemas.layer1.yaml#/rng/events/nb_final`
  Required: payload `n_outlets:i64 (â‰¥2)`, embedded `{seed, parameter_hash, run_id}`.
* **Policy artefact:** registry id `policy.s3.rule_ladder.yaml`
  Required: ordered `rules[]`, precedence law (total), **closed** `reason_codes[]`, optional validity window.
* **Static references:**
  `iso3166_canonical_2024` (canonical ISO set & lexicographic order).
  *(Optional)* `static.currency_to_country.map.json` (deterministic map) if referenced by policy.
* **Dictionary & registry:**
  `dataset_dictionary.layer1.1A.yaml` (dataset-id â†’ partition spec â†’ path template).
  `artefact_registry_1A.yaml` (audit of artefacts and semver/digests).

**Resolution rule:** all physical locations resolve via the **dataset dictionary**. **No literal paths** in S3.

---

## 6.3 Preconditions & gates (must hold before S3 continues)

1. **Presence & uniqueness** (within `{seed, parameter_hash, run_id}`):
   exactly one S1 hurdle row **and** exactly one S2 `nb_final` row per merchant; exactly one ingress merchant row.
2. **Gate conditions:** `is_multi == true` and `n_outlets (N) â‰¥ 2`.
3. **Pathâ†”embed equality (read side):** for S1 and S2 rows, embedded `{seed, parameter_hash, run_id}` **byte-equal** the path partitions.
4. **Closed vocabularies:** `channel âˆˆ (ingress schemaâ€™s closed vocabulary)` (case-sensitive); `home_country_iso âˆˆ` ISO set from the static artefact.
5. **Artefact integrity:** rule ladder precedence is a **total order**; `reason_codes[]` is a **closed set**; any configured validity windows are satisfied.
6. **Lineage availability:** runâ€™s `parameter_hash` and `manifest_fingerprint` exist; every artefact opened in Â§6.2 will be included in the fingerprint inputs for embedding later.

**If any precondition fails, S3 stops for this merchant** (see Â§6.7). S3.0 produces **no S3 outputs**.

---

## 6.4 Normative behavior (spec, not algorithm)

S3.0 **shall**:

* Open all governed artefacts in Â§6.2 **atomically**; record each `(id, semver, digest)` for fingerprint inclusion.
* Resolve S1/S2 datasets via the dictionary and read the **single** row per merchant from each (no scanning outside the partition scope).
* Enforce Â§6.3 exactly as written (no â€œbest effortâ€).
* Construct an immutable **Context** with the fields in Â§6.5.
* Perform **no writes** and **no RNG** activity.

---

## 6.5 Context (immutable; passed to S3.1+)

**Fields and semantics (all required unless marked optional):**

| Field                              | Type                                      | Source                  | Semantics                                                            |
|------------------------------------|-------------------------------------------|-------------------------|----------------------------------------------------------------------|
| `merchant_id`                      | `u64`                                     | ingress                 | Canonical key                                                        |
| `home_country_iso`                 | `string (ISO-3166-1)`                     | ingress                 | Must exist in ISO artefact; uppercase Aâ€“Z                            |
| `mcc`                              | `string`                                  | ingress                 | Merchant category code (read-only)                                   |
| `channel`                          | `(closed vocabulary from ingress schema)` | ingress                 | Closed vocabulary (read-only)                                        |
| `N`                                | `i64 (â‰¥2)`                                | S2 `nb_final.n_outlets` | Total outlets accepted by S2                                         |
| `seed`                             | `u64`                                     | S1/S2 embed             | For lineage joins only; S3 outputs are **not** seed-partitioned      |
| `parameter_hash`                   | `Hex64`                                   | S1/S2 embed / run       | Partition key for all S3 outputs                                     |
| `manifest_fingerprint`             | `Hex64`                                   | run                     | Recorded in the sidecar; rows MAY include `produced_by_fingerprint`. |
| `artefacts.rule_ladder`            | `{id, semver, digest}`                    | registry                | Governance attest                                                    |
| `artefacts.iso_countries`          | `{id, semver, digest}`                    | registry                | Governance attest                                                    |
| `artefacts.ccy_to_country` *(opt)* | `{id, semver, digest}`                    | registry                | Present only if used                                                 |

> **Deliberate omission:** S3 does **not** carry S2â€™s `mu`/`dispersion_k` in context; S3 never re-derives or uses them.

**Immutability:** later S3 steps must not modify `Context` nor re-open authorities beyond Â§6.2.

---

## 6.6 Postconditions (must be true after S3.0)

* Governed artefacts are open, version-pinned, and slated for inclusion in the run `manifest_fingerprint`.
* Merchant has passed gates: `is_multi==true`, `Nâ‰¥2`.
* Path partitions equal embedded lineage on S1/S2 rows.
* Closed vocabularies validated; ISO presence confirmed.
* A complete **Context** exists with lineage fields ready to embed in S3 egress.

---

## 6.7 Failure vocabulary (merchant-scoped; non-emitting)

| Code                         | Trigger                                                                                    | Effect                           |
|------------------------------|--------------------------------------------------------------------------------------------|----------------------------------|
| `ERR_S3_AUTHORITY_MISSING`   | Any governed artefact in Â§6.2 missing/unopenable or lacking semver/digest                  | Stop S3 for merchant; no outputs |
| `ERR_S3_PRECONDITION`        | `is_multi=false` or `N<2`                                                                  | Stop S3 for merchant; no outputs |
| `ERR_S3_PARTITION_MISMATCH`  | Path partitions â‰  embedded lineage on S1/S2 rows                                           | Stop S3 for merchant; no outputs |
| `ERR_S3_VOCAB_INVALID`       | `channel` not in (ingress schemaâ€™s closed vocabulary) or `home_country_iso` not in ISO set | Stop S3 for merchant; no outputs |
| `ERR_S3_RULE_LADDER_INVALID` | Ladder not total, unknown `reason_codes`, or out-of-window                                 | Stop S3 for merchant; no outputs |

**Non-emission guarantee:** S3.0 never writes tables or events; failures here do not produce partial S3 artefacts.

---

## 6.8 Spec-rehearsal (non-authoritative; for clarity only)

1. Open atomically: rule ladder, ISO set, (optional) currency-to-country map, dataset dictionary, artefact registry.
2. Read exactly one row each (dictionary-resolved IDs): ingress merchant, S1 hurdle, S2 `nb_final`.
3. Check: uniqueness; path partitions equal embedded lineage (S1/S2); `is_multi==true`; `Nâ‰¥2`; `channelâˆˆ(ingress schemaâ€™s closed vocabulary)`; `home` ISO in set; ladder is a total order with **closed** reason codes (within window if configured).
4. Assemble `Context` per Â§6.5.
5. Stop (no RNG, no writes). Pass `Context` to S3.1.

*(End non-authoritative rehearsal.)*

---

# 7) S3.1 â€” Rule ladder (deterministic policy)

## 7.1 Purpose (binding)

Evaluate an **ordered, deterministic** set of policy rules to decide the merchantâ€™s **cross-border eligibility** and to produce a **trace** of which rules fired (with reason codes/tags) for S3.2. **No RNG** and **no I/O** occur in S3.1.

---

## 7.2 Inputs (authoritative; read-only)

* **Context** from Â§6.5 (immutable):
  `merchant_id, home_country_iso, mcc, channel, N, seed, parameter_hash, manifest_fingerprint`, plus artefact digests. *(Deliberate omission: S3 does not use S2â€™s `Î¼, dispersion_k`.)*
* **Policy artefact** `policy.s3.rule_ladder.yaml` (opened in Â§6):
  â€“ an **ordered** array `rules[]` with a **total order**;
  â€“ a **closed set** `reason_codes[]`;
  â€“ a **closed set** `filter_tags[]` (merchant/candidate tags the rules may emit);
  â€“ optional **validity window**;
  â€“ if used, named constant sets/maps (e.g., sanctioned lists) and deterministic thresholds declared inside the artefact or via static artefacts from Â§2.

**Resolution rule:** this artefact is the **only** policy authority for S3.1.

---

## 7.3 Rule artefact â€” shape & fields (binding)

Each element of `rules[]` **must** have:

| Field                 | Type                             | Semantics                                                                                              |
|-----------------------|----------------------------------|--------------------------------------------------------------------------------------------------------|
| `rule_id`             | `string` (ASCII `[A-Z0-9_]+`)    | Unique and version-stable within the artefact                                                          |
| `precedence`          | enum (closed)                    | One of `{ "DENY","ALLOW","CLASS","LEGAL","THRESHOLD","DEFAULT" }`                                      |
| `priority`            | integer                          | Strict order **within** the same `precedence`; lower number = higher priority                          |
| `is_decision_bearing` | `bool`                           | If `true`, this rule may set `eligible_crossborder` under Â§7.4; else it only contributes to tags/trace |
| `predicate`           | deterministic boolean expression | Over **Context** fields and named sets/maps in the artefact (e.g., `home_country_iso âˆˆ SANCTIONED`)    |
| `outcome.reason_code` | `string`                         | Element of the artefactâ€™s **closed** `reason_codes[]`                                                  |
| `outcome.tags?`       | array<string>                    | Zero or more **closed** `filter_tags[]` to emit if the rule fires                                      |
| `notes?`              | string                           | Non-normative commentary (ignored by S3)                                                               |

**Determinism constraints**

* Predicates may use **only** equality/inequality, set membership, ISO lexicographic comparisons, and numeric comparisons on Â§6.5 fields or artefact-declared constants.
* **No RNG**, no external calls, no clock/host state.
* Numeric comparisons follow Â§3 (binary64, RNE, FMA-off).

---

## 7.4 Precedence law & conflict resolution (binding)

Let `Fired = { r âˆˆ rules : r.predicate == true }`. Define `eligible_crossborder` and the **decision source** as:

1. **DENY â‰» ALLOW â‰» {CLASS,LEGAL,THRESHOLD,DEFAULT}**

   * If any `DENY` fires â‡’ `eligible_crossborder = false` (decision source = the first decision-bearing `DENY`).
   * Else if any `ALLOW` fires â‡’ `eligible_crossborder = true` (decision source = the first decision-bearing `ALLOW`).
   * Else â‡’ choose from `{CLASS,LEGAL,THRESHOLD,DEFAULT}` by the ordering below.

2. **Within each precedence**, order rules by **priority asc**, then **rule\_id lexicographic Aâ†’Z**.

   * The **first** rule under this order whose `is_decision_bearing==true` becomes the decision source.
   * Rules with `is_decision_bearing==false` never set the decision but **do** contribute tags/reasons.

3. **DEFAULT terminal (mandatory, exactly one)**

   * Artefact **must** include exactly one `DEFAULT` with `is_decision_bearing==true` that **always fires** (or is otherwise guaranteed to catch the remainder). It provides the fallback decision (e.g., `eligible_crossborder=false`).

4. **Trace ordering (stable)**

   * `rule_trace` lists **all fired rules** sorted by `(precedence order, priority asc, rule_id asc)` â€” not evaluation time.
   * Mark the **single** decision source explicitly (`is_decision_source=true`).

---

## 7.5 Evaluation semantics (deterministic; no side-effects)

* Evaluate **all** predicates; collect `Fired`.
* Set `eligible_crossborder` **once** per Â§7.4.
* Compute `merchant_tags` as the **set-union** of `outcome.tags` from `Fired`, keeping a stable **Aâ†’Z** order for emission.
* **No I/O, no RNG**; results are in-memory outputs for S3.2.

---

## 7.6 Outputs to S3.2 (binding)

S3.1 yields the following immutable values:

| Name                   | Type            | Semantics                                                                                                                                |
|------------------------|-----------------|------------------------------------------------------------------------------------------------------------------------------------------|
| `eligible_crossborder` | `bool`          | Merchant-level decision per Â§7.4                                                                                                         |
| `rule_trace`           | list of structs | Each: `{rule_id, precedence, priority, is_decision_bearing, reason_code, is_decision_source:bool, tags:array<string>}` ordered as Â§7.4.4 |
| `merchant_tags`        | array<string>   | Deterministic union of all fired rule tags; **closed** vocabulary; **Aâ†’Z** order                                                         |

**Consumption:**
S3.2 uses `eligible_crossborder` to decide whether to add foreign countries. `rule_trace`/`merchant_tags` drive candidate-row `reason_codes[]`/`filter_tags[]` (mapping to per-country tags is defined in Â§8/Â§10).

---

## 7.7 Invariants (must hold)

* Artefact precedence is a **total order**; `reason_codes[]` and `filter_tags[]` are **closed**.
* Exactly **one** terminal, decision-bearing `DEFAULT` rule exists.
* `eligible_crossborder` is **always defined**.
* `rule_trace` ordering is **stable** and independent of evaluation order/data layout.
* No rule references fields/sets outside Â§6.2/Â§2.1.
* No randomness or host state influences the outcome.

---

## 7.8 Failure vocabulary (merchant-scoped; non-emitting)

| Code                         | Trigger                                                                                                                       | Action                              |
|------------------------------|-------------------------------------------------------------------------------------------------------------------------------|-------------------------------------|
| `ERR_S3_RULE_LADDER_INVALID` | Missing/duplicate `DEFAULT`; non-total precedence; duplicate `rule_id`; `reason_code`/`filter_tag` not in the **closed** sets | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_RULE_EVAL_DOMAIN`    | Predicate references unknown feature/value (e.g., unknown `channel`, ISO not in artefact, undeclared named set/map)           | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_RULE_CONFLICT`       | Multiple **decision-bearing** rules tie after priority and lexicographic tiebreak (malformed artefact)                        | Stop S3 for merchant; no S3 outputs |

---

## 7.9 Notes (clarifications; binding where stated)

* **Numeric thresholds:** comparisons are evaluated in **binary64** per Â§3. If thresholds are decimal, the artefact must state inclusivity (`>=` vs `>`).
* **No re-derivation:** if a rule needs an input (e.g., GDP bucket), it must appear in Â§2/Â§6; otherwise the rule is invalid.
* **Trace vs emission:** S3.1 **does not write** traces; `rule_trace`/`merchant_tags` are handed to S3.2 to annotate candidate rows.

---

# 8) S3.2 â€” Candidate universe construction (deterministic)

## 8.1 Purpose (binding)

Construct, for a single merchant, the **unordered** candidate country set `C` that Â§9 will **rank** (and, if enabled, Â§12 will weight / Â§13 will integerise). The set is **deterministic**, **non-empty**, and **always contains `home`**. **No RNG** and **no egress** occur in S3.2.

---

## 8.2 Inputs (authoritative; read-only)

* **`Context`** from Â§6.5 (immutable): `merchant_id`, `home_country_iso`, `mcc`, `channel`, `N`, lineage fields, artefact digests.
* **`eligible_crossborder : bool`** and **`rule_trace`** from Â§7.6 (immutable): ordered fired rules `{rule_id, precedence, priority, is_decision_bearing, reason_code, is_decision_source, tags[]}`.
* **Policy artefact** `policy.s3.rule_ladder.yaml` (opened in Â§6):
  â€¢ **Named country sets** (e.g., `SANCTIONED`, `EEA`, `WHITELIST_X`);
  â€¢ Per-rule **admit/deny lists** (`admit_countries[]`, `deny_countries[]`) and/or references to named sets;
  â€¢ **Closed vocabularies**: `reason_codes[]`, `filter_tags[]`; mapping notes for row-level tagging.
* **ISO reference** `iso3166_canonical_2024` (opened in Â§6): authoritative ISO set and lexicographic order (alpha-2, uppercase).

> **Resolution rule:** S3.2 consults **only** the policy artefactâ€™s named sets/lists and the ISO set; **no other source** is permitted.

---

## 8.3 Preconditions (must hold before S3.2 runs)

* `home_country_iso âˆˆ ISO` (already verified in Â§6).
* `eligible_crossborder` and `rule_trace` are present (from Â§7).
* Every named set/list referenced by **fired** rules exists in the policy artefact and expands **only** to ISO codes.

---

## 8.4 Deterministic construction (spec, not algorithm)

### 8.4.1 Start set (invariant)

* Initialise `C := { home }` with `home = Context.home_country_iso`.
* Tag the `home` row with `filter_tags += ["HOME"]` (from the policyâ€™s **closed** `filter_tags`) and include the **decision source** `reason_code` (from Â§7) in `reason_codes` for traceability.

### 8.4.2 Foreign admission when `eligible_crossborder == false`

* **No foreign country is admitted.**
* `C = { home }`; define `K_foreign := 0`.

### 8.4.3 Foreign admission when `eligible_crossborder == true`

Let `Fired` be the set of fired rules (from `rule_trace`). Build deterministic admits/denies using only **fired** rules and the artefact:

* `ADMITS`  = â‹ƒ over fired rules of: explicit `admit_countries[]` âˆª expansions of referenced **admit** named sets.

* `DENIES`  = â‹ƒ over fired rules of: explicit `deny_countries[]`  âˆª expansions of referenced **deny** named sets **including legal/geo constraints** (e.g., `SANCTIONED`).

* **Precedence reflection:** since Â§7 already applies **DENY â‰» ALLOW**, S3.2 forms the foreign set as
  `FOREIGN := (ADMITS \ DENIES) \ {home}`. *(No re-evaluation of precedence; this is a set-level reflection.)*

* **ISO filter:** `FOREIGN := FOREIGN âˆ© ISO`. Any element not in ISO is a **policy artefact error** (see Â§8.8).

* Add every `c âˆˆ FOREIGN` to `C`. For each added row, attach deterministic `filter_tags` and `reason_codes` per the artefactâ€™s mapping rules (e.g., per-rule `row_tags`, plus a **stable union** of fired rulesâ€™ `reason_code` values that justify inclusion; both vocabularies are **closed** and must appear in **Aâ†’Z** order).

* Define `K_foreign := |FOREIGN|`.

### 8.4.4 De-duplication & casing

* `C` contains **unique** ISO alpha-2 codes (uppercase `Aâ€“Z`).
* If multiple fired rules admit the same country, merge tags/reasons via **stable union** (Aâ†’Z for strings), no duplicates.

---

## 8.5 Outputs to Â§9 (binding; still unordered)

S3.2 yields an **unordered** list of candidate rows for the merchant:

| Field                             | Type                 | Semantics                                                                                                     |
|-----------------------------------|----------------------|---------------------------------------------------------------------------------------------------------------|
| `merchant_id`                     | `u64`                | From `Context`                                                                                                |
| `country_iso`                     | `string(ISO-3166-1)` | `home` or admitted foreign                                                                                    |
| `is_home`                         | `bool`               | `true` iff `country_iso == home`                                                                              |
| `filter_tags`                     | `array<string>`      | Deterministic tags (**closed** set from policy); **Aâ†’Z** order; includes `"HOME"` for the home row            |
| `reason_codes`                    | `array<string>`      | Deterministic union (**closed** set); **Aâ†’Z** order                                                           |
| *(optional)* `base_weight_inputs` | struct               | Only if Â§12 computes deterministic priors later; contains **declared** numeric inputs (no RNG, no host state) |

> **No `candidate_rank` is assigned in Â§8**; ranking happens in Â§9. If S3 does not implement priors (Â§12) or integerisation (Â§13), omit their optional fields.

---

## 8.6 Invariants (must hold after S3.2)

* `C` is **non-empty** and **contains `home`**.
* If `eligible_crossborder == false` â‡’ `C == {home}` and `K_foreign == 0`.
* If `eligible_crossborder == true` â‡’ `C == {home} âˆª FOREIGN`; `K_foreign == |C| âˆ’ 1`; `FOREIGN` is deterministic per fired rules.
* Every `country_iso âˆˆ ISO`; **no duplicates** in `C`.
* `filter_tags` and `reason_codes` per row are drawn **only** from the artefactâ€™s **closed** vocabularies and are in **Aâ†’Z** order.

---

## 8.7 Notes (clarifications; binding where stated)

* **No re-derivation:** S3.2 does not derive features beyond Â§6/Â§2. If a rule needs, e.g., *GDP bucket*, it must be provided via governed artefacts; otherwise the rule is invalid for S3.
* **No RNG:** Country selection in S3.2 is policy-driven, not stochastic. Any stochastic selection (e.g., Gumbel-top-K) belongs in a later state; S3 here is deterministic.
* **Admit/deny scope:** Admit/deny operate at **country-level** only. Merchant-level tags from rules apply to **all** candidate rows; per-row tags follow the artefactâ€™s mapping.

---

## 8.8 Failure vocabulary (merchant-scoped; non-emitting)

| Code                              | Trigger                                                     | Action                              |
|-----------------------------------|-------------------------------------------------------------|-------------------------------------|
| `ERR_S3_CANDIDATE_CONSTRUCTION`   | Candidate set becomes empty **or** `home` missing from `C`  | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_COUNTRY_CODE_INVALID`     | A named set/list expands to a value not in the ISO artefact | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_POLICY_REFERENCE_INVALID` | Fired rule references an undefined named set/list           | Stop S3 for merchant; no S3 outputs |

---

**Hand-off to Â§9:** Â§8 yields the **unordered** candidate rows `C`. Â§9 will impose a **total, deterministic order** (**`candidate_rank`**)â€”**priors are not used for sorting**. If configured, priors may be computed later and are used in **integerisation** (Â§10).

---

# 9) S3.3 â€” Ordering & tie-break (total order)

## 9.1 Purpose (binding)

Impose a **total, deterministic order** over the **unordered** candidate rows from Â§8 so that every merchantâ€™s candidates receive a **contiguous** **`candidate_rank âˆˆ {0,â€¦,|C|âˆ’1}`** with **`candidate_rank(home) = 0`**. **No RNG** and **no I/O** occur in S3.3.

> Canonical S3 flow (per Â§5): **rank first, then priors (Â§12)**. Therefore, ranking **does not** use weights.

---

## 9.2 Inputs (authoritative; read-only)

* **Candidate rows `C` from Â§8.5** (unordered), each with:
  `merchant_id`, `country_iso`, `is_home`, `filter_tags[]`, `reason_codes[]`, *(optional)* `base_weight_inputs` (only if Â§12 will run later; not used here).
* **Context** from Â§6.5 (read-only): includes `home_country_iso`.
* **Policy artefact `policy.s3.rule_ladder.yaml`** (read-only): precedence class order, per-rule `priority`, `rule_id`, and the **closed mapping** from row `reason_codes[]` to the admitting rule id(s) (see 9.3.2).

> Resolution rule: S3.3 consults **only** Â§8 outputs and the artefact fields listed above. No external sources.

---

## 9.3 Comparator (single path to a total order)

Define one deterministic comparator. Sorting must be **stable**.

### 9.3.1 Home override (rank 0)

* The row with `country_iso == home_country_iso` **must** receive **`candidate_rank = 0`**.
* All other countries are ranked **strictly after** home (beginning at `candidate_rank = 1`).

### 9.3.2 Primary key â€” **admission order key** (weights are not used)

For each foreign row `i`, derive a deterministic **admission key** from the artefact:

* Let `AdmitRules(i)` be the set of **admit-bearing** fired rules (from Â§7/Â§8 mapping) that justify inclusion of `i`.
  If the artefactâ€™s `reason_codes[]` alone are not sufficient to reconstruct `AdmitRules(i)`, the artefact **must** provide an explicit, closed mapping (e.g., per-row `admit_rule_ids[]`). If this mapping is missing, the artefact is **invalid** for S3 (Â§9.8).

* For each `r âˆˆ AdmitRules(i)`, compute the triplet
  `K(r) = âŸ¨ precedence_rank(r), priority(r), rule_id_ASC âŸ©`,
  where `precedence_rank` is the numeric index of the artefactâ€™s precedence class (lower = earlier).

* Define the rowâ€™s primary key as the **minimum** (lexicographic) triplet over `AdmitRules(i)`:

  ```
  Key1(i) = min_lex { K(r) : r âˆˆ AdmitRules(i) }
  ```

  (Intuition: if multiple rules justify inclusion, the earliest under artefact order wins deterministically.)

### 9.3.3 Secondary & tertiary keys (shared)

* **Key 2 (ISO tiebreak):** `country_iso` **lexicographic Aâ†’Z** (ISO alpha-2).
* **Key 3 (stability):** the rowâ€™s **original index** in Â§8â€™s output (or, equivalently, `(merchant_id, original_index)`) to guarantee **stable** order under equal keys.

---

## 9.4 Rank assignment (binding)

After sorting with Â§9.3 for a given merchant:

* Assign **`candidate_rank = 0`** to `home`.
* Assign **`candidate_rank = 1,2,â€¦`** in sorted order to the remaining rows **with no gaps**.

**Contiguity:** per merchant, `candidate_rank` spans `0..|C|âˆ’1`.
**Uniqueness:** per merchant, **no two rows share the same `(candidate_rank, country_iso)`**; **no duplicate `country_iso`** exist by Â§8.

---

## 9.5 Deterministic numeric discipline (binding)

* Priors/weights, if later computed in Â§12, are **not** used here.
* All string and integer comparisons follow Â§3â€™s environment (binary64 rules are irrelevant in Â§9 unless later sections add numeric keys).
* Sorting is **stable**; do not rely on host/library unspecified stabilityâ€”**stability is part of the contract**.

---

## 9.6 Outputs to Â§12/Â§13/Â§15 (binding)

Augment each candidate row with:

| Field                    | Type   | Semantics                                                                                             |
|--------------------------|--------|-------------------------------------------------------------------------------------------------------|
| `candidate_rank`         | `u32`  | Contiguous per merchant; `home` is `0`                                                                |
| *(optional)* `order_key` | struct | Non-emitted diagnostic tuple capturing `Key1` (for debugging only; include only if schema defines it) |

**Consumption:**

* Â§12 (if enabled) may compute **priors** over the already ranked list (does **not** affect `candidate_rank`).
* Â§13 (if enabled) consumes the ranked list (and, if present, priors) to integerise to counts.
* Â§15 egress always emits **`candidate_rank`** as the **sole authority** for inter-country order.

---

## 9.7 Invariants (must hold after S3.3)

* **`candidate_rank(home) = 0`**.
* Ranks are **contiguous** with no gaps; total order holds even when keys tie (via ISO then stability key).
* Comparator uses **admission order key** (no priors); sorting is **stable** and host-invariant under Â§3.
* If the artefact cannot provide a closed mapping from `reason_codes[]` to admit rules for any foreign row, the run is invalid for S3.

---

## 9.8 Failure vocabulary (merchant-scoped; non-emitting)

| Code                            | Trigger                                                                                            | Action                              |
|---------------------------------|----------------------------------------------------------------------------------------------------|-------------------------------------|
| `ERR_S3_ORDERING_HOME_MISSING`  | No row with `country_iso == home` in Â§8 output                                                     | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_ORDERING_NONCONTIGUOUS` | Assigned **candidate_rank** values are not contiguous `0..\|C\|âˆ’1`                                 | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_ORDERING_KEY_UNDEFINED` | Cannot reconstruct the **admission key** (no priors and no closed mapping from reasons â†’ rule ids) | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_ORDERING_UNSTABLE`      | Artefact inconsistency prevents a single total order (e.g., ambiguous mapping that yields ties)    | Stop S3 for merchant; no S3 outputs |

---

## 9.9 Notes (clarifications; binding where stated)

* **Home-first is an override, not a key:** assign `candidate_rank=0` to home **before** comparing the remainder.
* **Admission key derivation** depends on a **closed mapping** from row-level `reason_codes[]` (or explicit `admit_rule_ids[]`) to admitting rules. If your policy expresses reasons at a coarser grain, add explicit `admit_rule_ids[]`.
* **No probabilistic meaning** attaches to `candidate_rank`. It is a deterministic ordering surface only.

---

# 10) S3.4 â€” Integerisation (include only if S3 allocates counts)

## 10.1 Purpose (binding)

Convert a merchantâ€™s **ranked** candidate universe and a total outlet count **`N`** (from S2) into **non-negative integer per-country counts** that sum to **`N`**, using a **deterministic largest-remainder** method with fixed quantisation and tie-break rules. **No RNG** and **no I/O** occur in S3.4.

---

## 10.2 Inputs (authoritative; read-only)

* **Context** (from Â§6.5): `merchant_id`, `home_country_iso`, `N (â‰¥2)`, lineage fields.
* **Ranked candidates** (from Â§9): rows `âŸ¨country_iso, candidate_rank, â€¦âŸ©`, with `candidate_rank(home)=0`, contiguous ranks, no duplicates.
* **Deterministic priors (optional):** **quantised** weights `w_i^â‹„` (post-quantisation per Â§3.5 / Â§12) **if** priors are enabled in S3.
* **(Optional) bounds / policy knobs:** per-country integer bounds `L_i, U_i` with `0 â‰¤ L_i â‰¤ U_i â‰¤ N` **if** the policy artefact defines them for integerisation.

> **Resolution rule:** If priors are **not** enabled in S3, integerisation uses the **equal-weight** path (Â§10.3.B). If bounds exist, apply Â§10.6 (bounded Hamilton).

---

## 10.3 Ideal (fractional) allocation â€” two primary paths

Let `M = |C|` be the number of candidate countries.

### 10.3.A Priors present (preferred when enabled)

* Use **quantised** priors `w_i^â‹„ > 0` (dp fixed where produced).
* Normalise: `s_i = w_i^â‹„ / (Î£_j w_j^â‹„)`.
* Ideal fractional counts: `a_i = N Â· s_i`.

**Guard:** If `Î£_j w_j^â‹„ == 0` (policy error), fall back to Â§10.3.B (equal-weight) and raise `ERR_S3_WEIGHT_ZERO` (see Â§10.9).

### 10.3.B No priors (equal-weight discipline)

* Set `s_i = 1 / M` for all `i`.
* Ideal counts: `a_i = N / M` (identical for all countries).

*(Either path yields `a = (a_1,â€¦,a_M)` used below.)*

---

## 10.4 Floor step, residuals, and remainder

* **Floor counts:** `b_i = âŒŠ a_i âŒ‹` (integer).
* **Remainder to distribute:** `d = N âˆ’ Î£_i b_i` (integer, `0 â‰¤ d < M`).
* **Residuals:** `r_i = a_i âˆ’ b_i` (fractional part in `[0,1)`).
* **Residual quantisation (binding):** quantise residuals to fixed **`dp_resid = 8`** decimal places under binary64 RNE (Â§3.5):
  `r_i^â‹„ = round_to_dp(r_i, 8)`.

> Residuals are **always** computed **after** using the **quantised** priors (if any). The value of `dp_resid` is **binding**.

---

## 10.5 Deterministic bump rule (largest-remainder with fixed tie-break)

Distribute the `d` remaining units by adding **+1** to exactly `d` countries according to this deterministic order:

1. Sort by **`r_i^â‹„` descending**.
2. Break ties by **`country_iso`** lexicographic **Aâ†’Z** (ISO alpha-2).
3. If still tied (should not occur with fixed dp + ISO key), break by **`candidate_rank` ascending** (home first), then by the stable original input index from Â§8.

Let `S` be the resulting order. Bump the top `d` entries (`S[1..d]`) by +1. Final integer **count**:

```
count_i = b_i + 1[i âˆˆ top d].
```

**Persisted residual order:** define `residual_rank_i` as the **1-based position** of country `i` in `S` (the bump set is `{ i | residual_rank_i â‰¤ d }`). Persist `residual_rank` for **all** countries to make replay and tie reviews byte-deterministic downstream.

---

## 10.6 Optional bounds (lower/upper) â€” bounded Hamilton method

If the policy artefact supplies per-country integer bounds `(L_i, U_i)`:

1. **Feasibility guard:** require `Î£_i L_i â‰¤ N â‰¤ Î£_i U_i`. If violated â‡’ `ERR_S3_INTEGER_FEASIBILITY`.
2. **Initial allocation:** set `b_i = L_i`. Let `Nâ€² = N âˆ’ Î£_i L_i`. Define **capacities** `cap_i = U_i âˆ’ L_i`.
3. **Reweighting set:** consider only countries with `cap_i > 0`. Recompute **shares** over that set:

   * With priors: `s_i = w_i^â‹„ / Î£_{cap_j>0} w_j^â‹„`; else `s_i = 1 / |{j : cap_j>0}|`.
   * Ideal increments: `a_iâ€² = Nâ€² Â· s_i`.
   * Floors: `f_i = âŒŠ a_iâ€² âŒ‹`, limited by capacity: `f_i = min(f_i, cap_i)`; set `b_i â† b_i + f_i`.
   * Remainder `dâ€² = Nâ€² âˆ’ Î£_i f_i`.
4. **Residuals and bump:** compute `r_iâ€² = a_iâ€² âˆ’ f_i`, quantise to **`dp_resid = 8`**, and apply Â§10.5 **restricted to countries with remaining capacity** (`cap_i âˆ’ f_i > 0`) to distribute the remaining `dâ€²`.
5. **Final counts:** `count_i = b_i` after bumps; each satisfies `L_i â‰¤ count_i â‰¤ U_i` and `Î£_i count_i = N`.

---

## 10.7 Outputs to egress (Â§15) (binding)

For each candidate row:

| Field           | Type       | Semantics                                                        |
|-----------------|------------|------------------------------------------------------------------|
| `count`         | `i64 (â‰¥0)` | Final integer allocation for `country_iso`                       |
| `residual_rank` | `u32`      | Position in the residual order `S` of Â§10.5 (1 = highest resid.) |

If S3 emits a dedicated table **`s3_integerised_counts`**, include `merchant_id`, `country_iso`, `count`, `residual_rank`, and lineage fields, partitioned per Â§2.

---

## 10.8 Invariants (must hold)

* `Î£_i count_i = N`; `count_i â‰¥ 0`.
* **`candidate_rank(home) = 0`** still holds from Â§9; integerisation **does not** alter ranks.
* Residuals quantised at **`dp_resid = 8`** before ordering; tie-break exactly as Â§10.5.
* If bounds are used: `L_i â‰¤ count_i â‰¤ U_i` for all `i`, and feasibility guard passed.
* `{ i | residual_rank_i â‰¤ d }` matches exactly the set of bumped countries.

---

## 10.9 Failure vocabulary (merchant-scoped; non-emitting)

| Code                          | Trigger                                            | Action                              |
|-------------------------------|----------------------------------------------------|-------------------------------------|
| `ERR_S3_WEIGHT_ZERO`          | Priors enabled but `Î£_i w_i^â‹„ == 0` (policy error) | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_INTEGER_FEASIBILITY`  | Bounds specified but `Î£ L_i > N` or `N > Î£ U_i`    | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_INTEGER_SUM_MISMATCH` | After allocation, `Î£_i count_i â‰  N`                | Stop S3 for merchant; no S3 outputs |
| `ERR_S3_INTEGER_NEGATIVE`     | Any `count_i < 0`                                  | Stop S3 for merchant; no S3 outputs |

---

## 10.10 Notes (clarifications; binding where stated)

* **dp selection:** `dp_resid = 8` is binding for residuals to ensure cross-host determinism; change only via policy artefact **and** update this section.
* **Home minimum:** If policy requires a **home floor** (e.g., `L_home â‰¥ 1`), encode via Â§10.6; do **not** hand-wave it in code.
* **No probabilistic meaning:** counts are deterministic integers; priors (if any) are deterministic scores, *not* probabilities.

---

# 11) S3.5 â€” Sequencing & IDs (deterministic)

## 11.1 Purpose (binding)

Given per-country **integer counts** `count_i` (from Â§10) for a multi-site merchant, define a **deterministic, contiguous within-country sequence** `site_order âˆˆ {1..count_i}`, andâ€”if enabledâ€”a **deterministic identifier** `site_id` per `(merchant_id, country_iso, site_order)`. **No RNG**; **no gaps**; ordering is reproducible across hosts.

---

## 11.2 Preconditions (must hold)

* Inputs from Â§6.5 (**Context**) and **ranked candidate rows** from Â§9.
* Integer counts from Â§10 present and valid: for each `country_iso` in the merchantâ€™s set, `count_i â‰¥ 0` and `Î£_i count_i = N`.
* **`candidate_rank(home) = 0`** still holds (sequencing must not change inter-country order).

---

## 11.3 Sequencing (deterministic; no side-effects)

* **Per-country domain:** For each `(merchant_id, country_iso)` with `count_i > 0`, define a **contiguous** within-country sequence `site_order âˆˆ {1,2,â€¦,count_i}`.
* **Logical row grouping:** Within a merchant block, rows are *logically* grouped by `(country_iso, site_order)`; inter-country order remains Â§9â€™s **`candidate_rank`** and is **not** encoded here.
* **Zero counts:** If `count_i = 0`, **no rows** exist for that `(merchant_id, country_iso)` in any sequencing output.

> **Binding:** Sequencing **never** reorders countries: inter-country order remains the **`candidate_rank`** from Â§9; sequencing only establishes the order **within** each country.

---

## 11.4 Identifier policy (if `site_id` is enabled)

* **Format:** `site_id` is a **fixed-width, zero-padded 6-digit string**: `"{site_order:06d}"`.
  Examples: `1 â†’ "000001"`, `42 â†’ "000042"`, `999999 â†’ "999999"`.
* **Scope of uniqueness:** Unique **within** each `(merchant_id, country_iso)`. The same `site_id` string may appear in another country or merchant.
* **Overflow rule (binding):** If `count_i > 999999`, raise `ERR_S3_SITE_SEQUENCE_OVERFLOW` and **stop S3 for that merchant**; no partial sequencing/outputs.
* **Immutability:** Given identical inputs/lineage, the mapping `(merchant_id, country_iso, site_order) â†’ site_id` is a pure function (no host/time dependence).

---

## 11.5 Emitted dataset (Variant A â€” S3 owns sequencing)

If S3 emits sequencing, it **must** produce the following table; otherwise skip to Â§11.6.

| Dataset id         | JSON-Schema anchor                  | Partitions (path)    | Embedded lineage (columns)                               | Row order (physical)                                 | Columns (name : type : semantics)                                                                                                                                                             |
|--------------------|-------------------------------------|----------------------|----------------------------------------------------------|------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `s3_site_sequence` | `schemas.1A.yaml#/s3/site_sequence` | `parameter_hash={â€¦}` | `parameter_hash:Hex64`, `produced_by_fingerprint?:Hex64` | `(merchant_id ASC, country_iso ASC, site_order ASC)` | `merchant_id:u64` â€” key; `country_iso:string(ISO-3166-1 alpha-2)`; `site_order:u32` â€” **contiguous 1..count\_i**; *(optional)* `site_id:string(len=6)` â€” zero-padded; lineage fields as above |

**Contracts**

* **Contiguity:** For each `(merchant_id, country_iso)`, the set of `site_order` values is **exactly** `{1..count_i}`.
* **Uniqueness:** No duplicate `site_order` within a `(merchant_id, country_iso)` block; if `site_id` present, no duplicate `site_id` within that block.
* **Read scope:** Consumers **must not** infer inter-country order from this table; inter-country order is **only** `candidate_rank` from Â§9 (available via `s3_candidate_set`).

---

## 11.6 Deferred emission (Variant B â€” sequencing implemented later)

If S3 does **not** emit `s3_site_sequence`, it must still fix the **binding rules** in Â§Â§11.3â€“11.4. A later state (e.g., S7 â€œSequence & IDsâ€) must:

* Use **exactly** the same within-country sequencing (contiguous `1..count_i`),
* Enforce the **same** `site_id` format and **overflow** rule, and
* Preserve lineage/path rules from Â§2 (parameter-scoped partitions; embed `parameter_hash`; MAY include `produced_by_fingerprint`).  # rows remain parameter-scoped

---

## 11.7 Lineage & ordering (write-side discipline, Variant A)

* **Partitions:** `parameter_hash` only (parameter-scoped).
* **Embedded lineage:** each row embeds `parameter_hash` (must equal the path). Rows MAY include `produced_by_fingerprint` (informational; equals the runâ€™s manifest if present).
* **No path literals:** dictionary resolves the dataset id to a physical path.
* **JSON types:** numbers as JSON **numbers**; `site_id` as JSON **string** of length 6.

---

## 11.8 Failure vocabulary (merchant-scoped; non-emitting)

| Code                            | Trigger                                                                                       | Action                                               |
|---------------------------------|-----------------------------------------------------------------------------------------------|------------------------------------------------------|
| `ERR_S3_SITE_SEQUENCE_OVERFLOW` | `count_i > 999999` for any `(merchant_id, country_iso)`                                       | Stop S3 for merchant; emit **no** sequencing outputs |
| `ERR_S3_SEQUENCE_GAP`           | A `(merchant_id, country_iso)` block is missing any integer in `{1..count_i}`                 | Stop S3 for merchant; no outputs                     |
| `ERR_S3_SEQUENCE_DUPLICATE`     | Duplicate `site_order` (or `site_id`, if enabled) within a `(merchant_id, country_iso)` block | Stop S3 for merchant; no outputs                     |
| `ERR_S3_SEQUENCE_ORDER_DRIFT`   | Sequencing attempts to alter inter-country order (i.e., contradict Â§9 **candidate\_rank**)    | Stop S3 for merchant; no outputs                     |

---

## 11.9 Invariants (must hold after sequencing)

* For every country with `count_i > 0`, `site_order` is **exactly** `1..count_i` (contiguous, no gaps).
* **Inter-country order remains Â§9â€™s `candidate_rank`**; sequencing does not permute countries.
* If `site_id` is emitted, it is a deterministic function of `(merchant_id, country_iso, site_order)` with the 6-digit zero-padded format; overflow is impossible by construction or triggers Â§11.8.
* Outputs (Variant A) follow Â§2 lineage/partition rules; **no path literals**.

---

*Implementation note (non-authoritative):* If you anticipate future requirements for a check digit or namespace change, nest `site_id` under a versioned object in the schema (e.g., `{ "v": 1, "id": "000123" }`). Until then, the flat 6-digit string above is the **binding** representation.

---

# 12) Emissions (authoritative)

## 12.1 General write discipline (binding)

* **Dictionary-resolved paths only.** All physical locations resolve via the dataset dictionary by dataset **ID**; no hard-coded paths.
* **Partition scope:** all S3 datasets are **parameter-scoped** â€” partitioned by `parameter_hash` only (**no `seed`**).
* **Embedded lineage:** every S3 row **embeds** `parameter_hash`; MAY include `produced_by_fingerprint?`. A dataset-level sidecar `_manifest.json` is **required** (manifest, files, digest).
* **Numbers:** payload numbers are JSON **numbers** (not strings), except where a **decimal string** is required for deterministic fixed-dp representation (explicitly called out below).
* **Atomic publish:** stage â†’ fsync â†’ atomic rename into the dictionary location. No partials or mismatched partitions.
* **Idempotence:** identical inputs + lineage â‡’ **byte-identical** outputs.

---

## 12.2 Required table â€” `s3_candidate_set`

**Dataset id:** `s3_candidate_set`
**JSON-Schema anchor:** `schemas.1A.yaml#/s3/candidate_set`
**Partitions (path):** `parameter_hash={â€¦}`
**Embedded lineage (columns):** `parameter_hash: Hex64`, `produced_by_fingerprint?: Hex64`
**Row ordering guarantee (logical):** `(merchant_id ASC, candidate_rank ASC, country_iso ASC)`

**Columns (binding):**

| Name                       | Type                      | Semantics                                                                                    |
|----------------------------|---------------------------|----------------------------------------------------------------------------------------------|
| `merchant_id`              | `u64`                     | Canonical merchant key                                                                       |
| `country_iso`              | `string(ISO-3166-1, Aâ€“Z)` | Candidate country code                                                                       |
| `candidate_rank`           | `u32`                     | **Total, contiguous order** per merchant; **`candidate_rank(home)=0`** (Â§9)                  |
| `is_home`                  | `bool`                    | `true` iff `country_iso == home_country_iso`                                                 |
| `reason_codes`             | `array<string>`           | Deterministic union (Aâ†’Z) from policyâ€™s **closed** set                                       |
| `filter_tags`              | `array<string>`           | Deterministic tags (Aâ†’Z) from policyâ€™s **closed** set                                        |
| `parameter_hash`           | `Hex64`                   | Embedded lineage (must equal path)                                                           |
| `produced_by_fingerprint?` | `Hex64`                   | Optional provenance (equals the runâ€™s `manifest_fingerprint` if present; informational only) |

**Contracts**

* Per merchant: â‰¥1 row (candidate set **non-empty**) and exactly one row with `is_home==true` and `candidate_rank==0`.
* No duplicate `(merchant_id, country_iso)` and no duplicate `candidate_rank` within a merchant block.
* Inter-country order is **authoritatively** given by `candidate_rank` only. Consumers must **not** infer order from file order.

> **No priors in this table.** Deterministic priors (if any) live in `s3_base_weight_priors` (12.3) as the **single source of truth**.

---

## 12.3 Optional table â€” `s3_base_weight_priors` (deterministic scores)

Emit **only** if S3 computes deterministic priors (see Â§12 / Â§3.5 for `dp` selection). Priors are deterministic scores, not probabilities.

**Dataset id:** `s3_base_weight_priors`
**JSON-Schema anchor:** `schemas.1A.yaml#/s3/base_weight_priors`
**Partitions (path):** `parameter_hash={â€¦}`
**Embedded lineage (columns):** `parameter_hash`, `produced_by_fingerprint?`
**Row ordering guarantee:** `(merchant_id ASC, country_iso ASC)`

**Columns (binding):**

| Name                       | Type                      | Semantics                                                                                    |
|----------------------------|---------------------------|----------------------------------------------------------------------------------------------|
| `merchant_id`              | `u64`                     | Canonical merchant key                                                                       |
| `country_iso`              | `string(ISO-3166-1, Aâ€“Z)` | Candidate country code                                                                       |
| `base_weight_dp`           | **string (fixed-dp)**     | Deterministic prior **after quantisation**; exactly `dp` decimal places                      |
| `dp`                       | `u8`                      | Decimal places used for quantisation (constant within a run)                                 |
| `parameter_hash`           | `Hex64`                   | Embedded lineage                                                                             |
| `produced_by_fingerprint?` | `Hex64`                   | Optional provenance (equals the runâ€™s `manifest_fingerprint` if present; informational only) |

**Contracts**

* `dp` is constant within a run (may change **only** with policy change + new fingerprint/param hash).
* This table is the **only** authority for priors in S3; `s3_candidate_set` must not carry a `base_weight_dp` field.

---

## 12.4 Optional table â€” `s3_integerised_counts` (if S3 allocates counts)

Emit **only** if S3 performs integerisation (see Â§10). Otherwise, counts belong to the later state that owns allocation.

**Dataset id:** `s3_integerised_counts`
**JSON-Schema anchor:** `schemas.1A.yaml#/s3/integerised_counts`
**Partitions (path):** `parameter_hash={â€¦}`
**Embedded lineage (columns):** `parameter_hash`, `produced_by_fingerprint?`
**Row ordering guarantee:** `(merchant_id ASC, country_iso ASC)`

**Columns (binding):**

| Name                       | Type                      | Semantics                                                                                    |
|----------------------------|---------------------------|----------------------------------------------------------------------------------------------|
| `merchant_id`              | `u64`                     | Canonical merchant key                                                                       |
| `country_iso`              | `string(ISO-3166-1, Aâ€“Z)` | Candidate country code                                                                       |
| `count`                    | `i64 (â‰¥0)`                | Final integer allocation for this country                                                    |
| `residual_rank`            | `u32`                     | Rank in residual order (`1`=highest), as defined in Â§10.5                                    |
| `parameter_hash`           | `Hex64`                   | Embedded lineage                                                                             |
| `produced_by_fingerprint?` | `Hex64`                   | Optional provenance (equals the runâ€™s `manifest_fingerprint` if present; informational only) |

**Contracts**

* Per merchant: `Î£_i count_i = N` from S2; `count_i â‰¥ 0`.
* `residual_rank` is present for **every** row and deterministically reconstructs the bump set `{ i | residual_rank_i â‰¤ d }`.

---

## 12.5 Optional table â€” `s3_site_sequence` (if S3 owns sequencing; see Â§11)

If sequencing is deferred to a later state, **do not** emit this table here. If S3 owns sequencing (Variant A in Â§11):

**Dataset id:** `s3_site_sequence`
**JSON-Schema anchor:** `schemas.1A.yaml#/s3/site_sequence`
**Partitions (path):** `parameter_hash={â€¦}`
**Embedded lineage (columns):** `parameter_hash`, `produced_by_fingerprint?`
**Row ordering guarantee:** `(merchant_id ASC, country_iso ASC, site_order ASC)`

**Columns (binding):**

| Name                       | Type                      | Semantics                                                                                    |
|----------------------------|---------------------------|----------------------------------------------------------------------------------------------|
| `merchant_id`              | `u64`                     | Canonical merchant key                                                                       |
| `country_iso`              | `string(ISO-3166-1, Aâ€“Z)` | Country                                                                                      |
| `site_order`               | `u32`                     | Contiguous `1..count_i` within country (from Â§11.3)                                          |
| `site_id` *(optional)*     | `string(6)`               | Zero-padded 6-digit ID; overflow triggers Â§11.8                                              |
| `parameter_hash`           | `Hex64`                   | Embedded lineage                                                                             |
| `produced_by_fingerprint?` | `Hex64`                   | Optional provenance (equals the runâ€™s `manifest_fingerprint` if present; informational only) |

**Contracts:** see Â§11.5â€“Â§11.9.

---

## 12.6 Pathâ†”embed equality (write-side checks)

For every written row in all S3 datasets:

* `row.parameter_hash` (embedded) **equals** the `parameter_hash` path partition (string-equal).
* If present, `row.produced_by_fingerprint` **equals** the runâ€™s manifest fingerprint (informational only; not part of equality/partition).
* No other lineage fields appear in the path (e.g., **no `seed`**); any additional lineage fields must be **embedded** only.

Violation â‡’ **`ERR_S3_EGRESS_SHAPE`**.

---

## 12.7 Non-duplication & uniqueness (binding)

Per merchant:

* `s3_candidate_set`: unique `(country_iso)` and unique `(candidate_rank)`; exactly one `is_home==true` with `candidate_rank==0`.
* `s3_base_weight_priors` (if emitted): unique `(country_iso)`.
* `s3_integerised_counts` (if emitted): unique `(country_iso)`.
* `s3_site_sequence` (if emitted): unique `(country_iso, site_order)` (and `(country_iso, site_id)` if `site_id` present).

---

## 12.8 Example row *shapes* (illustrative; dictionary resolves paths)

> Illustrative JSON snippets (not full rows). Exact schemas are normative via the anchors.

**`s3_candidate_set`:**

```json
{
  "merchant_id": 123456789,
  "country_iso": "GB",
  "candidate_rank": 0,
  "is_home": true,
  "reason_codes": ["ALLOW_WHITELIST"],
  "filter_tags": ["GEO_OK","HOME"],
  "parameter_hash": "ab12...ef",
  "produced_by_fingerprint": "cd34...90"
}
```

**`s3_base_weight_priors`:**

```json
{
  "merchant_id": 123456789,
  "country_iso": "FR",
  "base_weight_dp": "0.180000",
  "dp": 6,
  "parameter_hash": "ab12...ef",
  "produced_by_fingerprint": "cd34...90"
}
```

**`s3_integerised_counts`:**

```json
{
  "merchant_id": 123456789,
  "country_iso": "FR",
  "count": 3,
  "residual_rank": 2,
  "parameter_hash": "ab12...ef",
  "produced_by_fingerprint": "cd34...90"
}
```

**`s3_site_sequence`:**

```json
{
  "merchant_id": 123456789,
  "country_iso": "FR",
  "site_order": 1,
  "site_id": "000001",
  "parameter_hash": "ab12...ef",
  "produced_by_fingerprint": "cd34...90"
}
```

---

## 12.9 Failure vocabulary (write-time)

| Code                              | Trigger                                                                            | Action                                            |
|-----------------------------------|------------------------------------------------------------------------------------|---------------------------------------------------|
| `ERR_S3_EGRESS_SHAPE`             | Schema violation; pathâ†”embed mismatch; forbidden lineage in path; wrong JSON types | Stop S3 for merchant; **no** S3 outputs published |
| `ERR_S3_DUPLICATE_ROW`            | Duplicate key per dataset (e.g., duplicate `(country_iso)` or `(candidate_rank)`)  | Stop S3 for merchant; no outputs                  |
| `ERR_S3_ORDER_MISMATCH`           | `candidate_rank(home)â‰ 0` or ranks not contiguous in emitted candidate set          | Stop S3 for merchant; no outputs                  |
| `ERR_S3_INTEGER_SUM_MISMATCH`     | Emitted counts donâ€™t sum to `N` (when integerising)                                | Stop S3 for merchant; no outputs                  |
| `ERR_S3_SEQUENCE_GAP`/`â€¦OVERFLOW` | See Â§11 sequencing errors                                                          | Stop S3 for merchant; no outputs                  |

---

## 12.10 Consumability notes (binding where stated)

* **Authority of order:** Consumers must use **`candidate_rank`** for inter-country order; file order is non-normative.
* **Priors meaning:** `base_weight_dp` are deterministic **priors**; consumers must not treat them as probabilities or re-normalise unless a later state explicitly says so.
* **Counts immutability:** If `s3_integerised_counts` is present, those counts are final for this stage and read-only downstream unless a new fingerprint changes.

---

This section gives implementers the **exact** shapes, partitions, lineage rules, and publish discipline for S3 outputs. Paired with Â§Â§8â€“11, it completes the blueprint so L0â€“L3 can be lifted directly without ambiguity.

---

# 13) Idempotence, concurrency, and skip-if-final

## 13.1 Scope (binding)

These rules apply to **all** S3 outputs defined in Â§12 (required and optional tables). They ensure **re-runs** and **parallelism** produce **byte-identical** results, with no double-writes, no order-dependence, and no cross-merchant interference. S3 uses **no RNG**.

---

## 13.2 Idempotence surface (what defines a unique result)

For a given merchant, S3â€™s outputs are a **pure function** of:

* The **Context** (Â§6.5) including `N`, `home_country_iso`, `mcc`, `channel`.
* The opened **artefacts** and **static references** listed in the BOM (Â§2), by *content bytes* (semver + digest).
* The **policy** (rule ladder) content bytes.
* The runâ€™s **lineage keys** used at write time: `parameter_hash` (partition). The manifest is recorded in the dataset-level sidecar; rows MAY embed it as `produced_by_fingerprint`.

**Idempotence rule:** Given identical inputs above, S3 **must** produce **byte-identical** rows for the same merchant (same JSON number spellings, same order guarantees, same embedded lineage).

---

## 13.3 Concurrency invariance (parallel-safe by construction)

* **Merchant independence:** Every merchantâ€™s S3 decisions depend only on that merchantâ€™s Context and the governed artefacts. No global mutable state is read or written.
* **No cross-merchant ordering effects:** Sorting/selection rules operate **within merchant** (e.g., `candidate_rank` contiguity), never across merchants.
* **Stable determinism:** Because S3 is deterministic and does not use RNG, **re-partitioning** or changing thread counts **cannot** change bytes.
* **No speculative writes:** A merchantâ€™s rows are written **only after** all its S3 steps succeed (no partial or incremental writes within S3).

---

## 13.4 Skip-if-final (at-most-one per merchant & run)

**Goal:** prevent duplicate rows when resuming or re-running the same logical work.

* Skip source: the dataset-level sidecar in the target partition (`parameter_hash`).
* Rule: If the sidecarâ€™s `manifest_fingerprint` and `dataset_digest` match the would-be output, **skip** writing (idempotent no-op). (If rows carry `produced_by_fingerprint`, you MAY sanity-check equality as a convenience.)
* Conflict rule: If rows exist for `(merchant_id, manifest_fingerprint)` but their bytes **do not** match the would-be output, this is a violation (`ERR_S3_IDEMPOTENCE_VIOLATION`) and S3 must **stop for that merchant** without publishing changes.

> Rationale: S3 tables are **parameter-scoped** in path (`parameter_hash`); the manifest is captured in the **sidecar**. Rows MAY carry `produced_by_fingerprint` as optional provenance.

---

## 13.5 Dataset-specific uniqueness (per merchant)

For the manifest named in the sidecar, the following must be unique per `merchant_id`:

* `s3_candidate_set`: keys `(country_iso)` **and** `(candidate_rank)` within a merchant block.
* `s3_base_weight_priors` (if emitted): key `(country_iso)`.
* `s3_integerised_counts` (if emitted): key `(country_iso)`; counts sum to `N`.
* `s3_site_sequence` (if emitted): key `(country_iso, site_order)` (and `(country_iso, site_id)` if present).

Any duplicate key in the same manifest is a shape error (`ERR_S3_DUPLICATE_ROW`) and must abort the merchantâ€™s publish.

---

## 13.6 Publish protocol (atomic; resume-friendly)

* **Stage â†’ fsync â†’ atomic rename.** All S3 tables follow the same publish discipline; partial files are forbidden.
* **Row grouping:** A merchantâ€™s rows **may** be appended to the same output file as other merchants (writer-side batching), but **logical uniqueness** is per keys in Â§13.5 and skip rule in Â§13.4.
* **Resume semantics:** On resume, S3 inspects the destination partition for `(merchant_id, manifest_fingerprint)`; if present and byte-identical, it **skips** emitting that merchant (no-op). If missing, it writes the rows atomically.
* **No deletions:** S3 does not delete or rewrite prior manifests; coexistence is allowed (partitioned by `parameter_hash`, distinguished by embedded `manifest_fingerprint`).

---

## 13.7 Read-side selection (downstream hygiene)

Downstream readers + Consumers assert the sidecarâ€™s `manifest_fingerprint == <current_run>`. If rows include `produced_by_fingerprint`, they MAY also filter on it; otherwise read the whole `parameter_hash` partition.

---

## 13.8 Failure vocabulary (merchant-scoped; non-emitting)

| Code                           | Trigger                                                                                           | Action                                   |
|--------------------------------|---------------------------------------------------------------------------------------------------|------------------------------------------|
| `ERR_S3_IDEMPOTENCE_VIOLATION` | Existing rows for `(merchant_id, manifest_fingerprint)` differ byte-wise from the would-be output | Stop S3 for merchant; do **not** publish |
| `ERR_S3_DUPLICATE_ROW`         | Any dataset in Â§12 detects a key duplicate within `(merchant_id, manifest_fingerprint)`           | Stop S3 for merchant; do **not** publish |
| `ERR_S3_PUBLISH_ATOMICITY`     | Writer cannot guarantee atomic rename / fsync discipline                                          | Stop S3 for merchant; do **not** publish |

---

## 13.9 Invariants (must hold)

* Re-running S3 with the **same** artefacts, parameters, and Context produces **byte-identical** rows for each merchant.
* Parallelism and partitioning **do not** affect outputs.
* For any merchant and manifest, S3 emits **at most one** logical set of rows per dataset (skip-if-final enforced); dataset-specific keys in Â§13.5 are **unique**.
* All rows embed lineage equal to the run; path partition equals embedded `parameter_hash`.

---

This locks S3â€™s operational guarantees: **deterministic**, **parallel-safe**, and **resume-safe** with clear failure shapesâ€”so implementers can scale and re-run without drift or surprises.

---

# 14) Failure signals (definition-level)

## 14.1 Scope & principles (binding)

* These failures are **definition-level**, not CI corridors. They represent **violations of the S3 spec** (inputs, ordering, shapes, lineage, determinism).
* **Non-emission rule:** On any failure below, **S3 must not publish any S3 outputs** for that merchant (no partial tables).
* **Granularity:** Failures are **merchant-scoped** unless explicitly marked **run-scoped**.
* **Evidence:** S3 may record a **merchant-scoped failure record** for operator visibility (outside S3 egress); this never relaxes the non-emission rule.

---

## 14.2 Merchant-scoped failures (authoritative list)

| Code                              | Trigger (precise)                                                                                                                | Section source | Effect                               |
|-----------------------------------|----------------------------------------------------------------------------------------------------------------------------------|----------------|--------------------------------------|
| `ERR_S3_AUTHORITY_MISSING`        | Any governed artefact in Â§2/Â§6 cannot be opened, lacks semver/digest, or the BOM is incomplete                                   | Â§6.2â€“Â§6.3      | **Stop merchant**; no S3 outputs     |
| `ERR_S3_PRECONDITION`             | `is_multi==false` or `N<2` at read time                                                                                          | Â§6.3.2         | Stop merchant; no outputs            |
| `ERR_S3_PARTITION_MISMATCH`       | For S1/S2 inputs, embedded `{seed,parameter_hash,run_id}` â‰  path partitions                                                      | Â§6.3.3         | Stop merchant; no outputs            |
| `ERR_S3_VOCAB_INVALID`            | `channelâˆ‰(ingress schemaâ€™s closed vocabulary)` or `home_country_iso` not in ISO set                                              | Â§6.3.4         | Stop merchant; no outputs            |
| `ERR_S3_RULE_LADDER_INVALID`      | Rule artefact missing `DEFAULT`, precedence not total, duplicate `rule_id`, unknown `reason_code`/`filter_tag`, or out-of-window | Â§7.3â€“Â§7.4      | Stop merchant; no outputs            |
| `ERR_S3_RULE_EVAL_DOMAIN`         | Rule predicate references an undeclared feature or named set/map                                                                 | Â§7.9           | Stop merchant; no outputs            |
| `ERR_S3_CANDIDATE_CONSTRUCTION`   | Candidate set empty **or** missing `home`                                                                                        | Â§8.6           | Stop merchant; no outputs            |
| `ERR_S3_COUNTRY_CODE_INVALID`     | Named set/list expands to a non-ISO code                                                                                         | Â§8.8           | Stop merchant; no outputs            |
| `ERR_S3_POLICY_REFERENCE_INVALID` | Fired rule references an undefined named set/list                                                                                | Â§8.8           | Stop merchant; no outputs            |
| `ERR_S3_ORDERING_HOME_MISSING`    | No row with `country_iso==home` when ranking                                                                                     | Â§9.8           | Stop merchant; no outputs            |
| `ERR_S3_ORDERING_NONCONTIGUOUS`   | Assigned **`candidate_rank`** values are not contiguous `0..\|C\|âˆ’1\`                                                            | Â§9.4â€“Â§9.8      | Stop merchant; no outputs            |
| `ERR_S3_ORDERING_KEY_UNDEFINED`   | Cannot reconstruct the **admission key** for a foreign row (no closed mapping from reasons â†’ admitting rule ids)                 | Â§9.3â€“Â§9.8      | Stop merchant; no outputs            |
| `ERR_S3_ORDERING_UNSTABLE`        | Artefact/mapping ambiguity prevents a single total order (e.g., reasons cannot map to rule ids deterministically)                | Â§9.3, Â§9.9     | Stop merchant; no outputs            |
| `ERR_S3_WEIGHT_ZERO`              | Priors enabled but `Î£ w_i^â‹„ == 0`                                                                                                | Â§10.3.A        | Stop merchant; no outputs            |
| `ERR_S3_WEIGHT_CONFIG`            | Priors enabled but policy config invalid (unknown coeff/param, or required `dp` not declared)                                    | Â§5.2, Â§12      | Stop S3 for merchant; no S3 outputs  |
| `ERR_S3_INTEGER_FEASIBILITY`      | Bounds provided but `Î£ L_i > N` or `N > Î£ U_i`                                                                                   | Â§10.6          | Stop merchant; no outputs            |
| `ERR_S3_INTEGER_SUM_MISMATCH`     | After allocation, `Î£_i count_i â‰  N`                                                                                              | Â§10.8â€“Â§12.4    | Stop merchant; no outputs            |
| `ERR_S3_INTEGER_NEGATIVE`         | Any `count_i < 0`                                                                                                                | Â§10.8          | Stop merchant; no outputs            |
| `ERR_S3_SITE_SEQUENCE_OVERFLOW`   | `count_i > 999999` when `site_id` is 6-digit                                                                                     | Â§11.4, Â§11.8   | Stop merchant; no outputs            |
| `ERR_S3_SEQUENCE_GAP`             | Missing any integer in `{1..count_i}` within a `(merchant,country)` block                                                        | Â§11.5â€“Â§11.8    | Stop merchant; no outputs            |
| `ERR_S3_SEQUENCE_DUPLICATE`       | Duplicate `site_order` (or `site_id`, if enabled) within a `(merchant,country)` block                                            | Â§11.5â€“Â§11.8    | Stop merchant; no outputs            |
| `ERR_S3_SEQUENCE_ORDER_DRIFT`     | Sequencing permutes inter-country order (contradicts Â§9 **candidate\_rank**)                                                     | Â§11.3, Â§11.9   | Stop merchant; no outputs            |
| `ERR_S3_EGRESS_SHAPE`             | Schema violation; wrong JSON types; pathâ†”embed mismatch; forbidden lineage in path; wrong fixed-dp representation                | Â§12.1â€“Â§12.6    | Stop merchant; no outputs            |
| `ERR_S3_DUPLICATE_ROW`            | Duplicate dataset key per Â§12.7 (e.g., duplicate `(candidate_rank)` or `(country_iso)`)                                          | Â§12.7          | Stop merchant; no outputs            |
| `ERR_S3_ORDER_MISMATCH`           | Emitted `s3_candidate_set` violates `candidate_rank(home)=0` or contiguity                                                       | Â§12.9          | Stop merchant; no outputs            |
| `ERR_S3_IDEMPOTENCE_VIOLATION`    | Existing rows for `(merchant_id, manifest_fingerprint)` differ byte-wise from would-be output (skip-if-final breach)             | Â§13.4          | Stop merchant; no outputs            |
| `ERR_S3_PUBLISH_ATOMICITY`        | Atomic publish discipline (stageâ†’fsyncâ†’rename) cannot be guaranteed                                                              | Â§13.6          | Stop merchant; no outputs            |

**Effect (all rows):** **no S3 tables** are published for that merchant in this run/fingerprint. Downstream must not see partial S3 state.

---

## 14.3 Run-scoped failures (rare; binding)

Run-scoped failures abort the **entire S3 run** (all merchants).

| Code                              | Trigger                                                                                                   | Effect                         |
|-----------------------------------|-----------------------------------------------------------------------------------------------------------|--------------------------------|
| `ERR_S3_SCHEMA_AUTHORITY_MISSING` | `schemas.layer1.yaml` (authoritative) is unavailable or inconsistent **(or the optional index, if used)** | **Abort run**; publish nothing |
| `ERR_S3_DICTIONARY_INCONSISTENT`  | Dataset dictionary cannot resolve required IDs or partitions for S3                                       | Abort run                      |
| `ERR_S3_BOM_INCONSISTENT`         | BOM claims artefacts that cannot be opened atomically across the run                                      | Abort run                      |

> Prefer merchant-scoped failure whenever the issue is isolated to a merchant; use run-scoped only for global authority problems.

---

## 14.4 Non-emission & logging contract (binding)

* **Non-emission:** On any failure above, S3 writes **no S3 datasets** for that merchant.
* **Logging:** A merchant-scoped failure **may** be recorded to an operator log with `{merchant_id, manifest_fingerprint, code, message, ts_utc}`; this log is **not** part of S3 egress.
* **No retries inside S3:** S3 does not auto-retry/auto-correct; recovery is orchestration policy.

---

## 14.5 Determinism & idempotence under failure

* Failures are **deterministic** given the same inputs; re-running with the same `parameter_hash` and artefacts must yield the **same** failure code.
* Skip-if-final (Â§13.4) applies only to **successful** publishes; on failure, there are **no** S3 rows to skip.

---

## 14.6 Consumer expectations (downstream hygiene)

* Downstream states **must not** infer intent from absence of S3 rows; orchestration should provide an explicit succeeded/failed roster.
* Consumers **must** assert the sidecarâ€™s `manifest_fingerprint` equals the intended run; they MAY also filter rows by `produced_by_fingerprint == <run.manifest_fingerprint>` if present. **Do not** join across fingerprints.

---

## 14.7 Mapping index (where each failure originates)

* **Â§5.2 / Â§12 (Priors config):** `WEIGHT_CONFIG`
* **Â§6 (Load scopes):** `AUTHORITY_MISSING`, `PRECONDITION`, `PARTITION_MISMATCH`, `VOCAB_INVALID`
* **Â§7 (Rule ladder):** `RULE_LADDER_INVALID`, `RULE_EVAL_DOMAIN`
* **Â§8 (Candidates):** `CANDIDATE_CONSTRUCTION`, `COUNTRY_CODE_INVALID`, `POLICY_REFERENCE_INVALID`
* **Â§9 (Ordering):** `ORDERING_HOME_MISSING`, `ORDERING_NONCONTIGUOUS`, `ORDERING_KEY_UNDEFINED`, `ORDERING_UNSTABLE`
* **Â§10 (Integerisation):** `WEIGHT_ZERO`, `INTEGER_FEASIBILITY`, `INTEGER_SUM_MISMATCH`, `INTEGER_NEGATIVE`
* **Â§11 (Sequencing/IDs):** `SITE_SEQUENCE_OVERFLOW`, `SEQUENCE_GAP`, `SEQUENCE_DUPLICATE`, `SEQUENCE_ORDER_DRIFT`
* **Â§12 (Emissions):** `EGRESS_SHAPE`, `DUPLICATE_ROW`, `ORDER_MISMATCH`
* **Â§13 (Ops):** `IDEMPOTENCE_VIOLATION`, `PUBLISH_ATOMICITY`
* **Run-scoped (Â§14.3):** `SCHEMA_AUTHORITY_MISSING`, `DICTIONARY_INCONSISTENT`, `BOM_INCONSISTENT`

---

This is a **closed catalogue** of S3 failure shapes with crisp triggers and effects, so implementations cannot drift on error handling and L3 can validate outcomes unambiguously.

---

# 15) Handoff to S4+

## 15.1 Scope (binding)

This section defines **how downstream states (S4+)** must consume S3 outputs. It is the only authority for:

* which S3 datasets to read,
* the **join keys** and **filters**,
* what fields are **binding** vs **illustrative**, and
* what downstream must **never** reinterpret.

Downstream may not infer semantics outside what is stated here.

---

## 15.2 What downstream must read

### 15.2.1 Required dataset (always)

| Dataset id         | Purpose                                                 | Filter (must)                                                                                                                                     | Ordering (must)                                                                       | Keys for joins               |
|--------------------|---------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------|------------------------------|
| `s3_candidate_set` | Inter-country **order of record** + policy tags/reasons | Partition by `parameter_hash`; MAY filter `produced_by_fingerprint == <this run>` if present; always assert the sidecarâ€™s `manifest_fingerprint`. | **Order by `(merchant_id ASC, candidate_rank ASC, country_iso ASC)`**; home at rank 0 | `(merchant_id, country_iso)` |

**Binding:** **`candidate_rank`** is the **sole** authority for inter-country order.

### 15.2.2 Optional datasets (present only if S3 owns them)

| Dataset id              | Purpose                                                        | Filter (must)        | Keys                                       |
|-------------------------|----------------------------------------------------------------|----------------------|--------------------------------------------|
| `s3_base_weight_priors` | Deterministic **priors** (fixed-dp strings), not probabilities | same filter as above | `(merchant_id, country_iso)`               |
| `s3_integerised_counts` | **Final integer counts** per country (sum to `N`)              | same filter as above | `(merchant_id, country_iso)`               |
| `s3_site_sequence`      | Within-country **site\_order** (and optional `site_id`)        | same filter as above | `(merchant_id, country_iso[, site_order])` |

> If an optional dataset is **not** produced by S3, downstream must not invent or guess it. The later state that owns it must produce it under its own spec.

---

## 15.3 Consumer recipe (minimal, closed)

### 15.3.1 Recover the ordered country list (always)

1. Select `s3_candidate_set` where `parameter_hash = <run.parameter_hash>`.
2. MAY filter `produced_by_fingerprint == <run.manifest_fingerprint>` if present; always assert the sidecarâ€™s `manifest_fingerprint`.
3. For each merchant, read rows ordered by `(candidate_rank ASC, country_iso ASC)`.
4. **Home row:** exactly one row with `candidate_rank == 0` and `is_home == true`.

Outcome: `âŸ¨country_iso[0..M-1]âŸ©` with `country_iso[0] == home`.

### 15.3.2 If deterministic priors are present

* Read `s3_base_weight_priors.base_weight_dp` as a **score only** (fixed-dp string).
* Do **not** normalise to probabilities unless a later state explicitly requires it.

### 15.3.3 If integerised counts are present

* Join `s3_integerised_counts` on `(merchant_id, country_iso)` to get `count`.
* Trust `Î£_i count_i = N`; **do not recompute**. Treat counts as **final** for this stage.

### 15.3.4 If site sequencing is present

* Join `s3_site_sequence` on `(merchant_id, country_iso)`; rows sorted by `(country_iso, site_order)`.
* Within a country, `site_order` is **contiguous** `1..count_i`.
* If `site_id` exists, it is a **6-digit zero-padded string**; do not change format.

---

## 15.4 What downstream must **not** reinterpret (binding)

* **Inter-country order:** must come **only** from `candidate_rank`. Do not use file order or lexicographic `country_iso`.
* **Priors:** `base_weight_dp` are deterministic **priors**, not probabilities; do not normalise or rescale unless a later state says so.
* **Counts:** if `s3_integerised_counts` exists, counts are **final** for this stage; do not re-integerise or change bump policy.
* **Sequencing:** if `s3_site_sequence` exists, within-country order/IDs are binding; do not renumber or reformat IDs.
* **Policy evidence:** `reason_codes`/`filter_tags` are from **closed vocabularies**; do not remap outside a documented consumer map.

---

## 15.5 Lineage & selection (consumer hygiene)

Consumers **must**:

* read the partition `parameter_hash = <run.parameter_hash>`, and
* **assert** the sidecarâ€™s `manifest_fingerprint == <run.manifest_fingerprint>`.

They MAY also filter rows by `produced_by_fingerprint == <run.manifest_fingerprint>` if present.

Do not join across **different fingerprints** unless explicitly implementing a multi-manifest analysis tool (out of scope here).

---

## 15.6 Allowed consumer transforms (safe)

* **Projection:** select a subset of columns.
* **Join:** equi-joins on keys in Â§15.2/Â§15.3.
* **Filtering:** by `merchant_id`, `candidate_rank` ranges, or `country_iso` subsets.
* **Stable sorting:** re-sorts that **do not** contradict `candidate_rank` (e.g., group by region but preserve `candidate_rank` within groups).

Any transform that would change `candidate_rank`, `count`, `site_order`, `site_id` format, or the fixed-dp representation of `base_weight_dp` is **not allowed** unless a later stateâ€™s spec explicitly authorises it.

---

## 15.7 Variant matrix (S3 configuration â†’ consumer expectations)

| S3 config                                       | candidate\_set | base\_weight\_priors | counts | sequencing | Consumer expectation                                                  |
|-------------------------------------------------|----------------|----------------------|--------|------------|-----------------------------------------------------------------------|
| **A**: order-only                               | âœ…              | âŒ                    | âŒ      | âŒ          | Consumer uses **`candidate_rank`** only.                              |
| **B**: order + priors                           | âœ…              | âœ…                    | âŒ      | âŒ          | Use `base_weight_dp` as deterministic **prior**; do not normalise.    |
| **C**: order + counts                           | âœ…              | âŒ                    | âœ…      | âŒ          | Use `count` as final; no integerisation downstream.                   |
| **D**: order + counts + sequencing              | âœ…              | âŒ                    | âœ…      | âœ…          | Read `site_order`/`site_id` as binding within country.                |
| **E**: order + priors + counts (+/âˆ’ sequencing) | âœ…              | âœ…                    | âœ…      | Â±          | Join by keys; priors are scores; counts final; sequencing if present. |

---

## 15.8 Failure surface for consumers (must stop)

A downstream consumer **must** treat these as **fatal** (merchant- or run-scoped per its own policy):

* Missing `s3_candidate_set` rows for the intended fingerprint.
* No `candidate_rank == 0` home row or duplicate `candidate_rank` within a merchant block.
* Present but malformed optional datasets (schema/type mismatches).
* Inconsistent priors (if duplicated elsewhere) or `Î£ count â‰  N` (should not happen if S3 is green).
* Path/lineage inconsistencies (enforce Â§12/Â§13 read-side hygiene).

---

## 15.9 Forward-compat & evolution (practical guardrails)

* **Adding columns** to S3 tables requires a **schema semver bump** and backward-compatible defaults (or fields marked optional).
* **Changing dp** for priors requires a policy/artefact bump and thus a new `parameter_hash` (and new fingerprint).
* **Changing ID format** (e.g., `site_id`) requires a new schema version and migration note; until then, the 6-digit string is binding.

---

## 15.10 Consumer â€œgreenâ€ checklist (quick)

* [ ] Filter by `parameter_hash`; **assert the sidecarâ€™s `manifest_fingerprint`**; MAY filter `produced_by_fingerprint` if present.
* [ ] Use **`candidate_rank`** as the only inter-country order.
* [ ] If priors exist: treat as deterministic scores (fixed-dp strings).
* [ ] If counts exist: treat as final; sum equals S2 `N`.
* [ ] If sequencing exists: `site_order` contiguous; `site_id` 6-digit string.
* [ ] Do not reinterpret tags/reasons; closed vocabularies only.
* [ ] No cross-fingerprint joins unless expressly required.

---

This handoff locks the **consumer contract** so S4+ can plug in with zero guesswork, zero reinterpretation, and guaranteed reproducibility.

---

# 16) Governance & publish

## 16.1 Scope (binding)

Fixes **how S3 is governed and published**: what must be opened and pinned, how lineage is formed, how outputs are staged and atomically committed, and what constitutes a valid publish. Applies to **all S3 datasets** defined in Â§12.

---

## 16.2 Artefact closure (BOM must be complete)

* S3 **may only** open artefacts explicitly listed in the BOM (Â§2).
* **Atomic open:** all governed artefacts (Â§2.1) are opened **before** any S3 processing starts. A missing/changed artefact after S3 begins is `ERR_S3_AUTHORITY_MISSING` (merchant-scoped stop).
* **No late opens:** later S3 steps **must not** open artefacts beyond Â§2.

---

## 16.3 Lineage keys (definitions & scope)

* **`parameter_hash` (path partition)** â€” hash of **parameter artefacts only** that affect S3 semantics (e.g., `policy.s3.rule_ladder.yaml`, `policy.s3.base_weight.yaml`, integerisation bounds). Changing any such parameter **changes the partition**.
* **`manifest_fingerprint` (run manifest, in sidecar)** â€” composite derived from **all opened artefacts** (BOM closure), **parameter bytes**, and code/commit identity (project-defined). Any byte change flips the fingerprint.
* **No `seed` in S3 paths:** S3 outputs are **parameter-scoped**; `seed` appears only as an embedded lineage field if carried for joins.

**Binding equality:** every emitted row **embeds** `parameter_hash` that **byte-equals** the path partition. If present, row `produced_by_fingerprint` **equals** the runâ€™s manifest. The manifest itself is always recorded in the dataset-level sidecar (Â§12.1/Â§12.6).

---

## 16.4 Versioning & change policy

* **SemVer on artefacts:** governed artefacts carry semantic versions. Backward-compatible additions (that donâ€™t change outcomes) may bump patch/minor. Any change that *can* alter S3 outputs **must** bump minor/major and will flip both `parameter_hash` and `manifest_fingerprint`.
* **Closed vocab drift:** adding/changing a `reason_code` / `filter_tag` / `rule_id` is *governed*; bump policy version and expect lineage flips.
* **Schema evolution:** any column addition/removal/type change is a **schema semver bump**; see consumer guidance in Â§15.9.

---

## 16.5 Publish protocol (atomic; resume-safe)

* **Resolution:** writers resolve dataset **IDs** to paths using the **dataset dictionary** (no literals).
* **Stage â†’ fsync â†’ atomic rename:** write to a staging area on the same filesystem, fsync, then atomically rename into `parameter_hash=â€¦`.
* **All-or-nothing per dataset:** for a merchant, either the complete row-set for that dataset is present **byte-identical** to computed rows, or nothing is written. Partials are forbidden.
* **Skip-if-final:** before writing, check for existing rows for `(merchant_id, manifest_fingerprint)` in the target partition. If present and **byte-identical**, **skip** (idempotent no-op). If present but bytes differ â‡’ `ERR_S3_IDEMPOTENCE_VIOLATION` (no publish).
* **No deletes:** S3 never deletes prior manifests. Multiple manifests may coexist under the same `parameter_hash`; selection is via `manifest_fingerprint` (Â§15.5).

---

## 16.6 Partitioning & embedded lineage (write-side checks)

For every emitted dataset:

* **Partition:** `parameter_hash` only (no `seed`, no `run_id` in the path).
* **Embed:** each row embeds `parameter_hash` (**equals** the path partition). If present, `produced_by_fingerprint` **equals** the runâ€™s manifest fingerprint.
* **Types:** lineage fields are **lowercase Hex64** strings; payload numbers are JSON **numbers**; fixed-dp priors are JSON **strings**.

Mismatch â‡’ **`ERR_S3_EGRESS_SHAPE`** and blocks publish for that merchant.

---

## 16.7 Governance attest (minimal, binding)

At publish time S3 must retain (operator audit; **outside S3 egress**):

* the **BOM snapshot** used (artefact ids, semver, digests),
* the **dictionary version** used to resolve paths, and
* the **schema authority/version** (`schemas.layer1.yaml`) and, if used, the **schema index** version.

---

## 16.8 Licence & provenance (must be auditable)

* Every external static reference (e.g., ISO list) must have recorded **licence** and **provenance** (Â§2.7).
* If licence constraints limit redistribution, embed **digests** and refer to artefacts by **id/version** (not copies).

---

## 16.9 Operator-visible publish receipt (optional; non-egress)

Optionally record a **publish receipt** per merchant (outside S3 datasets) with:

* `merchant_id`, `manifest_fingerprint`, `parameter_hash`, dataset ids written, row counts, and `ts_utc`.
  This improves observability only; presence/absence does **not** alter S3 semantics.

---

## 16.10 Run gating & dependencies (what S3 requires before start)

* **Schema authority present:** `schemas.layer1.yaml` containing all `#/s3/*` anchors is available and consistent; the **schema index** (if used) is also consistent.
* **Dictionary present:** required dataset IDs/partitions resolve.
* **BOM complete:** governed artefacts can be opened atomically.

Violation of any of the above is **run-scoped** failure (Â§14.3): `ERR_S3_SCHEMA_AUTHORITY_MISSING`, `ERR_S3_DICTIONARY_INCONSISTENT`, or `ERR_S3_BOM_INCONSISTENT`.

---

## 16.11 Governance â€œgreenâ€ checklist (tick before publish)

* [ ] All governed artefacts from Â§2.1 opened **before** processing; no late opens.
* [ ] `parameter_hash` reflects all **parameter** artefacts; `manifest_fingerprint` reflects **all opened artefacts + parameters + code id**.
* [ ] All datasets resolved via the **dictionary**; **no path literals**.
* [ ] Partition and embedded lineage **match** (byte-equal).
* [ ] Skip-if-final performed; no duplicate logical writes.
* [ ] Atomic stageâ†’fsyncâ†’rename completed without error.
* [ ] Optional receipts/attestations captured for operator audit.

---

## 16.12 Invariants (must hold)

* Given identical Context and artefact bytes, two S3 publishes produce **byte-identical** outputs.
* Re-partitioning or concurrency does **not** change outputs (no RNG; deterministic rules).
* For any dataset and merchant, there exists **at most one** logical row-set per `(manifest_fingerprint)`; duplicates are prevented by skip-if-final.
* All S3 outputs are parameter-scoped in path and carry embedded lineage equal to the run.

---

This governance & publish contract keeps S3 **reproducible**, **auditable**, and **operator-safe**â€”so implementersâ€™ bytes are accepted or rejected in a predictable, deterministic way.

---

# 17) Worked micro-examples (illustrative)

These are **non-normative** sanity checks that show how the spec behaves on small inputs. Shapes and numbers are **illustrative** only; the **normative** behavior is in Â§Â§6â€“16. All paths resolve via the **dataset dictionary**; examples show **logical rows** only.

---

## 17.1 Minimal â€œallowâ€ example â€” order + priors + integerisation

**Context.**
Merchant `m=123456789`, `home=GB`, `N=7` (from S2). Rule ladder fires `ALLOW_WHITELIST` (decision source) and `LEGAL_OK`; cross-border **eligible**.

**Candidate universe (Â§8).**
`C = { GB, DE, FR }`, each row tagged (closed vocab):

* `reason_codes`: `["ALLOW_WHITELIST","LEGAL_OK"]` (Aâ†’Z),
* `filter_tags`: `["GEO_OK"]` plus `"HOME"` for GB.

**Priors enabled (Â§12, dp=6).**
Deterministic priors are computed and **quantised** (RNE, binary64):

| country | conceptual `w_i` | **emitted** `w_i^â‹„` (fixed-dp string) |
|:-------:|-----------------:|--------------------------------------:|
|   GB    |           0.275â€¦ |                          `"0.275000"` |
|   DE    |           0.180â€¦ |                          `"0.180000"` |
|   FR    |           0.120â€¦ |                          `"0.120000"` |

Sum of quantised priors = `0.575000`.

**Ordering (Â§9 â€” ranking is independent of priors).**
`candidate_rank(GB)=0`. For foreigns, the **admission key** (precedenceâ†’priorityâ†’rule\_id) ties; break by **ISO Aâ†’Z**: `DE` before `FR`.
Final order: `GB(0) â†’ DE(1) â†’ FR(2)`.

**Integerisation (Â§10, dp\_resid=8).**
Use quantised priors for shares: `a_i = N * w_i^â‹„ / Î£ w^â‹„`.

* GB: `7*(0.275/0.575)=3.348â€¦` â†’ `b=3`, `r=0.348â€¦`
* DE: `7*(0.180/0.575)=2.191â€¦` â†’ `b=2`, `r=0.191â€¦`
* FR: `7*(0.120/0.575)=1.460â€¦` â†’ `b=1`, `r=0.460â€¦`
  Remainder `d = 7 âˆ’ (3+2+1) = 1`. Quantise residuals to **8 dp**; bump highest (`FR`) by +1.

**Final counts & residual ranks.**

* `GB: 3` (residual\_rank=2)
* `DE: 2` (residual\_rank=3)
* `FR: 2` (residual\_rank=1)
  Sum = 7 = `N`. **`candidate_rank` unchanged.**

**Illustrative rows (egress; Â§12).**

*`s3_candidate_set` (subset):*

```json
{ "merchant_id": 123456789, "country_iso": "GB", "candidate_rank": 0, "is_home": true,
  "reason_codes": ["ALLOW_WHITELIST","LEGAL_OK"], "filter_tags": ["GEO_OK","HOME"],
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "DE", "candidate_rank": 1, "is_home": false,
  "reason_codes": ["ALLOW_WHITELIST","LEGAL_OK"], "filter_tags": ["GEO_OK"],
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "FR", "candidate_rank": 2, "is_home": false,
  "reason_codes": ["ALLOW_WHITELIST","LEGAL_OK"], "filter_tags": ["GEO_OK"],
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
```

*`s3_base_weight_priors`:*

```json
{ "merchant_id": 123456789, "country_iso": "GB", "base_weight_dp": "0.275000", "dp": 6,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "DE", "base_weight_dp": "0.180000", "dp": 6,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "FR", "base_weight_dp": "0.120000", "dp": 6,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
```

*`s3_integerised_counts`:*

```json
{ "merchant_id": 123456789, "country_iso": "GB", "count": 3, "residual_rank": 2,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "DE", "count": 2, "residual_rank": 3,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "FR", "count": 2, "residual_rank": 1,
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
```

*(If S3 also owns sequencing; Â§11):*

```json
{ "merchant_id": 123456789, "country_iso": "FR", "site_order": 1, "site_id": "000001",
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
{ "merchant_id": 123456789, "country_iso": "FR", "site_order": 2, "site_id": "000002",
  "parameter_hash": "ab12...ef", "produced_by_fingerprint": "cd34...90" }
```

**Quick checks.**
`candidate_rank(home)=0`; ranks contiguous; priors are fixed-dp strings but **not used for ranking**; residuals use **dp\_resid=8**; counts sum to `N`; lineage embeds match partition.

---

## 17.2 Tie-heavy example â€” no priors, ISO tiebreak

**Context.**
Merchant `m=555`, `home=US`, `N=5`. Ladder admits `{CA, CH}` under the same admit rule, so admission keys tie.

**Candidate universe (Â§8).**
`C = { US, CA, CH }`; unioned `reason_codes` equal across CA/CH.

**Ordering (Â§9).**
Home gets `candidate_rank=0`. Foreigns tie on admission key; break by **ISO Aâ†’Z** â†’ `CA` then `CH`.
Final order: `US(0) â†’ CA(1) â†’ CH(2)`.

**Integerisation (equal-weights; Â§10).**
`M=3`; `a_i = 5/3 = 1.666â€¦`. Floors `[1,1,1]`, remainder `d=2`.
Residuals equal; ISO tiebreak bumps `CA` then `CH`.
Counts: `US=1`, `CA=2`, `CH=2`; residual ranks: `CA:1`, `CH:2`, `US:3`.

*`s3_integerised_counts`:*

```json
{ "merchant_id": 555, "country_iso": "US", "count": 1, "residual_rank": 3,
  "parameter_hash": "aa00...11", "produced_by_fingerprint": "bb22...33" }
{ "merchant_id": 555, "country_iso": "CA", "count": 2, "residual_rank": 1,
  "parameter_hash": "aa00...11", "produced_by_fingerprint": "bb22...33" }
{ "merchant_id": 555, "country_iso": "CH", "count": 2, "residual_rank": 2,
  "parameter_hash": "aa00...11", "produced_by_fingerprint": "bb22...33" }
```

**Quick checks.**
Ties resolved by ISO; **`candidate_rank`** is the authority; counts sum to `N`; `residual_rank` reconstructs bump set `{CA,CH}`.

---

## 17.3 No-foreign example â€” deny cross-border

**Context.**
Merchant `m=777`, `home=AE`, `N=4`. Ladderâ€™s `DENY_SANCTIONED` (decision source) yields `eligible_crossborder=false`.

**Candidate universe (Â§8).**
`C = { AE }` only; `K_foreign=0`.

**Ordering (Â§9).**
Trivial: `candidate_rank(AE)=0`.

**Integerisation (Â§10).**
If S3 owns counts: `count(AE) = 4`. No residuals (single row).

*Illustrative rows:*

```json
{ "merchant_id": 777, "country_iso": "AE", "candidate_rank": 0, "is_home": true,
  "reason_codes": ["DENY_SANCTIONED"], "filter_tags": ["HOME"],
  "parameter_hash": "fe98...76", "produced_by_fingerprint": "dc54...32" }
```

```json
{ "merchant_id": 777, "country_iso": "AE", "count": 4, "residual_rank": 1,
  "parameter_hash": "fe98...76", "produced_by_fingerprint": "dc54...32" }
```

**Quick checks.**
Candidate set non-empty with `home`; **`candidate_rank(home)=0`**; counts (if present) sum to `N`.

---

## 17.4 Edge case with bounds â€” bounded Hamilton (optional)

**Context.**
Merchant `m=888`, `home=GB`, `N=6`, candidates `{GB, IE, NL}` with fixed-dp priors (`dp=6`):
`"0.500000"`, `"0.300000"`, `"0.200000"`. Bounds: `L = {1,0,0}`, `U = {6,3,3}`.

**Step 1 (floor to L).** `b = {1,0,0}`, remaining `Nâ€²=5`, capacities `{5,3,3}`.
**Step 2 (shares over cap>0).** Same priors; `aâ€² = 5 * {0.5,0.3,0.2} = {2.5,1.5,1.0}` â†’ `f = {2,1,1}` (cap-limited), `dâ€² = 5 âˆ’ 4 = 1`.
**Step 3 (residuals, dp\_resid=8).** Residuals `{0.5,0.5,0.0}` â†’ ISO tiebreak: `GB` before `IE`. Bump `GB` by +1.
**Final counts.** `GB=1+2+1=4`, `IE=0+1=1`, `NL=0+1=1` (within bounds; sum=6).

*`s3_integerised_counts`:*

```json
{ "merchant_id": 888, "country_iso": "GB", "count": 4, "residual_rank": 1,
  "parameter_hash": "1357...9b", "produced_by_fingerprint": "2468...ac" }
{ "merchant_id": 888, "country_iso": "IE", "count": 1, "residual_rank": 2,
  "parameter_hash": "1357...9b", "produced_by_fingerprint": "2468...ac" }
{ "merchant_id": 888, "country_iso": "NL", "count": 1, "residual_rank": 3,
  "parameter_hash": "1357...9b", "produced_by_fingerprint": "2468...ac" }
```

**Quick checks.**
Feasibility ok; `L_i â‰¤ count_i â‰¤ U_i`; ISO tiebreak visible; sum equals `N`.

---

## 17.5 â€œGreenâ€ checklist for examples (what to verify quickly)

* [ ] **`candidate_rank(home)=0`**; ranks contiguous; no duplicate `country_iso`.
* [ ] If priors shown: fixed-dp **strings**; **ranking never uses priors** (priors affect integerisation only).
* [ ] Integerisation: residuals computed **after** dp; **`dp_resid=8`**; ties by ISO; counts sum to `N`.
* [ ] `residual_rank` present for **every** row when counts are emitted.
* [ ] Embedded lineage present: `parameter_hash` matches the path; if present, `produced_by_fingerprint` matches the run; sidecarâ€™s `manifest_fingerprint` asserted.
* [ ] No event streams (S3 uses none); only tables per Â§12.

---

*End of illustrative examples.*

---

# 18) Validator proof obligations (what L3 will re-derive)

## 18.1 Scope (binding)

* L3 is **read-only**. It **does not** mutate S3 outputs or produce S3 datasets.
* L3 **re-derives** the deterministic facts S3 promised in Â§Â§6â€“16 and either:
  â€¢ emits a **PASS** (run-scoped receipt outside S3 egress), or
  â€¢ raises the **precise** failure code(s) in Â§14 (merchant-scoped unless marked run-scoped).
* **No RNG**, no time dependence, no host state.

---

## 18.2 Inputs L3 must read (authoritative)

* **Schema authority & dictionary** (run-scoped gate): `schemas.layer1.yaml` containing all `#/s3/*` anchors; **optional** schema index if used; dataset dictionary resolving all S3 IDs.
* **Governed artefacts** listed in the S3 BOM (Â§2): `policy.s3.rule_ladder.yaml`, `iso3166_canonical_2024`, and any optional policy bundles (priors, bounds).
* **S3 datasets (egress)** for the target `parameter_hash`, MAY filter by `produced_by_fingerprint == <this run>` if present; otherwise read the whole `parameter_hash` partition (selection is parameter-scoped):
  `s3_candidate_set` (required); and optionally `s3_base_weight_priors`, `s3_integerised_counts`, `s3_site_sequence`.
* **Upstream evidence (read-only)** for cross-checks: S1 `hurdle_bernoulli` (gate) and S2 `nb_final` (for **N only**) for the same `{seed, parameter_hash, run_id}`.

*(All locations resolve via the dictionary; no literal paths.)*

---

## 18.3 What L3 must *never* do

* Must **not** â€œfixâ€ data, interpolate, or re-emit S3 rows.
* Must **not** derive features not declared in Â§Â§2/6.
* Must **not** treat file order as semantic; only specâ€™d keys/order count.

---

## 18.4 Proof obligations (per merchant unless stated)

> Ordered **shape â†’ lineage â†’ order/math â†’ cross-dataset coherence**. Each item cites the failure code on breach.

### V1 â€” Schema & JSON typing (shape)

* Every S3 row conforms to its **JSON-Schema** (Â§12).
* Numeric payload fields are JSON **numbers**; fixed-dp priors (if present) are JSON **strings** with exactly `dp` places.
  â†’ `ERR_S3_EGRESS_SHAPE`.

### V2 â€” Partition â†” embed equality (lineage)

* Embedded `parameter_hash` equals the **path partition**.
* If present, row `produced_by_fingerprint` equals the run fingerprint; otherwise the dataset-level sidecar carries the manifest used for selection.
* S3 paths contain **no `seed`**.
  â†’ `ERR_S3_EGRESS_SHAPE`.

### V3 â€” Gating & presence

* Join to S1: merchants with `is_multi==false` have **no S3 rows**.
* Join to S2: merchants used by S3 have exactly one `nb_final` with **`N â‰¥ 2`**.
  â†’ `ERR_S3_PRECONDITION`.

### V4 â€” Candidate coverage & uniqueness

* `s3_candidate_set` exists; includes **exactly one** home row; **no duplicate** `(country_iso)`; all `country_iso âˆˆ ISO`.
  â†’ `ERR_S3_CANDIDATE_CONSTRUCTION` or `ERR_S3_COUNTRY_CODE_INVALID`.

### V5 â€” Rank law (total order)

* Per merchant, **`candidate_rank`** is **contiguous** `0..|C|âˆ’1`; exactly one row has `candidate_rank==0` and `is_home==true`.
  â†’ `ERR_S3_ORDERING_NONCONTIGUOUS` or `ERR_S3_ORDERING_HOME_MISSING`.

### V6 â€” Ordering proof (primary key = admission order key)

* Reconstruct each foreign rowâ€™s **admission key** from the artefactâ€™s **closed mapping** (row `reason_codes[]` â†’ admitting rule id(s)), then compute:

  ```
  K(r) = âŸ¨ precedence_rank(r), priority(r), rule_id_ASC âŸ©
  Key1(i) = min_lex { K(r) : r âˆˆ AdmitRules(i) }
  ```
* Sort foreign rows by `Key1` â†’ ISO Aâ†’Z; pin `home â†’ candidate_rank=0`. The resulting order must match **`candidate_rank`**.
  â†’ `ERR_S3_ORDERING_KEY_UNDEFINED` (cannot reconstruct key) or `ERR_S3_ORDERING_UNSTABLE` (mismatch).

### V7 â€” Priors surface (if present)

* If `s3_base_weight_priors` exists:
  â€¢ `base_weight_dp` parses as a fixed-dp decimal; **dp is constant within the run**.
  â€¢ Values are deterministic strings; no duplicate `(merchant_id,country_iso)`.
  *(No equality check vs candidate\_set â€” priors live **only** here.)*
  â†’ `ERR_S3_EGRESS_SHAPE`.

### V8 â€” Integerisation reconstruction (if counts present)

* From S2 **N** and Â§10 policy:
  â€¢ If priors exist: use **quantised** `w_i^â‹„` (from `base_weight_dp`) for shares; else equal shares.
  â€¢ Compute `a_i`, floors `b_i`, remainder `d`, residuals `r_i`; **quantise residuals to `dp_resid=8`**; apply bump rule (residual DESC â†’ ISO Aâ†’Z â†’ `candidate_rank` â†’ stability).
  â€¢ Reconstruct `count_i`; verify **`Î£ count_i = N`**, `count_i â‰¥ 0`; and `residual_rank` matches the bump order for **all** rows.
  â†’ `ERR_S3_INTEGER_SUM_MISMATCH`, `ERR_S3_INTEGER_NEGATIVE`.

### V9 â€” Bounds (optional policy)

* If `(L_i,U_i)` are declared: verify `Î£ L_i â‰¤ N â‰¤ Î£ U_i` and `L_i â‰¤ count_i â‰¤ U_i`.
  â†’ `ERR_S3_INTEGER_FEASIBILITY`.

### V10 â€” Sequencing (if S3 emits it)

* For each `(merchant_id,country_iso)` in `s3_site_sequence`:
  â€¢ `site_order` is **exactly** `1..count_i` (use counts if present; else check contiguity alone).
  â€¢ If `site_id` present: **6-digit zero-padded string**; uniqueness within the block.
  â€¢ Every `(merchant_id,country_iso)` also appears in `s3_candidate_set`.
  â†’ `ERR_S3_SEQUENCE_GAP`, `ERR_S3_SEQUENCE_DUPLICATE`, or `ERR_S3_SITE_SEQUENCE_OVERFLOW`.

### V11 â€” Cross-dataset coherence

* Keys align across datasets (where present): `candidate_set` â†” `base_weight_priors` â†” `integerised_counts` â†” `site_sequence`.
* No extra countries appear in optional tables that are absent from `candidate_set`.
  â†’ `ERR_S3_EGRESS_SHAPE`.

### V12 â€” Dataset-specific uniqueness (write-side)

* Enforce Â§12.7 uniqueness:
  `candidate_set`: unique `(country_iso)` **and** `(candidate_rank)`;
  `base_weight_priors`: unique `(country_iso)`;
  `integerised_counts`: unique `(country_iso)`;
  `site_sequence`: unique `(country_iso, site_order)` (and `(country_iso, site_id)` if present).
  â†’ `ERR_S3_DUPLICATE_ROW`.

### V13 â€” Idempotence surface (semantic)

* Re-compute a **content hash** of each merchantâ€™s would-be rows from artefacts+Context to demonstrate outputs are a pure function (no dependency on file order/concurrency/host).
* If the same `(merchant_id, manifest_fingerprint)` already exists and bytes **differ**, classify as idempotence breach.
  â†’ `ERR_S3_IDEMPOTENCE_VIOLATION`.

### V14 â€” Publish discipline (run-scoped sanity)

* Stageâ†’fsyncâ†’atomic rename in use; no partials; no forbidden lineage in paths.
  â†’ `ERR_S3_PUBLISH_ATOMICITY` (run-scoped) or `ERR_S3_EGRESS_SHAPE` (lineage/path issues).

---

## 18.5 Non-emission confirmation

On any merchant-scoped failure above, **no S3 tables** for that merchant are valid for this fingerprint. L3 treats the merchant as **failed** and excludes them from PASS.

---

## 18.6 PASS criteria (per merchant and run)

A merchant **PASS** iff **all** applicable obligations V1â€“V12 succeed.
The run **PASS** iff:

* all merchants PASS, and
* V14 (publish discipline) holds.

*(L3 may publish a small PASS/FAIL receipt outside S3 egress; content & location are governance-side and non-normative.)*

---

## 18.7 Validator â€œgreenâ€ checklist (quick)

* [ ] All S3 rows conform to schemas; JSON numbers/strings as specified.
* [ ] Path partitions = embedded lineage; no `seed` in paths.
* [ ] Candidate coverage: non-empty; unique countries; home present.
* [ ] **`candidate_rank`** contiguous; `candidate_rank(home)=0`.
* [ ] Ordering proof matches (admission-key path).
* [ ] If priors present: fixed-dp strings; **dp constant** within run.
* [ ] If counts present: sum to **N**; `residual_rank` reconstructs bumps (`dp_resid=8`); bounds respected (if any).
* [ ] If sequencing present: contiguous `site_order`; 6-digit `site_id`; keys coherent.
* [ ] Dataset-specific uniqueness holds.
* [ ] No idempotence/publish breaches detected.

---

With these obligations, L3 can **mechanically** prove S3 kept its promisesâ€”no RNG, no ambiguity, byte-replayable ordering & integerisation, correct lineage, and run-safe publishingâ€”so downstream can rely on S3 without surprises.

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s4-expanded"></a>
# state.1A.s4.expanded.txt

<!-- Source file: state.1A.s4.expanded.txt | BYTE-EXACT EMBED -->

# S4 â€” Foreign-country count **K (target)** via Zero-Truncated Poisson (ZTP), logs-only producer


## 0) Document contract & status

**Master spec.** This document is **normative** for S4. Any pseudocode shown here is **illustrative** only; the definitive, language-agnostic build guidance must **derive** from this spec.

**Schema authority.** For 1A, **JSON-Schema is the single schema authority**; registry/dictionary entries point only to `schemas.*.yaml` anchors (JSON Pointer fragments). Avro, if generated, is **non-authoritative** and must **not** be referenced by 1A artefacts.

**Inherited numeric/RNG law (from S0).**

* IEEE-754 **binary64**, **RNE**, **FMA-off**, **no FTZ/DAZ** for any computation that can affect decisions/order. Non-finite values are hard errors.
* PRNG is **counter-based Philox** with **open-interval** mapping `uâˆˆ(0,1)`; **draws** = actual uniforms consumed; **blocks** = counter delta. Envelopes and trace obey the budgeting/trace rules already established upstream.

**Lineage & partitions (read-side discipline).** Where S4 reads upstream RNG events (S1/S2), **path partitions must equal embedded envelope fields** `{seed, parameter_hash, run_id}` **byte-for-byte**. S4 itself **emits logs only** (no Parquet egress).

**Scope boundary (what S4 does / doesnâ€™t).**

* **Does:** compute `Î»_extra`, sample ZTP for a foreign-count **target `K_target`**, and emit **RNG events only** (including a **non-consuming finaliser** that fixes `K_target`).
* **Does not:** choose countries (S6), allocate counts (S7), sequence/IDs or write `outlet_catalogue` (S8), or produce validation bundles (S9). Authority for inter-country order remains in S3â€™s `candidate_set`/`candidate_rank`.

**Branch purity (gates owned upstream).** S4 runs **only** for merchants with **S1 `is_multi=true`** and **S3 `is_eligible=true`**; singles and ineligible merchants produce **no S4 events**.

---

## 0A) One-page quick map (for implementers)

> A single-screen view of **what runs**, **whatâ€™s read/written**, and **where S4 hands off**. All MUST/SHOULD rules are defined in Â§Â§0â€“2A and later sections; this is the wiring diagram you keep beside the code.

### Flow (gates â†’ ZTP loop â†’ outcomes)

```
S1 hurdle      S3 eligibility        S3 admissible set size A
is_multi? â”€â”€â–º  is_eligible? â”€â”€â–º  compute A := size(S3.candidate_set \ {home})
   â”‚ no             â”‚ no                     â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º BYPASS S4 (domestic only) â—„â”€â”€â”˜

            yes             yes
                 â–¼
           [Parameterise]
  Î· = Î¸0 + Î¸1Â·log N + Î¸2Â·X (binary64, fixed order)
  Î» = exp(Î·) ; if non-finite/â‰¤0 â†’ NUMERIC_INVALID (abort S4 for m)

                 â–¼
       A == 0 ? â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ yes â”€â”€â–º  emit ztp_final{K_target=0[, reason:"no_admissible"]?} (non-consuming)
           â”‚ no
           â–¼
     ZTP attempt loop (attempt = 1..)
       draw K ~ Poisson(Î»)  â†’  emit poisson_component{attempt, k} (consuming)
             â”‚
             â”œâ”€ K == 0 â†’ emit ztp_rejection{attempt} (non-consuming) â†’ next attempt
             â”‚
             â”œâ”€ K â‰¥ 1 â†’ ACCEPT:
             â”‚          emit ztp_final{K_target=K, attempts=attempt, exhausted=false} (non-consuming)
             â”‚          STOP
             â”‚
             â””â”€ attempts == MAX_ZTP_ZERO_ATTEMPTS ?
                    â”‚ yes â†’ policy:
                    â”‚        â€¢ "abort"  â†’ emit ztp_retry_exhausted{attempts, aborted:true} (non-consuming); ZTP_EXHAUSTED_ABORT (no final)
                    â”‚        â€¢ "downgrade_domestic" â†’ emit ztp_final{K_target=0, exhausted:true} (non-consuming)
                    â”” no  â†’ next attempt
```

**After each event append:** append exactly **one** cumulative `rng_trace_log` row (saturating totals).

---

### Quick I/O (what S4 reads and writes)

**Reads (values / streams):**

* **S1 hurdle** (gate): `is_multi=true` â‡’ in scope.
* **S2 `nb_final`** (fact): authoritative **`N â‰¥ 2`** (non-consuming).
* **S3 eligibility** (gate) and **A** definition: **`A := size(S3.candidate_set \ {home})`**.
* **Hyper-parameters** `Î¸`, **cap** `MAX_ZTP_ZERO_ATTEMPTS` (governed), **policy** `ztp_exhaustion_policy`.
* **Features** `X âˆˆ [0,1]` (default **0.0** if missing).

**Writes (logs only; partitions from dictionary = `{seed, parameter_hash, run_id}`):**

* `rng_event_poisson_component` (context=`"ztp"`) â€” **consuming** attempts (`attempt` is **1-based**).
* `rng_event_ztp_rejection` â€” **non-consuming** zero markers.
* `rng_event_ztp_retry_exhausted` â€” **non-consuming** cap marker.
* `rng_event_ztp_final` â€” **non-consuming** finaliser fixing `{K_target, lambda_extra, attempts, regime, exhausted?}`.
* `rng_trace_log` â€” **one row per event append** (cumulative, saturating).

---

### Hard literals & regimes (so no one guesses)

* **module:** `1A.ztp_sampler`
* **substream_label:** `poisson_component`
* **context:** `"ztp"`
* **Poisson regimes:** **Inversion** if `Î» < 10`, **PTRS** if `Î» â‰¥ 10` (spec-fixed threshold/constants).
* **Budget law:** `draws` = uniforms consumed; `blocks` = `after âˆ’ before`.
* **File order is non-authoritative** â€” pairing/replay by **counters** only.

---

### Handoff (what downstream consumes)

* S4 exports **`K_target`** (or `K_target=0` via `A=0` short-circuit or policy **downgrade**).
* **S6 MUST realise** `K_realized = min(K_target, A)` (select up to `K_realized` foreigns); S6 owns selection/weights.
* S4 **never** encodes inter-country order (still only in S3 `candidate_rank`).

---

## 1) Purpose, scope & non-goals

### Purpose (what S4 is).
For each merchant `m` on the eligible multi-site branch, compute a deterministic **log-link**

$$
\eta_m=\theta_0+\theta_1\log N_m+\theta_2 X_m+\cdots\quad\text{(binary64, fixed order)}
$$
**Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.

and set $\lambda_{\text{extra},m}=\exp(\eta_m)>0$; then **sample ZTP** by drawing from Poisson$(\lambda)$ and **rejecting zeros** until acceptance or a governed **zero-draw cap** is hit. Record the attempt stream(s), zero-rejection markers, and a **non-consuming finaliser** that fixes **`K_target`** and run facts. S4 writes **no Parquet egress**â€”only RNG event logs under dictionary partitions `{seed, parameter_hash, run_id}`.
**By definition ZTP yields `K â‰¥ 1`; `K_target = 0` occurs only via (a) the `A=0` short-circuit or (b) the exhaustion policy = `"downgrade_domestic"` (never from ZTP itself).**

### Scope (what S4 owns).

* **Parameterisation:** evaluate $\eta$ and $\lambda$ in **binary64** with fixed operation order; **abort** the merchant if $\lambda$ is non-finite or â‰¤ 0. (If the features view lacks `X_m`, use **`X_m := 0.0`**.)
* **RNG protocol:** use keyed Philox substreams; **open-interval** $u\in(0,1)$; per-event envelopes obey **draws vs blocks** identities. **After each S4 event append, the producer MUST append exactly one cumulative `rng_trace_log` row** (saturating totals) for the S4 module/substream.
* **Events produced (logs-only):**

  1. one or more `poisson_component` attempts with `context:"ztp"` (**consuming**; attempts are **1-based**: `attempt = 1,2,â€¦`),
  2. `ztp_rejection` markers for zeros (**non-consuming**),
  3. optional `ztp_retry_exhausted` on cap (**non-consuming**),
  4. **exactly one** `ztp_final` (**non-consuming**) that **fixes** `{K_target, lambda_extra, attempts, regime, exhausted?}`.

### Non-goals (what S4 must not do).

* **No re-sampling or alteration of `N`.** Authoritative **`N`** is fixed by S2â€™s non-consuming `nb_final`; S4 only **reads** it.
* **No country choice or order.** S4 **does not** select which countriesâ€”S6 does; order authority remains S3â€™s `candidate_rank (home=0; contiguous)`.
* **No integerisation or sequencing.** Counts allocation (S7) and within-country sequence/IDs (S8) are out of scope here.
* **No egress or consumer gates.** `outlet_catalogue` and the 1Aâ†’1B gate live in S9.
* **No path literals.** All locations are dictionary-resolved; events must be written under `{seed, parameter_hash, run_id}` with **pathâ†”embed equality** for those keys.

### Branch & universe awareness (clarifying notes).

* **Definition of the admissible foreign universe.** Let **`A := size(S3.candidate_set \ {home})`**.
* **Eligibility short-circuit (`A=0`).** If **A=0** for a merchant, S4 **MUST NOT** sample and must resolve the merchant with a **finaliser carrying `K_target=0`** and, if the schema includes this optional field, `reason:"no_admissible"` (domestic-only downstream).
* **Cap governance.** The zero-draw cap **`MAX_ZTP_ZERO_ATTEMPTS`** is a **governed value** (default **64**) that **participates in `parameter_hash`**; the **exhaustion policy** `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}` is also governed and participates in `parameter_hash`.

### Hand-off contract (forward-looking pointer).
S4 **exports** an accepted **`K_target`** (or a deterministic `K_target=0` under short-circuit/policy). **S6 must realise**

$$
K_{\text{realized}}=\min\big(K_{\text{target}},\,A\big),
$$

and may log a shortfall marker in its own state; S4 does **not** encode inter-country order at any point (that remains in S3).

---

## 2) Authorities & schema anchors

### Single schema authority.
For 1A, **JSON-Schema is the only schema authority**. Every dataset/stream S4 references **must** be a `schema_ref` JSON Pointer into `schemas.*.yaml`. Avro (`.avsc`) may be generated but is **non-authoritative** and **must not** be referenced by the registry/dictionary.

### What S4 writes (logs only): authoritative event anchors.

* `schemas.layer1.yaml#/rng/events/poisson_component` â€” **consuming** attempt rows with `context="ztp"`; payload includes `k`, `attempt`. Budgets are measured via the envelope (`draws` vs `blocks`).
* `schemas.layer1.yaml#/rng/events/ztp_rejection` â€” **non-consuming** zero-draw marker (`k=0`, `attempt`).
* `schemas.layer1.yaml#/rng/events/ztp_retry_exhausted` â€” **non-consuming** cap-hit marker (`attempts=â€¦`).
* `schemas.layer1.yaml#/rng/events/ztp_final` â€” **non-consuming** finaliser fixing `{K_target, lambda_extra, attempts, regime, exhausted?}` for the merchant (mirrors S2â€™s non-consuming finaliser pattern).
* `schemas.layer1.yaml#/rng/core/rng_trace_log` â€” **trace stream** with cumulative totals per `(module, substream_label)`; append **exactly one** row after each S4 event (saturating).

### What S4 reads / gates it respects.

* **S1 hurdle events** (presence gate for multi-site RNG): partitioned by `{seed, parameter_hash, run_id}`. S4 emits **no** events for `is_multi = false`.
* **S2 `nb_final`** (exactly one, **non-consuming**): fixes **`N`**; S4 **must not** re-sample or alter **N**.
* **S3 eligibility & admissible set size.** S4 requires `is_eligible = true`. Let **`A := size(S3.candidate_set \ {home})`**; S4 uses **A** only for the **A=0** short-circuit (no sampling). S4 does **not** use S3 inter-country order here.

### Authority boundaries (reaffirmed).

* Inter-country **order authority** remains **only** in **S3 `candidate_set.candidate_rank`** (home=0; contiguous). S4 **never** encodes cross-country order; it only logs the ZTP outcome.

### Dictionary vs Schema roles.

* **JSON-Schema** defines **row shape/keys** and payload/envelope fields.
* The **Data Dictionary** defines **dataset IDs**, **partitions** (RNG logs: `{seed, parameter_hash, run_id}`), and **writer sort keys**; path resolution and lifecycle live there.

### File order is non-authoritative.
Pairing and replay are determined **only by counters** in the RNG envelopes (hi/lo counters and deltas), not by physical file order or timestamps.

---

## 2A) Label / stream registry (frozen identifiers)

> These literals fix **module / substream / context** so replay and budgeting are stable across releases. Changing any is a **breaking change**.

| Stream                          | **module**       | **substream_label** | **context** |
|---------------------------------|------------------|---------------------|-------------|
| `rng_event_poisson_component`   | `1A.ztp_sampler` | `poisson_component` | `"ztp"`     |
| `rng_event_ztp_rejection`       | `1A.ztp_sampler` | `poisson_component` | `"ztp"`     |
| `rng_event_ztp_retry_exhausted` | `1A.ztp_sampler` | `poisson_component` | `"ztp"`     |
| `rng_event_ztp_final`           | `1A.ztp_sampler` | `poisson_component` | `"ztp"`     |

**Note.** All S4 events share `substream_label="poisson_component"` to aggregate budgets/trace under one domain; event type is distinguished by the table/anchor and `context:"ztp"`.

**Budgeting, envelopes & trace (MUST).**

* `poisson_component(context="ztp")` is **consuming**; envelopes must satisfy **`blocks == after âˆ’ before`** and **`draws > 0`**.
* `ztp_rejection`, `ztp_retry_exhausted`, and `ztp_final` are **non-consuming**: **`before == after`**, **`blocks = 0`**, **`draws = "0"`**.
* **After each S4 event append, the producer MUST append exactly one cumulative `rng_trace_log` row** (saturating totals) for this `(module, substream_label)`.

**Dictionary partitions (read/write discipline).** All S4 streams are **logs** partitioned by **`{seed, parameter_hash, run_id}`**. When reading S1/S2 or writing S4, **path keys must equal embedded envelope fields** for those partitions **byte-for-byte**.

**Reminder (non-authority of file order).** Do not rely on writer order; validators and replayers must use **envelope counters** to sequence and pair events.

---

## 2B) Bill of Materials (BOM)

> Single place that enumerates every **governed artefact**, **value view**, and **authority** S4 depends on; what each item is for, whether it **participates in `parameter_hash`**, and how it is scoped. **Values, not paths.** Physical resolution always comes from the **Data Dictionary**.

### 2B.1 Governed artefacts (participate in `parameter_hash`) â€” **N**

| Name                      | Role in S4                                    | Kind                               | Scope | Fields / Contents (relevant to S4)                                                                       | Owner    | Versioning / Digest  | Participates in `parameter_hash` | Default / Notes                     |
|---------------------------|-----------------------------------------------|------------------------------------|-------|----------------------------------------------------------------------------------------------------------|----------|----------------------|----------------------------------|-------------------------------------|
| `crossborder_hyperparams` | Parameterises ZTP link & exhaustion behaviour | Artefact (governed values)         | value | `Î¸ = {Î¸â‚€, Î¸â‚, Î¸â‚‚, â€¦}`; `MAX_ZTP_ZERO_ATTEMPTS`; `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}` | Governed | semver + byte digest | **Yes**                          | Cap default **64** unless specified |
| `crossborder_features`    | Optional merchant feature(s) for Î·            | Artefact / View (parameter-scoped) | value | `X_m âˆˆ [0,1]` (and any documented transforms)                                                            | Governed | semver + byte digest | **Yes**                          | If `X_m` missing, **use 0.0**       |

### 2B.2 Authorities (schema & dictionary) â€” **N**

| Name                                                                                                                                                                                                                         | Role                                                                             | Kind                    | Scope     | Source of truth       | Participates in `parameter_hash` | Notes                                                            |
|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------|-------------------------|-----------|-----------------------|----------------------------------|------------------------------------------------------------------|
| RNG event schemas (`schemas.layer1.yaml#/rng/events/poisson_component`, `schemas.layer1.yaml#/rng/events/ztp_rejection`, `schemas.layer1.yaml#/rng/events/ztp_retry_exhausted`, `schemas.layer1.yaml#/rng/events/ztp_final`) | Define row/envelope shapes for all S4 logs                                       | **JSON-Schema anchors** | authority | `schemas.layer1.yaml` | No                               | Serialization authority only (row shape/keys)                    |
| Data Dictionary entries (S4 logs)                                                                                                                                                                                            | Define dataset IDs, **partitions** `{seed, parameter_hash, run_id}`, writer sort | Dictionary              | authority | Data Dictionary       | No                               | Paths, partitions, writer sort; **file order non-authoritative** |

### 2B.3 Upstream runtime surfaces S4 must read (gates & facts) â€” **N**

| Name                               | Role in S4                             | Kind                     | Partitions / Scope               | Source of truth | Notes                                                                                         |
|------------------------------------|----------------------------------------|--------------------------|----------------------------------|-----------------|-----------------------------------------------------------------------------------------------|
| S1 hurdle events                   | **Gate**: `is_multi = true` â‡’ in scope | RNG log                  | `{seed, parameter_hash, run_id}` | S1 producer     | Enforce pathâ†”embed equality on read                                                           |
| S2 `nb_final`                      | **Fixes** `N â‰¥ 2` (non-consuming)      | RNG log                  | `{seed, parameter_hash, run_id}` | S2 producer     | Exactly one non-consuming finaliser per merchant                                              |
| S3 `crossborder_eligibility_flags` | **Gate**: `is_eligible = true`         | Parameter-scoped dataset | `parameter_hash`                 | S3 producer     | Deterministic; no RNG                                                                         |
| S3 `candidate_set`                 | Defines admissible universe size **A** | Parameter-scoped dataset | `parameter_hash`                 | S3 producer     | **A := size(S3.candidate_set \ {home})** (foreigns only). S4 uses **A** only for the `A=0` check |

### 2B.4 Hard literals & spec constants (breaking if changed) â€” **N**

| Literal / Constant                                   | Role                      | Kind          | Participates in `parameter_hash` | Notes                                                           |
|------------------------------------------------------|---------------------------|---------------|----------------------------------|-----------------------------------------------------------------|
| `module = "1A.ztp_sampler"`                               | Envelope identity         | Spec literal  | No                               | Frozen identifier for replay/tooling                            |
| `substream_label = "poisson_component"`              | Envelope identity         | Spec literal  | No                               | Family reuse; disambiguated by `context="ztp"`                  |
| `context = "ztp"`                                    | Envelope identity         | Spec literal  | No                               | Tags S4 attempts/markers/final                                  |
| Poisson regime threshold **Î»â˜… = 10**                 | Selects Inversion vs PTRS | Spec constant | No                               | Regime constants/threshold are spec-fixed (breaking if changed) |
| Numeric profile (binary64, RNE, FMA-off, no FTZ/DAZ) | Deterministic math        | Spec constant | No                               | Inherited from S0; breaking if changed                          |
| Open-interval mapping `u âˆˆ (0,1)`                    | RNG mapping               | Spec constant | No                               | Inherited from S0                                               |

### 2B.5 Trace & observability (values, not paths) â€” **N**

| Name                  | Role                                                                  | Kind             | Scope                            | Participates in `parameter_hash` | Notes                                                                                                                          |
|-----------------------|-----------------------------------------------------------------------|------------------|----------------------------------|----------------------------------|--------------------------------------------------------------------------------------------------------------------------------|
| `rng_trace_log`       | **Cumulative** budget/coverage totals per `(module, substream_label)` | RNG trace stream | `{seed, parameter_hash, run_id}` | No                               | **MUST append exactly one row after every S4 event append** (saturating)                                                       |
| Run counters (`s4.*`) | Ops/telemetry                                                         | Values           | per-run                          | No                               | e.g., `s4.merchants_in_scope`, `s4.accepted`, `s4.rejections`, `s4.retry_exhausted`, `s4.policy.*`, `s4.ms.*`, `s4.trace.rows` |

**Definition.** "Saturating totals" = cumulative counters that never decrease per `(module, substream_label)`; validators reconcile these against event budgets.

**BOM discipline (MUST).**

1. Items listed as **governed artefacts** **must** be passed to S4 as **values** and **participate in `parameter_hash`** (reproducibility).
2. **Authorities** (schemas/dictionary) define shapes and partitions/sort; **do not** put physical paths in S4.
3. **Upstream surfaces** are read-only; S4 enforces pathâ†”embed equality on read.
4. **Spec literals/constants** are frozen; changing them is **breaking** and requires a spec revision.

---

## 3) Host inputs (values, not paths)

**What these are.** Run-constant **values** S4 receives from the orchestrator to bind lineage, parameterisation, and policy. They are **not** filesystem paths; all physical locations are resolved via the **Data Dictionary**.

### 3.1 Lineage surfaces (read-only values)

* `seed : u64`
* `parameter_hash : hex64`
* `run_id : str`
* `manifest_fingerprint : hex64`

**MUST.** S4 **must not** mutate these; when S4 writes logs, any lineage fields required by the stream schema **must** byte-match the path tokens.

### 3.2 Hyper-parameters & features (governed values)

* **ZTP link parameters** `Î¸ = (Î¸â‚€, Î¸â‚, Î¸â‚‚, â€¦)` â€” real-valued; **governed**.
  **MUST.** The bytes of `Î¸` **participate in `parameter_hash`**.
  **Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.
* **Merchant feature** `X_m âˆˆ [0,1]` (e.g., "openness") â€” governed mapping & provenance (document monotone transform, cohort, scaling).
  **Default.** If `X_m` is missing, **MUST use `X_m := 0.0`**. A different default MAY be supplied by governance and **MUST** participate in `parameter_hash`.
  **Precedence.** If governance provides `X_default`, it **overrides** 0.0; otherwise **use 0.0**.
* **Exhaustion cap** `MAX_ZTP_ZERO_ATTEMPTS âˆˆ â„•âº` â€” **governed** (default **64**); **participates** in `parameter_hash`.
* **Exhaustion policy** `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}` â€” **governed**; **participates** in `parameter_hash`.

### 3.3 Prohibitions (MUST NOT)

* No literal storage paths in S4 text or implementations.
* No dynamic/environment-dependent sources for `Î¸`, the `X` transform/default, the cap, or the policy; they **must** be governed values bound into the runâ€™s `parameter_hash`.

---

## 4) Required upstream datasets & gates

### 4.1 Gates S4 must respect (branch purity)

* **S1 hurdle (presence gate).** S4 runs for a merchant **iff** `is_multi = true`. Singles produce **no** S4 events.
* **S3 eligibility.** Merchant must be **cross-border eligible**; if ineligible, S4 **must** emit nothing.

### 4.2 Authoritative fact S4 must read (never alter)

* **S2 `nb_final`.** The accepted **`N_m â‰¥ 2`** (exactly one **non-consuming** finaliser per merchant). S4 **must not** re-sample or alter `N_m`.

### 4.3 Admissible-set size (context only)

* Define **`A_m := size(S3.candidate_set \ {home})`** (foreign countries only).
  **Use in S4.** Only for the **A=0** short-circuit; S4 does **not** use S3â€™s order here.

### 4.4 Partitions when reading

* S1/S2 logs are read under **`{seed, parameter_hash, run_id}`**; **pathâ†”embed equality** must hold for these keys (byte-for-byte).
* S3 tables are read under **`parameter_hash={â€¦}`** (parameter-scoped).
* **File order is non-authoritative;** pairing/replay **must** use **envelope counters** only.

### 4.5 Zero-row discipline

* Dataset **presence** implies â‰¥1 row for the runâ€™s partition. **Zero-row artefacts are forbidden**; treat as producer error upstream.

---

## 5) Symbols & domains

### 5.1 Upstream facts & context

* `N_m âˆˆ {2,3,â€¦}` â€” accepted multi-site total from S2 (**authoritative**).
* `A_m âˆˆ {0,1,2,â€¦}` â€” size of S3â€™s admissible foreign set (foreigns only).

### 5.2 Link and intensity

$$
\eta_m = \theta_0 + \theta_1 \log N_m + \theta_2 X_m + \cdots
$$

Compute in **binary64** with **fixed operation order**.

$$
\lambda_{\text{extra},m} = \exp(\eta_m) > 0
$$

**MUST.** Abort the merchant in S4 (`NUMERIC_INVALID`) if $\lambda$ is non-finite or â‰¤ 0.
**Default for features.** If `X_m` absent, **use `X_m := 0.0`** (deterministic).

### 5.3 Draw outcomes (targets vs realisation)

* `K_target,m âˆˆ {0,1,2,â€¦}` â€” result recorded by S4:
  **ZTP yields `Kâ‰¥1`;** `K_target=0` appears only from **A=0 short-circuit** or policy **"downgrade_domestic"** (never from ZTP itself).
* `K_realized,m = min(K_target, A_m)` â€” applied later by **S6** (top-K selection).

### 5.4 Attempting & regimes

* `attempt âˆˆ {1,2,â€¦}` â€” **1-based** index of Poisson attempts for the merchant.
* `regime âˆˆ {"inversion","ptrs"}` â€” closed enum indicating the Poisson sampler branch chosen by the fixed Î»-threshold.

### 5.5 PRNG & envelopes

* Uniforms `u âˆˆ (0,1)` (strict-open) per S0 law.
* **Envelope identities:**

  * **Consuming attempts:** `draws` = actual uniforms consumed; `blocks` = `after âˆ’ before`.
  * **Markers/final:** `before == after`, `blocks = 0`, `draws = "0"`.
* **Trace duty.** The **trace-after-every-event** obligation from Â§2A applies: after each S4 event append, append exactly one cumulative `rng_trace_log` row (saturating totals) for the S4 module/substream.

### 5.6 Caps & policies

* `MAX_ZTP_ZERO_ATTEMPTS âˆˆ â„•âº` â€” governed; default **64**.
* `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}` â€” governed.

### 5.7 Determinism requirement (MUST)

* For fixed inputs and lineage, the Poisson attempt sequence and resolved `K_target` are **bit-replayable** under the keyed substream and frozen literals; **counters provide the total order** (timestamps are observational only).

---

## 6) Outputs (streams) & partitions

### What S4 writes.
S4 is a **logs-only** producer. It emits **RNG event rows** (serialization per JSON-Schema). **No 1A egress tables.** 
Every S4 stream is partitioned by **`{ seed, parameter_hash, run_id }`**. Every S4 **event** row carries a full **RNG envelope**; trace rows carry only `ts_utc, module, substream_label` and cumulative counters per **Â§14.1**.

### Streams (authoritative event anchors).

1. **`poisson_component`** (with `context:"ztp"`) â€” **consuming** attempt rows.
   **Payload (minimum):** `{ merchant_id, attempt:intâ‰¥1, k:intâ‰¥0, lambda_extra:float64, regime:"inversion"|"ptrs" }`
   **Domain:** `merchant_id` is **int64** per ingress `merchant_ids` (see `schemas.ingress.layer1.yaml#/merchant_ids`).
   **Envelope (minimum):** `{ ts_utc, module, substream_label, context, before, after, blocks, draws }`.
2. **`ztp_rejection`** â€” **non-consuming** marker for a **zero** draw.
   **Payload:** `{ merchant_id, attempt, k:0, lambda_extra }` + non-consuming envelope.
3. **`ztp_retry_exhausted`** â€” **non-consuming** marker when the zero-draw **cap** is hit **and policy="abort"**.
   **Payload:** `{ merchant_id, attempts:int, lambda_extra, aborted:true }` + non-consuming envelope.
4. **`ztp_final`** â€” **non-consuming** **finaliser** that **fixes** the outcome for the merchant.
   **Payload:** `{ merchant_id, K_target:int, lambda_extra, attempts:int, regime, exhausted?:bool [ , reason:"no_admissible"]? }` + non-consuming envelope.

### Partitioning & pathâ†”embed equality (MUST).

* All four streams are written under `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`.
* The envelopeâ€™s `{ seed, parameter_hash, run_id }` **must equal** the path tokens **byte-for-byte**. A mismatch is a structural failure.

### Row ordering (writer-sort) (MUST).

* `poisson_component`, `ztp_rejection`: sort by **`(merchant_id, attempt)`** (stable).
* `ztp_retry_exhausted`: **`(merchant_id, attempts)`** (single row per merchant if present).
* `ztp_final`: **`(merchant_id)`** (exactly one per **resolved** merchant; absent only under hard abort).

### Cardinality & presence rules (MUST).

* **Exactly one** `ztp_final` per **resolved** merchant.
* Acceptance â‡’ **â‰¥1** `poisson_component(context:"ztp")` exists; the **last** such row has `kâ‰¥1`.
* Cap path â‡’ `ztp_retry_exhausted` exists; if policy is `"downgrade_domestic"`, a `ztp_final{K_target=0, exhausted:true}` **must** exist; if policy is `"abort"`, **no** `ztp_final` is written.

### Zero-row discipline & idempotence (MUST).

* **Zero-row files are forbidden.** If no rows are produced for a slice, write nothing.
* Re-runs with identical inputs produce byte-identical content; if the partition already exists and is complete, the writer **must** no-op ("skip-if-final").

### Non-authority of file order (MUST).
**File order is non-authoritative;** pairing/replay **MUST** use **envelope counters** (hi/lo and deltas) only.

### Trace duty (pointer).
After each S4 event append, append exactly **one** cumulative `rng_trace_log` rowâ€”see **Â§7 Trace duty**.

---

## 7) Determinism & RNG protocol

**Substream keying & identifiers (MUST).**

* Use the **frozen literals** from Â§2A for `module`, `substream_label`, `context:"ztp"`.
* Each merchantâ€™s attempt loop uses a **merchant-keyed** substream; **attempt** is **1-based** and strictly increasing.

**Open-interval uniforms & budgets (MUST).**

* Map counters to uniforms on the **open interval** `uâˆˆ(0,1)`.
* **Budget identities:**

  * `poisson_component(context:"ztp")` rows are **consuming**: `blocks == after âˆ’ before`, and `draws > 0`.
  * `ztp_rejection`, `ztp_retry_exhausted`, `ztp_final` are **non-consuming**: `before == after`, `blocks == 0`, `draws == "0"`.

**Poisson regimes (fixed & measurable) (MUST).**

* **Inversion** for `Î» < 10` â€” consumes exactly `K + 1` uniforms for `K`.
* **PTRS** for `Î» â‰¥ 10` â€” consumes a **variable** count per attempt (â‰¥2). Threshold/constants are spec-fixed.
* **Budgets are measured, not inferred**: validators rely on the envelope.

**Replay & ordering (MUST).**

* **Monotone, non-overlapping** counters per merchant/substream provide a total order; **timestamps are observational only**.
* Replaying attempts must reconstruct the same sequence and acceptance (bit-replay under the fixed literals).

**Concurrency discipline (MUST).**

* Parallelize **across** merchants only; a single merchantâ€™s attempt loop is **serial** with fixed iteration order.
* Any merge/sink stages must be **deterministic and stable** with respect to the writer-sort keys in Â§6.

**Trace duty (MUST).**

* **After each S4 event append, append exactly one cumulative `rng_trace_log` record** (saturating totals) for **`(module, substream_label)`**.
* **Responsibility:** the writer that commits the event row **MUST** immediately append the single cumulative `rng_trace_log` row; higher-level sinks **MUST NOT** emit additional trace rows.

---

## 8) Parameterisation & target distribution

### Link & intensity (MUST).

* Compute

  $$
  \eta_m = \theta_0 + \theta_1 \log N_m + \theta_2 X_m + \cdots
  $$

  in **binary64** with a **fixed operation order**.
* Set $\lambda_{\text{extra},m} = \exp(\eta_m)$. If $\lambda$ is **NaN/Inf/â‰¤0**, fail the merchant in S4 with `NUMERIC_INVALID`.

**Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.

### Target distribution (ZTP) (MUST).

* Let $Y \sim \text{Poisson}(\lambda_{\text{extra}})$. Define the **ZTP target**

  $$
  K_{\text{target}} = Y \,\big|\, (Y \ge 1).
  $$

  Acceptance probability is $1 - e^{-\lambda_{\text{extra}}}$ (for ops observability; not a decision gate).

### Realisation method (MUST).

* Realise ZTP by **sampling Poisson** and **rejecting zeros** until acceptance or the governed **zero-draw cap** is hit.
* On acceptance at attempt `a`: write the consuming `poisson_component` for that attempt and then write a **non-consuming `ztp_final`** echoing `{K_target, lambda_extra, attempts=a, regime, exhausted:false}`.
* On cap: follow the governed **exhaustion policy**:
  * `"abort"` â‡’ write `ztp_retry_exhausted{attempts, aborted:true}` and **no** `ztp_final` (merchant leaves S4 with `ZTP_EXHAUSTED_ABORT`).
  * `"downgrade_domestic"` â‡’ **do not** write `ztp_retry_exhausted`; write `ztp_final{K_target=0, exhausted:true}` (domestic-only downstream).

### Universe-aware short-circuit (MUST).

* If the **admissible foreign set is empty** (`A=0` from S3), **do not sample**; immediately write `ztp_final{K_target=0[, reason:"no_admissible"]?}` (non-consuming).

### Separation of concerns (MUST).

* S4 **fixes** the **target** count **`K_target`** only.
* In S6, the realised selection size is

  $$
  K_{\text{realized}}=\min\big(K_{\text{target}},\,A\big),
  $$

  and S6 may log a shortfall marker in its own state. S4 never encodes inter-country order.

---

## 9) Sampling algorithm (attempt loop & cap)

### 9.0 Overview (what this section fixes)

For each merchant **m** on the multi-site, cross-border path, S4 deterministically computes the intensity $\lambda_{\text{extra},m}$ and then realises a **Zero-Truncated Poisson** by repeatedly sampling $Y\sim \text{Poisson}(\lambda)$ and **rejecting zeros** until it accepts $K_{\text{target}}\ge 1$ or hits a governed **zero-draw cap**. S4 **emits logs only**: consuming **attempt** rows, **non-consuming** rejection/cap markers, and a **non-consuming finaliser** that fixes **`K_target`** (or records a governed `K_target=0` outcome). S4 never chooses which countriesâ€”that is later.

---

### 9.1 Preconditions (merchant enters S4) â€” **MUST**

* **Branch purity:** S1 `is_multi = true`. If `false` â‡’ **emit nothing** in S4 for m.
* **Eligibility:** S3 `is_eligible = true`. If `false` â‡’ **emit nothing** in S4 for m.
* **Total outlets:** S2 `nb_final` exists and fixes **`N_m â‰¥ 2`** (read-only).
* **Admissible set size:** obtain **`A_m := size(S3.candidate_set \ {home})`** (foreigns only).

---

### 9.2 Universe-aware short-circuit â€” **MUST**

If **`A_m = 0`**, S4 **MUST NOT** sample. It **MUST** immediately write a **non-consuming**
`ztp_final{ K_target=0, lambda_extra: computed Î» (see 9.3), attempts:0, regime: "inversion"|"ptrs" (from Î»), exhausted:false [ , reason:"no_admissible"]? }`
and **skip** S6 (domestic-only downstream).

*Note:* Computing Î» is still required for observability/trace uniformity; the optional `reason` field is written **only if present** in the schema.
The `regime` is derived once from Î» for observability/validator uniformity; it **does not imply** that a Poisson attempt occurred.

---

### 9.3 Deterministic parameterisation â€” **MUST**

* **Link:** $\eta_m = \theta_0 + \theta_1 \log N_m + \theta_2 X_m + \cdots$ evaluated in **binary64**, fixed operation order (no FMA/FTZ/DAZ).
  **Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.
* **Intensity:** $\lambda_{\text{extra},m}=\exp(\eta_m)$.
* **Guard:** If $\lambda$ is **NaN/Inf/â‰¤0**, fail merchant in S4 with `NUMERIC_INVALID` (no attempts written).
* **Regime selection (fixed threshold):** if $\lambda < 10$ â‡’ **regime = "inversion"**; else **"ptrs"**. The chosen **regime is constant per merchant** (no mid-loop switching).

---

### 9.4 Substream & envelope set-up â€” **MUST**

* Use the **frozen identifiers** (module / substream / context) from Â§2A for all S4 events.
* Start a merchant-keyed **attempt counter** `a := 1` (attempts are **1-based**).
* Each eventâ€™s envelope **must** carry `{ts_utc, module, substream_label, context, before, after, blocks, draws}`.
* **Budget law:** consuming attempts satisfy `blocks == after âˆ’ before` and `draws > 0`; markers/final are **non-consuming** with `before == after`, `blocks == 0`, `draws = "0"`.

---

### 9.5 Attempt loop (realising ZTP) â€” **MUST**

Repeat until **acceptance** or **cap**:

1. **Draw attempt `a`.** Sample $K_a \sim \text{Poisson}(\lambda)$ using the merchantâ€™s **fixed regime**.
   **Emit** a **consuming** `poisson_component{ merchant_id, attempt:a, k:K_a, lambda_extra, regime }`.

2. **Zero?**

   * If **`K_a == 0`**: **emit** a **non-consuming** `ztp_rejection{ merchant_id, attempt:a, k:0, lambda_extra }`.
     **Cap check (now):**
     - If **`a == MAX_ZTP_ZERO_ATTEMPTS`** â‡’ **emit** a **non-consuming** `ztp_retry_exhausted{ merchant_id, attempts:a, lambda_extra }` and apply policy (see below).
     - Else **set `a := a+1`** and continue.
   * If **`K_a â‰¥ 1`** (**ACCEPT**): set `K_target := K_a`; **emit** a **non-consuming**
     `ztp_final{ merchant_id, K_target, lambda_extra, attempts:a, regime, exhausted:false }` and **STOP**.

3. **Policy on cap (from the prior branch):**

   * **`"abort"` â‡’ STOP** with **no `ztp_final`**; outcome is `ZTP_EXHAUSTED_ABORT`.
   * **`"downgrade_domestic"` â‡’ emit** a **non-consuming**
     `ztp_final{ merchant_id, K_target=0, lambda_extra, attempts:a, regime, exhausted:true }` and **STOP** (domestic-only downstream).

*Trace note:* After **each** event append in steps (1)â€“(3), **append exactly one** cumulative `rng_trace_log` row (saturating totals) for `(module, substream_label)` (see Â§7).

**Norms inside the loop**

* **No regime switching** mid-merchant.
* **No silent retries:** each Poisson draw writes exactly one **consuming** attempt; each zero writes exactly one **non-consuming** rejection marker.
* **Attempt indexing** is **1-based, strictly increasing**, and **monotone** within m.

---

### 9.6 Ordering & replay â€” **MUST**

* Within a merchantâ€™s substream, envelope counters are **monotone, non-overlapping**; validators reconstruct attempt order **from counters** (not timestamps or file order).
* The accepting attempt (or capped path) is the **last** event sequence for that merchantâ€™s substream; the presence/absence of `ztp_final` reflects the policy outcome unambiguously.
* After **each** S4 append, write one **cumulative** `rng_trace_log` row (saturating totals) for `(module, substream_label)`.

---

### 9.7 Postconditions (what S4 fixes) â€” **MUST**

For a resolved merchant:

* Either **`K_target â‰¥ 1`** via acceptance, with exactly one `ztp_final{â€¦, exhausted:false}`, or
* **`K_target = 0`** via **A=0** short-circuit or **"downgrade_domestic"** policy, with exactly one `ztp_final{â€¦, exhausted:true [ , reason:"no_admissible"]? }`, or
* **Abort** under `"abort"` policy at cap: **no `ztp_final`**; exactly one `ztp_retry_exhausted`.
* In all acceptance/short-circuit/downgrade cases, **exactly one** `ztp_final` exists for the merchant.
* No S4 Parquet products exist; only the four event streams.

---

### 9.8 Prohibitions & edge discipline â€” **MUST NOT**

* **MUST NOT** write any S4 events for singles or ineligible merchants.
* **MUST NOT** compute or encode inter-country order in S4.
* **MUST NOT** switch the Poisson regime mid-loop or reuse counters across merchants.
* **MUST NOT** emit zero-row files for any S4 stream partitions.

---

### 9.9 Determinism under concurrency â€” **MUST**

* A merchantâ€™s attempt loop executes **serially** (fixed iteration order).
* Concurrency is **across** merchants only; any writer/merge step must be **stable** w\.r.t. the sort keys in Â§6 to ensure **byte-identical** outputs for identical inputs.

---

### 9.10 Observability hooks (values-only) â€” **SHOULD**

For each `(seed, parameter_hash, run_id)`:

* per-merchant: `{attempts, zero_rejections, accepted_K (or 0), regime, exhausted?}`
* per-run: acceptance-rate estimate $1-e^{-\bar{\lambda}}$ vs observed, cap rate, regime split, elapsed-ms quantiles.

---

## 9A) Universe awareness & short-circuits

### What "A" is (precise).
Let **`A := size(S3.candidate_set \ {home})`** be the count of *foreign* ISO2s in the merchantâ€™s admissible universe (home excluded). S4 **does not** use `candidate_rank` hereâ€”only the set size.

### How S4 obtains A (read-side discipline).

* Read **`s3_candidate_set`** under **`parameter_hash={â€¦}`** (parameter-scoped).
* **MUST** enforce pathâ†”embed equality for required lineage fields on read.
* **MUST NOT** infer A from file order or any non-governed source.
* Missing/ill-formed admissible-set data is an **upstream S3 error**, not an S4 defect.

### Short-circuit when `A = 0` (no admissible foreigns).

* **MUST NOT** run the Poisson loop.
* **MUST** still compute `lambda_extra` (binary64, fixed order) for observability and regime derivation.
* **MUST** immediately write a **non-consuming**
  `ztp_final{ K_target=0, lambda_extra, attempts:0, regime: "inversion"|"ptrs", exhausted:false [ , reason:"no_admissible"]? }`.
  *(The `reason` field is written only if present in the finaliser schema.)*
* **MUST** skip S6 (no top-K) and proceed along the domestic-only path downstream (S7 will allocate `{home: N}`).

### When `A > 0` (normal case).

* Run the Poisson loop per **Â§9.5**.
* Acceptance yields **`K_target â‰¥ 1`**.
* **MUST NOT** cap `K_target` to `A` in S4. S4 fixes **`K_target`**; **S6 MUST** realise `K_realized = min(K_target, A)` (see **Â§9B**).

### Invariant & logging.

* Exactly one `ztp_final` per resolved merchant (absent only on hard abort).
* **Informative:** ops counters **SHOULD** record short-circuits (count of `K_target=0` due to `A=0`).

### Prohibitions.

* **MUST NOT** emit any S4 events for `is_multi=false` or `is_eligible=false`.
* **MUST NOT** encode inter-country order in S4.

---

## 9B) S4 â†’ **S6** handshake

### Purpose.
Fix what S6 must consume from S4 and how to realise selection size for all outcomes.

### What S6 reads from S4 (authoritative):
fields from **`ztp_final`** for the merchant:

* `K_target : int` â€” the **target** foreign count S4 fixed (â‰¥1 on acceptance; 0 on short-circuit/downgrade).
* `lambda_extra : float64` â€” intensity used (audit/diagnostics; not a decision gate in S6).
* `attempts : intâ‰¥0` â€” number of Poisson attempts written by S4 (0 iff short-circuit).
* `regime : "inversion"|"ptrs"` â€” Poisson regime S4 used (closed enum).
* `exhausted? : bool` â€” present and `true` only when cap hit and policy was **"downgrade_domestic"**.

### What S6 must combine with its own inputs:

* **`A`** (admissible foreign set size) and the **ordered/weighted foreign candidate list** S6 owns.

### Realisation rule (binding).

* **MUST** compute **`K_realized = min(K_target, A)`**.
* If `K_target = 0` (short-circuit or downgrade): **MUST** skip top-K entirely and continue with the domestic-only path.
* If `K_target > A`: **MUST** select **all `A`** foreigns (top-K shortfall). S6 **MAY** emit its own **non-consuming** marker (e.g., `topk_shortfall{K_target, A}`) in **its** state; S4 does not emit this marker.

### Outcomes matrix (exhaustive).

| S4 outcome                                                   | `A`                | S6 mustâ€¦                                                                                                           |
|--------------------------------------------------------------|--------------------|--------------------------------------------------------------------------------------------------------------------|
| `ztp_final{K_target â‰¥ 1, exhausted:false}`                   | `A â‰¥ K_target`     | Select exactly `K_target` foreigns via its governed top-K mechanism; proceed.                                      |
| `ztp_final{K_target â‰¥ 1, exhausted:false}`                   | `0 < A < K_target` | Select **all `A`** (shortfall); **MUST** treat `K_realized = A`.                                                   |
| `ztp_final{K_target=0 [ , reason:"no_admissible"]? }`        | `A = 0`            | Skip top-K; domestic-only path.                                                                                    |
| `ztp_final{K_target=0, exhausted:true}` (policy = downgrade) | any `A`            | Skip top-K; domestic-only path.                                                                                    |
| Cap + policy = `"abort"` (no `ztp_final`)                    | any `A`            | **MUST NOT** run S6 for this merchant; pipeline treats merchant as **aborted** for S4+ (downstream states ignore). |

### Lineage continuity (MUST).

* S6 **must** carry forward the same `{seed, parameter_hash, run_id}` lineage triplet for any logs it writes.
* S6 **must not** reinterpret `lambda_extra` or `regime`.

### Authority boundaries (reaffirmed).

* S4 **fixes counts only at the target level** (`K_target`).
* S6 **owns**: which foreign ISO2s are chosen and in what order/weight for later stages.
* S3 `candidate_rank` remains the sole cross-country **order** authority; S4 never encodes order.

### Prohibitions.

* **MUST NOT** ignore `ztp_final` (if present).
* **MUST NOT** realise `K` greater than `A`.
* **MUST NOT** treat Poisson attempts or rejections as authoritative selection signals (they are evidence only; `ztp_final` is the single acceptance record).

---

## 10) Draw accounting & envelopes

### 10.1 Streams S4 writes (reminder).
Logs only, all partitioned by `{seed, parameter_hash, run_id}` with a full RNG **envelope** on every row:

* `poisson_component` (with `context:"ztp"`): **consuming** attempt rows.
* `ztp_rejection`: **non-consuming** zero marker.
* `ztp_retry_exhausted`: **non-consuming** cap-hit marker.
* `ztp_final`: **non-consuming** finaliser that **fixes** `{K_target, â€¦}`.

### 10.2 Envelope fields (MUST).
Every S4 event row **must** carry:

* `ts_utc` (microsecond; observational onlyâ€”never used for ordering).
* `module`, `substream_label`, `context` â€” **must match** the frozen identifiers in Â§2A.
* `before` (u128), `after` (u128), `blocks` (u64), `draws` (decimal-u128 as **string**).
* **MUST.** `draws` uses the S0 **canonical decimal-u128** format (no sign, no exponent, no leading zeros except `"0"`).
* Pathâ†”embed equality: embedded `{seed, parameter_hash, run_id}` **must equal** path tokens **byte-for-byte**.

### 10.3 Budget identities (MUST).

* **Consuming attempts** (`poisson_component(context:"ztp")`):
  `blocks == after âˆ’ before` (**strictly positive**), and `draws` parses as decimal-u128 and is **> 0** (actual uniforms consumed).
* **Non-consuming markers/final** (`ztp_rejection`, `ztp_retry_exhausted`, `ztp_final`):
  `before == after`, `blocks == 0`, `draws == "0"`.

### 10.4 Per-attempt write discipline (MUST).

* Exactly **one** consuming `poisson_component` row **per attempt index** for the merchant (attempts are **1-based** and contiguous).
* If that attemptâ€™s `k == 0`, write exactly **one** `ztp_rejection{attempt}` **after** the attempt row.
* If that attemptâ€™s `k â‰¥ 1` (acceptance), **no rejection marker** for that attempt; instead write exactly **one** `ztp_final{attempts := a}` after the attempt row.
* If the **cap** is reached with all zeros:
  - if policy=`"abort"` â†’ write exactly **one** `ztp_retry_exhausted{attempts := MAX, aborted:true}` and **no** `ztp_final`;
  - if policy=`"downgrade_domestic"` â†’ **do not** write an exhausted marker; write `ztp_final{K_target=0, exhausted:true}` (non-consuming).

### 10.5 Monotone, non-overlapping counters (MUST).

* Within a merchantâ€™s substream, counter spans **must** be **strictly increasing and non-overlapping** for consuming events.
* Ordering and pairing for replay/validation is by **counters only** (timestamps and file order are non-authoritative).

### 10.6 Payload typing & constancy (MUST).

* **Attempt rows** (`poisson_component`, `ztp_rejection`): `attempt:intâ‰¥1`.
* **Finaliser / cap rows** (`ztp_final`, `ztp_retry_exhausted`): `attempts:intâ‰¥0` (==0 only on A=0 short-circuit).
* Common fields (where present): `k:intâ‰¥0`, `K_target:intâ‰¥0`, `lambda_extra:float64 (finite, >0)`, `regime âˆˆ {"inversion","ptrs"}`.
* For a given merchant, `lambda_extra` and `regime` **must** be identical across all S4 rows for that merchant (computed once in Â§9.3).

### 10.7 Writer sort & uniqueness (MUST).

* Sort keys (as in Â§6):
  - attempts/rejections by `(merchant_id, attempt)` (stable),
  - cap marker by `(merchant_id, attempts)`,
  - finaliser by `(merchant_id)`.
* Uniqueness constraints:
  - â‰¤1 `poisson_component` per `(merchant_id, attempt)`,
  - â‰¤1 `ztp_rejection` per `(merchant_id, attempt)`,
  - â‰¤1 `ztp_retry_exhausted` per merchant,
  - â‰¤1 `ztp_final` per **resolved** merchant.

### 10.8 Trace duty (MUST).

* After **each** S4 row append, write one cumulative `rng_trace_log` record (saturating totals) keyed by `(module, substream_label)`.
  - Consuming attempt: trace counters **increase** by the eventâ€™s `blocks`/`draws`.
  - Non-consuming marker/final: trace counters **do not increase**; only the event count increments.

### 10.9 Zero-row files & idempotence (MUST).

* Zero-row files are **forbidden**; empty slices write nothing.
* Re-running with identical inputs **must** produce byte-identical content; if a complete partition already exists, **must** no-op (skip-if-final).

---

## 11) Invariants (state-level)

### 11.1 Branch purity & scope.

* **No S4 events** for merchants with `is_multi=false` or `is_eligible=false`.
* S4 is **logs-only**; S4 writes **no Parquet egress** and **never encodes inter-country order**.

### 11.2 Parameterisation & regime.

* For each merchant, `Î·` and `Î»_extra` are computed **once** (binary64, fixed order); `Î»_extra` must be **finite and >0**.
* The Poisson **regime** (`"inversion"` if `Î»<10`, otherwise `"ptrs"`) is **fixed** for the merchant; **no regime switching** mid-loop.

### 11.3 Attempts, markers, finalisers.

* **Acceptance path:**
  - â‰¥1 consuming `poisson_component(context:"ztp")`, with the **last** having `k â‰¥ 1`.
  - Exactly **one** non-consuming `ztp_final{K_targetâ‰¥1, exhausted:false}`.
  - No `ztp_retry_exhausted`.
* **Cap path:**
  - A sequence of `poisson_component` with `k=0` and matching `ztp_rejection`s.
  - Policy=`"abort"` â‡’ exactly **one** `ztp_retry_exhausted{aborted:true}` and **no** `ztp_final`.
  - Policy=`"downgrade_domestic"` â‡’ **no** exhausted marker; exactly **one** `ztp_final{K_target=0, exhausted:true}`.
* **A=0 short-circuit:**
  - Exactly **one** `ztp_final{K_target=0, attempts:0 [ , reason:"no_admissible"]? }`; **no** attempts, **no** rejections, **no** cap marker.

### 11.4 Counter & budget identities.

* For every consuming attempt row: `after > before`, `blocks == after âˆ’ before`, and `draws > 0` (decimal-u128).
* For every non-consuming marker/final: `before == after`, `blocks == 0`, `draws == "0"`.
* Within a merchantâ€™s substream, counter spans are **monotone** and **non-overlapping**.

### 11.5 Cardinality & contiguity.

* Attempt indices are **contiguous**: `1..a` for attempts; `ztp_final.attempts == a` on acceptance/cap, and `== 0` on A=0 short-circuit.
* Exactly **one** `ztp_final` per **resolved** merchant (absent only on hard abort).
* At most **one** `ztp_retry_exhausted` per merchant, and only when the cap is reached.

### 11.6 Partitions, lineage & identifiers.

* All S4 streams live under `{seed, parameter_hash, run_id}`; embedded lineage **equals** path tokens **byte-for-byte**.
* `module`, `substream_label`, `context` **must** match the frozen registry in Â§2A.

### 11.7 Determinism & concurrency.

* For fixed inputs and lineage, the attempt sequence, acceptance, and finaliser content are **bit-replayable** (counter-based).
* Concurrency is **across** merchants only; each merchantâ€™s loop is **serial**. Writer merges are **stable** w\.r.t. Â§6 sort keys.
* Re-runs on identical inputs yield **byte-identical** outputs (idempotence).

### 11.8 Separation of concerns (downstream compatibility).

* S4 **fixes** only `K_target` (or governed `0`); **S6** realises `K_realized = min(K_target, A)` and owns which foreign ISO2s are chosen.
* S3 `candidate_rank` remains the sole cross-country **order** authority; S4 never writes order.

### 11.9 Prohibitions.

* **MUST NOT** emit any S4 rows for singles/ineligible merchants.
* **MUST NOT** compute/encode inter-country order.
* **MUST NOT** write zero-row files.
* **MUST NOT** change `Î»_extra` or `regime` across attempts for a merchant.
* **MUST NOT** use timestamps or file order to reconstruct sequencing (counters only).

---

## 12) Failure vocabulary (stable codes)

> **Principles.**
> - Fail **deterministically**; never emit partial merchant output.
> - **Scope** every failure (Merchant vs Run).
> - Emit **values-only** context (no paths), with stable keys.
> - Prefer **merchant-scoped** failure; reserve **run-scoped** for structural/authority violations.

### 12.1 Required failure payload (all codes) â€” **MUST**

Each failure record **MUST** include:

```
{
  code,
  scope âˆˆ {"merchant","run"},
  reason : str,
  merchant_id? : int64,
  seed : u64, parameter_hash : hex64, run_id : str, manifest_fingerprint : hex64,
  attempts? : int,          // present if any attempts occurred; 0 for A=0 short-circuit; omitted otherwise
  lambda_extra? : float64,  // present if computed (Â§9.3) or any attempts were made
  regime? : "inversion" | "ptrs"
}
```

*`merchant_id` is present for merchant-scoped failures.*

### 12.2 Stable codes â€” **MUST**

| Code                    | Scope    | Condition (trigger)                                                                                      | Required producer behavior                                                  |
|-------------------------|----------|----------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| `UPSTREAM_MISSING_S1`   | Merchant | No authoritative hurdle decision found for merchant (S1)                                                 | **Abort** merchant; write no S4 events; upstream coverage error.            |
| `NUMERIC_INVALID`       | Merchant | $\lambda_{\text{extra}}$ is NaN/Inf/â‰¤0 after Â§9.3                                                        | **Abort** merchant; **no** attempts; **no** `ztp_final`; log failure.       |
| `BRANCH_PURITY`         | Merchant | Any S4 event for `is_multi=false` or `is_eligible=false`                                                 | **Abort** merchant; suppress further S4 events; log failure.                |
| `A_ZERO_MISSHANDLED`    | Merchant | `A=0` **and** (any attempts **or** `K_targetâ‰ 0` **or** *(if schema has field)* `reasonâ‰ "no_admissible"`) | **Abort** merchant; log failure (implementation bug).                       |
| `ATTEMPT_GAPS`          | Merchant | Attempt indices not contiguous from 1..a                                                                 | **Abort** merchant; log failure.                                            |
| `FINAL_MISSING`         | Merchant | Acceptance observed (last `poisson_component.kâ‰¥1`) but **no** `ztp_final`                                | **Abort** merchant; log failure.                                            |
| `MULTIPLE_FINAL`        | Merchant | >1 `ztp_final` for merchant                                                                              | **Abort** merchant; log failure.                                            |
| `CAP_WITH_FINAL_ABORT`  | Merchant | `ztp_retry_exhausted` present and policy=`abort` **but** a `ztp_final` exists                            | **Abort** merchant; log failure.                                            |
| `ZTP_EXHAUSTED_ABORT`   | Merchant | Cap hit and policy=`abort`                                                                               | **Stop** merchant; **no** `ztp_final`; log this code (outcome; not a bug).  |
| `TRACE_MISSING`         | Merchant | Event append without a corresponding **cumulative** `rng_trace_log` update                               | **Abort** merchant; log failure; trace duty breached.                       |
| `POLICY_INVALID`        | Run      | `ztp_exhaustion_policy` **missing or** âˆ‰ {"abort","downgrade_domestic"}                                  | **Abort run**; configuration/artefact error.                                |
| `REGIME_INVALID`        | Merchant | `regime` âˆ‰ {"inversion","ptrs"} **or** regime switched mid-merchant                                      | **Abort** merchant; log failure.                                            |
| `RNG_ACCOUNTING`        | Merchant | Consuming row with `drawsâ‰¤0` **or** `blocksâ‰ afterâˆ’before`; **or** non-consuming marker advanced counters | **Abort** merchant; log failure; counters must be monotone/non-overlapping. |
| `STREAM_ID_MISMATCH`    | Run      | `module/substream_label/context` deviate from Â§2A registry                                               | **Abort run**; label registry violated.                                     |
| `PARTITION_MISMATCH`    | Run      | Path tokens `{seed,parameter_hash,run_id}` â‰  embedded envelope fields                                    | **Abort run**; structural violation.                                        |
| `DICT_BYPASS_FORBIDDEN` | Run      | Producer used literal paths (bypassed dictionary)                                                        | **Abort run**; structural violation.                                        |
| `UPSTREAM_MISSING_S2`   | Merchant | S2 `nb_final` absent for merchant entering S4                                                            | **Abort** merchant; upstream coverage error.                                |
| `UPSTREAM_MISSING_A`    | Merchant | **`s3_candidate_set`** unavailable/ill-formed for the merchant (A cannot be derived)                     | **Abort** merchant; upstream S3 error.                                      |
| `ZERO_ROW_FILE`         | Run      | Any S4 stream wrote a zero-row file                                                                      | **Abort run**; zero-row files forbidden.                                    |
| `UNKNOWN_CONTEXT`       | Run      | S4 events have `contextâ‰ "ztp"`                                                                           | **Abort run**; schema/producer bug.                                         |

### 12.3 No partial writes â€” **MUST**

* On **merchant-scoped** failure, **MUST NOT** emit additional S4 rows for that merchant after logging the failure.
* On **run-scoped** failure, **MUST** stop writing immediately.

### 12.4 Logging keys (stable) â€” **MUST**

Use these values-only keys for failure lines:

```
s4.fail.code, s4.fail.scope, s4.fail.reason,
s4.fail.attempts, s4.fail.lambda_extra, s4.fail.regime,
s4.run.seed, s4.run.parameter_hash, s4.run.run_id, s4.run.manifest_fingerprint,
s4.fail.merchant_id?
```

### 12.5 Mapping to validation â€” **Informative**

Validator checks for `ATTEMPT_GAPS`, `FINAL_MISSING`, `RNG_ACCOUNTING`, `TRACE_MISSING` mirror these producer codes; failures should correlate 1:1.

**Informative.** S4 codes are the canonical names for this state and appear **as-is** in the global ledger; the runâ€™s failure record also carries the S0 global `failure_class` per the validation schema.

---

## 13) Observability (values-only; bytes-safe)

> **Aim.** Minimal, stable metrics for S4 health/cost/behavior **without** paths/PII or duplicating validator logic. Metrics are values-only and keyed to run lineage.

### 13.1 Run lineage dimensions â€” **MUST**

Every metric line **MUST** include:

```
{ seed, parameter_hash, run_id, manifest_fingerprint }
```

### 13.2 Minimal counters & gauges â€” **MUST**

| Key                              | Type    | Definition                                                                                                                                  |
|----------------------------------|---------|---------------------------------------------------------------------------------------------------------------------------------------------|
| `s4.merchants_in_scope`          | counter | # merchants that entered S4 (S1 multi **and** S3 eligible).                                                                                 |
| `s4.accepted`                    | counter | # merchants with `ztp_final{K_targetâ‰¥1, exhausted:false}`.                                                                                  |
| `s4.short_circuit_no_admissible` | counter | # merchants resolved via **A=0** short-circuit (detect as `attempts==0 âˆ§ K_target==0` and, **if field exists**, `reason=="no_admissible"`). |
| `s4.downgrade_domestic`          | counter | # merchants with `ztp_final{K_target=0, exhausted:true}`.                                                                                   |
| `s4.aborted`                     | counter | # merchants with `ZTP_EXHAUSTED_ABORT`.                                                                                                     |
| `s4.rejections`                  | counter | Total zero-draw rejections written (count of `ztp_rejection`).                                                                              |
| `s4.attempts.total`              | counter | Total attempts across all merchants (count of `poisson_component`).                                                                         |
| `s4.trace.rows`                  | counter | Total S4 events appended (sum over all four streams; should equal cumulative trace row count).                                              |
| `s4.regime.inversion`            | counter | # merchants whose regime was `"inversion"`.                                                                                                 |
| `s4.regime.ptrs`                 | counter | # merchants whose regime was `"ptrs"`.                                                                                                      |

### 13.3 Distributions / histograms â€” **SHOULD**

| Key                       | Kind      | Definition                                                                       |
|---------------------------|-----------|----------------------------------------------------------------------------------|
| `s4.attempts.hist`        | histogram | Per-merchant attempts (accepted path â†’ `attempts`; A=0 â†’ 0; abort â†’ cap value).  |
| `s4.lambda.hist`          | histogram | Bucketed $\lambda_{\text{extra}}$ (e.g., log-buckets); values are finite and >0. |
| `s4.ms.poisson_inversion` | histogram | Milliseconds spent in inversion branch (per merchant).                           |
| `s4.ms.poisson_ptrs`      | histogram | Milliseconds spent in PTRS branch (per merchant).                                |

### 13.4 Derived rates (computed by metrics layer) â€” **SHOULD**

* `s4.accept_rate = s4.accepted / s4.merchants_in_scope`
* `s4.cap_rate = s4.aborted / s4.merchants_in_scope`
* `s4.mean_attempts = s4.attempts.total / s4.merchants_in_scope`

### 13.5 Per-merchant summaries â€” **SHOULD**

Emit one values-only summary per **resolved** merchant:

```
s4.merchant.summary = {
  merchant_id,
  attempts,
  accepted_K : (K_target | 0),
  regime,
  exhausted : bool,
  reason?          // present only if the ztp_final schema has this optional field
}
```

*`accepted_K` is 0 for A=0 short-circuit or downgrade. Omit the summary for hard abort (policy=`abort`).*

### 13.6 Emission points â€” **MUST**

* Increment outcome counters **exactly once per merchant**: on writing `ztp_final` (accepted/downgrade/short-circuit) **or** on logging `ZTP_EXHAUSTED_ABORT`.
* Update attempt/rejection counters **immediately after** writing each corresponding row.
* Write histogram samples **once per merchant** at resolution (on final/abort).
* **Emission responsibility:** Metrics **MUST** be emitted by the same process that writes the event rows, **after** the event fsync completes.

### 13.7 Cardinality & privacy â€” **MUST**

* **Values-only; no paths/URIs.**
* **Bounded cardinality:** keys are run-scoped plus `merchant_id`; no high-cardinality labels beyond those.
* **No PII.** `merchant_id` is an ID; do not log names or free-text beyond stable enum `reason` values.

### 13.8 Alerting hints â€” **Informative**

* **Cap rate spike** (e.g., `s4.cap_rate > 0.01`) â†’ investigate Î¸ or `X` transform drift.
* **Mean attempts â†‘** or **rejections â†‘** â†’ indicative of low $\lambda$; check cohorts with small `N` or `X`.
* **Unexpected regime split** â†’ verify regime threshold/constants.
* Any **`NUMERIC_INVALID` > 0** â†’ input/overflow issue; block release.

### 13.9 Output format â€” **MUST**

All metrics are emitted as structured values (e.g., JSON lines) with the lineage dimension and keys from this section; consumers/aggregation are outside S4â€™s scope.

---

## 14) Interfaces & dictionary (lookup table)

> **Goal.** Freeze exactly what S4 **writes** and **reads**, how each stream is **partitioned**, which **envelope** fields are required, the **writer sort keys**, and who **consumes** the output. Physical paths come from the **Data Dictionary**; S4 **must not** hard-code paths.

### 14.1 Streams S4 **writes** (logs-only)

| Stream ID                                            | Schema anchor (authoritative)                         | Partitions (path keys)         | Required envelope fields (all rows)                                      | Required payload (minimum)                                                                                                                          | Writer sort keys (stable)                                               | Consumers                                             |
|------------------------------------------------------|-------------------------------------------------------|--------------------------------|--------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------|-------------------------------------------------------|
| `rng_event_poisson_component` (with `context:"ztp"`) | `schemas.layer1.yaml#/rng/events/poisson_component`   | `seed, parameter_hash, run_id` | `ts_utc, module, substream_label, context, before, after, blocks, draws` | `{ merchant_id, attempt:intâ‰¥1, k:intâ‰¥0, lambda_extra:float64, regime:"inversion" \| "ptrs" }`                                                       | `(merchant_id, attempt)`                                                | S4 validator, observability                           |
| `rng_event_ztp_rejection`                            | `schemas.layer1.yaml#/rng/events/ztp_rejection`       | `seed, parameter_hash, run_id` | *(same envelope fields as above)*                                        | `{ merchant_id, attempt:intâ‰¥1, k:0, lambda_extra }`                                                                                                 | `(merchant_id, attempt)`                                                | S4 validator, observability                           |
| `rng_trace_log`                                      | `schemas.layer1.yaml#/rng/core/rng_trace_log`         | `seed, parameter_hash, run_id` | `ts_utc, module, substream_label`                                        | `{ module, substream_label, rng_counter_after_hi:u64,  rng_counter_after_lo:u64  }`                                                                 | `(module, substream_label, rng_counter_after_hi, rng_counter_after_lo)` | S4 validator, observability                           |
| `rng_event_ztp_retry_exhausted`                      | `schemas.layer1.yaml#/rng/events/ztp_retry_exhausted` | `seed, parameter_hash, run_id` | *(same envelope fields as above)*                                        | `{ merchant_id, attempts:intâ‰¥1, lambda_extra, aborted:true }`                                                                                       | `(merchant_id, attempts)`                                               | S4 validator, observability (abort-only)              |
| `rng_event_ztp_final`                                | `schemas.layer1.yaml#/rng/events/ztp_final`           | `seed, parameter_hash, run_id` | *(same envelope fields as above)*                                        | `{ merchant_id, K_target:intâ‰¥0, lambda_extra:float64, attempts:intâ‰¥0, regime:"inversion" \| "ptrs", exhausted?:bool [ , reason:"no_admissible"]? }` | `(merchant_id)`                                                         | **S6** (reads `K_target,â€¦`), validator, observability |

**MUST.**

* **Pathâ†”embed equality:** For **event streams**, embedded `{seed, parameter_hash, run_id}` **must equal** path tokens **byte-for-byte**.  
  `rng_trace_log` **omits** these fields by design; lineage equality for trace rows is enforced via the partition path keys.
* **Label registry:** For **event streams**, `module`, `substream_label`, `context` **must** match Â§2Aâ€™s frozen literals.  
  `rng_trace_log` carries only `module` and `substream_label` (no `context`).
* **File order is non-authoritative:** Pairing/replay **MUST** use **envelope counters** only.
* **Trace duty:** After each event append, **append exactly one** cumulative `rng_trace_log` row (see Â§Â§7/10).
* **Failure records sink:** On abort, write values-only `failure.json` under the S0 bundle path `data/layer1/1A/validation/failures/fingerprint={manifest_fingerprint}/seed={seed}/run_id={run_id}/` using the payload keys in Â§12.1/Â§12.4. *(Not a stream.)*

**Schema versioning note.** The optional `reason:"no_admissible"` field on `ztp_final` is **present only** in schema versions that include it (per Â§21.1 it is absent in this version). Its mention in the table is **forward-compatible**; producers must omit it unless the bound schema version defines it.

---

### 14.2 Surfaces S4 **reads** (gates / facts)

| Surface                            | Schema anchor                                       | Partitions                     | What S4 uses (only)                                                                             | Notes                            |
|------------------------------------|-----------------------------------------------------|--------------------------------|-------------------------------------------------------------------------------------------------|----------------------------------|
| S1 hurdle events                   | `schemas.layer1.yaml#/rng/events/hurdle_bernoulli`  | `seed, parameter_hash, run_id` | **Gate:** `is_multi==true` to enter S4                                                          | S4 writes nothing for singles    |
| S2 `nb_final`                      | `schemas.layer1.yaml#/rng/events/nb_final`          | `seed, parameter_hash, run_id` | **Fact:** authoritative `N_mâ‰¥2` (non-consuming; one per merchant)                               | Read-only; S4 must not alter `N` |
| S3 `crossborder_eligibility_flags` | `schemas.1A.yaml#/s3/crossborder_eligibility_flags` | `parameter_hash`               | **Gate:** `is_eligible==true`                                                                   | Deterministic; no RNG            |
| S3 `candidate_set`                 | `schemas.1A.yaml#/s3/candidate_set`                 | `parameter_hash`               | **Context:**  `A := size(S3.candidate_set \ {home})` (foreign count only); S4 doesnâ€™t use order | File order non-authoritative     |

**MUST.** When reading S1/S2 logs, enforce **pathâ†”embed** equality on `{seed, parameter_hash, run_id}`; treat violations as structural failures (run-scoped).

---

### 14.3 Ordering & idempotence requirements (writer)

* **Sort before write** per table above; merges must be **stable** w.r.t. sort keys.
* **Skip-if-final:** if a complete partition already exists with byte-identical content, **no-op**.
* **Uniqueness per merchant:** â‰¤1 `poisson_component` per `(merchant_id, attempt)`; â‰¤1 `ztp_rejection` per `(merchant_id, attempt)`; â‰¤1 `ztp_retry_exhausted`; â‰¤1 `ztp_final` if the merchant is **resolved** (absent only under hard abort).

---

## 15) Numeric policy & equality (S4-local application)

> **Goal.** Pin the exact math, equality, and comparison discipline S4 applies so results are reproducible and validator-provableâ€”without tolerances or hidden heuristics.

### 15.1 Floating-point profile (binding)

* **IEEE-754 binary64**, **round-to-nearest-even**, **FMA-off**, **no FTZ/DAZ** for any computation that can affect outcomes or payloads.
* All merchant-local computations run with a **fixed operation order**; no parallel/underdetermined reductions.

**MUST.** Treat **NaN/Inf** anywhere in `Î·`/`Î»_extra` evaluation as a hard error (`NUMERIC_INVALID`); write no attempts.

---

### 15.2 Link evaluation & regime threshold

* **Link:** $\eta = \theta_0 + \theta_1 \log N + \theta_2 X + \cdots$ evaluated in **binary64**, fixed order.
  **Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.
* **Intensity:** $\lambda_{\text{extra}}=\exp(\eta)$ (**finite, >0** required).
* **Regime (spec-fixed threshold):**
  * If $\lambda_{\text{extra}} < 10$ â†’ `regime="inversion"`
  * Else (including `==10`) â†’ `regime="ptrs"`
    Regime is **fixed per merchant** (no switching mid-loop).
  *(Primary rule.)* See **Â§15.6 Payload constancy within a merchant** for the one-time evaluation and constancy of `regime` and `lambda_extra`.
* **Informative.** PTRS constants are normative and pinned upstream in **S0.3.7**; **S2 Â§3.2** implements that profile for NB Poisson.

---

### 15.3 Uniform mapping & budget identities

* **Open-interval uniforms:** map PRNG counters to `uâˆˆ(0,1)` (strict-open; never include 0 or 1).
* **Consuming attempts** (`poisson_component`) must satisfy **both**:
  `blocks == after âˆ’ before` (**>0**) and `draws` (decimal-u128 string) parses and **>0**.
* **Non-consuming markers/final** (`ztp_rejection`, `ztp_retry_exhausted`, `ztp_final`) must satisfy:
  `before == after`, `blocks == 0`, `draws == "0"`.

---

### 15.4 Equality & ordering rules

* **Exact equality** for integers, counters, regime enums, and lineage tokens (no tolerances).
* **Float comparisons:** the only float comparison that affects control flow is the **regime split** at `Î»<10` vs `â‰¥10`; apply it directly in binary64 (**no epsilons**).
* **Ordering for replay/validation:** use **counters** exclusively; timestamps are observational; **file order is non-authoritative**.

---

### 15.5 Determinism & concurrency

* **Serial per merchant:** the attempt loop is single-threaded with fixed iteration order.
* **Across merchants:** concurrency allowed; any writer/merge must be **stable** w\.r.t. Â§14 sort keys so identical inputs yield **byte-identical** outputs.

---

### 15.6 Payload constancy within a merchant

* `lambda_extra` and `regime` are computed **once** and **must** be identical across all S4 rows for that merchant (attempts, markers, final).
* Attempt indices are **contiguous** starting at 1; `ztp_final.attempts` equals the last attempt index (or 0 for A=0 short-circuit).

---

### 15.7 Prohibitions

* **No epsilons** or fuzzy checks in producer logic (validators may compute diagnostics, but producer decisions are exact).
* **No regime drift**, **no counter reuse**, **no zero-row files**, **no path literals**.

---

## 16) Complexity & parallelism

**16.1 Per-merchant asymptotics**

* **Attempt loop (Poisson):** amortised **O(1)** work per attempt; **O(1)** memory.
* **Expected attempts:** $\mathbb{E}[\text{attempts}]=1/p$, with $p=1-e^{-\lambda_{\text{extra}}}$. The governed cap `MAX_ZTP_ZERO_ATTEMPTS` bounds worst-case attempts.
* **Uniform budgets (qualitative):**

  * **Inversion** (`Î»<10`): exactly **`K+1` uniforms** for a draw returning `K`.
  * **PTRS** (`Î»â‰¥10`): a small, **variable** count per attempt (â‰¥2). Budgets are **measured from envelopes**; producers do not infer them.
* **Rows per merchant (expected):**

  * **Acceptance path:** `attempts`Ã—`poisson_component` + (`attemptsâˆ’1`)Ã—`ztp_rejection` + 1Ã—`ztp_final`.
  * **Cap + downgrade:** `MAX`Ã—`poisson_component` + `MAX`Ã—`ztp_rejection` + 1Ã—`ztp_retry_exhausted` + 1Ã—`ztp_final`.
  * **Cap + abort:** `MAX`Ã—`poisson_component` + `MAX`Ã—`ztp_rejection` + 1Ã—`ztp_retry_exhausted`.
  * **A=0 short-circuit:** 1Ã—`ztp_final` only.

**16.2 Throughput & sizing**

* **Concurrency model:** run merchants **in parallel** up to a worker cap `C`; each merchantâ€™s loop remains **serial**.
* **Writer strategy (deterministic):**
  (a) **Serial writer**: one writer enforces Â§6 sort keysâ€”simplest route to byte-identical outputs.
  (b) **Partitioned merge**: workers spill **sorted** chunks; a final **stable** merge per partition assembles `(merchant_id, attempt)` order (and cap/final keys).
* **Back-pressure:** bound in-flight merchants; size queues so the writer never merges out-of-order.
* **File layout:** avoid tiny files; batch into sensible row-groups. The spec mandates **content & order** (Â§6) and **idempotence**, not physical sizes.

**16.3 Determinism & resume**

* **Idempotence:** identical inputs â‡’ **byte-identical** outputs. If a complete partition exists, **skip-if-final**.
* **Resume:** stageâ†’fsyncâ†’rename ensures an all-or-nothing publish; reruns are safe.

**16.4 Instrumentation overhead**

* Metrics (values-only, Â§13) update at acceptance/short-circuit/abort and **after each event append**; they do not affect control flow.

---

## 17) Deterministic read-side lineage gates

> These gates ensure S4 runs only for the correct merchants and reads only authoritative inputs, with lineage equality enforced **byte-for-byte**.

### 17.1 Lineage equality for S1/S2 reads â€” MUST
When reading S1/S2 logs, embedded envelope fields **`{seed, parameter_hash, run_id}` must equal** the path tokens **byte-for-byte**. Any mismatch is a **run-scoped structural failure** (`PARTITION_MISMATCH`); S4 must abort the run.

### 17.2 Upstream coverage & uniqueness â€” MUST

* **Hurdle presence (S1):** exactly one authoritative hurdle decision **must** exist for the run.

  * If **absent** â‡’ **`UPSTREAM_MISSING_S1`** (merchant-scoped abort); S4 **must not** write any S4 rows for that merchant.
  * If present with `is_multi=false` â‡’ merchant is out of scope; any S4 events would be `BRANCH_PURITY`.
* **NB final (S2):** exactly one **non-consuming** `nb_final` per merchant in scope; it fixes **`N_mâ‰¥2`**. Absence â‡’ `UPSTREAM_MISSING_S2` (merchant-scoped abort).
* **Eligibility & admissible context (S3):** S4 requires an eligibility verdict and an admissible set to derive **`A`**. Missing/ill-formed context â‡’ `UPSTREAM_MISSING_A` (merchant-scoped abort). S4 **does not** use S3 order at this state.

  * **File order is non-authoritative** for S3 reads: derive **`A := size(S3.candidate_set \ {home})`** from set contents only (never from writer order).

### 17.3 Dictionary resolution â€” MUST
All physical locations (read and write) are resolved via the **Data Dictionary**. Hard-coding or constructing literal paths is forbidden (`DICT_BYPASS_FORBIDDEN`, run-scoped).

### 17.4 Partition scopes â€” MUST

* **Reads:** S1/S2 under **`{seed, parameter_hash, run_id}`**; S3 under **`parameter_hash={â€¦}`** (parameter-scoped).
* **Writes:** all S4 streams under **`{seed, parameter_hash, run_id}`**. Pathâ†”embed equality must hold for every S4 row written.

### 17.5 Time & ordering neutrality â€” MUST
S4 must not depend on wall-clock time or file enumeration order. Ordering/replay is by **counters only** (per Â§10); timestamps are observational.

### 17.6 Merchant scope isolation â€” MUST
A merchantâ€™s attempt loop uses a **merchant-keyed** substream and may not interleave counter spans with another merchantâ€™s substream. Counter reuse across merchants is forbidden.

### 17.7 Deterministic inputs surface â€” MUST
`Î·`/`Î»_extra`, `regime`, and `A` must be determined solely from governed values (`Î¸`, `X` transform/default, `MAX_ZTP_ZERO_ATTEMPTS`, `ztp_exhaustion_policy`) and authoritative upstream facts (S1, S2, S3). No environment-dependent inputs are permitted.

### 17.8 Failure handling â€” MUST
On any gate violation above, producers emit exactly one **values-only** failure line (per Â§12) and stop in the appropriate scope (merchant/run). **No partial merchant output** may be written after a merchant-scoped failure.

---

## 18) Artefact governance & parameter-hash participation

### 18.1 Purpose.
Pin exactly which governed inputs S4 depends on, how they are versioned and normalised, and how their bytes participate in the runâ€™s **`parameter_hash`**. S4 is **logs-only** and is partitioned by `{seed, parameter_hash, run_id}`; these rules ensure **reproducible** K-draws and traceability.

### 18.2 Governance ledger (S4-relevant artefacts) â€” MUST

| Artefact (governed value) | Purpose in S4                          | Owner       | Semver | Digest algo | Participates in `parameter_hash` | Notes                                             |
|---------------------------|----------------------------------------|-------------|--------|-------------|----------------------------------|---------------------------------------------------|
| `Î¸ = (Î¸â‚€, Î¸â‚, Î¸â‚‚, â€¦)`     | Link parameters for `Î·`                | Policy      | x.y.z  | SHA-256     | **YES**                          | Numeric values serialised canonically (see Â§18.3) |
| `X` transform spec        | Map raw signals â†’ `X_m âˆˆ [0,1]`        | Policy/Data | x.y.z  | SHA-256     | **YES**                          | Includes scaling, cohort, monotone mapping        |
| `X_default`               | Fallback when `X_m` missing            | Policy      | x.y.z  | SHA-256     | **YES**                          | Must be in \[0,1]                                 |
| `MAX_ZTP_ZERO_ATTEMPTS`   | Zero-draw cap (int)                    | Policy      | x.y.z  | SHA-256     | **YES**                          | Default 64 unless governed otherwise              |
| `ztp_exhaustion_policy`   | `"abort"` or `"downgrade_domestic"`    | Policy      | x.y.z  | SHA-256     | **YES**                          | Closed enum                                       |
| Label/stream registry     | `module`, `substream_label`, `context` | Engine      | x.y.z  | SHA-256     | **NO** (code contract)           | Changes are **breaking**; see Â§19                 |
| S0 numeric/RNG profile    | FP & PRNG law                          | Engine      | x.y.z  | SHA-256     | **NO** (code contract)           | Changes are **breaking**; see Â§19                 |

**Informative.** Governance MAY prefer a sub-linear size effect; this is **not** a protocol constraint.

### 18.3 Normalisation & hashing â€” MUST

* **Number serialisation:** All floating-point values **MUST** be serialised using **shortest round-trip binary64** text (no locale/epsilon variants).
* **Key order:** Within each artefact, keys **MUST** be sorted **lexicographically** before serialisation.
* **Concatenation order:** Compute

  ```
  parameter_hash = H(
    bytes(Î¸) ||
    bytes(X-transform) ||
    bytes(X_default) ||
    bytes(MAX_ZTP_ZERO_ATTEMPTS) ||
    bytes(ztp_exhaustion_policy)
  )
  ```

  using the **exact artefact order** shown above (topâ†’bottom).
* Any change to these bytes **must** produce a new `parameter_hash` and hence a new S4 run partition.

### 18.4 Change classes & scope â€” MUST

* **Policy changes** (Î¸, X transform/default, cap, policy) **participate** in `parameter_hash`; **not** breaking by themselves.
* **Code-contract changes** (labels/contexts, envelope field set, regime threshold/constants, partition keys, S0 numeric/PRNG law) **do not** flow through `parameter_hash`; they are **breaking** (see Â§19).
* **Upstream inputs (S1/S2/S3)** are authoritative **inputs** and **do not** participate in `parameter_hash` (they may change outcomes, but not the hash).

### 18.5 Provenance & auditability â€” MUST
For each governed artefact, the run manifest (outside S4 logs) **must** report: `{name, version, digest, owner, last_updated}`. Producers **must** ensure the values injected into S4 match those versions **byte-for-byte**.

### 18.6 Prohibitions â€” MUST NOT

* **MUST NOT** fetch governed values from environment variables, clocks, or non-versioned stores.
* **MUST NOT** compute `Î¸` or `X` from non-governed sources.

---

## 19) Compatibility & evolution

**Goal.** Define which changes are **additive-safe**, which are **breaking**, how to **version/tag** them, and how to **migrate** without ambiguity or data loss. S4 is logs-only; forward compatibility hinges on **stable labels, envelopes, partitions, and semantics**.

### 19.1 Change taxonomy â€” **MUST**

Classify each contemplated change into exactly one bucket:

1. **Policy change** (participates in `parameter_hash`): `Î¸`, `X` transform/default, `MAX_ZTP_ZERO_ATTEMPTS`, `ztp_exhaustion_policy`.
2. **Additive-safe schema extension**: optional payload fields with defaults; **no** change in meaning of existing fields.
3. **Breaking code-contract change**: labels/contexts, envelope structure, regime threshold/constants, partition keys, or meanings of existing fields.

### 19.2 Additive-safe changes â€” **MUST**

Allowed without breaking consumers, provided JSON-Schema marks fields **optional** with **default behaviour** and consumers are tolerant readers:

* Add an **optional** payload field to `poisson_component`, `ztp_rejection`, `ztp_retry_exhausted`, or `ztp_final` (e.g., `reason`, `merchant_features_hash`, `cap_policy_version`).
* Add an **optional** boolean like `short_circuit?: true` to `ztp_final` (A=0 case), default `false`.
* Add **observability-only** counters/histograms (values-only, Â§13) not used in control flow.
* Tighten **validator corridors** (outside S4 producer; no producer behaviour change).

**MUST.** Preserve **existing meanings**; defaults **must** exactly reproduce prior behaviour. Keep **writer sort keys, partitions, labels, contexts** unchanged.

### 19.3 Breaking changes â€” **MUST NOT** (without a major)

Require a **major** bump + migration (see Â§19.5):

* Changing any **label/stream identifier** in Â§2A: `module`, `substream_label`, or `context:"ztp"`.
* Changing **partition keys** (currently `{seed, parameter_hash, run_id}`) or the **pathâ†”embed equality** rule.
* Modifying the **envelope field set**, types, or semantics (`before/after/blocks/draws`).
* Changing the **regime threshold** (`Î»<10` inversion â†’ `ptrs`) or **PTRS constants**, or the **open-interval** rule for `u01`.
* Removing or altering the **`ztp_final`** contract (e.g., making it consuming, changing its role as the single acceptance record).
* Using **timestamps** or **file order** for ordering instead of counters.
* Altering **writer sort keys** per stream.

### 19.4 Deprecation policy â€” **MUST**

* Any additive field later removed is **breaking**.
* Announce deprecations as **"present but ignored"** for at least **one minor** release before removal; keep validators tolerant during the window.
* Record deprecations in the **Data Dictionary** and **artefact registry** changelog.

### 19.5 Migration playbook (for breaking changes) â€” **MUST**

1. **Version & tag.**

   * Bump the **module literal** (e.g., `1A.ztp_sampler.v2`).
   * Introduce **versioned schema anchors** by **suffixing anchor IDs with `@vN`** (e.g., `schemas.layer1.yaml#/rng/events/poisson_component@v2`). 
   * S4 normatively uses this suffix scheme; path-segment anchor versioning is **not used** by S4. 
   * The **Data Dictionary must pin** the exact anchor version per stream.

2. **Dual-write window (optional, recommended).**

   * Producers **MAY** dual-write v1 and v2 for a bounded window; the Dictionary **must** list both.
   * Validators pin to the intended version per run configuration.

3. **Cutover & freeze.**

   * After consumers confirm v2 ingestion, freeze v1 (no more writes) and mark it **deprecated** in dictionary/registry.

4. **Backfill policy.**

   * Backfills **must** run with the same **`parameter_hash`** inputs to guarantee byte-identical outcomes.
   * When the **code contract** changes, backfill under **new version tags** only (do **not** rewrite old partitions).

### 19.6 Coexistence rules â€” **MUST**

* Consumers **must** pin on one of: `(module, schema version)` or `(context, schema version)`; never "best-effort".
* Producers **must not** interleave v1 and v2 rows within the same `(seed, parameter_hash, run_id)` partition.

### 19.7 Consumer & validator impact â€” **MUST**

* **S6**: Reads only `ztp_final{K_target, lambda_extra, attempts, regime, exhausted?}`; tolerant to **optional** new fields; **must** ignore unknown keys.
* **Validators**: Tolerate additive fields; enforce invariants on the **core** set (attempt accounting, cardinalities, counters, existence/absence of `ztp_final`, cap semantics).
* **Downstream order**: S3 `candidate_rank` remains the sole authorityâ€”unchanged by S4 evolution.

### 19.8 Version signalling â€” **MUST**

* Expose `{module_version, schema_version}` in the S4 run manifest (outside logs) and **optionally** in `ztp_final` as **optional** payload fields for audit.
* Track `Î¸`/`X`/cap/policy versions in the **governance ledger** (Â§18) and tie them to `parameter_hash`.

### 19.9 Rollback stance â€” **MUST**

* Rollbacks **must not** overwrite or delete already-published partitions.
* After rollback, producers **must** resume writing with the previous stable `(module, schema)` pair; the Dictionary must point consumers accordingly.

### 19.10 Examples of safe vs breaking changes â€” **Informative**

* **Safe (additive):** Add optional `reason:"no_admissible"` to `ztp_final` (default absent).
* **Breaking:** Rename `context:"ztp"` â†’ `"ztp_k"`; change `Î»` threshold to 8; make `ztp_final` consuming.

---

## 20) Handoff to later states

### 20.1 Purpose.
Freeze exactly what S4 exports, who consumes it, and how downstream must interpret it. S4 is **logs-only**; it fixes a **target** foreign count and nothing else.

### 20.2 What S4 exports (authoritative for downstream).
From `ztp_final` for merchant *m*:

* `K_target : intâ‰¥0` â€” target foreign count (**authoritative outcome of S4**).
  - `â‰¥1` on acceptance;
  - `=0` only via **A=0 short-circuit** or **exhaustion policy = "downgrade_domestic"**.
* `lambda_extra : float64` â€” intensity used (audit/diagnostics only; not a gate downstream).
* `attempts : intâ‰¥0` â€” number of Poisson attempts written by S4 (`0` iff short-circuit).
* `regime : "inversion"|"ptrs"` â€” Poisson sampler branch (closed enum).
* `exhausted? : bool` â€” present/`true` only for **cap + downgrade** outcome; omitted otherwise.
* Optional `reason : "no_admissible"` â€” present only for A=0 short-circuit (if the schema includes this optional field).

### 20.3 Who consumes S4 and how.

* **S6 (top-K selection)** â€” *MUST* read `ztp_final{K_target, lambda_extra, attempts, regime, exhausted?, reason?}` and combine with its own admissible foreign set of size `A`.
  - *Realisation rule (binding):* **`K_realized = min(K_target, A)`**.
  - If `K_target = 0` (short-circuit/downgrade): *MUST* skip top-K and continue domestic-only.
  - If `K_target > A` (shortfall): *MUST* select **all A**; **MAY** log a non-consuming `topk_shortfall{K_target, A}` marker **in S6**.
* **S7 (allocation / integerisation)** â€” *MUST NOT* infer any probability from S4 logs. It receives the set chosen by S6 and later allocates **N** across {home + chosen foreigns} (outside S4â€™s scope).
* **S8 (sequencing / IDs)** â€” unaffected by S4 semantics; it operates on per-country counts.
* **S9 (egress / handoff to 1B)** â€” S4 contributes no egress rows. S9â€™s `outlet_catalogue` contains **no** inter-country order; consumers recover order from S3 `candidate_rank`.

### 20.4 Authority boundaries (reaffirmed).

* S4 **never** encodes inter-country order; **S3 `candidate_rank`** remains the sole authority for cross-country order (home=0; contiguous).
* S4 **fixes only** the **target** count (`K_target`); S6/S7/S8 own *which* countries, *how many per country*, and *per-country sequences* respectively.
* S4â€™s `lambda_extra`, `attempts`, `regime` are **audit surfaces**, not consumer gates.

### 20.5 Consumer pitfalls (MUST NOT).

* *MUST NOT* derive **`K_target`** by counting Poisson attempts or rejections; the **only** authoritative target is `ztp_final.K_target`. *(S6 later realises `K_realized = min(K_target, A)`.)*
* *MUST NOT* treat `lambda_extra` as a probabilistic weight for later selection.
* *MUST NOT* exceed `A` when realising K (enforced in **S6 (Top-K selection)** via `min(K_target, A)`).
* *MUST NOT* process a merchant **without a `ztp_final`** (e.g., `NUMERIC_INVALID` or cap + policy=`"abort"`).

### 20.6 Lineage continuity (MUST).
All downstream states (S6+) *must* carry forward `{seed, parameter_hash, run_id}` as read from S4; they *must not* reinterpret or recompute `lambda_extra` or `regime`.

---

## 21) Glossary & closed vocabularies â€” **Normative (terms)** / **Informative (glossary)**

### 21.1 Closed vocabularies (enumerations) â€” MUST

* `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}` â€” governed policy when the zero-draw cap is hit.
* `regime âˆˆ {"inversion","ptrs"}` â€” Poisson sampler branch; set once per merchant from the Î» threshold.
* `context == "ztp"` â€” fixed context string on all S4 events.
* `module == "1A.ztp_sampler"`, `substream_label == "poisson_component"` â€” fixed label literals (see Â§2A).
* `reason âˆˆ {"no_admissible"}` â€” optional `ztp_final` payload enum for A=0 short-circuit. 
  *(Schema presence.)* The `reason` field is optional and **absent in this schema version**; adding it in a later schema revision is **additive-safe**; this document fixes the vocabulary in advance.

### 21.2 Terms (precise meanings) â€” MUST/SHOULD

* **ZTP (Zero-Truncated Poisson)** â€” Distribution of `Y | (Yâ‰¥1)` where `Y~Poisson(Î»)`. Realised by rejecting 0s from Poisson draws.
* **PTRS** â€” Poisson sampling regime for large Î» (two uniforms + geometric attempts; constants/threshold fixed).
* **Inversion** â€” Poisson sampling regime for small Î»; consumes exactly `K+1` uniforms for result `K`.
* **`attempt` (intâ‰¥1)** â€” 1-based index of a Poisson draw for a merchant; strictly increasing and contiguous on accepted/capped paths.
* **`attempts` (intâ‰¥0)** â€” on `ztp_final`/cap rows: equals last attempt index; **0 only for A=0 short-circuit**.
* **`draws` (decimal-u128 string)** â€” actual uniforms consumed by the event (consuming rows only).
* **`blocks` (u64)** â€” counter delta = **`after âˆ’ before`** (consuming rows only).
* **`before` / `after` (u128)** â€” PRNG counters that prove order; **timestamps are observational only**.
* **`K_target` (intâ‰¥0)** â€” S4â€™s authoritative **target** foreign count: result of ZTP acceptance (`â‰¥1`) or governed `0` (A=0 / downgrade).
* **`K_realized` (intâ‰¥0)** â€” realised selection size used by **S6**: `min(K_target, A)`.
* **`A` (intâ‰¥0)** â€” size of admissible foreign set from S3 (foreigns only; home excluded).
* **`exhausted` (bool)** â€” `true` only when the cap is hit and policy=`"downgrade_domestic"`; omitted otherwise.
* **`Î»_extra` (float64 > 0)** â€” intensity for extra-country count; computed from log-link `Î·` in binary64 with fixed order.
* **`parameter_hash` (hex64)** â€” runâ€™s parameter set hash; partitions S4 inputs/outputs with `seed`/`run_id`.
* **`manifest_fingerprint` (hex64)** â€” run fingerprint used by egress/validation (S4 writes logs only).

### 21.3 Notational conventions â€” SHOULD

* `log` denotes natural logarithm.
* Where float comparisons affect control flow (Î» threshold), comparisons are exact in binary64 (`Î» < 10` â‡’ inversion; else PTRS).
* All sets/maps over ISO2 codes are **order-free** unless explicitly sorted/ranked by a defined key.

### 21.4 Prohibitions (terminology drift) â€” MUST NOT

* *MUST NOT* call `K_target` "realised K" in S4; **only S6** realises K vis-Ã -vis `A`.
* *MUST NOT* use "probability" for `base_weight_dp` (priors live outside S4); S4 has no priors and no Dirichlet.
* *MUST NOT* use "order" to describe any S4 output; cross-country order belongs exclusively to S3 `candidate_rank`.

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s5-expanded"></a>
# state.1A.s5.expanded.txt

<!-- Source file: state.1A.s5.expanded.v4.9.1.txt | BYTE-EXACT EMBED -->

# S5 SPEC â€” Currencyâ†’Country Weight Expansion (Layer 1 Â· Segment 1A)

# 0. Document metadata & status

**0.1 State identifiers, versioning, effective date**

* **State ID (canonical):** `layer1.1A.S5` â€” â€œCurrencyâ†’Country Weight Expansionâ€. Sub-modules fixed by this spec:
  **`1A.derive_merchant_currency`** (S5.0) and **`1A.expand_currency_to_country`** (S5). 
* **Document name:** `state.1A.s5.spec`.
* **Semver:** `MAJOR.MINOR.PATCH`.
  **MAJOR** bumps on any breaking change to schemas or invariants (e.g., dataset/field rename, default `dp` change, Î£-tolerance change, tie-break rule change, coverage rules). **MINOR** for backward-compatible additions (optional columns, new metrics). **PATCH** for clarifications that do not alter contracts.
* **Effective date:** filled at ratification by release management (`effective_date: YYYY-MM-DD`).

**0.2 Normative language policy**

* **RFC 2119/8174** terms are used with their normative meanings (â€œMUST/SHALL/SHOULD/MAYâ€).
* All requirements in this document are **Binding** unless explicitly marked **Informative**.

**0.3 Sources of authority (single schema authority)**

* **Only JSON-Schema is authoritative** for 1A. Avro (if present) is **non-authoritative** and MUST NOT be referenced in registry/dictionary contracts. The following schema sets and IDs are the sole authorities:
  - Ingress schemas: **`schemas.ingress.layer1.yaml`** (`$id: schemas.ingress.layer1.yaml`). 
  - 1A schemas: **`schemas.1A.yaml`** (`$id: schemas.1A.yaml`). 
  - Layer-wide RNG/log schemas: **`schemas.layer1.yaml`** (`$id: schemas.layer1.yaml`). *(S5 does not emit RNG but remains bound to layer conventions.)* 
  Your S0/S4 documents already establish JSON-Schema as the only authority; this spec inherits that rule.

**0.4 Compatibility window (what this spec binds to in S0-S4)**
This S5 spec is **compatible with** and **assumes** the following already-ratified contracts remain on their **v1.* line**:

* **Dictionary:** `dataset_dictionary.layer1.1A.yaml` **v1.0** (IDs, paths, partitioning). 
* **Schema sets:** `schemas.ingress.layer1.yaml v1.0`, `schemas.1A.yaml v1.0`, `schemas.layer1.yaml v1.0`.
* **Order authority:** S3â€™s `s3_candidate_set.candidate_rank` is the **sole** inter-country order authority; `outlet_catalogue` **does not** encode cross-country order. *(S5 MUST NOT alter/encode country order.)* 
* **Lineage keys & partition law:** `parameter_hash` (parameter-scoped), `manifest_fingerprint` (egress/validation), `run_id` (logs). S5 is **parameter-scoped only** (no RNG/log partitions).
  If any of the above bump **MAJOR**, this document MUST be re-ratified.

**0.5 Schema anchors & dataset IDs in scope (read/write set)**

* **Inputs (ingress; sealed reference reads):**
  - `settlement_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/settlement_shares`. 
  - `ccy_country_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/ccy_country_shares`. 
  - `iso3166_canonical_2024` (FK target) â†’ `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`. 
* **Outputs (parameter-scoped; produced by S5):**
  - `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache`; **PK** `(currency, country_iso)`; path `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/`.
  - `merchant_currency` (S5.0) â†’ `schemas.1A.yaml#/prep/merchant_currency`; path `data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/`. 
  - `sparse_flag` (per-currency diagnostics) â†’ `schemas.1A.yaml#/prep/sparse_flag`; path `data/layer1/1A/sparse_flag/parameter_hash={parameter_hash}/`. 
  All IDs, schema `$ref`s, PK/FK rules, and paths above are **normative** and MUST match the dictionary. 

**0.6 Hash canonicalisation (applies to the S5 policy file)**

* S5 inherits **S0.2** hashing rules: **SHA-256 over exact bytes**, names included, sorted by **ASCII basename**, encoded by the **Universal Encoding Rule (UER)** (UTF-8 length-prefixed strings; LE64 integers; concatenation without delimiters).
* **Parameter hash contribution:** `configs/allocation/ccy_smoothing_params.yaml` is a **required member of ð“Ÿ**; changing its bytes **MUST** flip `parameter_hash`. *(Other ð“Ÿ members per S0.2.2 may also cause flips. This is a contract on bytes, not YAML semantics; no normalisation is permitted.)*
* **Pathâ†”embed equality:** For all S5 outputs, the embedded `parameter_hash` column **MUST equal** the `parameter_hash={â€¦}` partition value byte-for-byte. 

**0.7 Document status & lifecycle**

* **Status:** `planning â†’ beta â†’ stable`. Publication on `stable` requires Section 9 PASS on a representative run and dictionary/schema lint clean for all `$ref`s noted above. 
* **Change control:** governed by Â§16 (semver triggers, deprecation, rollback); S5 remains **Binding** for the `v1.*` family of S0-S4 contracts cited in **0.4**.

---

# 1. Intent, scope, and non-goals

**1.1 Problem statement (what S5 does)**
S5 produces a **deterministic, parameter-scoped authority** of **currencyâ†’country weights** for later selection. Concretely, given the sealed, long-form share surfaces **`settlement_shares_2024Q4`** and **`ccy_country_shares_2024Q4`** (both Î£=1 per currency) and governed S5 policy, S5 emits **`ccy_country_weights_cache`**: per-currency, per-ISO weights that (a) live entirely under `parameter_hash`, (b) are **RNG-free**, and (c) are **S6-ready** for restriction to each merchantâ€™s ordered candidate set from S3.

**1.2 Scope (what S5 covers)**
S5 SHALL:
a) Read only **parameter-scoped** S0-sealed datasets and policy named in this spec (Â§3-Â§4). Inputs include **`settlement_shares_2024Q4`** and **`ccy_country_shares_2024Q4`** as defined by the **ingress JSON-Schemas** and the dataset dictionary.
b) Optionally materialise a **`merchant_currency`** cache (S5.0) that provides each merchantâ€™s settlement currency Îºâ‚˜ for downstream joins; it is parameter-scoped and listed in the dictionary. 
c) Produce **`ccy_country_weights_cache`** with **PK `(currency, country_iso)`**, **numeric `weight` (pct01) with dp rounding semantics (Â§6.7)**, and embedded `parameter_hash`, at the **parameter-scoped** path declared in the dictionary. 
d) Enforce that **coverage per currency equals the union** of ISO codes appearing in either input surface, unless policy narrows it (see Â§5.5/Â§6.10).
e) Preserve **S3â€™s sole authority over inter-country order**; S5 emits **no order** and SHALL NOT modify or imply order. S6 MUST continue to obtain order exclusively from **`s3_candidate_set.candidate_rank`**.
f) Adhere to **JSON-Schema as the single schema authority** for all inputs/outputs referenced in this document. 

**1.3 Non-goals (what S5 does not do)**
S5 SHALL NOT:
a) **Consume RNG** or write any `rng_*` streams; RNG traces and counters are out of scope for S5. (S5 is deterministic by construction.)
b) **Create, alter, or encode inter-country order**; the only order authority remains S3â€™s `candidate_rank`. 
c) **Make merchant-level choices** (e.g., selecting countries for a merchant, setting K, or allocating counts). Those belong to S6+ and remain gated by S3/S4 contracts. 
d) **Re-derive S0/S3 invariants** (e.g., ISO enumerations, Î£=1 constraints of ingress surfaces); S5 validates them pre-flight and fails closed if violated (see Â§3.3/Â§3.4 and Â§9). 
e) **Write egress artefacts** (e.g., `outlet_catalogue`) or any dataset partitioned by `{seed,fingerprint}`; S5 is **parameter-scoped only**.

**1.4 Success criteria (what â€œdone rightâ€ means)**
A run of S5 satisfies this spec iff all of the following hold:

1. **Determinism & Idempotence:** Same inputs + same policy bytes â‡’ **byte-identical** outputs (paths and rows). (See Â§6.9/Â§10.)
2. **Correctness of weights:** For each currency, `weight âˆˆ [0,1]`, and the **decimal sum equals exactly `1` at declared `dp`** (Î£=1 property). 
3. **Coverage:** For each currency, output countries match the **union of input countries** (unless narrowed by policy recorded in lineage/metrics). 
4. **Schema & lineage:** Every dataset passes its **JSON-Schema**; partitions are `parameter_hash` only; **pathâ†”embed equality** holds. 
5. **Interface fitness:** Outputs can be **restricted by S6 to each merchantâ€™s ordered candidate set** from S3 without additional transforms or re-derivation. 

**1.5 Practical constraints (binding guardrails)**

* Inputs must already pass their **ingress schema constraints**, notably **Î£ share = 1.0 Â± 1e-6 per currency** and ISO/CCY domain checks; otherwise S5 MUST fail closed. 
* `configs/allocation/ccy_smoothing_params.yaml` is a **required member of ð“Ÿ**; changing its bytes **MUST** flip `parameter_hash`. *(Other ð“Ÿ members per S0.2.2 may also cause flips; S5 is sealed by parameter-scope only.)*

---

# 2. Interfaces & â€œno re-deriveâ€ boundaries

**2.1 Upstream dependencies & invariants (what S5 may read and must assume)**
a) **Authoritative inputs (sealed reference; JSON-Schema bound).** S5 MAY read only the following sealed datasets and FK references, exactly as registered in the dictionary and bound by the ingress schema set:
- `settlement_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/settlement_shares` (PK: `(currency, country_iso)`).
- `ccy_country_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/ccy_country_shares` (PK: `(currency, country_iso)`).
- `iso3166_canonical_2024` â†’ `schemas.ingress.layer1.yaml#/iso3166_canonical_2024` (FK target for `country_iso`).
All three are listed as **approved** in the dataset dictionary. JSON-Schema is the **single authority** for domains and constraints.

b) **Ingress pre-flight constraints (must hold before S5 runs).** For each input surface, S5 SHALL require: (i) PK uniqueness, (ii) `currency âˆˆ ISO-4217` and uppercase, (iii) `country_iso âˆˆ ISO2` uppercase and FK-valid, (iv) `share âˆˆ [0,1]`, `obs_count â‰¥ 0`, and (v) **group sum** `Î£ share = 1.0 Â± 1e-6` per `currency`. Violations are **hard FAIL** (S5 does not repair ingress).

c) **Policy/config inputs (parameter-scoped).** S5 MAY read the governed smoothing policy at `configs/allocation/ccy_smoothing_params.yaml` (domains and precedence will be defined in Â§4). Any byte change to this file contributes to `parameter_hash`. 

d) **Order authority is upstream (S3).** Inter-country order is defined **only** by `s3_candidate_set.candidate_rank` (parameter-scoped). The egress `outlet_catalogue` explicitly **does not** encode cross-country order. S5 MUST neither read nor infer any alternative ordering.

e) **Lineage & partition law inherited.** S5 operates **parameter-scoped only**; it MUST NOT read or write `{seed,fingerprint}` partitions. Paths and embedded lineage fields are governed by the dictionary/schema pairs for S5 outputs. 

---

**2.2 Downstream usage (what S6+ may consume and how)**
a) **Consumable S5 outputs.** S6 and later 1A states MAY consume:
- `ccy_country_weights_cache` (`schemas.1A.yaml#/prep/ccy_country_weights_cache`, **PK** `(currency, country_iso)`), parameter-scoped path under `â€¦/ccy_country_weights_cache/parameter_hash={parameter_hash}/`.
- (Optionally) `merchant_currency` cache (`schemas.1A.yaml#/prep/merchant_currency`) if present for Îºâ‚˜ joins.
These dataset IDs, schema refs, and paths are normative per the dictionary.

b) **Join pattern required.** Downstream selection/allocation MUST: (i) obtain **order** from `s3_candidate_set.candidate_rank`; (ii) obtain **weights** from `ccy_country_weights_cache`; (iii) if merchant-scoped joins are needed, obtain Îºâ‚˜ from `merchant_currency`; and (iv) perform joins using the keys defined by the respective schemas (e.g., `(currency, country_iso)` for weights; `merchant_id` for Îºâ‚˜). No other source may be used for order or weights.

c) **Read gate.** Downstream MUST read S5 outputs **only after** the S5 PASS artefact defined in Â§9 is present for the same `parameter_hash` (**no PASS â†’ no read**). (This mirrors Layer-1 egress gating already used for other 1A surfaces.) 

d) **Scope of permissible transforms.** Downstream MAY **restrict** weights to each merchantâ€™s S3 candidate set and (if required by its own spec) renormalise within that set **for ephemeral computation only**. Downstream MUST NOT persist altered copies of S5 weights nor re-smooth/re-blend from ingress surfaces. Persisted weights remain the S5 authority. 

---

**2.3 â€œNo re-deriveâ€ guarantees & prohibitions (who owns which truth)**
a) **S5 guarantees to downstream:**
- A complete per-currency coverage equal to the **union** of countries present in either ingress surface (unless explicitly narrowed by policy recorded in lineage/metrics).
- Schema-valid rows with a weight column exactly as specified by `schemas.1A.yaml#/prep/ccy_country_weights_cache` (field names and types per schema), partitioned by `parameter_hash`, with pathâ†”embed equality. 

b) **S5 will NOT:**
- Emit, encode, or imply inter-country order.
- Use RNG or write any RNG traces/events.
- Alter or â€œrepairâ€ ingress surfaces that violate schema or Î£-constraints (S5 fails closed instead).

c) **Downstream MUST NOT:**
- Recompute weights from `settlement_shares_2024Q4` or `ccy_country_shares_2024Q4`, or apply alternative smoothing policies not included in the `parameter_hash`.
- Infer order from S5 outputs or any source other than `s3_candidate_set.candidate_rank`.
- Persist renormalised/re-weighted copies as substitutes for `ccy_country_weights_cache` (any persisted variant would constitute a new dataset and MUST NOT shadow S5).

d) **Ownership matrix (normative):**
- **Order (inter-country)** â†’ **S3** (`s3_candidate_set.candidate_rank`).
- **Weights (currencyâ†’country)** â†’ **S5** (`ccy_country_weights_cache`).
- **Merchant settlement currency Îºâ‚˜** â†’ **S5.0** (`merchant_currency`).
- **Egress outlet ordering & counts** â†’ **S3/S4/S7/S8** surfaces; `outlet_catalogue` encodes **within-country** order only.

**2.4 Forward contracts to S6 (selection hand-off).**
a) **Domain.** S6 MUST select from the **intersection** of S5 weights and S3â€™s `s3_candidate_set` for each merchant. Weights present for **non-admissible** countries are **ignored** (not an error).
b) **Missing weights for admissible countries.** Only allowed if policy explicitly narrowed coverage (Â§8.6). In that case, S6 MAY renormalise **ephemerally** within the intersection; persisted weights remain the S5 authority.
c) **Order.** S6 MUST take order only from `candidate_rank`; S5 encodes no order.

---

# 3. Inputs â€” datasets, schemas, partitions

**3.1 Required datasets (read set; JSON-Schema authoritative)**
S5 SHALL read **only** the following sealed artefacts, exactly as registered in the dataset dictionary. Field names, types, domains, PK/FK, and constraints are governed by the referenced JSON-Schema anchors.

* **`settlement_shares_2024Q4`** â€” long-form currencyâ†’country settlement share vectors with observation counts.
  **Path:** `reference/network/settlement_shares/2024Q4/settlement_shares.parquet` (no partitions).
  **Schema ref (dictionary):** `schemas.ingress.layer1.yaml#/settlement_shares` *(alias resolving to the vintage anchor used in S0)*.
  **PK:** `(currency, country_iso)`.
  **Licence/retention:** per dictionary entry.

* **`ccy_country_shares_2024Q4`** â€” long-form currencyâ†’country split (â€œpriorsâ€) with observation counts.
  **Path:** `reference/network/ccy_country_shares/2024Q4/ccy_country_shares.parquet` (no partitions).
  **Schema ref (dictionary):** `schemas.ingress.layer1.yaml#/ccy_country_shares`.
  **PK:** `(currency, country_iso)`. 

* **`iso3166_canonical_2024`** â€” canonical ISO-3166 alpha-2 list used for FK validation.
  **Path:** `reference/iso/iso3166_canonical/2024-12-31/iso3166.parquet` (no partitions).
  **Schema ref (dictionary):** `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`.
  **PK:** `(country_iso)`. 

* **(Optional, only if producing `merchant_currency`)** `iso_legal_tender_2024` â€” canonical ISO2â†’primary legal tender map.
  **Schema ref:** `schemas.ingress.layer1.yaml#/iso_legal_tender_2024`. **PK:** `(country_iso)`.

* **Policy/config:** **`ccy_smoothing_params`** â€” governed parameters file for S5 (alpha/floors/overrides).
  **Path:** `configs/allocation/ccy_smoothing_params.yaml`.
  **Contribution to lineage:** **MUST** contribute to `parameter_hash`. 

> **Authority note.** JSON-Schema is the **only** schema authority for these inputs; Avro (if any) is non-authoritative. 

---

**3.2 Domains, types, and nullability (as per schema anchors)**
For both share surfaces (`settlement_shares_2024Q4`, `ccy_country_shares_2024Q4`):

* `currency` **MUST** be ISO-4217 **uppercase** 3-letter code.
* `country_iso` **MUST** be ISO-3166 **uppercase** alpha-2 and **FK-valid** to `iso3166_canonical_2024.country_iso`.
* `share` **MUST** be numeric **in [0,1]**.
* `obs_count` **MUST** be integer **â‰¥ 0** (presence and type per ingress schema).
* **Primary key** uniqueness: no duplicate `(currency, country_iso)` rows.

No row-order requirements apply (dictionary `ordering: []`). 

---

**3.3 Row-group preconditions (per currency block, must hold before S5 proceeds)**
For **each** input surface independently:

* **Group sum rule:** for every `currency`, `Î£ share = 1.0 Â± 1e-6`.
* **Domain conformance:** all rows satisfy Â§3.2 domains and PK uniqueness.
* **Schema hygiene:** no extra/missing columns beyond the schema; strict type conformance.

---

**3.4 Rejection conditions (hard FAIL; S5 does not repair ingress)**
If any of the following are observed in either share surface, S5 **MUST** fail closed before producing outputs:

* Unknown `currency` (non-ISO-4217), non-uppercase, or null.
* Unknown `country_iso` or FK violation against `iso3166_canonical_2024`.
* Any `share` outside [0,1], NaN/Inf, or null where disallowed.
* Any `obs_count < 0` or non-integer where disallowed.
* **PK collision** on `(currency, country_iso)`.
* **Group sum** outside tolerance for any `currency`.
* Columns missing or extra vs schema anchor. 

---

**3.5 Enumerations and forbidden placeholders (Binding)**

* `country_iso` **MUST** belong to the **pinned** ISO set from `iso3166_canonical_2024`; placeholder codes such as `XX`, `ZZ`, `UNK` are **forbidden**.
* `currency` **MUST** belong to the ISO-4217 domain defined in the ingress schema set.

---

**3.6 Partitioning & lineage stance for inputs**

* All three datasets listed in Â§3.1 are **reference** inputs with **no path partitions** (vintage is in the folder name where applicable). S5 reads them **as-is** (S0 sealed them).
* The **policy file** `ccy_smoothing_params.yaml` is **parameter-scoped** by contract: any byte change **MUST** flip `parameter_hash` (see Â§0.6). 

---

# 4. Configuration & policy

**4.1 Policy file (location, consumers, version pinning)**

* **ID & path (registry):** `ccy_smoothing_params` at `configs/allocation/ccy_smoothing_params.yaml`. This artefact **MUST** appear in the **Artefact Registry** with a manifest key (e.g., `mlr.1A.params.ccy_smoothing`) and metadata (semver, version, digest). It is **first consumed in S5/S6** and governs the build of `ccy_country_weights_cache` (and the optional `merchant_currency` cache).  
* **Authority scope:** This document defines the **normative key set and domains** for the file. (JSON-Schema for this config may be added to the schema authority; until then, the rules in Â§4.2-Â§4.6 are binding.) 
* **Consumers:** S5 **weights builder** and S6 **merchant_currency** cache builder. Changing this file **changes policy** â†’ **new `parameter_hash`**. 
* **Versioning fields in-file:** `semver: "MAJOR.MINOR.PATCH"` and `version: "YYYY-MM-DD"` **MUST** be present. 

**4.2 Keys & domains (normative content of `ccy_smoothing_params.yaml`)**
The policy file **MUST** contain exactly the following top-level structure (no extra keys):

* `semver : string` â€” semantic version string `\d+\.\d+\.\d+`. 
* `version : string` â€” date string `YYYY-MM-DD`. 
* `dp : int` â€” **fixed decimals for OUTPUT weights**; **domain:** `0â€¦18` inclusive. 
* `defaults : object` â€” global defaults used unless overridden:
  - `blend_weight : number âˆˆ [0,1]`
  - `alpha : number â‰¥ 0` (additive Dirichlet Î± per ISO)
  - `obs_floor : integer â‰¥ 0` (minimum effective mass)
  - `min_share : number âˆˆ [0,1]` (per-ISO floors applied post-smoothing)
  - `shrink_exponent : number â‰¥ 0` (0 = no shrink; >1 reduces impact of large masses; **values < 1 are treated as 1 at evaluation time**) 
* `per_currency : object` â€” optional per-ISO-4217 blocks (uppercase 3-letter) overriding any subset of `defaults` for that **currency**; keys **MUST** be valid ISO-4217 codes (uppercase). 
* `overrides : object` â€” optional **ISO-scoped** adjustments for a given currency:
  - `alpha_iso : { <CCY> : { <ISO2> : number â‰¥ 0 } }`
  - `min_share_iso : { <CCY> : { <ISO2> : number âˆˆ [0,1] } }`
  All ISO2 keys **MUST** be uppercase and exist in `iso3166_canonical_2024`. 

**Conformance & hygiene:**

* The loader **MUST** fail closed on **unknown keys**, **duplicate keys**, or values outside domain. 
* All currency codes in `per_currency` and under `overrides.*` **MUST** be uppercase ISO-4217; all ISO2 codes under `overrides.*.*` **MUST** be uppercase and FK-valid to the canonical ISO set. 

**4.3 Override precedence (deterministic resolution)**
*Quantities resolved at **currency level only**: `blend_weight`, `obs_floor`, `shrink_exponent`. ISO-level overrides apply **only** to `alpha` and `min_share`.*
For any policy quantity **Q** and a given **currency** `cur` and **ISO** `iso` (when relevant), the effective value is resolved in this exact order:

1. **ISO override**: `overrides.<Q>_iso[cur][iso]` if present (where defined for `Q`), else
2. **Currency override**: `per_currency[cur].<Q>` if present, else
3. **Global default**: `defaults.<Q>`.
   If none exist for required Q, **hard FAIL** (`E_POLICY_MISSING_Q`). (Note: `blend_weight`, `obs_floor`, `shrink_exponent` are resolved at **currency** level only; ISO overrides apply only to `alpha` and `min_share`.) 

**4.4 Parameter hashing (governed-set membership)**

* **Governed files (hash set).** `configs/allocation/ccy_smoothing_params.yaml` is a **required member of ð“Ÿ**; changing its bytes **MUST** flip `parameter_hash`. *(Other ð“Ÿ members per S0.2.2 also flip `parameter_hash`. No normalisation is permitted: hash the exact bytes.)*
* **Registry alignment:** the **Artefact Registry** entry for `ccy_smoothing_params` MUST include its current digest and path; S0 seals that digest into lineage. 

**4.5 Domain ranges & value rules (cross-checks)**

* **Numeric domains (re-stated):** `dp âˆˆ [0,18]`; `blend_weight âˆˆ [0,1]`; `alpha â‰¥ 0`; `obs_floor â‰¥ 0`; `min_share âˆˆ [0,1]`; `shrink_exponent â‰¥ 0`. 
* **Feasibility guard:** For each currency with `min_share_iso` overrides, **Î£_iso `min_share_iso[cur][iso]` â‰¤ 1.0**; otherwise **hard FAIL** (`E_POLICY_MINSHARE_FEASIBILITY`). 
* **Enumerations:** ISO2 under overrides **MUST** exist in `iso3166_canonical_2024`; placeholders like `XX/ZZ/UNK` are forbidden. 
* **Units & case:** All codes uppercase; policy numbers are parsed as numbers (not strings). 

**4.6 Required presence & defaults**

* **Required keys:** `semver`, `version`, `dp`, `defaults`. Missing any of these is **hard FAIL**. 
* **Optional sections:** `per_currency`, `overrides`. Absence implies no overrides. 
* **Tolerance inheritance:** Where a quantity is not defined at ISO/currency level, the resolver **MUST** fall back per Â§4.3. 

**4.7 Traceability of overrides (record-keeping contract)**

* S5 **MUST** produce a **per-currency record** of any overrides applied (source = `global|per_currency|iso`, keys, and final effective values) to support the observability metrics enumerated in Â§14. (Format of metrics is defined in Â§14; this clause only requires that the information be derivable and emitted.) 

**4.8 Interaction with inputs & dictionary (cross-references)**

* This policy is used to blend `settlement_shares_2024Q4` and `ccy_country_shares_2024Q4` (both with `Î£ share = 1 Â± 1e-6` per currency) into `ccy_country_weights_cache` under **parameter scope**; dictionary IDs and schema anchors are binding. 
* The output dataset contract (ID, path, PK) is fixed by the dataset dictionary and `schemas.1A.yaml#/prep/ccy_country_weights_cache`.  

---

# 5. Outputs â€” datasets & contracts

All outputs in this section are **parameter-scoped** and governed by the **dataset dictionary** and **JSON-Schema** anchors cited below. Readers MUST NOT infer cross-country order from any S5 output (order remains S3â€™s `candidate_rank`). 

---

## 5.1 `ccy_country_weights_cache` (authority for currencyâ†’country weights)

**Dataset ID (dictionary):** `ccy_country_weights_cache`
**Schema authority:** `schemas.1A.yaml#/prep/ccy_country_weights_cache`
**Path & partitions:** `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/` with partitioning **[parameter_hash]**. **Embedded `parameter_hash` MUST equal the path key** (S0 lineage rule).

**Primary key:** `(currency, country_iso)` (unique within each `parameter_hash`). 

**Columns & semantics (must match schema):**

* `currency : ISO4217` (uppercase).
* `country_iso : ISO2` (uppercase; **FK â†’** `iso3166_canonical_2024.country_iso`).
* `weight : pct01` (numeric in **[0,1]**; **Î£=1** per currency under tolerance).
* `obs_count? : int64 (â‰¥0)` â€” **rounded blended evidence mass** supporting the surface: `obs_count = round_half_even(N0)` where `N0 = wÂ·Î£ n_ccy + (1âˆ’w)Â·Î£ n_settle` for the currency.
* `smoothing? : string` â€” optional provenance note (e.g., `"alpha=0.5"`). 

**Invariants (binding):**

* **Group sum constraint:** for each `currency`, `Î£ weight = 1.0 Â± 1e-6` (schema `group_sum_equals_one`).
* **Domain:** codes in ISO domains; `weightâˆˆ[0,1]`; `obs_countâ‰¥0` when present.
* **Coverage:** for each `currency`, **country set equals the union** of ISO codes present in **`settlement_shares_2024Q4`** and **`ccy_country_shares_2024Q4`**, unless narrowed by policy (recorded via metrics/lineage).
* **Row order:** **no semantic order for readers** (schema `sort_keys: []`). Writers MUST emit rows **sorted `(currency ASC, country_iso ASC)`** for determinism; readers MUST NOT depend on physical order.

**Retention & ownership (dictionary):** retention 365 days; owner `1A`; produced by `1A.expand_currency_to_country`; status `approved`. 

*Pathâ†”embed equality is enforced by the validator; atomic promote is required; no append on re-run.*

---

## 5.2 `merchant_currency` (S5.0 cache of Îºâ‚˜ per merchant)

**Dataset ID (dictionary):** `merchant_currency`
**Schema authority:** `schemas.1A.yaml#/prep/merchant_currency`
**Path & partitions:** `data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/` with partitioning **[parameter_hash]**. **Embedded `parameter_hash` MUST equal the path key**.

**Primary key:** `(merchant_id)` (unique within each `parameter_hash`). 

**Columns & semantics (must match schema):**

* `merchant_id : id64` (FK to ingress merchants via layer rules).
* `kappa : ISO4217` â€” settlement currency Îºâ‚˜.
* `source : enum{"ingress_share_vector","home_primary_legal_tender"}` â€” provenance.
* `tie_break_used : boolean` â€” true iff lexicographic tie-break applied. 

**Precedence (Binding).** If **both** sources are available for a merchant, set `source="ingress_share_vector"` and use that value. If that source yields multiple maxima, break ties lexicographically (Aâ†’Z) and set `tie_break_used=true`. If `ingress_share_vector` is unavailable, fall back to `home_primary_legal_tender`.

**Retention & ownership (dictionary):** retention 365 days; owner `1A`; produced by `1A.derive_merchant_currency`. 

**Cardinality & coverage.** If `merchant_currency` is produced, it MUST contain exactly one row per merchant in the S0 merchant universe (`schemas.ingress.layer1.yaml#/merchant_ids`). Missing or duplicate rows for any `merchant_id` are hard FAIL: `E_MCURR_CARDINALITY`. Îºâ‚˜ MUST be ISO-4217 uppercase; unknown codes are hard FAIL: `E_MCURR_RESOLUTION`.

**Source of truth & fallback.** Îºâ‚˜ is resolved deterministically with provenance in `source`:
- `ingress_share_vector` â€” Îºâ‚˜ comes from a sealed ingress field or table declared in the dictionary (if such source is listed).
- `home_primary_legal_tender` â€” Îºâ‚˜ is the primary legal tender of `merchant_ids.home_country_iso` as declared in the dictionary (if listed).
If neither declared source exists in the dictionary for a given deployment, do not produce `merchant_currency`. Producing a partial table is forbidden.

**Interoperability.** `merchant_currency` is optional for S6. When produced, S6 MUST NOT override Îºâ‚˜; it may only read it as is.

---

## 5.3 `sparse_flag` (per-currency sparsity diagnostics)

**Dataset ID (dictionary):** `sparse_flag`
**Schema authority:** `schemas.1A.yaml#/prep/sparse_flag`
**Path & partitions:** `data/layer1/1A/sparse_flag/parameter_hash={parameter_hash}/` with partitioning **[parameter_hash]**. **Embedded `parameter_hash` MUST equal the path key**.

**Primary key:** `(currency)` (unique within each `parameter_hash`). 

**Columns & semantics (must match schema):**

* `currency : ISO4217` (uppercase).
* `is_sparse : boolean` â€” true iff observations below policy threshold.
* `obs_count : int64 (â‰¥0)` â€” observed mass used in the decision.
* `threshold : int64 (â‰¥0)` â€” cutoff used. 

**Retention & ownership (dictionary):** retention 365 days; produced by `1A.expand_currency_to_country`; consumed by 1A/validation. 

---

## 5.4 Partitioning, paths, and lineage (common to all S5 outputs)

* **Partitioning law:** **parameter-scoped only**; S5 outputs MUST NOT include `{seed}` or `{fingerprint}` partitions. Paths MUST be exactly those in the dictionary; **pathâ†”embed equality** is required for `parameter_hash`.
* **Immutability & write semantics:** Partitions are **write-once**. Writers MUST stage under a temp path and **atomically promote** on success (S0 rule). Re-runs with identical inputs/policy MUST yield **byte-identical** content.
* **Schema authority:** Only **JSON-Schema** anchors cited above are authoritative for fields, domains, PK/FK, and the Î£ constraint. Avro (if any) is non-authoritative. 

---

## 5.5 Coverage & join contracts (downstream read expectations)

* **Weights authority.** `ccy_country_weights_cache` is the **only** persisted authority for currencyâ†’country weights. Downstream MAY restrict to a merchantâ€™s S3 candidate set and renormalise **ephemerally**; persisted weights remain S5â€™s authority.
* **Order authority.** Inter-country order MUST be read only from **`s3_candidate_set.candidate_rank`**; S5 outputs MUST NOT be used to infer order.

---

## 5.6 Validity constraints (Î£ and domains)

* For `ccy_country_weights_cache`, validators MUST enforce the schema constraint: per currency, `Î£ weight = 1.0 Â± 1e-6`, with all codes FK-valid to the canonical ISO table. (This mirrors the ingress constraints on the two input share surfaces.)
* *Pathâ†”embed equality is enforced by the validator; atomic promote is required; no append on re-run.*

---

# 6. Deterministic processing specification â€” no pseudocode

> This section fixes **what must be computed and how it must behave**, without prescribing implementation code. All math is **IEEE-754 binary64** until the final quantisation step. JSON-Schema remains the single authority for all field types and constraints. **S5 inherits S0.8 numeric environment controls** (RNE/half-even, **FMA off**, **no FTZ/DAZ**, deterministic libm, fixed-order reductions).

## 6.1 Currency scope & country-set construction

* **Per-currency working set.** For each `currency`, form the **union** of `country_iso` present in `settlement_shares_2024Q4` and `ccy_country_shares_2024Q4`. Missing pairs are treated as **share=0, obs_count=0** for that surface. **Duplicates are forbidden** by the inputsâ€™ PK rule. Writers must process the union in **`country_iso` Aâ†’Z** order (determinism); readers must not rely on file order.
* **Domain & FK.** All `country_iso` values **must** be uppercase ISO-3166 and FK-valid to `iso3166_canonical_2024`. All `currency` values **must** be uppercase ISO-4217. These are inherited ingress constraints S5 **validates** before any processing (Â§3). 

## 6.2 Numeric type & blending of share surfaces

* **Numeric type:** All arithmetic through Â§6.6 is in **binary64**. 
* **Blending rule (per currency).** Let `w âˆˆ [0,1]` be the effective `blend_weight` resolved by Â§4.3. For each `country_iso` in the union:
  **`q[c] = w Â· s_ccy[c] + (1âˆ’w) Â· s_settle[c]`** (missing shares treated as 0). 
* **Input discipline:** Each input surface must already satisfy **Î£ share = 1.0 Â± 1e-6** per currency; S5 does not repair ingress (Â§3.3/Â§3.4). 

## 6.3 Effective evidence mass (sparsity robustness)

* Compute a per-currency effective mass from observed counts. Let **`e = max(shrink_exponent, 1.0)`**:
  **`N0 = w Â· Î£ n_ccy + (1âˆ’w) Â· Î£ n_settle`** and **`N_eff = max(obs_floor, N0^(1/e))`** with `e â‰¥ 1`.  
  *If `shrink_exponent < 1` (including `0`), treat as `1` (no shrink).*  
  `shrink_exponent = 1.0` â‡’ `N_eff = max(obs_floor, N0)`.

## 6.4 Prior / smoothing policy (Dirichlet-style add-Î±)

* Resolve **Î±** using Â§4 precedence: base per-currency `alpha` with optional **per-ISO** overrides. Let **`Î±[c] â‰¥ 0`**, and **`A = Î£_c Î±[c]`**.
* Compute the **smoothed posterior** per ISO (binary64):
  **`posterior[c] = ( q[c] Â· N_eff + Î±[c] ) / ( N_eff + A )`.** 

## 6.5 Floors & feasibility (apply then prove)

* Resolve **minimum shares** per Â§4 (`min_share` global, with optional **`min_share_iso`** per currency/ISO). For each country:
  **`pâ€²[c] = max( posterior[c], min_share_for_c )`.**
* **Feasibility:** For every currency with any ISO-level floors, it **must** hold that
  **`Î£_c min_share_iso[cur][c] â‰¤ 1.0`** (policy guard). Otherwise **hard FAIL** (`E_POLICY_MINSHARE_FEASIBILITY`). 

## 6.6 Renormalisation (Î£ = 1 before quantisation)

* **Required renormalisation (binary64):** After floors, compute a single normaliser **`Z = Î£_c pâ€²[c]`** and set **`p[c] = pâ€²[c] / Z`** for all countries of the currency so that **`Î£_c p[c] = 1`** in binary64. Renormalisation **must occur after floors** and **before** any quantisation. 

## 6.7 Quantisation for output (fixed-dp; deterministic tie-break)

* **Fixed-dp rounding:** Convert `p[c]` to **`weight`** in **fixed-dp** with the configured `dp` using **round-half-even** (bankerâ€™s rounding).
* **Define fractional remainder:** Let `r[c] := frac(10^dp Â· p[c]) âˆˆ [0,1)`. One **ULP** equals `10^-dp`.
* **Group-sum at dp (shortfall vs overshoot):** After half-even rounding to integer ULPs `u[c]`, let `S = Î£ u[c]` and target `T = 10^dp`.  
  - If `S < T` (**shortfall**), add `Tâˆ’S` one-ULP increments: pick countries by **descending** `r[c]`, tie-break by `country_iso` Aâ†’Z.  
  - If `S > T` (**overshoot**), subtract `Sâˆ’T` one-ULP: pick countries by **ascending** `r[c]`, tie-break by `country_iso` Zâ†’A.  
* **Persistence type:** `weight` is persisted as a **numeric** (`pct01`) per schema; the **decimal** exact-sum at `dp` is a property of the quantised values, not of stored strings.

## 6.8 Determinism requirements (no RNG; stable evaluation)

* **RNG prohibition:** S5 **MUST NOT** emit or consume any RNG events (Â§11).  
* **Stable iteration:** Processing is defined **per currency**; within a currency, the canonical **evaluation order is `country_iso` Aâ†’Z**. Parallelism is **permitted by currency** only; merges **MUST** preserve `(currency ASC, country_iso ASC)` writer order.  
* **Numeric consistency:** Use IEEE-754 **binary64** throughout Â§6.1-Â§6.6; quantisation behaviour is fixed by Â§6.7.

## 6.9 Idempotence & re-run semantics

* **Byte-identity:** Given identical inputs and **identical policy bytes**, S5 **MUST** produce **byte-identical** outputs (rows, values, and file boundaries) at the same parameter-scoped path(s).  
* **Pathâ†”embed equality:** For every S5 dataset, embedded `parameter_hash` **MUST equal** the path partition key **byte-for-byte**.  
* **Writer sort:** Writers **MUST** emit rows sorted `(currency ASC, country_iso ASC)`; readers **MUST NOT** treat file order as authoritative.

## 6.10 Coverage rule (what rows must exist)

* **Per-currency coverage:** The set of `country_iso` emitted for each `currency` **MUST** equal the **union** of countries observed in `settlement_shares_2024Q4` and `ccy_country_shares_2024Q4`, unless **explicitly narrowed by policy** recorded in lineage/metrics. Any narrowing must be **discoverable** via Â§14 metrics and Â§10 lineage.

# 7. Invariants & integrity constraints

> These properties **must hold** for all S5 outputs at the time the PASS gate in Â§9 is computed. Where a rule duplicates a JSON-Schema constraint, the **schema remains authoritative**; this section makes those constraints explicit for operators and downstream specs.

**7.1 Schema & dictionary conformance**

* Every S5 dataset (`ccy_country_weights_cache`, `merchant_currency`, `sparse_flag`) **MUST** pass its JSON-Schema anchor from `schemas.1A.yaml`, and match the dataset dictionaryâ€™s ID, path pattern, partitions and ownership.

**7.2 Primary keys & uniqueness**

* `ccy_country_weights_cache` **PK** is `(currency, country_iso)` and **MUST** be unique within each `parameter_hash` partition.
* `merchant_currency` **PK** is `(merchant_id)`; `sparse_flag` **PK** is `(currency)`. 

**7.3 Domains & foreign keys**

* Codes **MUST** be uppercase and valid in their enumerations: `currency âˆˆ ISO-4217`, `country_iso âˆˆ ISO-3166-1 Î±-2` with FK to the canonical ISO table.
* Numeric domains: `weight âˆˆ [0,1]`; when present, `obs_count â‰¥ 0`. 

**7.4 Group-sum constraint (per currency)**

* In `ccy_country_weights_cache`, the **schema group constraint** MUST hold: for each `currency`, `Î£ weight = 1.0` within tolerance `1e-6`. (This mirrors the ingress constraints on the two input share surfaces.)

**7.5 Coverage parity**

* For each `currency`, the set of `country_iso` values present in `ccy_country_weights_cache` **MUST equal** the **union** of `country_iso` observed for that currency in `settlement_shares_2024Q4` and `ccy_country_shares_2024Q4`, except where explicitly narrowed by S5 policy (recorded via lineage/metrics).

**7.6 Quantisation & dp exactness (output discipline)**

* Although `weight` is stored as a numeric (`pct01`), each value **MUST** be the round-half-even quantisation of the pre-quantised probability to the configured **`dp`** from S5 policy; when `weight` values are expressed to exactly `dp` decimal places as strings, their **decimal sum MUST equal `1` at `dp`**. (This is stricter than the schema tolerance and is required by this spec.)

**7.7 Sorting & deterministic writer order**

* Physical row order is **not** an interface guarantee (dictionary `ordering: []`), but writers **MUST** emit rows sorted `(currency ASC, country_iso ASC)` to ensure byte-stable reruns; readers MUST NOT rely on file order. 

**7.8 Partitioning, lineage & equality**

* All S5 datasets are **parameter-scoped only**; no `{seed}` or `{fingerprint}` partitions are permitted.
* **Pathâ†”embed equality:** the embedded `parameter_hash` column **MUST equal** the partition key byte-for-byte.
* **Immutability & idempotence:** a concrete `parameter_hash` partition is **write-once**; reruns with identical inputs + policy bytes produce **byte-identical** results. 

**7.9 RNG non-interaction**

* S5 **MUST NOT** emit any `rng_*` streams or alter RNG traces; the RNG log families defined for Layer-1 remain untouched across S5. The validator in Â§9 MUST be able to demonstrate **no change** in RNG trace length versus the **pre-S5 snapshot of `rng_trace_log`** for the same `{seed, parameter_hash, run_id}`.

**7.10 Order authority separation (no implicit order in S5)**

* Inter-country order is **owned by S3** only (`s3_candidate_set.candidate_rank`). S5 outputs **MUST NOT** encode, imply, or be used to infer inter-country order; `outlet_catalogue` continues to omit cross-country order by design.

**7.11 Egress/readiness dependency**

* Downstream readers **MUST** only consume S5 outputs once the S5 PASS artefact (defined in Â§9) exists for the **same `parameter_hash`** (**no PASS â†’ no read**), consistent with Layer-1 gating norms. 

**7.12 Diagnostics visibility**

* If `sparse_flag` is emitted, its PK and domain constraints must hold (`currency` valid; `is_sparse` boolean; `obs_count, threshold â‰¥ 0`), and it lives under the same `parameter_hash`. 

---

# 8. Error handling, edge cases & degrade ladder

> This section defines **run-fail conditions** (hard FAIL), **per-currency degradations** (allowed fallbacks), and the **diagnostics** that MUST be produced. Where rules duplicate JSON-Schema or dictionary constraints, the schema/dictionary remain authoritative.

## 8.1 Pre-flight hard FAIL (ingress)

S5 MUST **abort the run** before writing any outputs if **either** share surface violates its ingress contract (Â§3). Violations include:

* PK collision on `(currency, country_iso)`; unknown or non-uppercase `ISO2/ISO-4217`; `shareâˆ‰[0,1]`; `obs_count<0`; or **Î£ share â‰  1.0 Â± 1e-6** per currency. **Error:** `E_INPUT_SCHEMA` / `E_INPUT_SUM`.

## 8.2 Policy file errors (hard FAIL)

S5 MUST fail closed on any policy/config non-conformance:

* Unknown keys; values outside domains (`dpâˆˆ[0,18]`, `blend_weightâˆˆ[0,1]`, `alphaâ‰¥0`, `obs_floorâ‰¥0`, `min_shareâˆˆ[0,1]`, `shrink_exponentâ‰¥0`). **Error:** `E_POLICY_DOMAIN`. 
* Unknown **currency** or **ISO** in overrides (not in canonical enumerations). **Error:** `E_POLICY_UNKNOWN_CODE`. 
* **Feasibility breach:** for any currency, `Î£ min_share_iso > 1.0`. **Error:** `E_POLICY_MINSHARE_FEASIBILITY`. 

## 8.3 Processing-time hard FAIL (per currency â†’ run abort)

If any of the following occur for any currency during Â§6:

* **Zero mass after floors:** `Î£ pâ€²[c] = 0` before renormalisation. **Error:** `E_ZERO_MASS`.
* **Renormalisation/quantisation failure:** after Â§6.7 tie-breaks, the **decimal** group sum cannot be made exactly `1` at `dp`. **Error:** `E_QUANT_SUM_MISMATCH`.
* **Output schema breach:** FK/PK violation, domain breach (`weightâˆ‰[0,1]`, negative `obs_count`). **Error:** `E_OUTPUT_SCHEMA`.
  The run MUST abort; S5 produces no partial outputs. 

## 8.4 Missing/partial source surfaces (per-currency degrade)

If, for a given currency:

* **Only** `ccy_country_shares_2024Q4` has rows (Î£=1 within tolerance) and `settlement_shares_2024Q4` has **none**, S5 MAY proceed using the available surface with **degrade_mode=`ccy_only`**. **Reason code:** `SRC_MISSING_SETTLEMENT`. 
* **Only** `settlement_shares_2024Q4` has rows (Î£=1) and `ccy_country_shares_2024Q4` has **none**, S5 MAY proceed with **degrade_mode=`settlement_only`**. **Reason code:** `SRC_MISSING_CCY`. 
* **Neither** surface contains the currency â‡’ currency is **out of scope** (no output rows). If policy explicitly references the currency, **hard FAIL** `E_POLICY_UNKNOWN_CODE`. Otherwise, no rows are written for that currency and no degrade is logged. 

**Contract:** Degraded currencies MUST still satisfy Â§6.1 union coverage (union is the non-empty sourceâ€™s support), Â§6.6 Î£=1 (binary64 pre-quant), and Â§6.7 exact decimal Î£ at `dp`. 

## 8.5 Sparsity handling (diagnostic, not degrade)

Low-evidence situations (small `N_eff` under Â§6.3) are handled via **policy floor/Î± smoothing**; this is **not** a degrade. Emit `sparse_flag` where the policy threshold marks a currency as sparse; persist under `parameter_hash`. **Reason code in metrics:** `SPARSITY_LOW_MASS`.

## 8.6 Coverage narrowing by policy (allowed)

If policy explicitly **narrows** the country set for a currency (e.g., removing specific ISOs), S5 MAY proceed **provided**:

* Narrowing is discoverable via lineage/metrics (Â§10/Â§14), and
* The resulting set still passes Â§6.6/Â§6.7 (Î£=1 rules).
  **Reason code:** `POLICY_NARROWING`. (No change to **degrade_mode**, which remains `none`.) 

## 8.7 Degrade vocabulary & emission (per-currency)

When a per-currency degrade in **8.4** is used, S5 MUST:

* Record **`degrade_mode âˆˆ {none, settlement_only, ccy_only}`** and **`degrade_reason_code`** (closed set: `{SRC_MISSING_SETTLEMENT, SRC_MISSING_CCY, POLICY_NARROWING}` plus `OTHER` as last resort) in run-level metrics (Â§14).
* Ensure outputs still satisfy Â§7 invariants; otherwise escalate to **`abort`** (run FAIL). 

## 8.8 RNG non-interaction breaches (hard FAIL)

Any presence of `rng_*` streams written under S5 tasking, or a **change in RNG trace length** vs the **pre-S5 snapshot of `rng_trace_log`** (same `{seed, parameter_hash, run_id}`), is a breach. **Error:** `E_RNG_INTERACTION`. 

## 8.9 Path/lineage equality breaches (hard FAIL)

Mismatch between embedded `parameter_hash` and the partition path key for any S5 dataset, or any write that violates **write-once/atomic-promote** semantics, MUST abort. **Error:** `E_LINEAGE_PATH_MISMATCH` / `E_ATOMICITY`. 

## 8.10 Diagnostics artefacts (minimal, parameter-scoped)

S5 MUST emit, alongside outputs:

* A **validation report** (format free) listing per-currency `degrade_mode`, `degrade_reason_code`, Î£ checks pre/post quantisation, and any policy overrides in force (to support Â§14 metrics).
* Optional `sparse_flag` dataset per dictionary (`schema_ref: #/prep/sparse_flag`). 

## 8.11 Run outcome

* **PASS:** No hard FAILs; all outputs meet Â§7; diagnostics present; (some currencies may have `degrade_mode â‰  none`).
* **FAIL:** Any error in 8.1-8.3, 8.8-8.9, or invariant breach â†’ **no read** by downstream until Section Â§9 PASS is recorded for the same `parameter_hash`. 

---

# 9. Validation battery & PASS gate

> The S5 validator proves that `ccy_country_weights_cache` (and any S5 side outputs) meet schema, lineage, coverage, Î£, and determinism obligations. It is a **parameter-scoped** gate for S6 reads, distinct from the layer-wide **fingerprint-scoped** gate used for egress (kept as-is per S0/S4). JSON-Schema and the dataset dictionary remain the single authorities for field shapes and paths.

## 9.1 Structural & lineage checks (must pass before any content checks)

1. **Schema conformance.** Every S5 dataset passes its JSON-Schema anchor (e.g., `schemas.1A.yaml#/prep/ccy_country_weights_cache`). Fail closed on any field/type/nullable/required mismatch. 
2. **PK/FK & domains.**
   - `ccy_country_weights_cache` has unique **PK** `(currency, country_iso)`; `currency âˆˆ ISO-4217`, `country_iso âˆˆ ISO2` and FK-valid to canonical ISO. 
   - If present, `merchant_currency` and `sparse_flag` obey their PKs and domains. 
3. **Partition & path discipline.** Parameter-scoped outputs live under `â€¦/parameter_hash={parameter_hash}/` and **embed the same `parameter_hash`** byte-for-byte. Writes are **atomic** (stageâ†’fsyncâ†’single rename). 
4. **No RNG interaction.** No `rng_*` streams for S5; RNG trace length is **unchanged** vs the **pre-S5 snapshot of `rng_trace_log`** (same `{seed, parameter_hash, run_id}`). Any delta is a run-fail.
   **Clarification:** Compare against the **pre-S5 snapshot of `rng_trace_log`** for the same `{seed, parameter_hash, run_id}`.

## 9.2 Content checks (weights, sums, quantisation)

1. **Î£ rule (numeric).** For each `currency`, the **numeric** sum `Î£ weight` equals **1.0 Â± 1e-6** (schema group constraint). 
2. **Quantisation discipline.** Re-express each `weight` to exactly `dp` decimal places (policy Â§4). The **decimal** sum must equal **`1` at `dp`** after the deterministic largest-remainder tie-break; dp used in the run must match policy. 
3. **Bounds.** `0 â‰¤ weight â‰¤ 1` and (when present) `obs_count â‰¥ 0`. 

## 9.3 Coverage & join-shape checks

1. **Union coverage.** For each currency, the set of `country_iso` in `ccy_country_weights_cache` equals the **union** of `country_iso` seen for that currency in `settlement_shares_2024Q4` and `ccy_country_shares_2024Q4`, unless policy **explicitly narrows** (which MUST be recorded in lineage/metrics).
2. **No order implication.** S5 outputs encode **no inter-country order**; downstream must keep reading order exclusively from S3 `s3_candidate_set.candidate_rank`. 

## 9.4 Re-derivation check (no re-derive elsewhere, but validator must prove identity)

The validator **recomputes** the S5 weights from sealed inputs + S5 policy, using the normative rules of Â§6 (binary64 math; blend; effective mass; Î±-smoothing; floors; renormalise; quantise+tie-break). It then asserts **byte-for-byte equality** of per-pair decimal values at `dp` (and equality of country coverage). Any mismatch is a **run-fail**. 

## 9.5 Degrade & overrides attestation

If Â§8â€™s degrade modes are exercised (`settlement_only` / `ccy_only`) or if any ISO/currency overrides applied, the validator must emit machine-readable **per-currency** attestations (source, reason code, effective values) and ensure **all** invariants in Â§7 still hold; otherwise abort. 

## 9.6 Validator artefacts (parameter-scoped receipt for S5)

S5 writes a **parameter-scoped receipt** adjacent to the weights cache:

```
data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/
  S5_VALIDATION.json            # summary: counts, Î£ checks, coverage parity, overrides, degrade modes
  _passed.flag                  # single line: 'sha256_hex = <hex64>'
```

`_passed.flag` contains the **SHA-256** over the **ASCII-lexicographic** concatenation of all other files in this receipt (currently **`S5_VALIDATION.json`**; exclude the flag itself). This mirrors the layer-wide gate pattern in S0â€™s validation bundle, but is **parameter-scoped** for S5. **Atomic publish** applies. 

*Notes.*
- This S5 receipt **does not replace** the 1A **fingerprint-scoped** validation bundle (`validation_bundle_1A`) and its `_passed.flag`; that layer-wide gate remains the authority for egress consumption (e.g., `outlet_catalogue`). 
- The dictionary continues to govern dataset paths; the S5 receipt is a **sidecar manifest** within the approved dataset path, consistent with S0â€™s publish/atomicity discipline. 

## 9.7 PASS/FAIL semantics

* **S5 PASS (parameter-scoped):** All checks in Â§Â§9.1â€“9.5 succeed **and** the S5 receipt is present with a valid `_passed.flag` whose hash matches its contents. **Downstream reads additionally require that the `ccy_country_weights_cache` dataset exists for the same `parameter_hash`.**
* **Layer-wide PASS (unchanged):** For egress reads (e.g., `outlet_catalogue`), consumers MUST verify `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/_passed.flag` matches `validation_bundle_1A` for that fingerprint, per S0. 
* **FAIL:** Any breach in Â§Â§9.1-9.5, or missing/invalid `_passed.flag`, aborts the run; no partial publishes. Follow S0 abort semantics (write failure sentinel; freeze; exit non-zero). 

## 9.8 Minimal validator report content (normative fields)

`S5_VALIDATION.json` MUST include at least:

* `parameter_hash` (hex64); `policy_digest` (hex64 of `ccy_smoothing_params.yaml` bytes). 
* `currencies_processed`, `rows_written`, `degrade_mode_counts{none,settlement_only,ccy_only}`. 
* `sum_check`: counts of currencies passing the numeric Î£ test and the **decimal @dp** test.
* `coverage_check`: counts passing union-coverage (and a list of any policy-narrowed currencies). 
* `overrides_applied`: per-currency summary (source: `global|per_currency|iso`). (Detailed metrics format in Â§14.)

## 9.9 Idempotence & re-run equivalence

Re-running S5 with identical inputs and **identical policy bytes** produces **byte-identical** dataset content and **identical** S5 receipt (and `_passed.flag`). Any divergence is a failure of idempotence. 

---

# 10. Lineage, partitions & identifiers

> This section fixes **where S5 writes**, **which identifiers appear**, and the **immutability/atomicity** rules. JSON-Schema + the Dataset Dictionary remain the single authorities for shapes, paths, and partition keys.

**10.1 Partitioning law (parameter-scoped only)**

* All S5 datasets are **parameter-scoped** with **partition key = `parameter_hash`**. No `{seed}` or `{fingerprint}` partitions are permitted for S5 outputs. The dictionary pins the paths and partitions:
  - `ccy_country_weights_cache â†’ data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/` with `partitioning: [parameter_hash]`. 
  - `merchant_currency â†’ data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/` with `partitioning: [parameter_hash]`. 
  - `sparse_flag â†’ data/layer1/1A/sparse_flag/parameter_hash={parameter_hash}/` with `partitioning: [parameter_hash]`. 
  The **contrast** (for clarity): RNG/egress families are **not** in scope here and remain `{seed,parameter_hash,run_id}` or `{seed,fingerprint}` per S0/S3/S9.

**10.2 Embedded lineage fields & pathâ†”embed equality**

* Where a schema **includes** lineage columns, their values are **normative**:
  - `parameter_hash` **MUST equal** the partition key byte-for-byte (hex64).
  - `produced_by_fingerprint?` (if present in the schema) is **informational only** and MUST equal the runâ€™s `manifest_fingerprint` when populated. 
* S0â€™s partition lint applies: parameter-scoped datasets live under `parameter_hash=â€¦` and **rows embed the same `parameter_hash`** wherever the schema defines that column. 
* Readers MUST treat **physical file order as non-authoritative** (dictionary `ordering: []`). Writers emit rows sorted `(currency ASC, country_iso ASC)` for byte-stable reruns (Â§6.8/Â§7.7). 

**10.3 Identifier semantics (source of truth)**

* **`parameter_hash` (hex64)** â€” the **only** partition key for S5 outputs; produced by S0 as SHA-256 over the governed parameter-set bytes **including** `ccy_smoothing_params.yaml`. Changing `ccy_smoothing_params.yaml` **MUST** flip `parameter_hash`.
* **`manifest_fingerprint` (hex64)** â€” global run fingerprint used by the **layer-wide** validation bundle (`validation_bundle_1A`). S5 is parameter-scoped; any `produced_by_fingerprint` field, when present, is optional provenance only.
* **`run_id`** â€” used only in RNG logs (not produced by S5). 

**10.4 Paths & schemas (authority alignment)**

* Paths and partition keys for S5 datasets **MUST** match the Dataset Dictionary entries and their schema anchors:
  - `ccy_country_weights_cache â†’ schemas.1A.yaml#/prep/ccy_country_weights_cache` (PK `(currency, country_iso)`, partition_keys `[parameter_hash]`).
  - `merchant_currency â†’ schemas.1A.yaml#/prep/merchant_currency` (PK `(merchant_id)`, partition_keys `[parameter_hash]`).
  - `sparse_flag â†’ schemas.1A.yaml#/prep/sparse_flag` (PK `(currency)`, partition_keys `[parameter_hash]`).
* **JSON-Schema remains authoritative** for lineage columns: some tables enumerate `parameter_hash` explicitly; others declare it as a `partition_keys` property. Both are binding, and S0â€™s partition lint enforces equality to the path. 

**10.5 Immutability & atomic publish**

* **Write-once per partition.** A concrete `parameter_hash` partition is immutable; re-runs with identical inputs/policy must be **byte-identical** or no-op. 
* **Atomic publish.** Writers MUST stage to a temporary folder and perform a single atomic rename; partial contents MUST NOT become visible. (Same rule S0 uses for validation bundles.) 

**10.6 Retry & promotion semantics**

* Retries write under a temp path; **promotion occurs only after** Section 9 PASS succeeds for the same `parameter_hash` (S5 receipt present and valid). Any earlier partial directories must be removed or remain hidden (no readers). 

**10.7 Scope separation (no seed/fingerprint in S5 outputs)**

* S5 outputs **MUST NOT** introduce `{seed}` or `{fingerprint}` path tokens. Those are reserved for RNG/event logs and egress hand-off datasets such as `outlet_catalogue` (fingerprint-scoped). 

**10.8 Registry & dictionary consistency (governance)**

* The **Artefact Registry** entries for `ccy_country_weights_cache`, `merchant_currency`, `sparse_flag`, and `ccy_smoothing_params` MUST exist and reflect path, version (`{parameter_hash}`), and schema refs exactly.
* The **dataset dictionary** is the single authority for dataset **IDs, paths, partitioning, owners, and retention**; S5 must not deviate. 

**10.9 Downstream gates (read discipline)**

* **Parameter-scoped readers (e.g., S6)** MUST verify the **S5 receipt** under the same `parameter_hash` before reading (Â§9). Layer-wide egress readers (e.g., `outlet_catalogue`) remain gated by the **fingerprint-scoped** `_passed.flag` in `validation_bundle_1A` (unchanged by this spec).

---

# 11. Interaction with RNG & logs

> S5 is **purely deterministic** and **RNG-free**. This section fixes what S5 MUST and MUST NOT do with respect to Layer-1 RNG audit/event infrastructure and trace logs. JSON-Schema for RNG envelopes and the dataset dictionary remain the single authorities for shapes, partitions, and producers.

**11.1 RNG event prohibition (no emissions)**

* S5 **MUST NOT** emit any dataset whose schema is under **`schemas.layer1.yaml#/rng/*`** (i.e., no `rng_audit_log`, `rng_trace_log`, or any `rng_event_*` streams). This includes all event families registered in the dictionary (e.g., `hurdle_bernoulli`, `gamma_component`, `poisson_component`, `gumbel_key`, `dirichlet_gamma_vector`, `residual_rank`, `sequence_finalize`, `site_sequence_overflow`).

**11.2 No writes under RNG partitions**

* S5 **MUST NOT** write to paths partitioned by **`{seed, parameter_hash, run_id}`** reserved for RNG audit, trace, and event logs; those paths are owned by S1/S2/S4/S6/S7/S8 producers per the dataset dictionary. S5 outputs are **parameter-scoped only** (Â§10). 

**11.3 No consumption of RNG logs (producer-only)**

* S5 **producers** MUST NOT read `rng_audit_log`, `rng_trace_log`, or any `rng_event_*` streams; S5 computation depends only on the ingress share surfaces and S5 policy (Â§3â€“Â§4).
* **Validator exception:** the S5 validator **MAY** read `rng_trace_log` **read-only** to prove non-interaction (Â§11.8/Â§13.4), but MUST NOT write to any RNG partitions.

**11.4 Trace invariants (proof of non-interaction)**

* The **cumulative RNG trace** (per `(module, substream_label)`) defined by `rng_trace_log` **MUST** be **unchanged** across an S5 run relative to the **pre-S5 snapshot of `rng_trace_log`** for the same `{seed, parameter_hash, run_id}`: totals (`events_total`, `draws_total`, `blocks_total`) and final `(before/after)` counters per key are **identical**. Any delta indicates an RNG interaction and is a **run-fail** (Â§9).

**11.5 Envelope & budgeting law (reference; S5 does not produce)**

* RNG events, when produced by other states, must carry the **Layer-1 RNG envelope** (counters, `blocks`, `draws`), with **open-interval** uniform mapping and budget identities enforced by S0/S1/S4. S5 inherits these rules only as constraints it must **not** exercise.

**11.6 S4 trace duty remains intact**

* S4â€™s contract (â€œappend exactly one cumulative `rng_trace_log` row **after each event append**â€) remains authoritative; S5 SHALL NOT append additional trace rows nor alter S4â€™s trace.

**11.7 Producer/label registry (non-membership of S5)**

* The dataset dictionary enumerates **producer modules** and **`substream_label`** values for 1A RNG streams. S5 is **not** a registered RNG producer and MUST NOT appear as `module` in any RNG JSONL event. 

**11.8 Validation of non-interaction (gate condition)**

* The S5 validator (Â§9) MUST assert **both**:
  (a) **Absence** of any new/modified files under `logs/rng/**/seed=*/parameter_hash=*/run_id=*` for the run; and
  (b) **Unchanged** final rows in `rng_trace_log` (per key) vs the **pre-S5 snapshot of `rng_trace_log`** (same `{seed, parameter_hash, run_id}`). Any breach â‡’ `E_RNG_INTERACTION` (hard FAIL). 
    - This validator read is the **only** permitted RNG log read in S5 and is **read-only**.

**11.9 Separation from order authority**

* RNG-bearing selection/ordering streams (e.g., `gumbel_key`) remain downstream concerns (S6+). S5 MUST NOT encode or imply order, nor interact with those RNG events. Order authority remains **S3 `s3_candidate_set.candidate_rank`**.

---

# 12. Performance, scaling & resource envelope

> Purpose: bound runtime behaviour and concurrency *without* dictating implementation internals. All numeric and determinism rules in Â§6 remain in force.

**12.1 Expected cardinalities** *(Informative)*

* Currencies in scope: O(10Â²).
* Countries per currency (union of the two ingress surfaces): O(10Â²); practical maximum â‰² a few Ã—10Â².
* Total pairs processed per run: O(currencies Ã— countries) â†’ typically â‰¤ O(10â´-10âµ).
* Policy overrides: sparse relative to total pairs (expected << 10%).

**12.2 Concurrency scope & determinism** *(Binding)*

* **Concurrency boundary:** Parallelism is **per currency only** (no parallel reductions within a single currency). (Â§6.8)
* **Deterministic merge:** Independent currency shards **MUST** converge to outputs that are **byte-identical** to a single-threaded run, with writer order `(currency ASC, country_iso ASC)`. (Â§6.8/Â§7.7)
* **Within-currency evaluation:** The effective computation **MUST** be equivalent to evaluating Â§6.1-Â§6.7 in `country_iso` Aâ†’Z order using binary64, then applying the Â§6.7 tie-break. No alternative evaluation order is permitted.
* **Shard-count invariance:** Changing the number of worker shards **MUST NOT** change any output byte.

**12.3 Time complexity** *(Informative)*

* End-to-end runtime is **linear** in the number of input rows plus output rows:
  `T(run) = Î˜(|settlement_shares| + |ccy_country_shares| + |weights_cache|)`.
* Per-currency work is Î˜(#countries in that currency).

**12.4 Memory envelope** *(Informative)*

* Per-currency working set is O(#countries) for a small number of vectors (blend `q`, priors `Î±`, floors, `pâ€²`, `p`).
* Implementations SHOULD bound peak memory by processing **one currency at a time** (or a small batch) and streaming rows; global, all-currency in-memory accumulation is discouraged.

**12.5 I/O & file layout** *(Binding where noted)*

* Inputs are reference tables (no partitions); outputs are parameter-scoped directories (Â§10).
* **Single-file or pinned writer policy (Binding):** Producers **MUST** either (a) publish **a single file per partition**, or (b) pin a **writer policy** (codec/level, row-group/page sizes, writer threads, dictionary encoding) via the Artefact Registry so reruns are **byte-identical**. If no writer policy is pinned, option (a) applies.
* Readers MUST treat physical file boundaries as non-semantic (dictionary `ordering: []`).

**12.6 Streaming vs. in-memory** *(Informative)*

* A **single pass per currency** is sufficient after forming the union of countries (Â§6.1).
* Join of the two ingress surfaces MAY be implemented as a streamed merge on `(currency, country_iso)`; no global sort across all currencies is required by this spec.

**12.7 Large-currency stress behaviour** *(Informative)*

* For currencies with very wide support (e.g., â‰³200 ISO codes), implementers SHOULD:

  * keep per-currency processing isolated (avoid cross-currency buffers),
  * ensure renormalisation (Â§6.6) and quantisation + tie-break (Â§6.7) do not allocate super-linear intermediates,
  * surface **metrics** on renormalisation magnitude and largest-remainder placements (see Â§14.3).

**12.8 Retry cost & atomicity** *(Informative â†’ Binding where referenced)*

* Retries SHOULD be scoped to the affected `parameter_hash` only.
* **Binding:** Atomic publish and write-once rules in Â§10.5/Â§10.6 apply; partial outputs MUST NOT be made visible.

**12.9 External calls & side effects** *(Binding)*

* S5 **MUST NOT** perform network calls or read any data source beyond the artefacts listed in Â§3 and the policy in Â§4; doing so would violate parameter-scope determinism.

**12.10 Throughput targets & SLO posture** *(Informative)*

* This spec does not set wall-clock SLOs; operators SHOULD size concurrency to available vCPUs (min(#currencies, vCPUs)) while respecting Â§12.2.
* Recommended telemetry: `currencies_processed/sec`, `rows_written/sec`, back-pressure indicators (see Â§14.1).

**12.11 Failure domains** *(Informative)*

* Pre-flight hard FAILs (Â§8.1-Â§8.2) short-circuit the run before any writes.
* Per-currency errors in Â§8.3 escalate to **run abort** (no partial publish).
* Degrades (Â§8.4/Â§8.6) are **per currency** and do not affect others, but PASS requires all invariants (Â§7) to hold on emitted outputs.

---

# 13. Orchestration & CLI contract **(Binding at interface; Informative for ops)**

> Goal: fix the **invocation surface** and **publish semantics** for S5 without prescribing implementation details. Paths/partitions must align with the **Dataset Dictionary** and schema authority. DAG wiring is specified below in Â§13.4. JSON-Schema and the dictionary remain the single authorities for shapes and locations.

## 13.1 Command interface (Binding)

**Canonical producer name (dictionary `produced_by`):** `1A.expand_currency_to_country`. 

**Invocation (normative flags â€” no implicit defaults for locations):**

* `--parameter-hash <hex64>` **(required)** â€” selects the **parameter-scoped** partition for all S5 outputs. **Must** match the embedded `parameter_hash` written into rows. 
* `--input-root <DIR>` **(required)** â€” root under which **reference inputs** are resolved, e.g.
  `reference/network/settlement_shares/2024Q4/settlement_shares.parquet`,
  `reference/network/ccy_country_shares/2024Q4/ccy_country_shares.parquet`,
  `reference/iso/iso3166_canonical/2024-12-31/iso3166.parquet`.
* `--output-root <DIR>` **(required)** â€” root under which S5 must publish **parameter-scoped** outputs exactly at dictionary paths, e.g.
  `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/`,
  `data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/`,
  `data/layer1/1A/sparse_flag/parameter_hash={parameter_hash}/`. **Write-once.**
* `--policy-file <PATH>` **(required)** â€” bytes of `ccy_smoothing_params.yaml`; include in run lineage/receipt (Â§9). (Changing bytes **must** flip `parameter_hash` per S0 hashing rules.)
* `--dictionary <PATH>` **(required)** â€” dataset dictionary file (e.g., `dataset_dictionary.layer1.1A.yaml`); S5 **must** resolve IDsâ†’paths/partitions from here and **fail** on drift. 
* `--schemas <PATH>` **(required)** â€” schema authority bundle (e.g., `schemas.1A.yaml`, `schemas.ingress.layer1.yaml`); used by the validator to enforce schema/constraint checks.

**Optional interface switches (Binding where stated):**

* `--emit-sparse-flag` *(MAY; default off)* â€” if set, produce `sparse_flag` per dictionary/schema. 
* `--validate-only` *(MAY)* â€” perform Â§9 validation and emit the S5 receipt **under** the weights cache partition path (create the partition directory if absent) **without writing data files**; returns the same exit code semantics as a full run. This receipt does **not** authorise S6 reads unless the weights cache exists.
* `--fail-on-degrade` *(MAY)* â€” if any per-currency `degrade_mode â‰  none` (per Â§8.4), exit as FAIL even if Â§7 invariants hold (used in strict CI).

**Argument rules (Binding):**

* Locations **MUST NOT** be inferred from environment; each required path/ID must be provided explicitly as above.
* The command **MUST** reject unknown flags and missing required flags with a usage error (see Â§13.3).
* The producer **MUST** honour dictionary paths/partitions exactly (no ad-hoc subfolders). 

---

## 13.2 Idempotent rerun & temp-artefact policy (Binding)

* **Write-once per partition.** If `â€¦/parameter_hash={H}/` exists for any S5 dataset, the producer **MUST** refuse to overwrite; re-runs with identical inputs/policy must be **byte-identical** (Â§10). 

* **Exists/resume.** If the target `â€¦/parameter_hash={H}/` already exists:
  (i) if byte-for-byte identical, no-op and exit with PASS;
  (ii) otherwise hard FAIL `E_PARTITION_EXISTS` (do not overwrite or append).
* **Atomic publish.** Writers **MUST** stage to a temp directory under the target parent and perform a **single atomic rename**; no partial contents may become visible. This mirrors S0â€™s atomic bundle publish. 
* **Pathâ†”embed equality.** After publish, embedded `parameter_hash` **MUST** equal the partition key **byte-for-byte**; any mismatch is a run-fail. 
* **No RNG paths.** S5 **MUST NOT** touch `{seed, parameter_hash, run_id}` log partitions reserved for RNG streams. 

---

## 13.3 Exit codes & emitted artefacts (Binding)

**Exit codes (minimal, unambiguous):**

* `0` â€” **PASS**: all checks in Â§9 succeed; S5 receipt present and valid for the given `parameter_hash`. (Degrades allowed; see metrics for `degrade_mode` counts.)
* `64` â€” **USAGE**: missing/unknown/invalid CLI flags or non-existent required paths.
* `65` â€” **INPUT_SCHEMA**: ingress dataset breach (schema/PK/FK/Î£) detected pre-flight. 
* `66` â€” **POLICY_DOMAIN**: policy file domain/feasibility error (e.g., `Î£ min_share_iso>1`). 
* `67` â€” **OUTPUT_SCHEMA**: any S5 output fails its schema or lineage partition rules. 
* `68` â€” **RNG_INTERACTION**: any RNG log written/changed or trace length delta vs the **pre-S5 snapshot of `rng_trace_log`**.
* `1` â€” **GENERAL_FAIL**: any other invariant breach in Â§7/Â§8/Â§9.

**Emitted artefacts on PASS (parameter-scoped, alongside weights cache):**

* `S5_VALIDATION.json` â€” machine-readable validation summary (normative fields in Â§9.8).
* `_passed.flag` â€” single-line sha256 receipt over the S5 receipt files (hash excludes the flag itself), mirroring S0â€™s gate pattern (but **parameter-scoped**). 

**Read gate reminder:** Downstream readers (e.g., S6) **MUST** verify the S5 receipt for the **same `parameter_hash`** before reading (`no PASS â†’ no read`). The **layer-wide** fingerprint-scoped validation bundle for egress remains unchanged and separate. 

---

## 13.4 DAG wiring â€” internal & S0-S4 integration

*(Binding at interfaces; Informative for scheduling)*

> This subsection fixes the **node boundaries, prerequisites, edges, and gates** for S5. It is framework-agnostic (no Airflow/Prefect specifics). Dataset IDs, schema refs, and paths come from the **Dataset Dictionary** and **Schema Authority** and remain the single sources of truth.

### 13.4.1 Run prerequisites (Binding)

**P1 â€” Parameter scope fixed.** A concrete **`parameter_hash`** is selected (CLI Â§13.1) and corresponds to the governed parameter set sealed by S0. Policy bytes **`ccy_smoothing_params.yaml`** must be part of that set; changing its bytes flips `parameter_hash`. 

**P2 â€” Inputs exist and are sealed.** The ingress surfaces listed in Â§3 are present and conform to their schema anchors:
- `settlement_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/settlement_shares`
- `ccy_country_shares_2024Q4` â†’ `schemas.ingress.layer1.yaml#/ccy_country_shares`
- `iso3166_canonical_2024` (FK target)
All are registered/approved in the dictionary/registry.

**P3 â€” Dictionary & schema availability.** The producer has the **Dataset Dictionary** (`dataset_dictionary.layer1.1A.yaml`) and schema bundle(s) at run start; S0â€™s path/partition lints apply. 

**P4 â€” RNG stance.** No RNG streams are to be produced by S5; S5 will later verify **no change** in `rng_trace_log` totals vs the pre-run snapshot for this run context (see Â§11 / Â§9). 

> **Note.** S5 has **no hard data dependency** on S1-S4 datasets to compute weights. S3â€™s order authority and S4â€™s ZTP logs are relevant only to **downstream** readers and the **non-interaction proof**, respectively.

---

### 13.4.2 Nodes & edges (Binding at interfaces)

**N0 â€” Resolve policy & hash (Binding).**
Inputs: `ccy_smoothing_params.yaml` (bytes), dictionary, schemas.
Responsibilities: (a) validate policy keys/domains/overrides (Â§4), (b) assert inclusion into the governed parameter set for this `parameter_hash`, (c) record policy digest for the S5 receipt (Â§9). **Outputs:** ephemeral policy handle (in-memory), `policy_digest`. **On failure:** `E_POLICY_*` (abort). 

**N1 â€” Pre-flight ingress checks (Binding).**
Inputs: `settlement_shares_2024Q4`, `ccy_country_shares_2024Q4`, `iso3166_canonical_2024`.
Responsibilities: enforce Â§3.2-Â§3.4 (PK/FK, domains, **Î£=1Â±1e-6** per currency). **On failure:** `E_INPUT_SCHEMA`/`E_INPUT_SUM` (abort). 
**Edge:** `N0 â†’ N1`.

**N2 â€” Build `ccy_country_weights_cache` (Binding).**
Inputs: N1 datasets + N0 policy.
Responsibilities: apply Â§6.1-Â§6.7 (union coverage; blend; effective mass; Î± smoothing; floors; renormalise; **fixed-dp + deterministic largest-remainder**; writer sort `(currency, country_iso)` ASC). **Output dataset:** `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/` with **PK `(currency, country_iso)`** and **pathâ†”embed equality**.
**Edge:** `N1 â†’ N2`.

**N2b â€” (Optional) Build `merchant_currency` (Binding).**
Inputs: ingress surfaces + policy (if needed by your rule).
Output: `data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/` (PK `merchant_id`). May run **in parallel** with N2 once N1 passes. 

**N3 â€” S5 validator & receipt (Binding).**
Inputs: outputs from N2/N2b; dictionary & schemas; pre-run RNG trace snapshot.
Responsibilities (see Â§9): schema+PK/FK; **Î£ numeric** and **decimal@dp = 1**; union coverage; **re-derivation**; **RNG non-interaction** (trace totals unchanged); write `S5_VALIDATION.json` and `_passed.flag` **under the weights cache partition** (parameter-scoped). **On failure:** abort; no publish.
**Edge:** `N2 â†’ N3` (and `N2b â†’ N3` if N2b executed).

**N4 â€” Atomic publish (Binding).**
Publish S5 datasets by **staging â†’ single atomic rename**; ensure **write-once** for the target `parameter_hash`. **Downstream read gate:** S6 **MUST** see S5 `_passed.flag` before reading. 
**Edge:** `N3 (PASS) â†’ N4`.

---

### 13.4.3 Wiring to S0-S4 (Binding)

* **S0 (governance & gates).** S5 inherits S0â€™s partition law and atomicity: parameter-scoped outputs embed the same `parameter_hash` as the path, and validation receipts use the `_passed.flag` pattern (**ASCII-lexicographic** hash over the sidecar files). 

* **S1/S2 (no direct data dependency).** S5 does not read hurdle/NB artefacts. Their RNG streams and budgets remain untouched during S5. 

* **S3 (order authority stays in S3).** S5 produces **no order**; downstream states must continue to join order only from **`s3_candidate_set.candidate_rank`**. S5 outputs are designed to be **S6-ready** (restrict/renormalise within merchantâ€™s candidate set only in S6).

* **S4 (RNG logs only; S5 non-interaction proof).** S4 appends ZTP events and updates `rng_trace_log` under `{seed,parameter_hash,run_id}`; S5 MUST NOT write to those paths and MUST prove **no change** in trace totals preâ†’post run.

---

### 13.4.4 Concurrency & idempotence (Binding)

* **Shard boundary:** currencies may be processed in parallel **by currency** only; merges must yield **byte-identical** results to a single-threaded run and preserve writer sort `(currency, country_iso)` ASC. If a pinned writer policy is not in force, producers MUST publish one file per partition to preserve byte identity.
* **Re-runs:** a completed `parameter_hash` partition is **immutable**; re-running with identical inputs/policy must be **byte-identical** or refused. 

---

### 13.4.5 Failure & abort semantics (Binding)

* On any **hard FAIL** from Â§8 or Â§9, S5 follows S0â€™s abort procedure: stop emitting, **delete temp dirs**, write failure sentinel(s) if any partial escaped temp, and **exit non-zero**; no `_passed.flag` means **no read** downstream. 

---

### 13.4.6 Artefact and registry alignment (Binding)

* The **artefact registry** entries for `ccy_country_weights_cache`, `merchant_currency`, and `ccy_smoothing_params` must exist and match dictionary IDs, schema refs, paths, and version semantics (`{parameter_hash}` for datasets). 

### 13.4.7 ASCII overview *(Informative; non-authoritative)*

> This diagram is for **reader orientation only**. It does **not** add requirements. On any discrepancy, Â§Â§6-11 and Â§Â§13.1-13.4.6 (Binding) prevail.

```
[ENTER S5]
   â”‚
   â”‚ Resolve parameter scope + policy bytes (N0)
   â”‚â€”â€” fail â†’ [STOP: E_POLICY_*]
   v
[Pre-flight ingress checks (N1)]
   â”‚  (PK/FK, domains, Î£=1 per currency on each input surface)
   â”‚â€”â€” fail â†’ [STOP: E_INPUT_*]
   v
[OPTIONAL N2b: Build merchant_currency]   (may run in parallel with N2 after N1)
   â”‚
   v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ For each currency Îº (Aâ†’Z)                                                    â”‚
â”‚    â”‚                                                                          â”‚
â”‚    â”‚ Any source rows for Îº?                                                   â”‚
â”‚    â”‚â€”â€” no â†’ [SKIP Îº] (no outputs; no degrade)                                 â”‚
â”‚    v                                                                          â”‚
â”‚ [Union country set for Îº]                                                     â”‚
â”‚    â”‚                                                                          â”‚
â”‚    â”‚ Only one surface present?                                                â”‚
â”‚    â”‚â€”â€” yes â†’ set degrade_mode = ccy_only | settlement_only                    â”‚
â”‚    v                                                                          â”‚
â”‚ [Blend  q = w*s_ccy + (1âˆ’w)*s_settle]                                         â”‚
â”‚    v                                                                          â”‚
â”‚ [Effective mass N_eff; Î±-smoothing]                                           â”‚
â”‚    v                                                                          â”‚
â”‚ [Apply floors (min_share*, incl. ISO overrides)]                              â”‚
â”‚    â”‚                                                                          â”‚
â”‚    â”‚ Î£ min_share_iso > 1 ?                                                    â”‚
â”‚    â”‚â€”â€” yes â†’ [ABORT RUN: E_POLICY_MINSHARE_FEASIBILITY]                       â”‚
â”‚    v                                                                          â”‚
â”‚ [Renormalise p so Î£=1 (binary64)]                                             â”‚
â”‚    v                                                                          â”‚
â”‚ [Quantise to dp (half-even) + largest-remainder tie-break]                    â”‚
â”‚    â”‚                                                                          â”‚
â”‚    â”‚ Decimal Î£@dp == 1 ?                                                      â”‚
â”‚    â”‚â€”â€” no â†’ [ABORT RUN: E_QUANT_SUM_MISMATCH]                                 â”‚
â”‚    v                                                                          â”‚
â”‚ [Write rows for Îº â†’ ccy_country_weights_cache (sorted by currency, ISO2)]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚
   v
[S5 Validator & Receipt (N3)]
   â”‚  Re-derive; schema/PK/FK; union coverage; Î£ numeric & decimal@dp;
   â”‚  RNG non-interaction (trace totals unchanged); record overrides/degrades
   â”‚â€”â€” fail â†’ [ABORT RUN: no publish]
   v
[Atomic publish (N4)]
   â”‚  Stage â†’ single rename; write-once; emit S5_VALIDATION.json + _passed.flag
   v
[STOP: S5 PASS â€” downstream MAY read (parameter scope)]
```

---

# 14. Observability & metrics **(Binding for metric names/semantics; Informative where marked)**

> Purpose: make S5â€™s correctness and policy effects **visible and auditable** without prescribing implementation code. Metrics are **parameter-scoped** and live with the S5 receipt (see Â§9). JSON-Schema and the Dataset Dictionary remain the single authorities for dataset shapes and paths; S5 does **not** introduce a new dataset for metrics.

## 14.1 Surfaces (where metrics appear)

* **S5 receipt (Binding):** `S5_VALIDATION.json` adjacent to `ccy_country_weights_cache/parameter_hash={parameter_hash}/` (same partition), plus `_passed.flag`. This file **MUST** contain the run-level summary (Â§14.3) and per-currency records (Â§14.4). No separate metrics dataset is created. 
* **Structured logs (Binding for fields, Informative for transport):** JSON-lines emitted during N0-N4 (see Â§13.4) with the required fields in Â§14.5. Transport/backends are out of scope.
* **Layer-wide bundle (Informative):** fingerprint-scoped validation bundle remains unchanged and separate; it is not a sink for S5 parameter-scoped metrics. 

## 14.2 Dimensions & identity (Binding)

Every record in `S5_VALIDATION.json` **MUST** carry:

* `parameter_hash : hex64` â€” the partition key for S5 outputs. 
* `policy_digest : hex64` â€” SHA-256 of the **bytes** of `ccy_smoothing_params.yaml` consumed by the run. 
* `producer : "1A.expand_currency_to_country"` â€” matches dictionary `produced_by`. 
* `schema_refs : object` â€” anchors used to validate inputs/outputs (must include `schemas.ingress.layer1.yaml#/settlement_shares`, `schemas.ingress.layer1.yaml#/ccy_country_shares`, and `schemas.1A.yaml#/prep/ccy_country_weights_cache`).

## 14.3 Run-level metrics (Binding)

Top-level object **MUST** include these keys (types/semantics fixed):

* **Cardinality & output:**

  * `currencies_total : int` â€” distinct currencies seen in inputs (union). 
  * `currencies_processed : int` â€” currencies for which rows were written (may be `< currencies_total` if some had no source rows).
  * `rows_written : int` â€” total rows in `ccy_country_weights_cache` for this `parameter_hash`. 

* **Î£ & quantisation discipline:**

  * `sum_numeric_pass : int` â€” count of currencies where **numeric** Î£(weight)=1.0Â±1e-6 (schema group constraint). 
  * `sum_decimal_dp_pass : int` â€” count of currencies where the **decimal** sum at `dp` equals exactly `"1"` after tie-break. (Target: equals `currencies_processed`.)

* **Rounding/tie-break effort:**

  * `largest_remainder_total_ulps : int` â€” total absolute ULP adjustments applied across all currencies in Â§6.7 (0 means half-even already hit exact decimal Î£).
  * `largest_remainder_ulps_quantiles : {p50:int,p95:int,p99:int}` â€” distribution over per-currency ULP adjustments.

* **Policy application:**

  * `overrides_applied_count : int` â€” total ISO- or currency-level overrides used (from Â§4).
  * `floors_triggered_count : int` â€” total `(currency, ISO)` pairs where the **floor** was binding (`posterior < min_share*`).
  * `degrade_mode_counts : {none:int, settlement_only:int, ccy_only:int}` â€” per-currency degrade tallies (no `abort` here; aborts are run-fail per Â§8).

* **Coverage:**

  * `coverage_union_pass : int` â€” count of currencies where output ISO set equals the **union** of input ISOs.
  * `coverage_policy_narrowed : int` â€” count of currencies narrowed by policy (must also be listed in `policy_narrowed_currencies[]`). 

* **RNG non-interaction:**

  * `rng_trace_delta_events : int` â€” sum of deltas in `rng_trace_log.events_total` across all (module, substream) keys (MUST be 0).
  * `rng_trace_delta_draws : int` â€” sum of deltas in `draws_total` (MUST be 0). 

* **Lists (for operator visibility):**

  * `policy_narrowed_currencies : [ISO4217]` â€” currencies explicitly narrowed by policy (Â§8.6).
  * `degraded_currencies : [{currency, mode, reason_code}]` â€” per-currency degrade summary (Â§8.4/Â§8.7).

## 14.4 Per-currency records (Binding)

`S5_VALIDATION.json` **MUST** contain a collection `by_currency : [ â€¦ ]` with one object per processed currency, each with:

* **Identity:** `currency`, `parameter_hash`, `policy_digest`.
* **Coverage:** `countries_union_count : int`; `countries_output_count : int`; `policy_narrowed : bool`. (If `true`, include `narrowed_isos : [ISO2]`.) 
* **Î£ checks:**

  * `sum_numeric_ok : bool` (schema group check). 
  * `sum_decimal_dp_ok : bool` (exact decimal Î£ at `dp`).
* **Rounding effort:** `largest_remainder_ulps : int`.
* **Policy effects:** `overrides_applied : {alpha_iso:int, min_share_iso:int, per_currency:int}`; `floors_triggered : int`.
* **Degrade:** `degrade_mode : "none"|"settlement_only"|"ccy_only"`; `degrade_reason_code : enum` (see Â§8.7).
* **Evidence (Informative):** `N0 : number`, `N_eff : number`, and `dp : int` used.

## 14.5 Structured logs (Binding for fields; Informative taxonomy)

Each log line **MUST** be a single JSON object with at least:

* `ts : string (ISO 8601)`; `level : "INFO"|"WARN"|"ERROR"`;
* `component : "1A.expand_currency_to_country"`;
* `stage : "N0"|"N1"|"N2"|"N2b"|"N3"|"N4"` (see Â§13.4);
* `parameter_hash : hex64`; `currency? : ISO4217`;
* `event : string` (stable programmatic name, e.g., `"POLICY_OVERRIDES_APPLIED"`, `"QUANT_TIE_BREAK"`, `"DEGRADE_USED"`);
* `reason_code? : string` (closed vocab from Â§8); `details? : object` (small, structured).

**Error taxonomy (Binding):** usage â†’ `USAGE`; input schema/sum â†’ `E_INPUT_*`; policy domain/feasibility â†’ `E_POLICY_*`; output schema/lineage â†’ `E_OUTPUT_SCHEMA`/`E_LINEAGE_PATH_MISMATCH`; RNG breach â†’ `E_RNG_INTERACTION`; quantisation sum mismatch â†’ `E_QUANT_SUM_MISMATCH`. (Names align with Â§8 and Â§13.3.) 

## 14.6 Metric naming & units (Binding)

* Counts are **integers**; ULP totals are **integers**; quantiles report integers; `N0`/`N_eff` are **binary64 numbers**.
* Code/enum fields use **uppercase ISO domains** pinned by ingress/schema authority (ISO2/ISO-4217).
* All metrics are **parameter-scoped**; do **not** partition or key them by `{seed, run_id}` (RNG/log partitions remain reserved for RNG systems). 

## 14.7 Golden fixtures & audit snapshots *(Informative)*

Operators SHOULD maintain one tiny, public-derivable fixture (â‰¤ 3 currencies, â‰¤ 6 ISO codes) with a frozen `ccy_smoothing_params.yaml` to sanity-check: (a) union coverage, (b) floors/overrides application, (c) largest-remainder behaviour, and (d) exact decimal Î£ at `dp`. The fixtureâ€™s outputs and `S5_VALIDATION.json` live in the same parameter-scoped partition as the weights cache and are versioned by `parameter_hash`.

---

**Notes.**
- Nothing in Â§14 alters dataset contracts; the **weights cache** remains the only persisted authority for currencyâ†’country weights, and **order** continues to be owned by S3â€™s candidate set (not by S5 metrics).
- RNG logs (audit/trace/event) are **unchanged**; S5 merely proves non-interaction via zero deltas.

---

# 15. Security, licensing & compliance

> Purpose: ensure S5â€™s inputs/outputs obey the platformâ€™s **closed-world, contract-governed** posture; keep artefacts **licensed**, non-PII, immutable by key, and auditable.

## 15.1 Data provenance & closed-world stance

* S5 operates **only** on the sealed, version-pinned artefacts enumerated in Â§3 and the S5 policy in Â§4; **no external enrichment or network reads** are permitted. This follows the enterprise â€œsealed universeâ€ control-plane rules (no PASS â†’ no read; JSON-Schema authority; lineage anchors). 
* Provenance for each input/output is already declared in the **Dataset Dictionary** (owner, retention, licence, schema_ref). S5 MUST NOT deviate. 

## 15.2 Licensing (inputs, outputs, and registry alignment)

* **Ingress licences (examples relevant to S5):**
  - `iso3166_canonical_2024` â†’ **CC-BY-4.0** (external reference). 
  - `settlement_shares_2024Q4` â†’ **Proprietary-Internal**. 
  - `ccy_country_shares_2024Q4` â†’ **Proprietary-Internal**. 
* **S5 outputsâ€™ licence class:** `ccy_country_weights_cache`, `merchant_currency`, and `sparse_flag` are **Proprietary-Internal**, retained 365 days; S5 MUST publish under those exact classes and retention windows declared in the dictionary. 
* **Licence mapping artefact:** the registry exposes `licenses/license_map.yaml` for tracing artefactâ†’licence during validation/release. S5 MUST confirm the **presence** of a licence entry for every input it consumes; absence is a **run-fail**. (No need to interpret legal textâ€”presence + ID match is required.) 

## 15.3 Privacy & PII posture

* All S5 inputs and outputs in scope are declared **`pii: false`** in the dictionary; S5 MUST NOT introduce PII or fields enabling re-identification.
* Structured logs and the S5 receipt MUST avoid row-level payloads; they MAY include **codes and counts only** (currency, ISO, integer counters). See Â§14 for allowed fields. 

## 15.4 Access control, encryption, and secrets

* S5 inherits platform security rails: **least-privilege IAM**, **KMS-backed encryption** at rest/in transit, and **audited access** to governance artefacts. S5 MUST NOT embed secrets in datasets/logs and MUST rely on the platformâ€™s secret store when credentials are needed (none are required by S5).

## 15.5 Retention & immutability

* Retention periods are governed by the dictionary (e.g., **365 days** for S5 outputs; **1095 days** for most ingress references). S5 MUST NOT override retention.
* Datasets are **content-addressed by `parameter_hash`** at write time and are **write-once** per partition (immutability); atomic publish rules in Â§10 apply. 

## 15.6 Licence & compliance checks (validator duties)

The S5 validator (Â§9) MUST additionally assert:

* **Dictionary/licence presence:** for each input dataset ID consumed, there exists a dictionary entry with **non-empty `licence`** and `retention_days`. Missing â‡’ **FAIL**. 
* **Licence-map coverage:** an entry exists in `license_map` for each input ID (compare IDs, not legal text). Missing â‡’ **FAIL**. 
* **Receipt fields:** `S5_VALIDATION.json` MUST include `licence_summary` listing `{dataset_id, licence, retention_days}` for all inputs and the output family, plus `policy_digest` and `parameter_hash` (see Â§14.2). 

## 15.7 Redistribution & downstream use

* S5 outputs are **internal authorities** (Proprietary-Internal). Downstream systems MUST NOT republish them externally or change licence class without governance approval. The **order authority** remains S3; S5 weights MAY be used downstream only under the **no re-derive** rules in Â§2 and after S5 PASS. 

## 15.8 Geospatial & other external datasets (for completeness)

* Spatial datasets pinned in Layer-1 (e.g., `world_countries`, `tz_world`, `population_raster`) carry **ODbL-1.0** or similar licences in the dictionary; although S5 does not read them, their licence posture is part of the environment and MUST NOT be altered by S5. 

---

**Compliance note.** These clauses do not expand legal obligations; they operationalise what is already declared in the **Dataset Dictionary** and **Artefact Registry** so that S5 remains sealed, non-PII, **licensed**, and auditable.

---

# 16. Change management, compatibility & rollback

> Purpose: define how S5 evolves without breaking consumers, how deprecations are handled, and how to roll back safely. Dataset IDs, paths, partitions, owners, retention and schema refs remain governed by the **Dataset Dictionary** and **Artefact Registry**.

## 16.1 Semver triggers (what forces MAJOR/MINOR/PATCH)

**MAJOR** (breaking for consumers; requires re-ratification and dictionary/registry updates):

* Change to **dataset IDs, paths, or partition keys** for any S5 output (e.g., anything other than `parameter_hash`), or change to **PKs**/join keys. 
* Change to **schema fields or types** for `ccy_country_weights_cache`/`merchant_currency`/`sparse_flag` (rename, removal, type change; group-sum tolerance). 
* Change to **quantisation/tie-break rule** (Â§6.7) or default **`dp`**; change to the **Î£ rule** beyond `1e-6`. (Alters persisted values.)
* Change to **PASS gate semantics** or receipt location/naming (e.g., rename `_passed.flag` or move receipt). 
* Removal of an output currently marked **approved** in the dictionary. 

**MINOR** (backward compatible):

* Add **optional** columns with default `null`/non-required semantics to S5 outputs or to the S5 receipt. 
* Add new **metrics**/fields in `S5_VALIDATION.json` (Â§14).
* Add an **optional** output dataset such as diagnostics (kept parameter-scoped, with its own schema_ref and dictionary entry).

**PATCH**:

* Clarifications, doc fixes, stronger wording that does **not** change dataset shapes, values, gates, or paths.

**Policy file (`ccy_smoothing_params.yaml`)**: bump **MAJOR** if keys/semantics change (e.g., add new mandatory key or change domain of an existing key); **MINOR** to add optional keys; **PATCH** for comments/description only. The policy artefact carries semver in the registry and contributes to `parameter_hash`. 

## 16.2 Compatibility window & cross-state contracts

* S5 remains bound to the **v1.* lines** of the schema bundles and dictionary cited in Â§0/Â§5. A MAJOR bump in those upstream authorities requires S5 re-ratification.
* **Order authority** remains in S3; S5 must not encode order. This separation is stable across versions. 
* Ingress schemas may provide **compatibility aliases** (e.g., `settlement_shares` â†’ `settlement_shares_2024Q4`); S5 may rely on those aliases without change to its own IDs. 

## 16.3 Deprecation & migration (how we retire things)

* Use the dictionaryâ€™s `status: deprecated` to retire legacy datasets (kept read-only for a deprecation window); do not delete without a migration note. Examples exist for **`country_set`** and **`ranking_residual_cache_1A`**.
* Deprecations MUST include: dataset ID, replacement surface, last supported semver, and an **end-of-life** date in release notes (outside this spec).
* During the window, S5/S6 MUST continue producing/consuming the **authoritative** surfaces (e.g., `ccy_country_weights_cache`), and MUST NOT re-elevate deprecated ones to authority. 

## 16.4 Rollback strategy (parameter-scoped; no mutation)

* **What to roll back:** select the **last-good `parameter_hash`** whose S5 receipt exists and `_passed.flag` is valid under the weights cache partition. No data mutation is required.
* **How:** point downstream (e.g., S6) to that `parameter_hash` (or re-run S5 using the prior policy bytes to reproduce the same `parameter_hash`). **Atomic publish** guarantees no partials are visible. 
* **Registry alignment:** the Artefact Registry tracks `{semver, version='{parameter_hash}', digest}` for S5 datasets and the policy, enabling operators to reference an exact previous version.

## 16.5 Forward/Backward compatibility guidance

* **Minor upgrades** MUST keep dataset IDs, paths, partitions, PKs and schema types stable so that older readers continue to function. 
* If adding optional columns/metrics, mark them **nullable** and avoid changing PKs or constraints. 
* **Breaking changes** MUST provide a migration note and a grace period where both old and new forms co-exist (old marked **deprecated**) before removal. 

## 16.6 Release & ratification hooks

* Any MAJOR change in Â§16.1 requires: (a) Schema updates; (b) Dictionary entries updated (`schema_ref`, `path`, `version`); (c) Registry entries updated (`semver`, `digest`, `manifest_key`); (d) S0 CI re-sealing so the new bytes appear in the **manifest**.
* Publish notes MUST list the affected dataset IDs and policy semver, and state whether downstream (S6) requires action. (S6 continues to read by `parameter_hash`; no action if shapes unchanged.)

## 16.7 Breaking-change checklist (Binding)

Before merging a change that would bump **MAJOR**, ensure all are true:

1. Schema diffs applied to `schemas.1A.yaml` and validated; dictionary entries updated to match.
2. Artefact Registry rows updated (`semver`, `version`, `digest`, `manifest_key`). 
3. S0 sealing passes with a new **`manifest_fingerprint`** and the validation bundle `_passed.flag` is correct.
4. Deprecation window and migration notes published where applicable (dictionary `status`/notes for legacy items). 

---

# 17. Acceptance checklist

> Use this as the go/no-go gate for promoting S5 outputs. Each item is **required** unless marked optional. Cross-references point to the normative clauses that define the rule.

## 17.1 Build-time (before first run)

* [ ] **Parameter scope fixed** and communicated (`parameter_hash` chosen for this run). (Â§0.6, Â§10.1-Â§10.3)
* [ ] **Policy file present** at `ccy_smoothing_params.yaml`; has `semver`, `version`, `dp`; passes key/domain rules and feasibility (**Î£ min_share_iso â‰¤ 1**); all codes upper-case and valid. (Â§4.2-Â§4.6)
* [ ] **Dictionary + schema bundles** available and readable; S5 will treat **JSON-Schema as the only authority**. (Â§0.3, Â§5, Â§13.1)
* [ ] **Artefact registry** entries exist for: `ccy_country_weights_cache`, `merchant_currency` (if used), `sparse_flag` (if used), and `ccy_smoothing_params`. (Â§10.8)
* [ ] **CLI wiring**: required flags supplied (`--parameter-hash`, `--input-root`, `--output-root`, `--policy-file`, `--dictionary`, `--schemas`). No implicit defaults. (Â§13.1)
* [ ] **No external reads** beyond Â§3 inputs and Â§4 policy; network access not required/used. (Â§12.9, Â§15.1)

## 17.2 Run-time (execution checks)

* [ ] **Ingress pre-flight passes** for both share surfaces: PK/FK, domains, **Î£ share = 1 Â± 1e-6** per currency; schema-exact columns. (Â§3.2-Â§3.4, Â§8.1)
* [ ] **Union coverage formed** per currency (countries = union of both surfaces; missing treated as 0). (Â§6.1)
* [ ] **Degrade rules respected** when one surface is missing: `degrade_mode âˆˆ {ccy_only, settlement_only}` with reason code; otherwise no degrade. (Â§8.4, Â§8.7)
* [ ] **Numeric discipline**: all math in **binary64** through blend â†’ effective mass â†’ Î±-smoothing â†’ floors â†’ renormalise. (Â§6.2-Â§6.6)
* [ ] **Feasibility guard** enforced for floors (Î£ min_share_iso â‰¤ 1). (Â§6.5, Â§8.2)
* [ ] **Quantisation** uses fixed-dp **round-half-even** then deterministic **largest-remainder** tie-break; per-currency **decimal Î£@dp = 1**. (Â§6.7)
* [ ] **Determinism**: no RNG usage; stable order within currency (ISO Aâ†’Z); parallelism only **by currency**; writer sort `(currency ASC, country_iso ASC)`. (Â§6.8, Â§12.2, Â§11)
* [ ] **Outputs conform** to schemas and dictionary: IDs, paths, PKs, partitioning (parameter-scoped only). (Â§5, Â§10.1, Â§7.2-Â§7.5)
* [ ] **Pathâ†”embed equality** for `parameter_hash` holds byte-for-byte. (Â§7.8, Â§10.2)
* [ ] **RNG non-interaction**: S5 writes **no** `rng_*`; `rng_trace_log` totals unchanged vs pre-run snapshot. (Â§11.1-Â§11.4)
* [ ] *(Optional if enabled)* `merchant_currency` and/or `sparse_flag` built and schema-valid. (Â§5.2-Â§5.3)

## 17.3 Validator & PASS artefacts (publish gate)

* [ ] **Re-derivation succeeds**: validator recomputes weights from inputs+policy per Â§6 and matches **byte-for-byte** at `dp`. (Â§9.4)
* [ ] **Structural/content checks pass**: schema, PK/FK, domain, **numeric Î£**, **decimal Î£@dp**, coverage parity (or recorded policy-narrowing). (Â§9.1-Â§9.3)
* [ ] **Degrade/override attestations** present for every affected currency. (Â§9.5)
* [ ] **S5 receipt written** under the weights cache partition: `S5_VALIDATION.json` (required fields present) and `_passed.flag` with a valid hash computed as specified. (Â§9.6, Â§9.8)
* [ ] **Write-once + atomic publish** observed; no partial visibility; retry semantics respected. (Â§10.5-Â§10.6)
* [ ] **Downstream gate armed**: policy that **no PASS â†’ no read** is enforced for S6 by contract. (Â§9.7)

## 17.4 Operability & compliance (post-run sign-off)

* [ ] **Metrics sanity**: totals in `S5_VALIDATION.json` (currencies_processed, rows_written, Î£ checks, ULP adjustments) look plausible; RNG deltas are zero. (Â§14.3)
* [ ] **Per-currency records present** with coverage, Î£ flags, ULP counts, overrides/floors, degrade mode. (Â§14.4)
* [ ] **Licence summary present** in the receipt; dictionary shows licences and retention for all inputs/outputs. (Â§15.2, Â§15.6)
* [ ] **Rollback pointer** noted (current `parameter_hash`) and last-good `parameter_hash` recorded for operators. (Â§16.4)

**Acceptance outcome:**

* **PASS:** All boxes checked above â†’ S5 is **green** for this `parameter_hash`; S6 may read.
* **FAIL:** Any unchecked mandatory item â†’ remediate and re-run; **downstream reads remain blocked** until Â§9 PASS is present for the same `parameter_hash`.

---

# Appendix A. Glossary & symbols **(Normative)**

> Terms below are binding for S5. Where a definition references an artefact, the **Dataset Dictionary** and **JSON-Schema** anchors are the single authorities for IDs, paths, types, and partitions.

## A.1 Identifiers & partitions

* **`parameter_hash` (hex64)** â€” The sole **parameter-scoped** partition key for S5 outputs and related caches. It is embedded (where the schema includes it) and must equal the path key byte-for-byte. Changing governed policy bytes flips this value. Paths using `parameter_hash` are pinned in the dictionary (e.g., S3 deterministic surfaces).
* **`manifest_fingerprint` (hex64)** â€” Layer-wide run fingerprint used for **egress** gating (e.g., `outlet_catalogue`). Not a partition for S5 outputs.
* **`run_id`** â€” Per-run identifier **only** for RNG log partitions `{seed, parameter_hash, run_id}`; S5 does not read/write these. 

## A.2 Schema, dictionary & domains

* **JSON-Schema authority** â€” For 1A, **JSON-Schema is the only schema authority**; Avro (if present) is non-authoritative. Every dataset/stream must reference its `$ref` into `schemas.*.yaml`.
* **Dataset Dictionary** â€” Registry of dataset **IDs, paths, partitions, ordering, schema_ref, retention, licence** (e.g., `s3_candidate_set`, `outlet_catalogue`). Consumers must honour dictionary paths and gates. 
* **ISO2 / ISO-4217** â€” Uppercase ISO-3166-1 alpha-2 country codes and uppercase currency codes as constrained by ingress/schema. FK to canonical ISO is enforced where declared. 

## A.3 Order authorities & hand-offs

* **`candidate_rank`** â€” The **sole authority** for **inter-country order** (S3). It is total, contiguous, and has `candidate_rank(home)=0`. S5 must not encode or imply country order.
* **`outlet_catalogue`** â€” Immutable egress of site stubs; **does not encode cross-country order**. Consumers must join S3â€™s `candidate_rank` when order is needed.

## A.4 RNG infrastructure (referential; S5 is RNG-free)

* **RNG logs** â€” Families under `schemas.layer1.yaml#/rng/*` (events/audit/trace), partitioned by `{seed, parameter_hash, run_id}`. **RNG trace** totals are cumulative per `(module, substream_label)`; S4 appends exactly one trace row per event. S5 must not change any RNG totals. 

## A.5 Policy & smoothing terms (S5)

* **`ccy_smoothing_params.yaml`** â€” Governed S5 policy artefact contributing to `parameter_hash`; contains keys below (domains in Â§4).
* **`dp`** â€” Fixed decimal places used for **output quantisation** of weights (0â€¦18).
* **`blend_weight (w)`** â€” Convex weight in [0,1] used to blend two share surfaces.
* **`alpha, alpha_iso`** â€” Non-negative Dirichlet-style prior(s) (per currency; optional per-ISO overrides).
* **`min_share, min_share_iso`** â€” Lower bounds on per-ISO weights (feasible only if Î£ floors â‰¤ 1).
* **`obs_floor`** â€” Minimum effective mass for smoothing; integer â‰¥ 0.
* **`shrink_exponent`** â€” Exponent â‰¥ 0 used to shrink large masses when computing effective evidence. *(All policy fields are normative; see Â§4 for domains/precedence.)*

## A.6 Probability surfaces & working symbols

* **`s_settle[c]`, `s_ccy[c]`** â€” Input share for country `c` from the settlement and currency-country surfaces, respectively; each surface individually satisfies Î£=1 per currency by ingress contract. 
* **`q[c]`** â€” Blended share: `q[c] = wÂ·s_ccy[c] + (1âˆ’w)Â·s_settle[c]`.
* **`N0`** â€” Evidence mass from counts: `N0 = wÂ·Î£ n_ccy + (1âˆ’w)Â·Î£ n_settle`.
* **`N_eff`** â€” Effective mass: `max(obs_floor, N0^(1/max(shrink_exponent, 1)))`.
* **`posterior[c]`** â€” Smoothed value: `(q[c]Â·N_eff + Î±[c]) / (N_eff + Î£ Î±)`.
* **`pâ€²[c]`** â€” Post-floor value: `max(posterior[c], min_share_for_c)`.
* **`p[c]`** â€” Renormalised value: `pâ€²[c] / Î£ pâ€²`.
* **`Z`** â€” Renormaliser `Î£ pâ€²`.
  *(All arithmetic is IEEE-754 binary64 until quantisation.)*

## A.7 Quantisation & exact-sum discipline

* **Round-half-even (bankerâ€™s rounding)** â€” Required rounding mode when converting `p[c]` to fixed-dp decimals.
* **Largest-remainder tie-break** â€” Deterministic placement of Â±1 ULP adjustments **within a currency** when the fixed-dp decimal sum deviates from exactly `1.00â€¦0` at `dp`. Let `r[c] = frac(10^dp Â· p[c])`.  
  - **Shortfall (add):** allocate +1 ULP to countries in **descending** `r[c]`, ties by `country_iso` **Aâ†’Z**.  
  - **Overshoot (subtract):** take âˆ’1 ULP from countries in **ascending** `r[c]`, ties by `country_iso` **Zâ†’A**.  
  Output must become **byte-identical** across shard counts after applying this rule.
* **ULP** â€” One **unit in the last place** of the fixed-dp decimal representation used for the Î£=1 exactness step.
* **Î£ (sum) tolerance** â€” Schema-level numeric group constraint of `1.0 Â± 1e-6`; S5 additionally requires **decimal** Î£ at `dp` to equal **exactly** `"1"` after tie-break. 

## A.8 Coverage, joins & scope

* **Union coverage** â€” For each currency, S5 outputs rows for the **union** of ISO codes appearing in either input surface, unless narrowed by policy (recorded via lineage/metrics).
* **Join keys** â€” Weights join on `(currency, country_iso)`; S3 order joins on `(merchant_id, country_iso)` with `candidate_rank` as the order key. 
* **Parameter scope vs egress scope** â€” S5 outputs are **parameter-scoped** (`parameter_hash=â€¦`); egress (e.g., `outlet_catalogue`) is **fingerprint-scoped** (`fingerprint=â€¦`). 

## A.9 Degrade modes & attestations (per currency)

* **`degrade_mode`** â€” `{none, settlement_only, ccy_only}` indicating a single-surface fallback was used.
* **`degrade_reason_code`** â€” Closed set including `{SRC_MISSING_SETTLEMENT, SRC_MISSING_CCY, POLICY_NARROWING}` (and `OTHER` as last resort).
* **S5 receipt** â€” `S5_VALIDATION.json` + `_passed.flag` written under the weights partition as the **parameter-scoped** PASS artefact; required for downstream reads. *(Names and placement are normative in Â§9.)*

## A.10 Notation & abbreviations

* **Aâ†’Z / ASC** â€” Lexicographic ascending order.
* **PK / FK** â€” Primary key / Foreign key as declared in JSON-Schema and the dictionary. 
* **`home`** â€” The merchantâ€™s home (registration) country; appears in S3 candidate set at `candidate_rank=0`. 
* **`A`** â€” Admissible foreign universe size `|C\{home}|` from S3; used downstream (e.g., S4â€™s `A=0` short-circuit). 

---

**Cross-reference note.** For the authoritative order surface and its guarantees, see **S3** (`s3_candidate_set`). For RNG trace/partition rules see **S4**. For egress order absence and within-country sequencing, see **`outlet_catalogue`** schema/dictionary entries.

---

# Appendix B. Enumerations & reference tables **(Normative)**

> These closed vocabularies and anchors are **binding** for S5. Dataset shapes/paths/owners/retention are governed by the **Dataset Dictionary** and **JSON-Schema**; this appendix pins the exact IDs, `$ref`s, domains, and error/metric vocabularies used by S5.

---

## B.1 Read/write dataset anchors (IDs, `$ref`, PKs, partitions)

| Role                   | Dataset ID                  | `$ref` (schema anchor)                                | Primary key (per partition) | Partitions         | Dictionary path (prefix)                                                    |
|------------------------|-----------------------------|-------------------------------------------------------|-----------------------------|--------------------|-----------------------------------------------------------------------------|
| **Input**              | `settlement_shares_2024Q4`  | `schemas.ingress.layer1.yaml#/settlement_shares`      | `(currency, country_iso)`   | â€”                  | `reference/network/settlement_shares/2024Q4/â€¦`                              |
| **Input**              | `ccy_country_shares_2024Q4` | `schemas.ingress.layer1.yaml#/ccy_country_shares`     | `(currency, country_iso)`   | â€”                  | `reference/network/ccy_country_shares/2024Q4/â€¦`                             |
| **FK target**          | `iso3166_canonical_2024`    | `schemas.ingress.layer1.yaml#/iso3166_canonical_2024` | `(country_iso)`             | â€”                  | `reference/iso/iso3166_canonical/2024-12-31/â€¦`                              |
| **Output (authority)** | `ccy_country_weights_cache` | `schemas.1A.yaml#/prep/ccy_country_weights_cache`     | `(currency, country_iso)`   | `[parameter_hash]` | `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/` |
| *(Optional)*           | `merchant_currency`         | `schemas.1A.yaml#/prep/merchant_currency`             | `(merchant_id)`             | `[parameter_hash]` | `data/layer1/1A/merchant_currency/parameter_hash={parameter_hash}/`         |
| *(Optional)*           | `sparse_flag`               | `schemas.1A.yaml#/prep/sparse_flag`                   | `(currency)`                | `[parameter_hash]` | `data/layer1/1A/sparse_flag/parameter_hash={parameter_hash}/`               |

**Notes.** JSON-Schema governs domains (e.g., `currency: ISO-4217`, `country_iso: ISO2`, `share âˆˆ [0,1]`, per-currency **Î£ share = 1 Â± 1e-6** on the two ingress surfaces).

---

## B.2 Code domains & FK constraints

| Symbol              | Closed domain                                                                                   | Enforcement / source of truth                         |
|---------------------|-------------------------------------------------------------------------------------------------|-------------------------------------------------------|
| `country_iso`       | ISO-3166-1 **alpha-2**, **uppercase**; placeholders such as `XX`, `ZZ`, `UNK` are **forbidden** | FK to `iso3166_canonical_2024.country_iso`            |
| `currency`          | ISO-4217, **uppercase** 3-letter                                                                | Ingress schema for both share surfaces                |
| Inter-country order | **S3** `s3_candidate_set.candidate_rank` (home=0; contiguous)                                   | Sole order authority; S5 must not encode/ imply order |

---

## B.3 Policy file keys (top-level & overrides)

**Artefact:** `configs/allocation/ccy_smoothing_params.yaml` (the **only** S5 file that contributes to `parameter_hash`). Keys/domains/precedence are **closed** as below.

| Key                                    | Type / Domain                                                     | Scope    | Precedence              |
|----------------------------------------|-------------------------------------------------------------------|----------|-------------------------|
| `semver`                               | string `MAJOR.MINOR.PATCH`                                        | file     | â€”                       |
| `version`                              | date `YYYY-MM-DD`                                                 | file     | â€”                       |
| `dp`                                   | int **[0,18]**                                                    | global   | â€”                       |
| `defaults.blend_weight`                | number **[0,1]**                                                  | currency | global â†’ currency       |
| `defaults.alpha`                       | number **â‰¥ 0**                                                    | ISO      | global â†’ currency â†’ ISO |
| `defaults.obs_floor`                   | int **â‰¥ 0**                                                       | currency | global â†’ currency       |
| `defaults.min_share`                   | number **[0,1]**                                                  | ISO      | global â†’ currency â†’ ISO |
| `defaults.shrink_exponent`             | number **â‰¥ 0** *(values < 1 are treated as 1 at evaluation time)* | currency | global â†’ currency       |
| `per_currency.<CCY>.{â€¦}`               | subset of `defaults` keys                                         | currency | overrides `defaults`    |
| `overrides.alpha_iso.<CCY>.<ISO2>`     | number **â‰¥ 0**                                                    | ISO      | **top priority**        |
| `overrides.min_share_iso.<CCY>.<ISO2>` | number **[0,1]** (with Î£ floors â‰¤ 1)                              | ISO      | **top priority**        |

**Strictness:** unknown keys â†’ **error**; codes must be uppercase and exist in the ISO domains.

---

## B.4 Degrade & reason vocabularies (per-currency)

| Field                 | Allowed values (closed)                                              | Semantics                                                        |
|-----------------------|----------------------------------------------------------------------|------------------------------------------------------------------|
| `degrade_mode`        | `{none, settlement_only, ccy_only}`                                  | Used when only one ingress surface exists for a currency (Â§8.4). |
| `degrade_reason_code` | `{SRC_MISSING_SETTLEMENT, SRC_MISSING_CCY, POLICY_NARROWING, OTHER}` | Machine-readable reason recorded in S5 metrics.                  |

---

## B.5 Error code taxonomy (producer & validator)

| Code                                      | Raised when                                                                             |
|-------------------------------------------|-----------------------------------------------------------------------------------------|
| `USAGE`                                   | CLI contract violation (missing/unknown flags, missing paths).                          |
| `E_INPUT_SCHEMA` / `E_INPUT_SUM`          | Ingress schema/PK/FK breach or **Î£ share** constraint violated on an input surface.     |
| `E_POLICY_DOMAIN`                         | Policy key/domain invalid (incl. unknown currency/ISO in overrides).                    |
| `E_POLICY_UNKNOWN_CODE`                   | Policy references an unknown currency or ISO code not present in the canonical domains. |
| `E_POLICY_MINSHARE_FEASIBILITY`           | For a currency, **Î£ min_share_iso > 1.0**.                                              |
| `E_POLICY_MISSING_Q`                      | Required policy quantity `Q` not found after precedence resolution (Â§4.3).              |
| `E_ZERO_MASS`                             | Post-floor mass sums to 0 before renormalisation.                                       |
| `E_QUANT_SUM_MISMATCH`                    | After quantisation + tie-break, decimal Î£ at `dp` â‰  `1`.                                |
| `E_OUTPUT_SCHEMA`                         | Any S5 output breaches its schema/PK/FK.                                                |
| `E_RNG_INTERACTION`                       | RNG logs changed or new RNG streams appeared during S5.                                 |
| `E_LINEAGE_PATH_MISMATCH` / `E_ATOMICITY` | Pathâ†”embed inequality or non-atomic publish.                                            |
| `E_PARTITION_EXISTS`                      | Target partition exists with non-identical content (write-once rule).                   |
| `E_MCURR_CARDINALITY`                     | `merchant_currency` missing/duplicate row(s) for a merchant.                            |
| `E_MCURR_RESOLUTION`                      | Îºâ‚˜ missing/invalid after deterministic resolution.                                      |

---

## B.6 Structured-log fields & levels

Each log record is a single JSON object with at least:

| Field            | Values / Type                                                                      |
|------------------|------------------------------------------------------------------------------------|
| `level`          | `{INFO, WARN, ERROR}`                                                              |
| `component`      | `"1A.expand_currency_to_country"`                                                  |
| `stage`          | `{N0, N1, N2, N2b, N3, N4}` (see Â§13.4)                                            |
| `event`          | Stable names (e.g., `POLICY_OVERRIDES_APPLIED`, `DEGRADE_USED`, `QUANT_TIE_BREAK`) |
| `parameter_hash` | hex64                                                                              |
| `currency?`      | ISO-4217 (optional, when applicable)                                               |
| `reason_code?`   | one of B.4, or `SPARSITY_LOW_MASS` (optional, when applicable)                     |

---

## B.7 Metric names (S5 receipt keys)

**Run-level (top object in `S5_VALIDATION.json`):**
`parameter_hash`, `policy_digest`, `producer`, `schema_refs` (object);
`currencies_total`, `currencies_processed`, `rows_written`;
`sum_numeric_pass`, `sum_decimal_dp_pass`;
`largest_remainder_total_ulps`, `largest_remainder_ulps_quantiles.{p50,p95,p99}`;
`overrides_applied_count`, `floors_triggered_count`;
`degrade_mode_counts.{none,settlement_only,ccy_only}`;
`coverage_union_pass`, `coverage_policy_narrowed`;
`rng_trace_delta_events`, `rng_trace_delta_draws`;
`policy_narrowed_currencies[]`, `degraded_currencies[]`.

**Per-currency (`by_currency[]`):**
`currency`, `parameter_hash`, `policy_digest`;
`countries_union_count`, `countries_output_count`, `policy_narrowed` (`bool`), `narrowed_isos?`;
`sum_numeric_ok`, `sum_decimal_dp_ok`;
`largest_remainder_ulps`;
`overrides_applied.{alpha_iso, min_share_iso, per_currency}`, `floors_triggered`;
`degrade_mode`, `degrade_reason_code`;
`N0`, `N_eff`, `dp`.

---

## B.8 Rounding & tie-break settings (closed)

| Setting           | Allowed value                                                                                                  |
|-------------------|----------------------------------------------------------------------------------------------------------------|
| Rounding mode     | **Round-half-even** (bankerâ€™s rounding)                                                                        |
| Tie-break order   | **Shortfall (add)**: descending `r[c]`, ties **Aâ†’Z**; **Overshoot (subtract)**: ascending `r[c]`, ties **Zâ†’A** |
| Decimal exact-sum | **Required:** sum of fixed-dp decimals equals `1` exactly at `dp`                                              |

---

## B.9 Receipt artefacts (parameter-scoped gate)

| File                 | Placement                          | Content                                                                                       |
|----------------------|------------------------------------|-----------------------------------------------------------------------------------------------|
| `S5_VALIDATION.json` | In the weights partition directory | Run-level + per-currency metrics; schema/Î£/coverage attestations; RNG non-interaction deltas. |
| `_passed.flag`       | Same directory                     | Single line: `sha256_hex = <hex64>` over the receipt files (excluding the flag itself).       |

---

## B.10 Cross-state authority references

| Surface             | Authority                         | Notes                                                                            |
|---------------------|-----------------------------------|----------------------------------------------------------------------------------|
| Inter-country order | `s3_candidate_set.candidate_rank` | Sole order source (home=0, contiguous; stable). S5 must not encode/ imply order. |
| Egress outlet stubs | `outlet_catalogue`                | No cross-country order; readers must join S3 order; fingerprint-scoped gate.     |

---

# Appendix C. Worked example (tiny, numeric) *(Non-normative)*

> Purpose: illustrate Â§6 behaviour with small numbers. This appendix does **not** add requirements; if any discrepancy appears, Â§Â§6-11 control.

## C.1 No tie-break needed (USD; dp=3)

**Inputs (per currency USD):**

| ISO2 | `s_settle` | `s_ccy` |
|------|-----------:|--------:|
| US   |       0.50 |    0.48 |
| DE   |       0.30 |    0.32 |
| JP   |       0.20 |    0.20 |

**Policy:** `w=0.6`, `alpha=0`, `obs_floor=0`, `shrink_exponent=1`, `min_share=0`, `dp=3`.

1. **Blend** `q = wÂ·s_ccy + (1âˆ’w)Â·s_settle`
   US: `0.6Â·0.48 + 0.4Â·0.50 = 0.288 + 0.200 = 0.488`
   DE: `0.6Â·0.32 + 0.4Â·0.30 = 0.192 + 0.120 = 0.312`
   JP: `0.6Â·0.20 + 0.4Â·0.20 = 0.120 + 0.080 = 0.200`
   (Î£q = 1.000)

2. **Smoothing / floors:** `alpha=0`, no floors â‡’ posterior = q; `pâ€² = posterior`.

3. **Renormalise:** `p = pâ€² / Î£pâ€² = pâ€²` (already 1.0).

4. **Quantise to dp=3 (half-even):**
   US 0.488 â†’ **0.488**, DE 0.312 â†’ **0.312**, JP 0.200 â†’ **0.200**.
   **Decimal Î£@dp = 1.000**, **largest_remainder_ulps = 0**.

**Final row group (USD):** (US,0.488), (DE,0.312), (JP,0.200).

---

## C.2 Tie-break in action (EUR; dp=3)

Assume after Â§6.6 renormalisation we have:

| ISO2 | pre-quant `p[c]` |
|------|-----------------:|
| US   |           0.3334 |
| DE   |           0.3333 |
| JP   |           0.3333 |

**Half-even to dp=3:** all three round to **0.333** â‡’ decimal sum **0.999** (short by 1 ULP at dp=3).
**Largest-remainder placement (Â§6.7):** fractional remainders are 0.0004 (US), 0.0003 (DE), 0.0003 (JP). Add **+1 ULP (0.001)** to the max remainder (US):

* US â†’ **0.334**, DE â†’ **0.333**, JP â†’ **0.333** â‡’ **Î£@dp = 1.000**.
* **largest_remainder_ulps = 1** for this currency; tie order would fall back to ISO Aâ†’Z only if remainders tie.

**Final row group (EUR):** (US,0.334), (DE,0.333), (JP,0.333).

---

## C.3 Infeasible floors (policy guard â†’ FAIL)

**Policy snippet (GBP):** `min_share_iso.GBP.GB = 0.70`, `min_share_iso.GBP.US = 0.35`.
**Check:** Î£ floors = **1.05 > 1.0** â‡’ **`E_POLICY_MINSHARE_FEASIBILITY`** (see Â§6.5/Â§8.2). Run must fail before producing outputs.

---

# Appendix D. Degrade decision table *(Non-normative)*

| Scenario                               | Degrade           | Reason                   | Notes                                   |
|----------------------------------------|-------------------|--------------------------|-----------------------------------------|
| Only `ccy_country_shares` has currency | `ccy_only`        | `SRC_MISSING_SETTLEMENT` | Must still meet Â§6.6/Â§6.7               |
| Only `settlement_shares` has currency  | `settlement_only` | `SRC_MISSING_CCY`        | Must still meet Â§6.6/Â§6.7               |
| Neither has currency                   | â€”                 | â€”                        | Currency out of scope (no rows)         |
| Policy narrowed set                    | `none`            | `POLICY_NARROWING`       | Record via metrics; S6 ephemeral renorm |

# Appendix E. Policy audit fields *(Non-normative)*

The S5 receipt MAY include the following fields under `by_currency[]` to aid audits (names are informativeâ€”Â§14 lists the binding metrics):

- `effective.blend_weight`
- `effective.alpha_total`
- `floors.count`, `floors.sum`
- `overrides.alpha_iso : [ISO2]`
- `overrides.min_share_iso : [ISO2]`
[[[MASTER-SEP-1A]]]

<a id="state-1a-s6-expanded"></a>
# state.1A.s6.expanded.txt

<!-- Source file: state.1A.s6.expanded.v3.7.txt | BYTE-EXACT EMBED -->

# S6 SPEC â€” Foreign Set Selection (Layer 1 Â· Segment 1A)

# 0. Document metadata & status **(Binding)**

**0.1 State ID, version, semver policy, effective date**

* **State ID:** `layer1.1A.S6` (â€œForeign Set Selectionâ€).
* **Versioning:** semantic versioning **MAJOR.MINOR.PATCH**.

  * **MAJOR** bump required for: any change to read/write dataset IDs or schemas, tie-break rules, RNG event family shapes, partition law, or PASS-gate semantics.
  * **MINOR**: additive fields/metrics, optional convenience dataset enablement.
  * **PATCH**: clarifications with zero behaviour/schema impact.
* **Effective date:** set by release tag on approval.

**0.2 Normative marks & RFC 2119/8174 usage**

* **MUST/SHALL/SHOULD/MAY** are per RFC 2119/8174 and are **binding** in this spec.
* This document is **binding** unless a clause is explicitly labelled *Informative*.

**0.3 Sources of authority (precedence)**

1. **JSON-Schema** (`schemas.1A.yaml`, `schemas.layer1.yaml`, `schemas.ingress.layer1.yaml`) is the **sole** schema authority for all S6 inputs/outputs/logs. 2) **Dataset Dictionary** (`dataset_dictionary.layer1.1A.yaml`) governs dataset IDs, paths, partitions, PK/FK, retention, and ownership. 3) This S6 spec (behavioural rules) sits beneath those authorities. 

**0.4 Compatibility window (bound S0â€“S5; numeric environment)**

* **Numeric policy:** S6 **inherits S0.8** verbatim â€” IEEE-754 **binary64**, **round-to-nearest ties-to-even**, **FMA off**, **no FTZ/DAZ**, deterministic libm profile; any decision-critical math follows S0â€™s fixed-order and attestation rules.
* **Assumed baselines (v1.* line unless re-ratified):**

  * **Dictionary:** `dataset_dictionary.layer1.1A.yaml` v1.0.
  * **Schemas:** `schemas.ingress.layer1.yaml` v1.0; `schemas.1A.yaml` v1.0; `schemas.layer1.yaml` v1.0.
  * **Order authority:** **S3** `s3_candidate_set.candidate_rank` is **sole** inter-country order; `outlet_catalogue` carries **no** cross-country order. If any baseline bumps **MAJOR**, S6 must be re-ratified. 

**0.5 Schema anchors & dataset IDs in scope (explicit read/write set)**

* **Inputs (read):**

  * `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` (partition `[parameter_hash]`). **Authority for order & admissible set A.** 
  * `rng_event_ztp_final` â†’ `schemas.layer1.yaml#/rng/events/ztp_final` (partitions `{seed, parameter_hash, run_id}`); carries `K_target`. 
  * `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache` (partition `[parameter_hash]`); authority for currencyâ†’country weights. 
  * *(Optional)* `merchant_currency` â†’ `schemas.1A.yaml#/prep/merchant_currency` (partition `[parameter_hash]`). 
  * Canonical ISO FK table per dictionary (e.g., `iso3166_canonical_2024`). 
* **Outputs (write):**

  * **RNG events:** `rng_event.gumbel_key` â†’ `schemas.layer1.yaml#/rng/events/gumbel_key` (partitions `{seed, parameter_hash, run_id}`); **logging mode:** if `log_all_candidates=true`, one per **considered** candidate; if `false`, keys only for **selected** candidates. Envelope fields (`before/after/blocks/draws`) per layer law; **trace row appended after each event**.
  * **Core RNG logs updated:** `rng_audit_log`, `rng_trace_log` per layer schemas; cumulative **trace** by `(module, substream_label)`. 
  * *(Optional)* **`s6_membership`** â†’ `schemas.1A.yaml#/s6/membership` (PK `(merchant_id, country_iso)`, partitions `{seed, parameter_hash}`); **authority note:** must be re-derivable from RNG events; **no** inter-country order (*order remains in S3 `candidate_rank`*).

**0.6 Hashing & manifests (lineage identifiers & participation)**

* **`parameter_hash` (S0.2.2):** a hash over the governed set **ð“Ÿ**; partitions parameter-scoped datasets. S6 **adds its policy file(s)** to ð“Ÿ; changing their bytes **MUST** flip `parameter_hash`. *(Cross-note: S0.2.2 must enumerate the S6 policy basename(s) to keep ð“Ÿ canonical.)* 

* **`manifest_fingerprint` (S0.2.3):** flips if **any opened artefact** (by bytes), the **code commit**, or the **parameter bundle** changes; all artefacts S6 actually opens (inputs, schemas, dictionary, numeric policy, S6 policy) **contribute** to the manifest. 

* **`run_id`:** partitions **logs** only; never affects modelling state or RNG decisions. 

* **Partition/embedding equality (layer law):** where present, embedded lineage fields `{seed, parameter_hash, run_id}` in events/logs **MUST equal** the path tokens byte-for-byte; `rng_trace_log` lineage is enforced via partition keys. 

* **Numeric environment attestation:** successful S0.8 self-tests are a **precondition**; S6 assumes the environment and math profile in effect. 

---

# 1. Intent, scope, and non-goals **(Binding)**

**1.1 Goal (what S6 does).**
For each **eligible multi-site** merchant, S6 selects a **subset of foreign ISO2 countries** of size
$$
K_{\text{realized}}=\min\big(K_{\text{target}},\,|\text{Eligible}|\big)
$$
where **$K_{\text{target}}$** comes from **S4â€™s `rng_event.ztp_final`** and **Eligible** is the set of S3 **foreign** candidates (home excluded) with **strictly positive** S5 weight **after** applying policy filters/caps (Â§4.2; Appendix A). The **selection domain** is the **intersection** of S3â€™s candidate set and **S5â€™s `ccy_country_weights_cache`** for the merchantâ€™s settlement currency; weights are taken from S5. **S5 must have PASSed** for the same `parameter_hash` before S6 reads.

**1.2 Out of scope (what S6 will not do).**

* **No inter-country order creation or implication.** **S3 `candidate_rank`** is the **sole** authority for cross-country order; S6 produces **membership only**. Egress datasets (e.g., `outlet_catalogue`) **do not** encode cross-country order and consumers must keep joining S3 for order.
* **No allocation of outlet counts across countries (S7 job).** S6 does **not** split N; the count allocation state uses its own RNG family (e.g., `rng_event.dirichlet_gamma_vector`) and contracts.
* **No site materialisation / IDs (S8 job).** S6 emits no site stubs and does not touch egress; `outlet_catalogue` remains ordered **within-country** only.
* **No re-derivation or persistence of weights.** Any subset **renormalisation is ephemeral** (for scoring/selection only) and **must not be persisted**; the persisted authority for currencyâ†’country weights remains **S5 `ccy_country_weights_cache`**.
* **No modification of S4â€™s `K_target`.** S6 reads `K_target` as fixed from S4â€™s non-consuming final event and does not overwrite it. 

**1.3 Success criteria (how we know S6 is correct).**

* **Deterministic-under-seed:** For a fixed `{seed, parameter_hash, run_id}`, the realized foreign set equals the **top-`K_target`** countries by the S6 scoring rule over the domain (ties broken per Â§6), or **all `|\text{Eligible}|`** when `|\text{Eligible}| < K_target`. Inputs (`s3_candidate_set`, `rng_event.ztp_final`, `ccy_country_weights_cache`) are consumed exactly as registered in the dictionary/schemas.
* **Membership-only output:** Any optional S6 â€œmembershipâ€ surface contains **no order** and is provably **re-derivable from S6 RNG events + S3/S5 inputs**. 
* **RNG logging completeness & isolation:** If `log_all_candidates=true`, write exactly one `rng_event.gumbel_key` **per considered candidate** (domain after policy). If `false`, write keys **only for selected candidates** and rely on Â§9.3 counter-replay. In both modes, only S6 families appear; envelopes/trace totals reconcile.
* **Upstream gate honored:** S6 reads S5 only after verifying the **S5 PASS** receipt for the same `parameter_hash` (**no PASS â†’ no read**).

---

# 2. Interfaces & â€œno re-deriveâ€ boundaries **(Binding)**

**2.1 Upstream (must exist to run S6).**

* **S3 candidate set (authority for domain & order).** `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` (partitioned by `parameter_hash`). **A** is the count of **foreign** rows per merchant (home has `candidate_rank=0`). `candidate_rank` is **total & contiguous** and is the **sole** authority for inter-country order.
* **S4 target K (logs-only):** `rng_event_ztp_final` â†’ `schemas.layer1.yaml#/rng/events/ztp_final` under `{seed,parameter_hash,run_id}`; exactly **one** per resolved merchant. S6 **MUST** read `K_target` here and **MUST NOT** infer it from any other rows.
* **S5 weights (parameter-scoped):** `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache` under `parameter_hash={â€¦}`. **Read gate:** S6 **MUST** verify S5 **PASS** (presence of `S5_VALIDATION.json` + valid `_passed.flag`) for the **same `parameter_hash`** before reading (**no PASS â†’ no read**).

**2.2 Downstream (what consumes S6 and how).**

* **S7 (allocation):** consumes **membership only** (domain = home + S6-selected foreigns). S7 **MAY** renormalise **ephemerally** within this domain to drive its own RNG (e.g., `rng_event.dirichlet_gamma_vector`) but **MUST NOT** persist new weights as S5. 
* **S8 (materialisation):** never encodes cross-country order; consumers derive order **only** from S3 `candidate_rank`. `outlet_catalogue` egress explicitly states â€œdoes NOT encode cross-country order.â€ 

**2.3 â€œNo re-deriveâ€ guarantees (promises S6 makes).**

* **No order creation or implication.** S6 **MUST NOT** create, persist, or imply inter-country order; downstream must continue to use **S3 `candidate_rank`** as the only order authority. 
* **No weight replacement.** S6 **MUST NOT** alter or persist weights; any subset renormalisation used for scoring/selection is **ephemeral** and **not written**. Persisted currencyâ†’country weights remain **S5**. 
* **No reinterpretation of S4 context.** `lambda_extra`, `regime`, `attempts`, `exhausted?` in `ztp_final` are **audit** fields only; S6 **MUST NOT** use them as selection weights or gates beyond reading `K_target`. 
* **RNG isolation.** S6 **reads/writes only** its own RNG families (e.g., `rng_event.gumbel_key`) and **MUST NOT** write to any S1â€“S5 streams; envelopes and trace obey the layer budgeting law. 

**2.4 Forward contracts to S7 (what S6 guarantees to its consumer).**

* **Selection size:** S6 **MUST** realise
  $$
  K_{\text{realized}}=\min\!\big(K_{\text{target}},\,|\text{Eligible}|\big)
  $$
  using the S3 foreign domain and S5 weights; if `|\text{Eligible}| < K_target`, S6 selects **all `|\text{Eligible}|`** (shortfall).

* **Provenance & replay:** If `log_all_candidates=true`, write exactly **one** `rng_event.gumbel_key` per **considered** candidate; if `false`, write keys **only for selected** candidates and rely on Â§9.3 counter-replay. Selection is re-derivable from events + S3/S5 in both modes. (Membership, if emitted, is convenience-only and exactly re-derivable.)

---

# 3. Inputs â€” datasets, schemas, partitions **(Binding)**

**3.1 Required datasets (IDs, `$ref`, PK/FK; partitions).**

* **`s3_candidate_set`** â†’ `schemas.1A.yaml#/s3/candidate_set`; **partition:** `parameter_hash={â€¦}`; **row order (logical):** `(merchant_id, candidate_rank, country_iso)`; **authority:** `candidate_rank` is **total & contiguous** per merchant with **home=0**.
* **`rng_event_ztp_final`** (S4) â†’ `schemas.layer1.yaml#/rng/events/ztp_final`; **partition:** `{seed, parameter_hash, run_id}`; **one** acceptance record per resolved merchant; consumed by **S6**. 
* **`ccy_country_weights_cache`** (S5) â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache`; **partition:** `parameter_hash={â€¦}`; **PK:** `(currency, country_iso)`; downstream **must** verify **S5 PASS** for same `parameter_hash` (**no PASS â†’ no read**).
* *(Optional)* **`merchant_currency`** â†’ `schemas.1A.yaml#/prep/merchant_currency`; **partition:** `parameter_hash={â€¦}`; **PK:** `(merchant_id)`; precedence & domains pinned in S5.
* **Canonical ISO registry** (FK target), e.g. **`iso3166_canonical_2024`** â†’ `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`. 
* **RNG core logs** (read-only by validator): `rng_audit_log`, `rng_trace_log` â†’ `schemas.layer1.yaml#/rng/core/*`; **partition:** `{seed, parameter_hash, run_id}`. 

**3.2 Domains, types, nullability (per schema anchors).**

* **S3 candidate set:** `merchant_id:u64`, `country_iso: ISO-3166-1 (Aâ€“Z)`, `candidate_rank:u32 (total, contiguous)`, `is_home:bool`; embedded `parameter_hash` **must equal** path key. 
* **S4 ztp_final:** event schema under layer catalog; partitions `{seed, parameter_hash, run_id}`; **exactly one** final per resolved merchant.
* **S5 weights cache:** `currency: ISO-4217 (Aâ€“Z)`, `country_iso: ISO2 (Aâ€“Z, FKâ†’ISO)`, `weightâˆˆ[0,1]`, optional `obs_countâ‰¥0`; **Î£ weight = 1 Â± 1e-6** per currency; embedded `parameter_hash` equals path key. 
* **merchant_currency (if produced):** `merchant_id:id64`, `kappa: ISO-4217`, `source enum`, `tie_break_used:bool`; **1 row per merchant** in S0 universe. 

**3.3 Pre-flight checks (run MUST abort on failure).**
Per `{seed, parameter_hash[, run_id]}`:
a) **Presence & schema pass** for **all** inputs above; **pathâ†”embed equality** holds (where embedded).
b) **S3**: for each merchant, `candidate_rank` is present, **home=0**, contiguous, no dups; compute **A = #foreign candidates**. 
c) **S0 eligibility (explicit)**: `crossborder_eligibility_flags.is_eligible == true` for the merchant under the same `parameter_hash`; otherwise **do not run S6** (`E_UPSTREAM_GATE`). 
d) **S4**: exactly **one** `ztp_final` for each merchant that is multi+eligible (per S1/S0 gating upstream). 
e) **S5**: weights cache exists for the **same `parameter_hash`** and **S5 PASS receipt** is present and valid under that partition (`S5_VALIDATION.json` + `_passed.flag`); otherwise **no read**. 
f) **Domains/FK**: ISO codes uppercase and FK-valid to `iso3166_canonical_2024`; currencies uppercase ISO-4217.

**3.4 Hard rejections (fail-closed).**

* **`E_UPSTREAM_GATE`** â€” missing required dataset/partition; S5 PASS receipt absent/invalid; S3 candidate set missing or malformed (non-contiguous ranks, no home).
* **`E_LINEAGE_PATH_MISMATCH`** â€” any embedded lineage field not byte-equal to its partition token. 
* **`E_DOMAIN_FK`** â€” unknown or non-uppercase ISO/ISO-4217 codes; FK violation to canonical ISO. 
* **`E_S5_CONTENT`** â€” `ccy_country_weights_cache` group-sum/ bounds/coverage breach (Î£â‰ 1Â±1e-6, weight out of [0,1], or union-coverage violated). 

**Partition law (summary, binding).**

* **Parameter-scoped tables** (S3, S5, optional membership): `â€¦/parameter_hash={parameter_hash}/` and embed the **same** `parameter_hash`.
* **RNG logs/events** (S4/S6 and core logs): `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`.

---

# 4. Configuration & policy **(Binding)**

**4.1 Policy file(s), `$ref`, version pinning**

* **Basenames & location.** One or more S6 policy files (the â€œS6 policy setâ€) **MUST** exist under the governed parameters directory and be **registered** in the schema catalog with a stable `$ref` (e.g., `schemas.layer1.yaml#/policy/s6_selection`). The exact basenames **MUST** be enumerated in **S0.2.2â€™s governed set ð“Ÿ** so that changing any of their bytes flips `parameter_hash`. 
* **Schema requirement.** Each policy file **MUST** validate against its JSON-Schema with **`additionalProperties: false`** (unknown keys are a **hard FAIL**).
* **Version pinning.** The policy file(s) **MUST** declare `policy_semver` and **MUST** be pinned by `$ref` version; bump rules follow Â§16 (MAJOR when keys or semantics change in a breaking way).

**4.2 Keys & domains (values, defaults, and semantics)**
The policy **MUST** define the following keys in the **`defaults`** block, with optional currency-specific overrides in **`per_currency`** (keys = **uppercase ISO-4217**):

* `emit_membership_dataset : bool` â€” default **false**. If true, S6 **produces** the convenience **membership** dataset (authority note still applies in Â§5.2).
* `log_all_candidates : bool` â€” default **true**.

  * **true:** write one `rng_event.gumbel_key` **for every considered candidate** (recommended).
  * **false:** write keys **only for selected candidates**; the validator **MUST** use **counter-replay** in stable iteration order to regenerate the missing keys (Â§9.3).
* `max_candidates_cap : int â‰¥ 0` â€” default **0** (no cap). If >0, S6 **MUST** truncate the S3 domain to the first **`max_candidates_cap`** countries by **S3 `candidate_rank`** (no re-order).
* `zero_weight_rule : enum{"exclude","include"}` â€” default **"exclude"**.
* `dp_score_print : int â‰¥ 0` â€” **optional, diagnostic-only** (formatting for logs/UI). It MUST NOT affect scoring, selection, RNG budgets, or any validator checks.

  * **"exclude":** candidates with **S5 weight == 0** are **dropped** from the domain (no key written; they do not contribute to selection or event counts).
  * **"include":** zero-weight candidates are **considered for logging** (keys may be written per `log_all_candidates`) but are **not eligible for selection** (`ln(0) = âˆ’âˆž`).
  * **Definitions (binding):**

    * **Considered set** = S3 candidates after cap and policy filters (**may** include zero-weights if `"include"`).
    * **Eligible set** = considered set **with weight > 0**. Selection **MUST** draw from the **eligible set** only; the validator **MUST** treat expected event counts using the **considered** set, and cardinality using the **eligible** set.

* **Domain rules (binding).**

  * Currency overrides: `per_currency["[Aâ€“Z]{3}"]` **MAY** override any key above except `log_all_candidates` and `dp_score_print` (both global-only, to keep validator mode uniform).
  * ISO-level overrides (per country) are **not allowed** unless a future schema explicitly adds them (presently prohibited).
  * Unknown currency codes, non-uppercase keys, or out-of-range values are **policy validation failures** (see 4.4).

**4.3 Override precedence (deterministic resolution)**

* Resolution order per merchant **MUST** be: **per-currency override â†’ defaults**.
* If a key is **absent** in a per-currency block, the **defaults** value **MUST** be used.
* If both blocks omit a **required** key, this is a **schema error** (hard FAIL).
* Overrides **MUST NOT** change semantics outside Â§6 (e.g., cannot redefine tie-breaks, RNG families, or numeric environment bound in S0.8). 

**4.4 Parameter hashing & manifests (lineage participation)**

* **Governed set ð“Ÿ.** All S6 policy basenames are **required members of ð“Ÿ**; changing any of their **bytes** **MUST** flip `parameter_hash` and therefore re-partition all **parameter-scoped** reads/writes that carry it. 
* **Manifest participation.** All artefacts S6 **opens** (S3/S4/S5 datasets, ISO registry, schemas, dictionary, S0.8 numeric policy files, S6 policy files) **MUST** be included in the **`manifest_fingerprint`** calculation as per S0.2.3 (flip on any byte change). 
* **Path â†” embed equality.** Where lineage fields are embedded, their values **MUST** equal the partition tokens byte-for-byte; violations are **hard FAIL** during pre-flight (Â§3.3/Â§3.4). 
* **Policy validation (binding).** Prior to any selection work, the S6 runner **MUST**:

  1. Validate the policy file(s) against the registered `$ref`;
  2. Resolve overrides deterministically (Â§4.3);
  3. Record the **effective** policy (global + per-currency) in the S6 validation bundle for provenance;
  4. Abort with **`E_POLICY_SCHEMA`**/**`E_POLICY_DOMAIN`** on schema/domain violations (unknown keys, bad ranges, non-uppercase ISO-4217), or **`E_POLICY_CONFLICT`** when resolution yields an inconsistent state (e.g., `max_candidates_cap` < size of **eligible** positives for a normative test case).

**Notes on numeric & RNG environment.** S6 **inherits S0.8â€™s** numeric determinism (binary64, RNE, FMA-off, no FTZ/DAZ) and the RNG envelope law; policy **MUST NOT** attempt to change number modes or RNG familiesâ€”those are fixed by the layer and schema authorities.

---

# 5. Outputs â€” datasets & contracts **(Binding)**

**5.1 RNG event families (authoritative; partitions `{seed, parameter_hash, run_id}`)**
S6 **produces** the following RNG artefacts; these are the **sole authoritative evidence** of selection and are governed by the layer RNG envelope law (open-interval mapping; `before/after/blocks/draws`; one **trace** append per event).

* **`rng_event.gumbel_key`** â€” **logging mode:** if `log_all_candidates=true`, one event per **considered** candidate (post-cap, post-policy); if `false`, keys only for **selected** candidates (budgets unchanged; validator uses Â§9.3 counter-replay).

  * **Schema anchor:** `schemas.layer1.yaml#/rng/events/gumbel_key`.
  * **Dictionary entry & path pattern:** `logs/rng/events/gumbel_key/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`.
  * **Payload (binding semantics):** `merchant_id`, `country_iso`, **`weight` (S5 subset-renormalised)**, the **uniform `u`**, the **Gumbel `key`**, a **`selected`** flag, and optional `selection_order` (**1..K when `selected=true`; omitted otherwise**); plus the standard envelope fields.
    **Budgets:** `draws="1"`, `blocks=1` for each event.
    **Zero-weight rows:** if `weight==0` (allowed only when `zero_weight_rule="include"`), S6 **MUST NOT** emit a numeric key â€” set `key: null`. Such rows are **diagnostic only** and **never eligible**; `selection_order` MUST be absent.
* **Core RNG logs (updated by S6):**

  * **`rng_audit_log`** â€” run-scoped audit entries; one per run context per policy.
  * **`rng_trace_log`** â€” **exactly one cumulative row appended after each event**; saturating totals per `(module, substream_label)`. (Both are already registered with partitions `{seed, parameter_hash, run_id}`.) 

**5.2 Selection membership surface (optional convenience)**
When enabled by policy (`emit_membership_dataset=true`), S6 **MAY** write a **membership** dataset to simplify S7 joins.

* **Authority note (binding):** this surface is **entirely re-derivable** from `rng_event.gumbel_key` + S3/S5 inputs and **MUST NOT** encode or imply inter-country order; consumers **MUST** continue to obtain order exclusively from **S3 `candidate_rank`**. 
* **Schema & dictionary:** **MUST** have an approved dataset ID and JSON-Schema `$ref` registered **before** any consumer reads.
* **Primary key & partitions:** **PK** `(merchant_id, country_iso)` per `{seed, parameter_hash}`; **pathâ†”embed equality** is binding.
* **Writer sort (non-semantic to readers):** `(merchant_id ASC, country_iso ASC)`.

**5.3 Partition law & path discipline (binding)**

* **Events/logs:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦` for `rng_event.gumbel_key`, `rng_audit_log`, `rng_trace_log`; embedded lineage fields **MUST** equal the path tokens byte-for-byte. 
* **Membership (if produced):** `â€¦/seed={seed}/parameter_hash={parameter_hash}/â€¦` and embeds the **same** `parameter_hash`.

**5.4 Sort, stability & byte policy**

* **Event files:** reader semantics are **set-based**; **row order is non-semantic**.
* **Byte identity:** if the Registry pins a writer policy (codec/level/row-group), producers **MUST** adhere to it; otherwise only **value identity** is required across re-runs. (See registry notes for event/log families.) 

**5.5 Retention, ownership & gating**

* **Ownership:** S6 is the **producer** for `rng_event.gumbel_key`; core RNG logs are owned by the layer RNG emitters; consumer is **validation** (and downstream audit). 
* **Retention:** as per Dataset Dictionary (e.g., events typically **180 days**, core logs **365 days**). 
* **Read gate:** Downstream states (S7/S8) **MUST NOT** read any S6-scoped convenience surface unless the **S6 PASS** receipt (see Â§9) exists for the same `{seed, parameter_hash}`; for inputs derived from S5, readers **MUST** also observe the **S5 PASS** gate. 

**5.6 Cross-references (normative anchors)**

* **Event schema & dictionary entries** for `gumbel_key`, `ztp_final`, `dirichlet_gamma_vector`, and core logs are registered and versioned with partitions exactly as shown in the Dataset Dictionary and Artefact Registry.

---

# 6. Deterministic processing specification â€” no pseudocode **(Binding)**

**6.1 Gating (must be true to run S6).**
S6 **MUST** proceed for a merchant only if all are true:

* **S1** decided `is_multi == true` (gate carried by dictionary on upstream RNG families). 
* **S3 eligibility present** and an ordered candidate set exists (`s3_candidate_set`, home has `candidate_rank=0`, ranks total & contiguous).
* **S4** wrote exactly one `rng_event_ztp_final` fixing `K_target` for the merchant (logs under `{seed, parameter_hash, run_id}`).
* **S5** weights cache exists **and has PASS** for the same `parameter_hash` (S5 receipt present); otherwise **no read**. 

---

**6.2 Selection domain & weights (read-only authorities).**

* **Domain:** foreign candidates = **S3 `candidate_set` minus home**; intersect with S5â€™s `ccy_country_weights_cache` for the merchantâ€™s settlement currency (from S5; `merchant_currency` optional). **S6 MUST NOT add countries not present in S3.**
* **Cap (optional):** if `max_candidates_cap>0`, **truncate by S3 `candidate_rank` prefix** to the first `A_cap` foreigns. **No re-order is permitted.** 
* **Zero-weight policy:**

  * `"exclude"` (default): drop candidates with S5 weight `== 0` from the **considered** set (hence also from the eligible set); **no key written**.
  * `"include"`: such countries may be **considered** (keys may be logged), but are **not eligible** for selection (see score rule below).
    *(Considered set is for logging expectations; eligible set is for selection.)*
* **Subset renormalisation:** within the **eligible** subset *(eligible âŠ‚ considered)*, **ephemerally renormalise** weights in **binary64** for scoring; **MUST NOT** persist any new weights (persisted weight authority remains S5).
  *Equivalence note:* renormalising on the **considered** subset yields identical numeric results because candidates with `w==0` contribute **0** to the normaliser; we write â€œeligibleâ€ to emphasise the selection domain.
---

**6.3 RNG substreams, numeric law, and scoring (authoritative).**

* **Uniforms:** S6 **MUST** use the S0 **open-interval** mapping $u\in(0,1)$ for all uniforms (never exact 0 or 1). 
* **Numeric environment:** **inherit S0.8** â€” IEEE-754 **binary64**, round-to-nearest-ties-even, **FMA off**, **no FTZ/DAZ**, deterministic libm; decision kernels run in fixed order. 
* **Iteration order:** when drawing, **iterate in S3 `candidate_rank` order** to keep substream counters reproducible. 
* **Event family (logging mode):** if `log_all_candidates=true`, write exactly **one** `rng_event.gumbel_key` for each **considered** candidate; if `false`, write keys **only for selected** candidates (validator counter-replays per Â§9.3). Append **exactly one** trace row after each event (per RNG trace law).
* **Score (`key`) definition:** For candidate $c$ with weight $w_c>0$, compute **binary64**
  $$
  \text{key}_c = \ln(w_c) - \ln\!\big(-\ln u_c\big),\quad u_c\in(0,1).
  $$
  **Zero-weight convention:** when `zero_weight_rule="include"` and `w_c==0`, producers set `key: null`. Validators **MUST** treat `key:null` as $-\infty$ for ordering.
---

**6.4 Selection rule (K-realisation).**

* Let $A_{\text{filtered}}$ be the **considered** foreign candidate count after policy filters/cap, and let $|\text{Eligible}|$ be the number of **eligible** candidates with $w>0$ in that domain; let $K_{\text{target}}$ come from S4.
* S6 **MUST** select the **top $K_{\text{target}}$** countries by **`key`** from the **eligible** subset; if $|\text{Eligible}| < K_{\text{target}}$, select **all $|\text{Eligible}|$** (shortfall).

---

**6.5 Tie-breaks (total order).**
When two candidates have equal **`key`** in binary64:

1. choose lower **S3 `candidate_rank`** (ascending);
2. then `country_iso` **Aâ†’Z**.
   Tie-breaks are **binding** to ensure a total order consistent with S3. 

---

**6.6 Order-authority separation (no new order).**
S6 **MUST NOT** persist or imply inter-country order. Any projected order for display **MUST** inherit **S3 `candidate_rank`** for selected members; egress order remains defined only within country (S8). 

---

**6.7 Logging discipline (budgeting & modes).**

* **Stable loop:** produce keys in **S3 `candidate_rank`** order; **logging mode** â†’ if `log_all_candidates=true`, **one** `gumbel_key` per **considered** candidate; if `false`, keys only for **selected** candidates. 
* **Expected event count per merchant:**  
  - if `log_all_candidates=true`: $\mathrm{events}(\texttt{gumbel\_key})=A_{\text{filtered}}$;  
  - if `false`: $\mathrm{events}(\texttt{gumbel\_key})=K_{\text{realized}}$.  
  (after zero-weight policy and cap). The validator **counter-replays** missing keys in reduced-logging mode (Â§9.3).
* **Trace rule:** emit **exactly one** `rng_trace_log` row **after each event**; cumulative totals reconcile to sum of event budgets for the `(module, substream_label)` key. 

---

**6.8 Determinism & idempotence.**
With identical `{seed, parameter_hash, run_id}`, the **considered** set, the sequence of uniforms, the **keys**, and the selected membership **MUST** be identical across re-runs; envelopes satisfy S0 budget/counter invariants; pathâ†”embed equality holds. 

---

**6.9 Write semantics (publish discipline).**

* **Write-once partitions.** On success, atomically publish event/log files under `{seed, parameter_hash, run_id}`; optional membership dataset under `{seed, parameter_hash}`.
* **Row/byte stability.** Reader semantics are set-based; if a registry writer policy is pinned (codec/level/row-group), producers **MUST** adhere to it; otherwise **value-identity** across re-runs is sufficient. 

---

# 7. Invariants & integrity constraints **(Binding)**

**7.1 Gating invariants (must hold per merchant before selection).**

* **S1 hurdle:** merchant is **multi** (`is_multi==true`) as carried via dictionary gating. 
* **S3 domain:** `s3_candidate_set` exists; **home has `candidate_rank=0`**, ranks are **total & contiguous** per merchant (no gaps/dups).
* **S4 target:** exactly **one** `rng_event_ztp_final` fixing `K_target` under `{seed, parameter_hash, run_id}`. 
* **S5 weights:** `ccy_country_weights_cache` exists **and S5 PASS is present** for the **same `parameter_hash`** (**no PASS â†’ no read**). 

**7.2 Domain & FK invariants.**

* **Subset law:** Selected foreigns âŠ† S3 **foreign** candidates (home excluded) **and** âŠ† S5 weight support for the merchantâ€™s currency.
* **ISO/ISO-4217 validity:** all `country_iso` and `currency` values are **uppercase** and **FK-valid** against the canonical registries. 

**7.3 Cardinality invariant.**
For each merchant, the realized set size is
$$
|\text{selected}| = K_{\text{realized}}=\min\!\big(K_{\text{target}},\,|\text{Eligible}|\big),
$$
where $|\text{Eligible}|$ is the eligible-count **after** applying `max_candidates_cap` and the `zero_weight_rule` (positives only). Shortfall $|\text{Eligible}| < K_{\text{target}}$ **MUST** result in selecting **all $|\text{Eligible}|$**. 

**7.4 Tie-break determinism.**
When `key` values are exactly equal in **binary64**, order **MUST** resolve by **S3 `candidate_rank`** (ascending), then `country_iso` Aâ†’Z, ensuring a **total order consistent with S3**. 

**7.5 RNG event/logging invariants (authoritative evidence).**

* **Per-merchant event count:**  
  - if `log_all_candidates=true`, equals the **considered** domain size after policy/cap (`A_filtered`).  
  - if `false`, equals **`K_realized`** (validator **counter-replays** the missing keys).
* **Isolation:** S6 **MUST NOT** write to any RNG families other than those declared for S6; validator finds **only** S6 families and matching trace deltas. 
* **Trace duty:** **exactly one** cumulative `rng_trace_log` row is appended **after each event**; pairing/replay relies on **envelope counters**, not file order. 

**7.6 Partitioning & lineage equality.**

* **Events/logs:** paths are `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`; embedded lineage fields (where present) **MUST** equal the path tokens **byte-for-byte**; for `rng_trace_log`, lineage is enforced via partition keys. 
* **Tables (parameter-scoped):** any convenience **membership** dataset is partitioned by `{seed, parameter_hash}` and **MUST** embed the **same** `parameter_hash`. 

**7.7 Primary key & uniqueness.**

* If the **membership** surface is produced: **PK** `(merchant_id, country_iso)` is **unique** per `{seed, parameter_hash}`; **no duplicates** per merchant. (Authority remains the RNG events; membership is re-derivable.) 

**7.8 Order-authority separation.**
No S6 output **may encode or imply** inter-country order; consumers **MUST** continue to obtain order exclusively from **S3 `candidate_rank`**. `outlet_catalogue` carries **no** cross-country order.

**7.9 Idempotence & stability.**
With identical `{seed, parameter_hash, run_id}` and identical inputs, the **considered** set, uniform sequence, **keys**, and selected membership are **identical** across re-runs. If a writer policy is pinned in the registry, producers **MUST** adhere to it; otherwise **value-identity** suffices.

**7.10 S5 weight authority preserved.**
Any subset renormalisation used during selection is **ephemeral** and **MUST NOT** be persisted; persisted currencyâ†’country weights remain **S5** (`Î£=1Â±1e-6`, bounds). 

**7.11 PASS-gate coupling.**

* **S6 PASS**: S7/S8 **MUST NOT** read S6 convenience surfaces without `S6_VALIDATION.json` + `_passed.flag` for the same `{seed, parameter_hash}`.
* **S5 PASS**: S6 **MUST** have verified S5 PASS before reading weights (parameter-scoped receipt). 

**7.12 Numeric & RNG law inheritance.**
All decision-critical math executes under **S0.8** (IEEE-754 binary64; RNE; FMA-off; no FTZ/DAZ); uniforms use the **open-interval** mapping; counters/budgets obey the layer envelope rules. 

---

# 8. Error handling, edge cases & degrade ladder **(Binding)**

**Overview.** S6 is **fail-closed** for structural/lineage/RNG breaches; otherwise it returns **deterministic empties** for well-defined edge cases. State-level `E_*` errors MUST also map to S0â€™s failure classes (F2â€“F10) for fleet observability.

---

## 8.1 Deterministic empty selections (non-error outcomes)

When these conditions hold, S6 **MUST** emit a **valid, empty selection** for the merchant (no rows in the optional membership surface) and record a **reason_code** (diagnostic). RNG events are **not** written for un-considered candidates.

* **`NO_CANDIDATES`** â€” $A=0$: S3 exposes only `home` (no foreigns). 
* **`K_ZERO`** â€” S4 fixed `K_target=0` (short-circuit/downgrade path). 
* **`ZERO_WEIGHT_DOMAIN`** â€” After applying S6 policy filters (cap + `zero_weight_rule`), **no candidate with weight>0** remains in the eligible set (S5 is still PASS). 
* **`CAPPED_BY_MAX_CANDIDATES`** *(diagnostic only)* â€” Domain truncated by `max_candidates_cap` (selection still proceeds if any eligible >0 remain).

Shortfall **is not an error**: if $|\text{Eligible}| < K_{\text{target}}$, S6 MUST select **all $|\text{Eligible}|$** (validator may log `SHORTFALL_ELIG_LT_K`). 

---

## 8.2 Hard FAIL conditions (run-abort for the affected merchant)

On any of the following, S6 **MUST** NOT publish outputs for the merchant; it **MUST** emit an `E_*` with a canonical S0 failure class.

* **`E_UPSTREAM_GATE`** â€” Missing required inputs or gates:

  * S5 PASS receipt absent/invalid for the same `parameter_hash` (**no PASS â†’ no read**);
  * `s3_candidate_set` missing/malformed (no home, non-contiguous ranks);
  * S4 `ztp_final` missing/duplicated.
    â†’ Map to **F1/F2/F9** as appropriate.

* **`E_RNG_ENVELOPE`** â€” RNG envelope or accounting violations in S6 events/logs: missing `before/after/blocks/draws`, counter deltas inconsistent, audit not present before first draw, or trace row not appended **after each event**. â†’ **F4**. 

* **`E_LINEAGE_PATH_MISMATCH`** â€” Any embedded lineage field differs from its partition token (e.g., `{seed, parameter_hash, run_id}`). â†’ **F5**. 

* **`E_SCHEMA_AUTHORITY`** â€” Dataset or log does not validate against the **JSON-Schema** anchor registered in the dictionary (JSON-Schema is sole authority). â†’ **F6**. 

* **`E_NUMERIC_POLICY`** â€” S0.8 numeric environment violation detected on an ordering/decision path (binary64, RNE, **FMA off**, **no FTZ/DAZ**, deterministic libm). â†’ **F7**.

* **`E_EVENT_COVERAGE`** â€” Required S6 RNG families missing/inconsistent (e.g., wrong count of `rng_event.gumbel_key` vs. **considered** domain, when `log_all_candidates=true`). â†’ **F8**. 

* **`E_DUP_PK`** â€” Duplicate `(merchant_id, country_iso)` in the optional membership surface. â†’ **F10**. 

* **`E_ORDER_INJECTION`** â€” Any S6 output encodes or implies inter-country order (S3 `candidate_rank` is the **sole** authority; `outlet_catalogue` explicitly carries **no** cross-country order). â†’ **F9**.

---

## 8.3 Policy and configuration failures (pre-flight)

These abort **before** selection:

* **`E_POLICY_SCHEMA` / `E_POLICY_DOMAIN`** â€” Policy fails JSON-Schema or value ranges/uppercase code rules.
* **`E_POLICY_CONFLICT`** â€” Deterministic resolution (Â§4.3) yields an inconsistent effective policy.
  Map to S0 **F2/F1** as applicable (parameter/fingerprint & ingress/schema classes). 

---

## 8.4 RNG isolation & cross-stream interaction

S6 **MUST** write only its declared RNG families (e.g., `rng_event.gumbel_key`) and **MUST NOT** write to S1â€“S5 families; validator confirms **only** S6 families appear and trace deltas match appends. Violations â†’ `E_RNG_ENVELOPE` (**F4**). 

---

## 8.5 I/O integrity & publish atomics

Any short write, partial instance, non-atomic promote, or mismatched writer policy (when byte-identity is pinned) is `E_IO_ATOMICS` â†’ **F10**. The partition law and path discipline from the dictionary/registry **MUST** be obeyed. 

---

## 8.6 Degrade vocabulary (per-merchant; closed set)

S6 **MUST** record one of the following **reason_codes** when emitting a deterministic empty (non-error) or when cap diagnostics apply:

* `{none, NO_CANDIDATES, K_ZERO, ZERO_WEIGHT_DOMAIN, CAPPED_BY_MAX_CANDIDATES}`

These are **diagnostics**; they **do not** authorize re-ordering, re-weighting, or policy changes downstream. (S7 remains responsible for count allocation; S3 remains order authority.) 

---

## 8.7 Exit codes (runner)

* **`SUCCESS`** â€” All merchants processed; PASS receipt written (Â§9).
* **`STRUCTURAL_FAIL`** â€” Any of Â§8.2/Â§8.3 failures encountered (per-merchant aborts allowed; run fails if policy dictates).
* **`RNG_ACCOUNTING_FAIL`** â€” Envelope/trace breaches.
* **`RE_DERIVATION_FAIL`** â€” Validator cannot reconstruct membership from events + S3/S5 (or counter-replay when `log_all_candidates=false`).
* **`SHORTFALL_NOTED`** â€” Non-error; at least one merchant had $|\text{Eligible}| < K_{\text{target}}$.

(Exact numeric codes enumerated in Appendix **B** alongside RNG family names and schema anchors.) 

---

## 8.8 Cross-state gates (consumption rules)

Downstream states **MUST** verify the **S6 PASS** receipt before reading S6 convenience surfaces, and continue to respect the **S5 PASS** gate when joining S5 outputs. `No PASS â†’ no read` remains binding. 

---

# 9. Validation battery & PASS gate **(Binding)**

**Purpose.** Prove that S6 produced a **correct, reproducible** foreign-set membership under the S0â€“S5 contracts, with **isolation** to S6 RNG families, and publish a **receipt** that downstream MUST check (**no PASS â†’ no read**). JSON-Schema + the Dataset Dictionary remain the **sole** authorities for shapes/paths/partitions. 

---

## 9.1 Structural validation (schemas, partitions, lineage)

**Inputs present & valid (precondition recap).**

* `s3_candidate_set` exists for `parameter_hash={â€¦}` and validates against its `$ref`; ranks total/contiguous with home=0. 
* Exactly one `rng_event_ztp_final` per merchant under `{seed,parameter_hash,run_id}` (schema-valid). 
* `ccy_country_weights_cache` exists for **the same** `parameter_hash` and S5 **PASS** is present (S5 receipt + valid `_passed.flag`). **No PASS â†’ no read.** 

**S6 outputs/logs (produced here).**

* `rng_event.gumbel_key`, `rng_audit_log`, `rng_trace_log` validate against registered schema anchors; partitions are `{seed,parameter_hash,run_id}`; **pathâ†”embed equality** holds where embedded (trace lineage enforced via partition keys). 
* If the optional **membership** dataset is enabled, it validates against its `$ref`, is partitioned by `{seed, parameter_hash}`, and embeds the **same** `parameter_hash`. **PK** `(merchant_id,country_iso)` is unique. 

**Lineage discipline.** For all produced artefacts, embedded `{seed,parameter_hash,run_id}` (if present) **MUST** equal path tokens **byte-for-byte**. Violations are **hard FAIL**. 

---

## 9.2 Content checks (domain, cardinality, order separation)

* **Subset law:** Selected foreigns âŠ† S3 **foreign** candidates and âŠ† S5 weight support for the merchantâ€™s currency. (Home is never selectable.) 
* **Cardinality:** For each merchant,
  $$
  |{\text{selected}}| = K_{\text{realized}} = \min(K_{\text{target}},\,|\text{Eligible}|),
  $$
  where $|\text{Eligible}|$ is the count of candidates with $w>0$ **after** policy filters and any S3-rank cap. Shortfall (`|\text{Eligible}| < K_{\text{target}}`) **MUST** result in selecting **all `|\text{Eligible}|`**. 
* **Tie-break determinism:** When **`key`** values are equal in **binary64**, break by **S3 `candidate_rank`** (ascending), then by `country_iso` Aâ†’Z. (Ensures a total order consistent with S3.)
* **No order encoding:** Any S6 surface (incl. membership) **MUST NOT** encode or imply inter-country order; downstream MUST continue to read order **exclusively** from S3 `candidate_rank`. 

---

## 9.3 Re-derivation (authoritative proof of selection)

**Mode A â€“ `log_all_candidates = true` (recommended).**

* **Expectations:** For each merchant, **exactly one** `rng_event.gumbel_key` exists **per considered candidate** (`A_filtered`). The validator recomputes **`key` values** from **logged `u` (or verifies logged `key`) + S5 weights + S3 domain** in the **same iteration order (S3 rank)** and recomputes the **top-`K_target`** set. The recomputed membership **MUST** equal the published membership (or, if no membership surface is written, the validator must derive the same set from events). 

**Mode B â€“ `log_all_candidates = false` (reduced logging).**

* **Expectations:** Only **selected** candidates have logged keys. The validator performs **counter-replay** on the S6 substream in **S3-rank order** to regenerate the missing keys, recomputes **key values**, and verifies the selected set equals the runâ€™s published membership. Any divergence is **FAIL**. (This mirrors S5â€™s â€œre-derive to byte equalityâ€ posture, adapted to S6â€™s stochastic key logs.)

**Numeric/RNG law:** Re-derivation runs under the S0.8 numeric profile; uniforms use the S0 open-interval mapping; pairing uses **envelope counters**, not file order. 

---

## 9.4 RNG isolation & accounting

* **Family isolation:** Only S6 RNG families (e.g., `rng_event.gumbel_key`) appear in S6; validator finds **no writes** to S1â€“S5 families. 
* **Trace duty:** After **each** RNG event append, **exactly one** cumulative `rng_trace_log` row is appended; **draws/blocks/events** totals reconcile per `(module,substream_label)`. Any counter/total drift is **FAIL**. 
* **Event coverage:** When `log_all_candidates=true`, per-merchant count of `gumbel_key` events **equals** `A_filtered`. (When `false`, coverage is verified via counter-replay.) 

---

## 9.5 Validator artefacts (S6 PASS receipt; seed/parameter-scoped)

S6 writes a **seed/parameter-scoped receipt** under the S6 task path:

```
data/layer1/1A/s6/seed={seed}/parameter_hash={parameter_hash}/
  S6_VALIDATION.json          # summary: structural/content/RNG checks; per-merchant diagnostics
  _passed.flag                # single line: 'sha256_hex = <hex64>'
```

* `_passed.flag` contains the **SHA-256** over the **ASCII-lexicographic** concatenation of all other files in this receipt (currently **`S6_VALIDATION.json`**; exclude the flag itself). This mirrors the **parameter-scoped** receipt pattern used in S5 and the layer-wide gate pattern used for egress. **Atomic publish** applies.
* **Minimum required fields (normative) in `S6_VALIDATION.json`:**
  `seed`, `parameter_hash`, `policy_digest` (hex64 of S6 policy bytes), `merchants_processed`, `events_written`, `gumbel_key_expected` vs `written` (by mode), `shortfall_count`, `reason_code_counts{NO_CANDIDATES,K_ZERO,ZERO_WEIGHT_DOMAIN,CAPPED_BY_MAX_CANDIDATES}`, `rng_isolation_ok: bool`, `trace_reconciled: bool`, `re_derivation_ok: bool`. (Per-merchant detail may be emitted to a sibling `S6_VALIDATION_DETAIL.jsonl`.)
* **`policy_digest` construction (binding):** compute as **`sha256_hex` of the byte-concatenation of all S6 policy files, sorted by ASCII basename**. This ordering is binding to avoid toolchain drift.

---

## 9.6 PASS/consume semantics (gates)

* **S6 PASS (seed/parameter-scoped):** All checks in Â§Â§9.1â€“9.4 succeed **and** the receipt exists with a valid `_passed.flag` whose hash matches its contents. **Downstream S7/S8** MUST verify S6 PASS for the same `{seed,parameter_hash}` before reading any S6 convenience surface (**no PASS â†’ no read**). 
* **S5 PASS (dependency):** S6 MUST have verified S5 PASS for the same `parameter_hash` before reading weights; consumers that touch S5 surfaces continue to verify S5 PASS independently. 
* **Layer-wide PASS (unchanged):** Egress readers (e.g., `outlet_catalogue`) keep verifying the **fingerprint-scoped** validation bundle `_passed.flag` per S0/Dictionary.

---

## 9.7 Failure handling (publish discipline)

* **FAIL:** Any breach in Â§Â§9.1â€“9.4, or missing/invalid `_passed.flag`, **aborts** the run for the affected merchant set; **no partial publishes** to S6 outputs. Follow S0 abort semantics (write failure sentinel if defined; freeze; non-zero exit). 
* **Idempotence:** Re-running S6 with identical inputs and policy bytes must yield **value-identical** outputs and an identical PASS receipt; if a writer policy is pinned in the registry, **byte-identity** applies. 

---

# 10. Lineage, partitions & identifiers **(Binding)**

**Purpose.** Fix **where S6 writes**, **which identifiers appear**, and the **immutability/atomicity** rules. JSON-Schema + the Dataset Dictionary remain the single authorities for shapes, paths, and partition keys. 

---

## 10.1 Partitioning law (normative)

* **RNG events & core logs (S6-produced/updated).**
  **Path:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`
  **Applies to:** `rng_event.gumbel_key`, `rng_audit_log`, `rng_trace_log`. **These IDs and partition keys are already defined in the Dictionary/Registry.** 

* **S6 convenience membership dataset (if produced).**
  **Path:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/â€¦` â€” seed is required because membership is **seed-dependent**; `parameter_hash` binds the parameter scope. **S3 deterministic inputs remain parameter-scoped only** (`parameter_hash` partition), per their contracts. 

---

## 10.2 Embedded lineage & pathâ†”embed equality (binding)

* **Events/logs.** Where lineage fields are embedded, **`{seed, parameter_hash, run_id}` MUST byte-equal the path tokens**. For `rng_trace_log`, lineage is enforced via its partition keys and cumulative rows; one trace row is appended **after each event**. **Any mismatch is a hard FAIL.** 
* **Parameter-scoped tables.** Any S6 membership table (if enabled) **embeds the same `parameter_hash`** as its partition (and **MUST NOT** embed a different seed than its path). S3 inputs embed `parameter_hash` by spec. 

---

## 10.3 Identifier semantics (roles; non-interchangeable)

* **`seed`** â€” Determines stochastic outcomes; partitions **all RNG event/log paths** and any seed-dependent convenience surface. **Never appears in parameter-scoped S3/S5 tables.** 
* **`parameter_hash`** â€” Hash of the governed set **ð“Ÿ** (per S0.2.2). **All parameter-scoped inputs (S3/S5)** and the **S6 receipt/membership** carry this. **Policy bytes for S6 are required ð“Ÿ members**, so changing them flips this value and re-partitions reads/writes. 
* **`run_id`** â€” Partitions **logs only**; **does not change modelling state** or selection outcomes. Multiple `run_id`s may exist for the same `{seed, parameter_hash}` without changing the dataset semantics. 
* **`manifest_fingerprint`** â€” Layer-wide content/address for **egress** and the layer validation bundle; **not** used by S6 outputs. (S3/S5 keep using `parameter_hash`; egress (e.g., `outlet_catalogue`) remains fingerprint-scoped.) 

---

## 10.4 Atomic publish, immutability & idempotent retries (binding)

* **Write-once partitions.** Producers **MUST** stage â†’ fsync â†’ **atomic rename** into the dictionary location; **no partials** or mismatched partitions. Once published with PASS, **immutable**. 
* **Idempotence.** Re-running S6 with identical `{seed, parameter_hash, run_id}` and inputs **MUST** yield **value-identical** events/logs (and receipt). If a registry writer policy (codec/level/row-group) is pinned for the family, **byte-identity** applies. 
* **Resume semantics.** On failure, producers **MUST NOT** partially publish; they may retry the same `{seed, parameter_hash, run_id}` after cleaning any temp paths. (Receipt rules in Â§9 control final gating.) 

---

## 10.5 Canonical path patterns (normative)

* **`rng_event.gumbel_key`** â†’ `logs/rng/events/gumbel_key/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` (schema: `schemas.layer1.yaml#/rng/events/gumbel_key`). 
* **`rng_audit_log`** â†’ `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl` (schema: core audit). 
* **`rng_trace_log`** â†’ `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl` (schema: core trace). 
* **S3 input** `s3_candidate_set` â†’ `data/layer1/1A/s3_candidate_set/parameter_hash={parameter_hash}/â€¦` (schema: `schemas.1A.yaml#/s3/candidate_set`). 
* **S5 input** `ccy_country_weights_cache` â†’ `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/â€¦` with **S5 PASS receipt** co-located. 
* **S6 receipt (PASS gate)** â†’ `data/layer1/1A/s6/seed={seed}/parameter_hash={parameter_hash}/(S6_VALIDATION.json, _passed.flag)` (see Â§9). 

---

## 10.6 Producer/consumer & ownership

* **Producers:**

  * `rng_event.gumbel_key` â€” **S6** only.
  * `rng_audit_log` / `rng_trace_log` â€” layer RNG emitters; S6 **appends** per envelope law. 
  * Membership dataset (if enabled) â€” **S6** only; **authority remains the RNG events**.
* **Consumers:** Validation (S6 validator), then **S7/S8** post **S6 PASS**. Egress (`outlet_catalogue`) continues to rely on **fingerprint-scoped** validation per Dictionary. 

---

## 10.7 Cross-artefact lineage consistency (binding checks)

* **Path/Embed parity.** Every produced artefact with embedded lineage **MUST** match its path tokens **byte-for-byte**; any drift is `E_LINEAGE_PATH_MISMATCH`. 
* **Authority separation.** S3â€™s `candidate_rank` remains the **sole** order authority; S6 outputs **MUST NOT** encode order. (Dictionary and S3 spec reiterate this.)
* **Gate coupling.** S6 **MUST** verify **S5 PASS** (parameter-scoped receipt) before reading S5; downstream **MUST** verify **S6 PASS** before consuming any S6 convenience surface. **No PASS â†’ no read.** 

---

# 11. Interaction with RNG & logs **(Binding)**

**Purpose.** Pin exactly **which RNG families** S6 produces, how **substreams** are derived, the **budgeting/trace** law (`before/after/blocks/draws`), and what the **producer vs validator** may read/write.

---

## 11.1 Event families & substream taxonomy (authoritative)

* **Produced by S6 (events):**
  **`rng_event.gumbel_key`** â€” **logging mode:** if `log_all_candidates=true`, one event **per considered candidate** (post-cap & policy filter); if `false`, keys only for **selected** candidates (validator counter-replays missing keys per Â§9.3). **Schema anchor:** `schemas.layer1.yaml#/rng/events/gumbel_key`. **Partition:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`.

* **Core logs updated by S6:**
  **`rng_audit_log`** and **`rng_trace_log`**, both under `{seed, parameter_hash, run_id}` per the Dataset Dictionary. **Trace is cumulative per `(module, substream_label)`** and **emits exactly one row after each RNG event append** (saturating totals). 

* **Optional control event:** **`rng_event.stream_jump`** â€” explicit Philox stream/substream jump records (enabled only if the registry entry is present for 1A). 

* **Module & substreams (naming convention for S6):**
  **`module="1A.foreign_country_selector"`**, **`substream_label âˆˆ {"gumbel_key","stream_jump"}`**; IDs & partitions follow the registry/dictionary listings above. 

---

## 11.2 Substream derivation & ID tuple (normative)

* **Keyed substreams.** For event family label **â„“** (e.g., `"gumbel_key"`) and ordered **ids**, derive the keyed Philox state per **S0** (UER/SER framing â†’ SHA-256 â†’ `(k,(hi,lo))`). **IDs for `gumbel_key`:** `(merchant_u64, country_iso)` with **uppercase ISO2** under UER; types fixed by schema. **All draws for that event must come from `PHILOX(k(â„“,ids),Â·)` with a monotonically advancing 128-bit counter.** 

* **Open-interval uniforms.** Uniforms **MUST** use S0â€™s **strict-open** mapping $u\in(0,1)$ with the binary64 hex literal multiplier; exact `0.0`/`1.0` are **forbidden** (apply the clamp rule). 

* **Lane policy (single-uniform).** Single-uniform events consume the **low lane** from one Philox block and **discard the high lane** â†’ **`blocks=1`, `draws="1"`** (see budgeting law below). **`gumbel_key` is a single-uniform event.** 

---

## 11.3 Budgeting law: `before/after/blocks/draws` (binding)

* **Envelope arithmetic.** For every RNG event row:
  `blocks := u128(after) âˆ’ u128(before)` (unsigned 128-bit); **`draws`** is a **decimal uint128 string** equal to the **actual number of $U(0,1)$** consumed by the sampler(s) for that event and is **independent** of the counter delta. 

* **Budgets by family.**
  **`gumbel_key`**: **`blocks=1`, `draws="1"`** (single uniform);
  **non-consuming** markers (if any) must have `before==after`, `blocks=0`, `draws="0"`. (Patterns follow the layerâ€™s envelope rules.) 

* **Trace duty (per event).** After **each** RNG event append, S6 **MUST** append **exactly one** cumulative row to **`rng_trace_log`** for `(module, substream_label)`; totals reconcile (saturating) as specified by the dictionary/core schemas.

---

## 11.4 Producer vs validator scope (isolation & allowed reads)

* **Producer scope (S6 runner):**
  **MUST write** only the S6 families (`rng_event.gumbel_key` + optional `stream_jump`) and **MUST update** `rng_audit_log`/`rng_trace_log` per the envelope/trace law; **MUST NOT write** to S1â€“S5 event families. 

* **Validator scope (read-only):**
  **MAY read** S6 events and the **core RNG logs** to: (a) reconcile budgets/totals; (b) prove isolation (no cross-family writes); (c) re-derive selection from logged keys or via **counter-replay** in S3-rank order when `log_all_candidates=false` (see Â§9). **Validator MUST NOT write** RNG logs. 

---

## 11.5 Event coverage & expected counts (binding)

* **Per-merchant coverage.** The number of `rng_event.gumbel_key` events **MUST equal** the size of the **considered** domain **after** applying `max_candidates_cap` and `zero_weight_rule` (when `log_all_candidates=true`). If reduced logging is enabled, coverage is verified via **counter-replay** (see Â§9). 

* **Cumulative totals.** On the **final** `rng_trace_log` row for a given `(module, substream_label)`, validators check `draws_total = Î£ parse_u128(draws)` and `blocks_total = Î£ blocks` (saturating), per the core schema guidance. 

---

## 11.6 Partitions, lineage & equality (binding)

* **Partitions:** All S6 RNG events and core logs **MUST** live under `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦` with **embedded lineage equal to path tokens** where present. Mismatch is **hard FAIL**.

* **Immutability & idempotence:** Event/log partitions are **write-once**; re-runs with identical `{seed, parameter_hash, run_id}` must be **value-identical** (and **byte-identical** if the registry pins a writer policy). 

---

## 11.7 Cross-state consistency clauses (binding)

* **S4 handoff:** S6 **reads** `K_target` exclusively from **`rng_event.ztp_final`** (one per resolved merchant) and **must not** infer it elsewhere. 
* **S5 handoff:** S6 **reads** weights only from **`ccy_country_weights_cache`** after verifying **S5 PASS** for the same `parameter_hash` (**no PASS â†’ no read**). 

---

# 12. Performance, scaling & resource envelope **(Informative; determinism sub-clauses Binding)**

**Scope.** This section sets practical run-shape expectations and operational envelopes for S6. Items explicitly marked **(Binding)** are determinism requirements that implementers **must** satisfy; the rest are guidance to hit predictable performance without altering behaviour.

---

## 12.1 Cardinalities & expected volumes

* Let **M** be the number of merchants passing S6 gating; let **Aâ‚˜** be each merchantâ€™s foreign candidate count from S3; after policy (`max_candidates_cap`, `zero_weight_rule`) define **A_filtered,â‚˜**.
* **Event counts.**

  * If `log_all_candidates=true`: total `rng_event.gumbel_key` â‰ˆ **Î£â‚˜ A_filtered,â‚˜** (Binding expectation is enforced in Â§9).
  * If `false`: total events â‰ˆ **Î£â‚˜ K_realized,â‚˜**; validator uses **counter-replay** to cover missing keys (see Â§9).
* **Data written.** Core RNG logs grow linearly with the number of events (one **trace** append per event). 

## 12.2 Concurrency & determinism (Binding)

* **12.2.1 Concurrency unit = merchant (Binding).** Work **MAY** be sharded by merchant, but **MUST NOT** interleave state for the same merchant across shards.
* **12.2.2 Shard-count invariance (Binding).** Changing the number of shards/threads **MUST NOT** change: considered domain per merchant, uniform draw sequence, selected set, or the PASS receipt.
* **12.2.3 Deterministic merges (Binding).** Independent of shard count, producers **MUST**:

  * iterate candidates in **S3 `candidate_rank`** order when drawing;
  * logging mode: if `log_all_candidates=true`, write one `gumbel_key` per **considered** candidate; if `false`, write keys only for **selected** candidates;
  * append **exactly one** `rng_trace_log` row **after each** event;
  * ensure any optional membership surface is **writer-sorted** `(merchant_id, country_iso)` (row order non-semantic to readers).
* **12.2.4 Writer policy (Binding when pinned).** If the Registry pins codec/level/row-group policy for an S6 family, producers **MUST** use it (byte-identity); otherwise value-identity suffices. 

## 12.3 Memory envelope (per merchant)

* **Working set.** Implementation **should** bound peak memory to **O(A_filtered)** per merchant: weights (read-only), one uniform, one **key** per candidate, plus small envelope state.
* **Streaming discipline.** **Prefer** streaming: computeâ†’emit events per candidate in order; avoid accumulating all **keys** when `A_filtered` is large (use online top-K).
* **Join posture.** Reads should stream-join **S3 domain** with **S5 weights** by `country_iso` (both uppercase, FK-valid) to avoid full materialisations. (Authority on domains from schemas/dictionary remains binding.) 

## 12.4 CPU envelope & algorithmic shape

* **Per-merchant complexity.** Expected **O(A_filtered Â· log K_target)** for top-K selection with a bounded structure; **O(A_filtered)** if using Gumbel top-K with an online threshold scheme.
* **Numerics (Binding).** All scoring and comparisons execute under **S0.8** (IEEE-754 binary64; RNE; FMA-off; no FTZ/DAZ). Any deviation is a run-fail (see Â§8 `E_NUMERIC_POLICY`). 

## 12.5 I/O & file layout

* **Events/logs.** Expect small JSONL chunks per partition; throughput scales linearly with events (see Â§12.1). **Row order is non-semantic** to readers. 
* **Optional membership surface.** One file per `{seed, parameter_hash}` partition is **recommended** for simpler atomic promote; if the Registry pins a writer policy, follow it (Binding when pinned). 

## 12.6 Retry cost & atomicity (Binding cross-ref Â§10.3)

* **Stagingâ†’atomic publish.** Producers **MUST** stage to a temp path, fsync, and **atomically rename** into place; **no partial publishes**. Re-runs with the same `{seed, parameter_hash, run_id}` are idempotent (value-identical; byte-identical if policy pinned). 
* **Failure handling.** On any Â§8 hard fail, **do not** publish events/membership; the PASS receipt **must not** be created.

## 12.7 Practical sizing guidance (non-binding, recommended)

* **Shard sizing.** Size shard counts to keep `A_filtered` Ã— (`key`+`weight`) within memory headroom; prefer many small shards to avoid per-shard spikes.
* **Caps.** Use `max_candidates_cap` to bound worst-case `A_filtered` in extreme markets without changing S3 order (cap applies as S3-rank prefix only).
* **Diagnostics.** Enable `log_all_candidates=true` in early runs for simpler validation and performance sizing; switch to reduced logging only with Â§9 counter-replay wired.

## 12.8 Telemetry hooks (tie-in to Â§14)

* Expose counters needed to validate the envelopes above: `events_written`, `gumbel_key_expected` vs `written`, selection size histogram, and shard-count invariance checks (hash of selected set per merchant). (See Â§14 for required metric names.) 

---

# 13. Orchestration & CLI contract **(Binding at interface; Informative for ops)**

**Purpose.** Define the **entrypoints**, **required arguments**, **modes**, **exit codes**, and **DAG wiring** to run S6 in production. JSON-Schema + the Dataset Dictionary remain the single authorities for shapes, IDs, and partition keys; downstream consumption is gated by **PASS receipts** (**no PASS â†’ no read**). 

---

## 13.1 Required arguments (Binding)

* `--seed <u64>` â€” RNG seed for this run; **partitions all S6 RNG events/logs** (`â€¦/seed={seed}/â€¦`). 
* `--parameter-hash <hex64>` â€” exact **parameter scope**; must match S3/S5 partitions and S6 receipt location. (**S6 policy bytes are members of ð“Ÿ; changing them flips this value.**) 
* `--run-id <string>` â€” logical run instance (ULID/ISO-ts acceptable). **Partitions logs only**; does **not** change selection outcomes. 
* `--input-root <path>` â€” root directory used with the **Dataset Dictionary path patterns** to locate **S3/S4/S5** inputs. 
* `--output-root <path>` â€” root directory where S6 writes events/logs and the S6 **PASS receipt**. 
* `--dictionary <path|ref>` â€” the **dataset_dictionary.layer1.1A.yaml** (or service handle) to resolve IDs â†’ schemas, partitions, and paths. 
* `--schemas <path|ref>` â€” schema catalog(s) (**`schemas.1A.yaml`**, **`schemas.layer1.yaml`**, ingress catalog) used for validation. 
* `--policy-file <path>[,<path>â€¦]` â€” S6 policy set; **must validate** against the registered `$ref`; **must be in ð“Ÿ** (flips `parameter_hash` on byte change). 

**Notes (Binding):** the runner **MUST** fail pre-flight if any required argument is missing, if schemas/dictionary do not load, or if S6 policy fails schema validation. (See Â§4 for policy validation and Â§3 for input pre-flight.)

---

## 13.2 Switches & modes (Binding where stated)

* `--emit-membership-dataset` (default **false**) â€” if set, write the **convenience membership** table (authority remains the RNG events; **no order encoded**). 
* `--log-all-candidates` (default **true**) â€”

  * **true:** write one `rng_event.gumbel_key` **per considered candidate**.
  * **false:** write keys **only for selected**; validator **MUST** use **counter-replay** in **S3-rank** order to regenerate missing keys. (See Â§9.3.) 
* `--validate-only` â€” run the **validator** only: read existing S6 events/logs (and membership if present), perform **Â§Â§9.1â€“9.4**, and write the **S6 PASS receipt** in place.

  * **Binding semantics:** **requires** the S6 events/logs to already exist for `{seed, parameter_hash, run_id}`; **MUST NOT** create RNG events or membership; **USAGE** error if required inputs are absent. Receipt placement:
    `data/layer1/1A/s6/seed={seed}/parameter_hash={parameter_hash}/(S6_VALIDATION.json,_passed.flag)`. 
* `--fail-on-degrade` â€” if set, treat deterministic empties (`NO_CANDIDATES`, `K_ZERO`, `ZERO_WEIGHT_DOMAIN`, `CAPPED_BY_MAX_CANDIDATES`) as **STRUCTURAL_FAIL** for the run instead of recording diagnostics only. (Names per Â§8.6.) 

**Operational (Informative):** You may add **`--workers N` / `--shards N --shard-id i`** to parallelise **by merchant** (S6 determinism requires **shard-count invariance** and deterministic merges; see Â§12.2). 

---

## 13.3 Exit codes & artefacts (Binding at interface)

**Symbolic exit codes** (exact numeric values listed in Appendix **B**):

* **`SUCCESS`** â€” All checks passed; S6 **PASS receipt** written under `â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/`. 
* **`STRUCTURAL_FAIL`** â€” Any Â§8.2/Â§8.3 failure (inputs, schema, policy, lineage) encountered. 
* **`RNG_ACCOUNTING_FAIL`** â€” Envelope/trace mismatch (S6 families). 
* **`RE_DERIVATION_FAIL`** â€” Unable to reconstruct membership from events (+ counter-replay when reduced logging). 
* **`SHORTFALL_NOTED`** â€” Non-error; â‰¥1 merchant had $|\text{Eligible}| < K_{\text{target}}$.

**Published artefacts (mandatory on SUCCESS):**

* `S6_VALIDATION.json` and `_passed.flag` (hash over other receipt files, ASCII-lexicographic concat). **Atomic publish** required. 

---

## 13.4 DAG wiring (Binding)

**Prerequisites (gates):**

1. **S3** candidate set present & schema-valid for `parameter_hash={â€¦}`.
2. **S4** `ztp_final` present (one per resolved merchant) under `{seed, parameter_hash, run_id}`.
3. **S5** weights cache present for same `parameter_hash` **and S5 PASS receipt exists** (**no PASS â†’ no read**). 

**Nodes & order (single run):**

1. **Draw keys** â€” iterate S3 domain (policy-filtered/capped) in **S3-rank** order; if `log_all_candidates=true`, write one `rng_event.gumbel_key` **per considered candidate**; if `false`, write keys only for **selected** candidates; append **one** `rng_trace_log` row **after each** event.
2. **Select** â€” compute keys, apply top-`K_target` rule with tie-breaks; (optional) write membership surface (authority note: re-derivable; no order). 
3. **Validate** â€” run Â§9 structural/content/RNG isolation & (re)derivation checks.
4. **Publish** â€” atomic publish of S6 receipt (and membership if enabled). **On FAIL:** publish nothing; return appropriate exit code (above). 

**Gates to S7:** S7 **MUST** verify S6 PASS for the same `{seed, parameter_hash}` before reading any S6 convenience surface, and must continue to respect **S5 PASS** when joining S5 outputs. **No PASS â†’ no read.** 

## 13.5 ASCII overview *(Informative; non-authoritative)*

> This diagram is for **reader orientation only**. It does **not** add requirements. On any discrepancy, Â§Â§6â€“11 and Â§Â§13.1â€“13.4 (Binding) prevail.

```
[ENTER S6]
   â”‚
   â”‚ Load dictionary & schemas; resolve {seed, parameter_hash, run_id}
   â”‚ Load S6 policy set (in ð“Ÿ) and validate against $ref
   â”‚â€”â€” fail â†’ [STOP: E_POLICY_*]
   v
[Pre-flight (N1)]
   â”‚  Inputs present & schema-valid:
   â”‚    â€¢ S3 candidate_set (home=0; ranks total/contiguous)
   â”‚    â€¢ S4 rng_event.ztp_final (one per merchant) â†’ K_target
   â”‚    â€¢ S5 ccy_country_weights_cache (same parameter_hash) + S5 PASS
   â”‚  Lineage checks: pathâ†”embed equality
   â”‚â€”â€” fail â†’ [STOP: E_UPSTREAM_GATE / E_SCHEMA_AUTHORITY / E_LINEAGE_PATH_MISMATCH]
   v
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ For each merchant m (shard by merchant; deterministic merges)                â”‚
â”‚   â”‚                                                                           â”‚
â”‚   â”‚ [Build selection domain D_m]                                              â”‚
â”‚   â”‚   D_m := (S3 foreign candidates) âˆ© (S5 weight support for Îº_m)            â”‚
â”‚   â”‚   If max_candidates_cap>0 â†’ keep first cap by S3 candidate_rank           â”‚
â”‚   â”‚   Apply zero_weight_rule:                                                 â”‚
â”‚   â”‚     - "exclude": eligible = {w>0}                                         â”‚
â”‚   â”‚     - "include": considered may include w=0 (never eligible)              â”‚
â”‚   â”‚   A_filtered := |considered| ; Eligible := {w>0}                           â”‚
â”‚   â”‚                                                                           â”‚
â”‚   â”‚ Any deterministic-empty reasons?                                          â”‚
â”‚   â”‚â€”â€” A=0               â†’ [EMIT EMPTY: NO_CANDIDATES] â†’ next merchant         â”‚
â”‚   â”‚â€”â€” K_target=0        â†’ [EMIT EMPTY: K_ZERO] â†’ next merchant                â”‚
â”‚   â”‚â€”â€” Eligible=âˆ…        â†’ [EMIT EMPTY: ZERO_WEIGHT_DOMAIN] â†’ next merchant    â”‚
â”‚   â”‚ (If cap applied: record diagnostic CAPPED_BY_MAX_CANDIDATES)              â”‚
â”‚   v                                                                           â”‚
â”‚ [Draw keys (RNG events)]                                                      â”‚
â”‚   Iterate considered in S3 candidate_rank order                               â”‚
â”‚   For each candidate c:                                                       â”‚
â”‚     u ~ U(0,1) (open interval); G = -ln(-ln u); key = ln(w_c) - ln(-ln u)     â”‚
â”‚     log_all_candidates?                                                       â”‚
â”‚       â€¢ true  â†’ write rng_event.gumbel_key for every considered c             â”‚
â”‚       â€¢ false â†’ write rng_event.gumbel_key only for selected set (below)      â”‚
â”‚   (Append exactly one rng_trace_log row after each RNG event)                 â”‚
â”‚   â”‚                                                                           â”‚
â”‚   v                                                                           â”‚
â”‚ [Select]                                                                      â”‚
â”‚   K_realized := min(K_target, |Eligible|)                                     â”‚
â”‚   Choose top-K_realized by key; ties â†’ S3 candidate_rank, then country_iso    â”‚
â”‚   (No order is created; S3 remains sole authority for inter-country order)    â”‚
â”‚   â”‚                                                                           â”‚
â”‚   v                                                                           â”‚
â”‚ [Optional write: membership dataset]                                          â”‚
â”‚   If emit_membership_dataset=true â†’ write (merchant_id, country_iso)          â”‚
â”‚   (authority = RNG events; no order encoded; writer sort only)                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚
   v
[Validator & Receipt (N3)]
   â”‚  Structural: schemas, partitions, PK/FK, pathâ†”embed equality
   â”‚  Content: subset law, cardinality, tie-break determinism, no-order encoding
   â”‚  RNG isolation & accounting: only S6 families; trace totals reconcile
   â”‚  Re-derivation:
   â”‚    â€¢ if log_all_candidates=true  â†’ recompute from logged keys + S3/S5
   â”‚    â€¢ if log_all_candidates=false â†’ counter-replay keys in S3-rank order
   â”‚â€”â€” fail â†’ [STOP: RE_DERIVATION_FAIL / RNG_ACCOUNTING_FAIL / STRUCTURAL_FAIL]
   v
[Atomic publish (N4)]
   â”‚  Stage â†’ single rename; write-once
   â”‚  Emit S6_VALIDATION.json + _passed.flag under â€¦/s6/seed={seed}/parameter_hash={H}/
   v
[STOP: S6 PASS â€” downstream MAY read (seed+parameter scope)]
   (S7/S8 must verify S6 PASS; S5 PASS still required where S5 is read)
```

---

# 14. Observability & metrics **(Binding for names/semantics)**

**Scope.** These metrics/log fields are **canonical**. Names, units, and dimensions here are **binding**; implementation may add more, but **MUST NOT** change these. Dimensions default to `{seed, parameter_hash, run_id}` (the lineage triplet used across RNG events/logs and receipts). The Dataset Dictionary and RNG core logs remain the authorities for paths/partitions.

---

## 14.1 Run-level counters & gauges (Binding)

Emit the following **per run** (dimensions: `{seed, parameter_hash, run_id}`):

**Volume & gating**

* `s6.run.merchants_total : counter` â€” merchants seen by S6 after Â§3 pre-flight.
* `s6.run.merchants_gated_in : counter` â€” merchants satisfying S1/S3/S4/S5 gates. 
* `s6.run.merchants_selected : counter` â€” merchants with `K_realized > 0`.
* `s6.run.merchants_empty : counter` â€” merchants with deterministic empty (sum of reason codes below).

**Domain & selection**

* `s6.run.A_filtered_sum : counter` â€” Î£ over merchants of considered domain size after cap & `zero_weight_rule`.
* `s6.run.K_target_sum : counter` â€” Î£ over merchants of `K_target` (from S4 `ztp_final`). 
* `s6.run.K_realized_sum : counter` â€” Î£ over merchants of selected set size.

**Shortfall & reasons**

* `s6.run.shortfall_merchants : counter` â€” count where `|Eligible| < K_target` (selection proceeded with all `|Eligible|`).
* `s6.run.reason.NO_CANDIDATES : counter` â€” (A=0).
* `s6.run.reason.K_ZERO : counter` â€” `K_target=0`.
* `s6.run.reason.ZERO_WEIGHT_DOMAIN : counter` â€” eligible set empty after policy.
* `s6.run.reason.CAPPED_BY_MAX_CANDIDATES : counter` â€” diagnostic; cap truncated domain (non-error). *(Closed setâ€”no other labels permitted.)*

**RNG coverage & accounting**

* `s6.run.events.gumbel_key.expected : counter` â€” if `log_all_candidates=true`, Î£ `A_filtered`; else Î£ `K_realized`.
* `s6.run.events.gumbel_key.written : counter` â€” number of `rng_event.gumbel_key` rows written.
* `s6.run.trace.events_total : counter` â€” final `events_total` from `rng_trace_log` for `(module="1A.foreign_country_selector", substream_label="gumbel_key")`.
* `s6.run.trace.blocks_total : counter` â€” final blocks total for the same key.
* `s6.run.trace.draws_total : counter` â€” final draws total for the same key. *(Trace fields mirror the core RNG schema; one trace append per event is required.)* 

**Policy & mode attestation**

* `s6.run.policy.log_all_candidates : gauge(bool)` â€” policy mode used.
* `s6.run.policy.max_candidates_cap : gauge(int)` â€” cap value used (0 = none).
* `s6.run.policy.zero_weight_rule : gauge(enum{"exclude","include"})`.
* `s6.run.policy.currency_overrides_count : counter` â€” number of currencies with per-currency overrides applied (names in validator report).

**Result shape**

* `s6.run.selection_size_histogram : histogram` â€” bucketed `K_realized` with **fixed buckets**: `b0=0`, `b1=1`, `b2=2`, `b3_5=3â€“5`, `b6_10=6â€“10`, `b11_plus=11+`. *(Bucket names fixed; implementations record bucket counts.)*

**Gate flags**

* `s6.run.rng_isolation_ok : gauge(bool)` â€” true iff only S6 families appear and totals reconcile. 
* `s6.run.re_derivation_ok : gauge(bool)` â€” true iff Â§9.3 re-derivation passes (logged or counter-replay mode).
* `s6.run.pass : gauge(bool)` â€” true iff the S6 receipt is written with a valid `_passed.flag`. (Downstream **must** still read the receipt and enforce gates.) 

---

## 14.2 Per-merchant diagnostics (Binding names; high-cardinality â†’ log, not metrics)

Emit as **structured log rows** (JSONL) or a per-run detail file; do **not** export as cardinality-heavy metrics:

* `merchant_id:u64`, `A:int`, `A_filtered:int`, `K_target:int`, `K_realized:int`.
* `considered_expected_events:int`, `gumbel_key_written:int` (equals `considered_expected_events` only when `log_all_candidates=true`).
* `is_shortfall:bool` â€” true iff `|Eligible| < K_target`, `reason_code:enum{NO_CANDIDATES,K_ZERO,ZERO_WEIGHT_DOMAIN,CAPPED_BY_MAX_CANDIDATES,none}`.
* `ties_resolved:int` â€” count of key ties broken by S3 `candidate_rank` / ISO.
* `policy_cap_applied:bool`, `cap_value:int`.
* `zero_weight_considered:int` â€” count of considered candidates with `w==0` (under `"include"` mode).
* `rng.trace.delta.{events,blocks,draws}:int` â€” deltas observed in `rng_trace_log` for this merchantâ€™s S6 substream.
  *(Order remains S3â€™s authority; membership surface (if enabled) encodes no order.)*

---

## 14.3 RNG audit metrics (Binding)

For each `(module="1A.foreign_country_selector", substream_labelâˆˆ{"gumbel_key","stream_jump"})`, expose:

* `s6.rng.trace.events_total : counter`
* `s6.rng.trace.blocks_total : counter`
* `s6.rng.trace.draws_total : counter`
* `s6.rng.trace.append_rows : counter` â€” **MUST equal** `events_total` for `gumbel_key`.
  Values **MUST** be read from the **final row(s)** of `rng_trace_log` and agree with S6 event budgets (`gumbel_key` uses `blocks=1`, `draws="1"`).

---

## 14.4 Structured logs (Binding fields)

Every S6 structured log line (INFO/WARN/ERROR) **MUST** include:

* **Lineage:** `seed`, `parameter_hash`, `run_id`.
* **Context:** `stage:enum{"preflight","draw","select","write","validate","publish"}`, `module:"1A.foreign_country_selector"`.
* **Keys:** `merchant_id` *(omit on run-level messages)*, optional `country_iso` on candidate-level messages.
* **Reasoning:** `reason_code` (from the closed set above) when emitting empties or diagnostics.
* **Counters (when applicable):** `A`, `A_filtered`, `K_target`, `K_realized`, `gumbel_key_written`, `considered_expected_events`.
  These fields align with the RNG core and dataset contracts so operators can correlate logs with RNG trace and dictionary paths.

---

## 14.5 Golden fixtures *(Binding to ship & keep green; values themselves are non-normative)*

Maintain **three tiny, deterministic fixtures** (seeded) checked in CI; they **MUST** run under Â§12â€™s shard-invariance rules and assert Â§9 signals:

1. **Nominal selection:** `A=4, K_target=2`, non-zero S5 weights â†’ `K_realized=2`; `log_all_candidates=true`; event coverage = `A_filtered`; re-derivation passes.
2. **Deterministic empty (no candidates):** `A=0` â†’ reason `NO_CANDIDATES`; zero S6 events; PASS receipt still required.
3. **Zero-weight domain:** S5 weights zero on all foreigns after policy â†’ reason `ZERO_WEIGHT_DOMAIN`; zero S6 events; PASS receipt required.

Each fixture **MUST** assert: schema/PK/FK, pathâ†”embed equality, RNG isolation & accounting (trace rows = events), and **â€œno order encodingâ€** (order remains from S3 `candidate_rank`).

---

## 14.6 Source-of-truth reminders (Binding)

* **Order authority** remains S3 `candidate_rank`; egress (`outlet_catalogue`) carries **no** cross-country orderâ€”operators must not infer order from S6 row order. 
* **RNG receipts** rely on core logs: `rng_audit_log` (run-scoped) and `rng_trace_log` (cumulative per `(module,substream_label)`); one trace append **after each** event is mandatory. 
* **S5 PASS gate** remains in force when joining S5 outputs; S6 PASS is **seed+parameter-scoped** and must be verified by S7/S8 (`no PASS â†’ no read`).

---

# 15. Security, licensing & compliance **(Binding)**

**Purpose.** Keep S6 within the platformâ€™s **closed-world, contract-governed** posture; ensure all artefacts are **licensed**, **non-PII**, **immutable** under their lineage keys, and **auditable** end-to-end. JSON-Schema + the Dataset Dictionary remain the single authorities for shapes, paths, partitions, retention, and licence classes. 

---

## 15.1 Data provenance & closed-world stance

* S6 operates **only** on the sealed, version-pinned artefacts enumerated in Â§3 (S3 candidate set, S4 `ztp_final`, S5 weights) plus the S6 policy (Â§4). **No external enrichment or network reads** are permitted. 
* Provenance (owner, retention, licence, `schema_ref`) for inputs/outputs is declared in the **Dataset Dictionary**; S6 **MUST NOT** deviate from those entries.

## 15.2 Licensing (inputs, outputs, registry alignment)

* **Ingress examples (for transitive awareness):**
  `iso3166_canonical_2024` â†’ **CC-BY-4.0**; `world_countries` â†’ **ODbL-1.0** (ingress). These licences are already pinned in the Dictionary.
* **S6-produced/updated artefacts:**
  `rng_event.gumbel_key`, `rng_audit_log`, `rng_trace_log` are **Proprietary-Internal**, with declared **retention** and **pii=false** in the Dictionary; S6 **MUST** publish/update under those classes. 
* **Optional S6 membership dataset (if enabled):** before any consumer reads, a Dictionary entry **MUST** be registered with `pii:false`, an explicit **licence class** (default **Proprietary-Internal**), retention window, and a `$ref` schema; until then it is **not consumable**. 
* The Artefact Registry **MUST** carry licence metadata for S6 families/configs; storage policies (e.g., `compression_zstd_level3`) are referenced there and **MUST** be respected when pinned.

## 15.3 Privacy & PII posture

* All S6 inputs/outputs in scope are **`pii:false`** in the Dictionary; S6 **MUST NOT** introduce PII or fields enabling re-identification. 
* Structured logs and the S6 receipt **MUST NOT** contain row-level payloads beyond **codes and counts** (e.g., ISO codes, integer counters). (See Â§14 for required fields.) 

## 15.4 Access control, encryption, and secrets

* S6 inherits platform rails: **least-privilege IAM**, **KMS-backed encryption** at rest/in transit, and **audited access** to governed artefacts.
* S6 **MUST NOT** embed secrets in datasets/logs; use the platform secret store if credentials are required (none are required for S6â€™s normal operation). *(Policy, schemas, and dictionaries are public-internal artefacts.)* 

## 15.5 Retention & immutability

* Retention periods are governed by the Dictionary (e.g., **365 days** for S6 outputs/logs; ingress typically **1095 days**). S6 **MUST NOT** override retention.
* Event/log partitions are **content-addressed** by `{seed, parameter_hash, run_id}` and are **write-once**; S6 uses **atomic publish** and **never** mutates published partitions (see Â§10). 

## 15.6 Licence & compliance checks (validator duties)

The S6 validator (Â§9) **MUST additionally assert**:

* **Dictionary/licence presence:** every dataset ID read or written by S6 has a Dictionary entry with **non-empty `licence`** and `retention_days`. Missing â‡’ **FAIL**. 
* **Receipt summary:** `S6_VALIDATION.json` **MUST** include `licence_summary` listing `{dataset_id, licence, retention_days}` for all S6-touched artefacts (inputs: S3/S4/S5 IDs; outputs: S6 event/log families and membership if produced), plus `policy_digest` and `parameter_hash`. (Names align with Â§14 diagnostics.) 
* **Registry policy adherence:** when a writer policy is pinned in the Registry (codec/level/row-group), the produced files reflect that policy (else **FAIL**).

## 15.7 Redistribution & downstream use

* S6 event/log streams and any membership surface are **internal authorities** (Proprietary-Internal). Downstream systems **MUST NOT** republish them externally or change licence class without governance approval. 
* **Order authority** remains S3; S6 outputs **MUST NOT** be used to derive or imply inter-country order for publication or release. 

---

# 16. Change management, compatibility & rollback **(Binding)**

**Purpose.** Define how S6 evolves without breaking consumers; how changes interact with **`parameter_hash`** (ð“Ÿ), **`manifest_fingerprint`**, schemas, the Dataset Dictionary, and the Artefact Registry. JSON-Schema and the Dictionary remain the **sole** authorities for shapes/IDs/paths. 

---

## 16.1 Versioning model (SemVer) â€” interface vs lineage (Binding)

* **SemVer scope (this spec & its public interfaces).**

  * **MAJOR** â€” breaking changes to: dataset **IDs/paths/partitions**, schema shapes/required fields, **RNG event family** payloads or budgeting law, **tie-break rules**, **substream naming**, PASS-gate semantics, or adding **new required** CLI args.
  * **MINOR** â€” additive, backwards-compatible changes: optional fields/metrics, enabling the **optional membership** dataset, adding **diagnostic** fields, enabling **reduced logging** mode provided Â§9 supports counter-replay, registering a **writer policy** in the Registry.
* **Lineage keys are separate from SemVer.**

  * **`parameter_hash`** flips whenever **any** member of the governed set **ð“Ÿ** changes **bytes** (S0.2.2). S6 policy files are **required** ð“Ÿ members. 
  * **`manifest_fingerprint`** flips when **any opened artefact** (schemas/dictionary/ISO, etc.) or the **code commit** changes (S0.2.3). 

---

## 16.2 Compatibility window (Binding)

S6 v1.* is compatible with the following **v1.* baselines** (or as re-ratified):

* **Dictionary:** `dataset_dictionary.layer1.1A.yaml` v1.* (IDs/paths for `rng_event_ztp_final`, `rng_event_gumbel_key`, core RNG logs, S3/S5 datasets). 
* **Schemas:** `schemas.layer1.yaml` (RNG events/logs), `schemas.1A.yaml` (S3/S5 tables) v1.*.
* **S0 lineage law:** S0.2.* (`parameter_hash`, `manifest_fingerprint`, `run_id`). 
  If any of the above bump **MAJOR**, S6 **must** be re-ratified and its SemVer **MAJOR** incremented.

---

## 16.3 Event families & schema evolution (Binding)

* **RNG events.** `rng_event_gumbel_key` is the **authoritative** S6 event; its **schema_ref** and **partitioning** are fixed by the Dictionary. Backwards-compatible additions (optional fields) are **MINOR**; any required-field or budgeting change is **MAJOR**. 
* **Core logs.** `rng_audit_log`/`rng_trace_log` are shared; S6 **must not** alter their shapesâ€”any change is Dictionary-governed (likely **MAJOR** at layer-scope). 
* **Membership dataset (optional).** Introducing it is **MINOR** if schema is additive and it carries **no order** (authority remains RNG events). Any future claim to authority would be **MAJOR**.

---

## 16.4 Policy changes & logging mode (Binding)

* **S6 policy is in ð“Ÿ.** Changing policy bytes **MUST** flip `parameter_hash` (new parameter scope). 
* **`log_all_candidates` default.** Switching default **trueâ†’false** is **MINOR** if Â§9 counter-replay is implemented and enabled; reverting is also **MINOR**. (Per-currency overrides are disallowed; mode is global to keep validation uniform.)
* **`max_candidates_cap` changes.** Adjusting cap is **MINOR** (diagnostic `CAPPED_BY_MAX_CANDIDATES` required); removing the cap is **MINOR**.
* **`zero_weight_rule` changes.** `"exclude"â†”"include"` toggles are **MINOR** (selection unchanged for positive weights; logging/expected-events differ and Â§9 covers both).

---

## 16.5 Registry & writer policy (Binding)

* **Writer policy.** If the Artefact Registry pins a writer policy (e.g., **ZSTD-3** and row-group sizes), S6 **MUST** use it; changing or pinning such policy is **MINOR** (value semantics unchanged; **byte-identity** may newly apply). 
* **Deprecated datasets.** The Registry keeps legacy **`country_set`** for compatibility but marks it **deprecated as order authority** (S3 owns order). S6 must **not** re-elevate it. 

---

## 16.6 Migration patterns (Binding)

When introducing **MINOR** changes:

1. **Shadow**: run S6 with new policy/schema in **shadow** (`--validate-only`) against existing events/logs; produce a PASS receipt without publishing new artefacts. 
2. **Dual-write (if needed)**: for new optional surfaces/fields, **dual-write** for at least one retention window; consumers switch by config.
3. **Canary**: enable for a small shard of merchants (seed-consistent) and confirm Â§14 telemetry and Â§9 PASS.
4. **Promote**: expand to 100% once green; remove shadow paths.

For **MAJOR** changes:

* **New IDs or schema_refs** in the Dictionary, or a new **module/substream** name; keep the prior family **readable** for â‰¥ retention window.

---

## 16.7 Deprecation policy (Binding)

* Announce in the Dictionary entry (`status: deprecated`, `notes`) and Registry (`notes:`) for at least one **retention** cycle before removal; provide the replacement ID/field.
* During deprecation, S6 **MUST** continue to write the legacy surface **or** produce a deterministic shim the validator can re-derive from the authoritative events.

---

## 16.8 Rollback (Binding)

* **What rollback means.** Revert to the **last-good** `{seed, parameter_hash}` and S6 **SemVer** that produced a PASS receipt; re-run with the earlier **policy bytes** and **code commit** to regenerate identical outputs (value-identical; **byte-identical** if writer policy pinned). 
* **Mechanics.**

  1. Restore previous S6 policy file(s) (ð“Ÿ member); this restores the prior `parameter_hash`. 
  2. Check out the last-good code commit (participates in `manifest_fingerprint`). 
  3. Re-run S6 with the same `{seed, run_id}` (or a **new** `run_id`, since it does not affect modelling state). 
  4. Publish the S6 PASS receipt; downstream reads remain gated by PASS receipts (S5 and S6). 

---

## 16.9 Consumer impact matrix (Binding)

* **S3** â€” No impact unless S3 schema/IDs change (**MAJOR** there); S6 must continue to read `candidate_set` v1.*. 
* **S4** â€” `ztp_final` contract unchanged; any S4 MAJOR requires S6 re-ratification. 
* **S5** â€” S6 continues to enforce **S5 PASS** for the same `parameter_hash` (`no PASS â†’ no read`). If S5 changes schema/IDs (**MAJOR**), S6 must re-ratify and bump **MAJOR**. 
* **S7/S8** â€” Downstream continue to rely on S6 **PASS** receipt and on S3 order authority; optional membership surface remains convenience only.

---

## 16.10 Golden fixtures & CI gates (Binding)

* Keep Â§14.5 golden fixtures **green** across changes; add new fixtures when introducing **MINOR** features (e.g., reduced logging mode) and **MAJOR** interfaces. The CI **must** assert: schema/PK/FK, pathâ†”embed equality, RNG accounting (trace rows = events), re-derivation, and **no order encoding**. 

---

# 17. Acceptance checklist **(Binding)**

Use this **tick-box** list to sign off S6 before hand-off to implementation/ops. All items are **binding**.

---

## 17.1 Build-time (before any run)

* [ ] **Dictionary & schemas loaded** â€” `dataset_dictionary.layer1.1A.yaml` and schema catalogs (`schemas.1A.yaml`, `schemas.layer1.yaml`) resolve; IDs & `$ref`s for:
  `s3_candidate_set`, `rng_event_ztp_final`, `rng_event_gumbel_key`, core RNG logs (`rng_audit_log`, `rng_trace_log`), plus optional membership surface (if enabled).
* [ ] **Order authority pinned** â€” dictionary states **S3 `candidate_rank` is the sole inter-country order**; `outlet_catalogue` encodes **no** cross-country order. (Sanity: S6 must not encode order.)
* [ ] **RNG event families registered** â€” `rng_event.gumbel_key` exists with correct path/partitions `{seed,parameter_hash,run_id}` and `gated_by` = hurdle (`is_multi==true`). 
* [ ] **Core RNG logs registered** â€” `rng_audit_log`, `rng_trace_log` have correct partitions and schema anchors. 
* [ ] **S6 policy files validated** â€” JSON-Schema `$ref` passes; basenames **listed in S0.2.2 governed set ð“Ÿ** so byte changes flip `parameter_hash`. (Cross-check ð“Ÿ discipline.) 
* [ ] **S5 contract in place** â€” S5 defines `ccy_country_weights_cache` with Î£ rules and **parameter-scoped PASS receipt** (`S5_VALIDATION.json` + `_passed.flag`) required **before reads**.
* [ ] **Registry writer policy (if pinned)** â€” any codec/level/row-group requirements for S6 families present in Artefact Registry (for byte identity). 

---

## 17.2 Run-time (per run; fail-closed if any item fails)

**Pre-flight (Â§3):**

* [ ] **Inputs present & schema-valid** â€” S3 candidate set (home=0; ranks contiguous), S4 `ztp_final` (exactly one per merchant), S5 weights (same `parameter_hash`) with **S5 PASS receipt**; pathâ†”embed equality holds.
* [ ] **Lineage triplet** â€” `{seed, parameter_hash, run_id}` resolved and used for S6 paths.

**Selection & RNG (Â§6/Â§11):**

* [ ] **Domain built correctly** â€” foreign = S3 candidates âˆ– home, âˆ© S5 weight support; optional cap is **S3-rank prefix only**. No out-of-domain countries admitted. 
* [ ] **Event coverage** â€” if `log_all_candidates=true`: **one** `rng_event.gumbel_key` **per considered candidate** (`A_filtered`). If false: keys only for selected, and validator will **counter-replay**. 
* [ ] **Trace duty** â€” **one** `rng_trace_log` append **after each** RNG event; totals reconcile per `(module, substream_label)`. 
* [ ] **Top-K rule** â€” select `min(K_target, |Eligible|)` by **`key`**; ties â†’ S3 `candidate_rank`, then ISO Aâ†’Z. `K_target` read **only** from `rng_event_ztp_final`.
* [ ] **No order encoding** â€” S6 writes **no** cross-country order; membership surface (if emitted) is **authority-free** and re-derivable from events. 

**Validator (Â§9):**

* [ ] **Structural** â€” schemas/PK/FK pass; partition law & pathâ†”embed equality hold for all S6 artefacts. 
* [ ] **Content** â€” subset law (selected âŠ† S3 foreign âˆ© S5 support), cardinality, tie-break determinism, **no order encoding**. 
* [ ] **RNG isolation & accounting** â€” only S6 families appear; per-merchant/event totals match expectations; trace totals = Î£ event budgets. 
* [ ] **Re-derivation** â€” Mode A: recompute from logged keys + S3/S5; Mode B: **counter-replay** missing keys in S3-rank order; published membership matches. 

**Gates:**

* [ ] **S5 PASS verified** (same `parameter_hash`) **before** any S5 reads. 

---

## 17.3 Publish (write-once; atomic promote; gate armed)

* [ ] **Receipt written** â€” under `â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/`:
  `S6_VALIDATION.json` + `_passed.flag` (SHA-256 over ASCII-lexicographic concat of other receipt files). **Atomic publish**; no partials. 
* [ ] **Events/logs partitions** â€” `rng_event.gumbel_key`, `rng_audit_log`, `rng_trace_log` under `{seed,parameter_hash,run_id}`; embedded lineage equals path tokens.
* [ ] **Optional membership surface** â€” if enabled, partitioned by `{seed,parameter_hash}`, **writer-sorted**, and **re-derivable** from RNG events; **no order** encoded.
* [ ] **Downstream gates armed** â€” S7/S8 must verify **S6 PASS** (seed+parameter) and continue to enforce **S5 PASS** for weight joins (**no PASS â†’ no read**). 

---

# Appendix A. Glossary & symbols *(Normative)*

**A (raw foreign candidates).**
For a merchant $m$, **A** is the count of **foreign** rows in **S3 `s3_candidate_set`** (home has `candidate_rank=0` and is excluded). Ranks are total & contiguous per merchant.

**A_cap (rank-prefix cap).**
If policy `max_candidates_cap>0`, **A_cap = min(A, cap)** by taking the **first** `cap` foreign candidates in **S3 `candidate_rank`** order (no re-order).

**Considered set / $A_{\text{filtered}}$.**
The **considered** domain after policy filters: take the foreign S3 set, apply the cap, then apply `zero_weight_rule`.

* If `"exclude"` (default): drop candidates with `w==0`.
* If `"include"`: keep `w==0` in the considered set (they can be **logged** but never selected).
  Define **$A_{\text{filtered}}$** as the **size of the considered** set.

**Eligible set / $|\text{Eligible}|$.**
Subset of the **considered** set with **strictly positive** S5 weight (**$w>0$**). S6 **selects only** from this set. Its size $|\text{Eligible}|$ may be < $A_{\text{filtered}}$ when `"include"` is used.

**$K_{\text{target}}$.**
Per-merchant target cardinality fixed by **S4 `rng_event.ztp_final`** (logs-only authority; exactly one final per resolved merchant).

**$K_{\text{realized}}$.**
The realized selection size:
$$
K_{\text{realized}}=\min\big(K_{\text{target}},\ |\text{Eligible}|\big).
$$
If the eligible set is smaller than $K_{\text{target}}$ (shortfall), S6 selects **all** eligible countries.

**Gumbel `key` (a.k.a. score $S$).**
S6 scores each **considered** candidate $c$ (with S5 weight $w_c$) using:
$$
S_c = \ln(w_c) + G_c,\qquad G_c = -\ln\big(-\ln u_c\big),\quad u_c\in(0,1).
$$

* **Uniforms:** $u_c$ come from the layerâ€™s **strict-open** (U(0,1)) mapping (never 0 or 1).
* **Zero weights:** if `zero_weight_rule="include"`, treat $\ln(0)=-\infty$ (loggable, **not** selectable).
  *Event payload note (binding cross-ref to Â§Â§5.1/6.3): when `weight==0`, the event **MUST** encode `key: null` (never $\pm\infty$); such rows are diagnostic only and cannot be selected.*
* **Tie-breaks (total order):** higher $S$ first; exact tie â†’ lower **S3 `candidate_rank`**; then `country_iso` Aâ†’Z.

**ULP (Unit in the Last Place).**
For IEEE-754 **binary64**, the **ULP** at a value $x$ is the difference between $x$ and the next representable binary64 number. ULPs matter only for **comparisons** (e.g., equality of $S$ in binary64); they **do not** change the scoring formula or selection rule.

**RNG envelope *counters* and *budgets*.**
Every RNG event row carries a **lineage envelope**:

* `before`, `after` â€” **128-bit** Philox counters (as decimal strings) **before** and **after** the event.
* `blocks` â€” unsigned 128-bit delta: `u128(after) âˆ’ u128(before)`.
* `draws` â€” **decimal uint128 string** equal to the **actual number of $U(0,1)$** draws consumed by the eventâ€™s sampler(s) (independent of `blocks`).
* **Single-uniform family (`gumbel_key`):** `blocks=1`, `draws="1"`.
* **Non-consuming markers (if any):** `before==after`, `blocks=0`, `draws="0"`.

**RNG trace *budget totals*.**
For each `(module="1A.foreign_country_selector", substream_labelâˆˆ{"gumbel_key","stream_jump"})`, S6 appends **exactly one** cumulative row to **`rng_trace_log`** **after each event**; validators check:

* `events_total` increments by 1 per event append,
* `draws_total = Î£ parse_u128(draws)`,
* `blocks_total = Î£ blocks` (saturating),
  and that **only S6 families** appear (isolation).

**Lineage triplet.**
`{seed, parameter_hash, run_id}` â€” required partition keys for S6 RNG events/logs; embeddings (when present) **must byte-equal** path tokens.

**Receipts & gates (reminder).**

* **S5 PASS (parameter-scoped):** `S5_VALIDATION.json` + `_passed.flag` **must exist** before S6 reads S5.
* **S6 PASS (seed+parameter-scoped):** `S6_VALIDATION.json` + `_passed.flag` gate downstream reads of any S6 convenience surface.

---

# Appendix B. Enumerations & reference tables *(Normative)*

## B.1 Dataset IDs and schema anchors (read/write set)

| ID (Dictionary)                      | Type         | Partitions                     | Schema `$ref`                                            | Notes                                                                                                                                                            |
|--------------------------------------|--------------|--------------------------------|----------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `s3_candidate_set`                   | dataset      | `parameter_hash`               | `schemas.1A.yaml#/s3/candidate_set`                      | Order & admissible set **A** (home `candidate_rank=0`, ranks total & contiguous).                                                                                |
| `rng_event_ztp_final`                | rng_event    | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/events/ztp_final`              | S4 **fixes `K_target`**; exactly one per resolved merchant. **Consumed by S6.**                                                                                  |
| `rng_event_gumbel_key`               | rng_event    | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/events/gumbel_key`             | **Logging mode:** if `log_all_candidates=true`, one per **considered** candidate; if `false`, keys only for **selected** candidates (validator counter-replays). |
| `rng_audit_log`                      | rng core log | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/core/rng_audit_log`            | Run-scoped audit; emitted before events.                                                                                                                         |
| `rng_trace_log`                      | rng core log | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/core/rng_trace_log`            | Cumulative per `(module, substream_label)`; **one append after each event**.                                                                                     |
| `ccy_country_weights_cache`          | dataset      | `parameter_hash`               | `schemas.1A.yaml#/prep/ccy_country_weights_cache`        | S5 currencyâ†’country **weights**; **S5 PASS** required before S6 reads (**no PASS â†’ no read**).                                                                   |
| `merchant_currency` *(optional)*     | dataset      | `parameter_hash`               | `schemas.1A.yaml#/prep/merchant_currency`                | Deterministic Îºâ‚˜ cache for S5/S6 joins.                                                                                                                          |
| `rng_event_dirichlet_gamma_vector`   | rng_event    | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/events/dirichlet_gamma_vector` | S7 allocator (downstream of S6).                                                                                                                                 |
| `rng_event_stream_jump` *(optional)* | rng_event    | `seed, parameter_hash, run_id` | `schemas.layer1.yaml#/rng/events/stream_jump`            | Explicit Philox stream/substream jump records.                                                                                                                   |
| `country_set` *(legacy/compat)*      | dataset      | `seed, parameter_hash`         | `schemas.1A.yaml#/alloc/country_set`                     | **Deprecated as order authority;** S3 remains sole order source.                                                                                                 |

> **Authority reminder:** JSON-Schema + Dataset Dictionary govern IDs, shapes, and paths; S6 **must not** encode inter-country orderâ€”consumers **must** join S3 `candidate_rank`. 

---

## B.2 RNG family names and substream conventions

* **Module name (S6):** `module="1A.foreign_country_selector"` *(normative)*.
* **Substream labels (S6):** `substream_label âˆˆ {"gumbel_key","stream_jump"}` *(if `stream_jump` is registered)*. 
* **Families touched by S6:**

  * **Produced:** `rng_event.gumbel_key` (S6). 
  * **Updated core logs:** `rng_audit_log`, `rng_trace_log` (append per event). 
  * **Optional:** `rng_event.stream_jump` (if present in the registry). 
* **Related upstream/downstream families (read or next state):**
  `rng_event.ztp_final` (S4) â†’ **read by S6**; `rng_event.dirichlet_gamma_vector` (S7) â†’ **downstream**.

---

## B.3 Reason codes *(closed vocabulary; diagnostics only)*

These codes annotate **deterministic empties or cap diagnostics** (they do **not** authorise re-weighting or re-ordering):

* `NO_CANDIDATES` â€” S3 exposes only home (`A=0`).
* `K_ZERO` â€” S4 fixed `K_target=0`.
* `ZERO_WEIGHT_DOMAIN` â€” after policy, no candidate with `w>0` remains.
* `CAPPED_BY_MAX_CANDIDATES` â€” domain truncated by S3-rank cap (non-error).

*(Names align with Â§8; downstream still uses S3 order and S5 weights.)*

---

## B.4 Error codes *(hard FAIL; per-merchant unless noted)*

S6 **fails closed** with these canonical codes; map to S0 failure classes in ops dashboards.

* `E_UPSTREAM_GATE` â€” Missing/malformed required inputs or missing S5 PASS.
* `E_RNG_ENVELOPE` â€” Envelope/counter/trace breach (missing `before/after/blocks/draws`, no trace append, or cross-family writes).
* `E_LINEAGE_PATH_MISMATCH` â€” Embedded `{seed, parameter_hash, run_id}` not equal to path tokens.
* `E_SCHEMA_AUTHORITY` â€” Any S6 artefact fails its registered JSON-Schema.
* `E_NUMERIC_POLICY` â€” Violation of S0.8 numeric environment on decision paths.
* `E_EVENT_COVERAGE` â€” Missing/inconsistent `gumbel_key` coverage vs **considered** domain (when `log_all_candidates=true`).
* `E_DUP_PK` â€” Duplicate `(merchant_id, country_iso)` in membership surface (if emitted).
* `E_ORDER_INJECTION` â€” Any S6 output encodes or implies inter-country order.
* `E_POLICY_SCHEMA` / `E_POLICY_DOMAIN` â€” S6 policy fails JSON-Schema or value domains.
* `E_POLICY_CONFLICT` â€” Deterministic override resolution yields inconsistent state.
* `E_IO_ATOMICS` â€” Non-atomic publish, short write, or mismatched writer policy.

*(Exit codes for the runner are listed in Â§13.3 and are distinct from these `E_*` codes.)*

---

## B.5 Path patterns (authoritative excerpts)

* `logs/rng/events/gumbel_key/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` â†’ `schemas.layer1.yaml#/rng/events/gumbel_key`. 
* `logs/rng/events/ztp_final/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` â†’ `schemas.layer1.yaml#/rng/events/ztp_final`. 
* `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl` â†’ `schemas.layer1.yaml#/rng/core/rng_audit_log`. 
* `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl` â†’ `schemas.layer1.yaml#/rng/core/rng_trace_log`. 
* `data/layer1/1A/ccy_country_weights_cache/parameter_hash={parameter_hash}/` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache`. 
* *(Compat)* `data/layer1/1A/country_set/seed={seed}/parameter_hash={parameter_hash}/` â†’ `schemas.1A.yaml#/alloc/country_set` (**deprecated as order authority**). 

---

## B.6 Registry tie-ins (writer policy / compression)

* **Compression policy (when pinned):** `compression_zstd_level3` (ZSTD-3) in the Artefact Registry; when present, producers **MUST** adhere for byte-identity. 
* **Storage path pattern (egress reference):** `storage_path_pattern` documents fingerprint-scoped egress (e.g., `outlet_catalogue`). *(S6 writes seed+parameter-scoped RNG streams and receipts.)* 

---

## B.7 Cross-refs (normative)

* **S5 PASS receipt** location & semantics (parameter-scoped): `S5_VALIDATION.json` + `_passed.flag` under the weights cache partition. **Required before S6 reads.** 
* **Layer validation bundle** (fingerprint-scoped) for egress consumption remains unchanged. 

---

# Appendix C. Worked example *(Non-normative)*

> Tiny, concrete walk-through. Numbers are illustrative and computed in **binary64**; this appendix **does not** add requirements. Binding rules live in Â§Â§6â€“11 & Â§13.

## Setup (single merchant $m$)

* **S3 candidate set (home excluded from selection):**
  `home=GB (candidate_rank=0)`, foreigns:

  1. **FR** (rank 1) Â· 2) **DE** (rank 2) Â· 3) **ES** (rank 3) Â· 4) **IT** (rank 4) â‡’ **A=4**
* **S4 target:** `K_target = 2`.
* **S5 weights (raw, before subset renorm):** FR 0.25, DE 0.15, ES 0.10, IT 0.05 (sum over these four = **0.55**).
  Ephemeral **subset renormalisation** (foreign-only):
  FR 0.454545â€¦, DE 0.272727â€¦, ES 0.181818â€¦, IT 0.090909â€¦ (sum = 1.0).
* **Policy:** `log_all_candidates=true`, `max_candidates_cap=0`, `zero_weight_rule="exclude"`.

## Gumbel keys & key values

For each **considered** candidate $c$: draw $u_c\in(0,1)$, compute
$G_c=-\ln(-\ln u_c)$, $S_c=\ln(w_c)+G_c$ (binary64). Stable iteration = **S3 rank**.

| S3 rank | ISO | $w_{\text{raw}}$ | $w_{\text{norm}}$ |  $u$ |       $G$ | $\ln w_{\text{norm}}$ |           $S$ | Selected? |
|--------:|:---:|-----------------:|------------------:|-----:|----------:|----------------------:|--------------:|:---------:|
|       1 | FR  |             0.25 |          0.454545 | 0.22 | âˆ’0.414840 |             âˆ’0.788457 |     âˆ’1.203297 |           |
|       2 | DE  |             0.15 |          0.272727 | 0.51 |  0.395498 |             âˆ’1.299283 |     âˆ’0.903785 |   **âœ“**   |
|       3 | ES  |             0.10 |          0.181818 | 0.73 |  1.156101 |             âˆ’1.704748 | **âˆ’0.548647** |   **âœ“**   |
|       4 | IT  |             0.05 |          0.090909 | 0.04 | âˆ’1.169032 |             âˆ’2.397895 |     âˆ’3.566927 |           |

**Result:** sort by $S$ (desc) â†’ **ES**, **DE**, FR, IT.
Since `K_target=2`, **$K_{\text{realized}}=\min(2,4)=2$** â†’ selected set = **{ES, DE}**.
*(No tie encountered; if (S) ties in binary64, break by **S3 `candidate_rank`**, then ISO Aâ†’Z.)*

## RNG evidence (events & trace)

* With `log_all_candidates=true`, **one** `rng_event.gumbel_key` per **considered** candidate (here 4 events), appended in **S3-rank order**: FR â†’ DE â†’ ES â†’ IT.
* **Budgets:** each event consumes **`blocks=1`, `draws="1"`** (single-uniform family).
* **Trace:** exactly **4** `rng_trace_log` appends; final totals for `(module="1A.foreign_country_selector", substream_label="gumbel_key")` are:
  `events_total=4`, `blocks_total=4`, `draws_total=4`.
* Validator **re-derives** the membership from logged keys + S3/S5 and matches **{ES, DE}**.

## Persisted order (authority separation)

* If a **membership** dataset is emitted, it contains **unordered** pairs `(merchant_id, country_iso)` (writer-sorted only).
* Any **display/order** of the selected set **MUST** be obtained by **joining S3** and using `candidate_rank` (here the projected order would appear as **DE (rank 2), ES (rank 3)**). **S6 does not encode inter-country order.**

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s7-expanded"></a>
# state.1A.s7.expanded.txt

<!-- Source file: state.1A.s7.expanded.v1.6.txt | BYTE-EXACT EMBED -->

# S7 â€” Integer Allocation Across Legal Country Set (Layer 1 Â· Segment 1A)

# 0) Document metadata & status **(Binding)**

**0.1 State ID, semver, effective date**

* **State ID (canonical):** `layer1.1A.S7` â€” â€œInteger Allocation Across Legal Country Set.â€
* **SemVer:** **MAJOR.MINOR.PATCH**. **MAJOR** when any binding interface changes (dataset IDs or `$ref` schema anchors, partition law, PASS-gate semantics, tie-break rules, or event family shapes); **MINOR** for backward-compatible additions (optional fields/metrics); **PATCH** for clarifications with zero behavioural or schema impact. 
* **Effective date:** set by release management at ratification (`effective_date: YYYY-MM-DD`). 

**0.2 Normative language**
This spec uses RFC 2119/8174 terms (**MUST/SHALL/SHOULD/MAY**) with their normative meanings. Unless explicitly labelled *Informative*, every clause here is **Binding**. 

**0.3 Sources of authority (precedence)**

1) **JSON-Schema is the single schema authority** for all 1A inputs/outputs/logs: `schemas.ingress.layer1.yaml`, `schemas.1A.yaml`, `schemas.layer1.yaml`. Avro (if present) is non-authoritative.
2) The **Dataset Dictionary** (`dataset_dictionary.layer1.1A.yaml`) governs dataset IDs, paths, partitions, writer sorts, PK/FK, retention, and licence classes.
3) **This S7 spec** (behavioural rules) sits beneath those authorities.

**0.4 Compatibility window (S0â€“S6 baselines; numeric environment)**

* **Schema/Dictionary lines:** This S7 spec assumes `schemas.ingress.layer1.yaml v1.0`, `schemas.1A.yaml v1.0`, `schemas.layer1.yaml v1.0`, and `dataset_dictionary.layer1.1A.yaml v1.0` remain on their **v1.* line**; a **MAJOR** bump in any of these requires S7 re-ratification.  
* **Numeric environment:** S7 **inherits S0.8 verbatim** â€” IEEE-754 **binary64**, **round-to-nearest ties-to-even (RNE)**, **FMA off**, **no FTZ/DAZ**, deterministic libm profile; decision/ordering kernels execute in fixed serial order. The artefacts `numeric_policy.json` and `math_profile_manifest.json` are part of the S0 manifest and flipping either changes the fingerprint.  

**0.5 Run sealing & lineage (identifiers, partitions, equality)**

* **Lineage keys:** Use `{seed, parameter_hash, run_id}` exactly as defined layer-wide: `run_id` partitions **logs**; `parameter_hash` scopes parameter-derived datasets; `manifest_fingerprint` keys layer-egress/validation artefacts. 
* **RNG envelope (for any S7 events):** envelope fields are mandatory (incl. `run_id`, `seed`, `parameter_hash`, `manifest_fingerprint`) with **UTC timestamps carrying exactly 6 fractional digits**. 
* **Pathâ†”embed equality:** Where lineage fields are embedded, their values **MUST** equal the partition tokens byte-for-byte; violations are **hard FAIL** during pre-flight. 
* **Gated consumption (platform rule):** Producers publish validation bundles and a PASS flag; consumers refuse to read otherwise (**no PASS â†’ no read**). 

*(IDs and `$ref` anchors read/written by S7 are enumerated in Â§3; this section only freezes identity, authority, compatibility, and lineage law.)*

---

# 1) Intent, scope, non-goals **(Binding)**

**Intent (what S7 does).**
S7 takes **N** from S2, the **ordered legal country set** from S3, **currencyâ†’country weights** from S5, and the **selected foreign membership** from S6, then produces **deterministic integer counts per country** that **sum exactly to N**. It records a **`residual_rank`** for the largest-remainder rounding step. S7 **does not** create or persist any inter-country order; consumers continue to use S3â€™s `candidate_rank` as the **sole authority** for cross-country order.    

**Scope (what S7 covers).**
S7 SHALL:

* Allocate counts over the **domain = {home} âˆª (S6-selected foreigns)**, respecting S3â€™s total, contiguous **`candidate_rank`** (home at rank 0). **Order authority remains S3.** 
* Use **S5 `ccy_country_weights_cache`** as the weight authority; S7 MAY only **ephemerally** restrict/renormalise it to the domain (no persistence). 
* Treat **S2 `nb_final.n_outlets â†’ N`** and **S4 `ztp_final.K_target`** as read-only facts (no reinterpretation). 
* Emit one deterministic **`rng_event.residual_rank`** row per domain country (draws=`"0"`; blocks=0), with a trace append after each event. 
* Default to **deterministic-only** operation (no RNG consumption). A feature-flagged **Dirichlet lane** MAY exist (policy OFF by default) and is specified elsewhere in Â§4.4.

**Non-goals (what S7 MUST NOT do).**
S7 MUST NOT:

* **Pick countries** (that is S6), **define or encode inter-country order** (that is S3), or **persist weights** (that is S5).   
* **Materialise sites or within-country site order** (that is S8; egress `outlet_catalogue` explicitly does **not** encode cross-country order). 
* **Alter** S2â€™s **N** or S4â€™s **`K_target`**, or reinterpret any S4 audit fields beyond reading `K_target`. 
* **Write a counts dataset** as a new authority surface by default; counts flow forward to S8. (Any future S7 counts cache would require a dictionary ID and schema anchor before use.) 

**Outcome (success criteria).**
On completion, for every merchant S7 provides: (i) per-country **integer counts** that sum to **N** over the domain; (ii) a complete set of **`residual_rank`** events consistent with the deterministic largest-remainder rounding; and (iii) no new order or weight surfaces introducedâ€”**S3/S5 remain the authorities**.   

---

# 2) Interfaces & â€œno re-deriveâ€ boundaries **(Binding)**

**2.1 Upstream authorities S7 MUST trust (read-side contracts).**
S7 reads **only** the artefacts below, at the stated `$ref` anchors and partitions. Embedded lineage fields (where present) **MUST** byte-equal the path tokens (pathâ†”embed equality).

* **Domestic count (fact):** `rng_event.nb_final` â†’ `schemas.layer1.yaml#/rng/events/nb_final`, partitioned by `{seed, parameter_hash, run_id}`. **Exactly one** per resolved merchant; `n_outlets (N) â‰¥ 2`; **non-consuming** envelope. 
* **Foreign target (fact):** `rng_event.ztp_final` â†’ `schemas.layer1.yaml#/rng/events/ztp_final`, partitioned by `{seed, parameter_hash, run_id}`. **Exactly one** per resolved merchant **unless** S4 aborted; S7 treats only `K_target` as a decision fact (other fields audit-only).
* **Inter-country order & domain base:** `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set`, partitioned by `[parameter_hash]`. **Sole authority** for inter-country order; rank is **total & contiguous** per merchant with `home=0`. 
* **Weights authority:** `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache`, partitioned by `[parameter_hash]`. Group-sum per currency **= 1 Â± 1e-6**; **no order is implied**. **Gate:** S7 MUST read only when **S5 PASS** is present for the same `parameter_hash`.
* **Selected-foreign membership (optional convenience):** `s6_membership` â†’ `schemas.1A.yaml#/s6/membership`, partitioned by `{seed, parameter_hash}`. **Gate:** S7 MAY read **only** if **S6 PASS** exists for the same `{seed, parameter_hash}`. When absent, S7 **MUST** reconstruct membership from `rng_event.gumbel_key` (selected rows). **Order remains from S3.**
* **Membership via events (authoritative log):** `rng_event.gumbel_key` â†’ `schemas.layer1.yaml#/rng/events/gumbel_key`, partitioned by `{seed, parameter_hash, run_id}`; single-uniform budget (`blocks=1`, `draws="1"`); if `selected=true` then `1 â‰¤ selection_order â‰¤ K`. Zero-weights **must** carry `key:null` and canâ€™t be selected.
* **Merchantâ†’currency map (if produced):** `merchant_currency` â†’ `schemas.1A.yaml#/prep/merchant_currency`, partitioned by `[parameter_hash]`; **PK `(merchant_id)`**; Îºâ‚˜ in ISO-4217. If present, S7 **MUST NOT** override it. 

**2.2 Downstream consumers (write-side promises).**

* **S8 `outlet_catalogue`** consumes S7â€™s **per-country integer counts** to materialise sites. Egress **does NOT encode inter-country order**; consumers **MUST** join S3 `candidate_rank`. Egress remains gated by the layer **fingerprint PASS**; S7 does not alter that gate.
* **RNG logs:** S7 emits only its own event family (`residual_rank`; see Â§5/Â§6) and appends one cumulative `rng_trace_log` row **after each** event; readers treat event files as **set-semantics**. 

**2.3 â€œNo re-deriveâ€ boundaries (hard prohibitions & guarantees).**

* **Order authority:** S7 **MUST NOT** create, persist, or imply any inter-country order. **S3 `candidate_rank` is sole authority**; S8 and any consumer **MUST** continue to join it. 
* **Weights authority:** S7 **MUST NOT** persist weights or alter S5 values. Any subset/renormalisation used for allocation is **ephemeral** and **not written**. 
* **S4 facts:** S7 **MUST NOT** reinterpret S4 fields beyond reading `K_target`. `lambda_extra`, `regime`, `attempts`, `exhausted?` remain **audit-only**. 
* **Membership authority:** If `s6_membership` is read, S7 treats it as the membership set but **MUST** still obtain order from S3; if not read, S7 reconstructs membership **only** from `rng_event.gumbel_key` selection flags (or counter-replay per S6 rules), **never** from S7-invented logic.
* **Egress scope:** By default, S7 **MUST NOT** publish a new counts dataset as an authority surface; counts flow into S8. Any future S7 counts cache would require a Dictionary ID and schema anchor. 

**2.4 Lineage, partitions, and gates (enforcement summary).**

* **Partitions:** events/logs under `{seed, parameter_hash, run_id}`; parameter-scoped tables under `[parameter_hash]`. Pathâ†”embed equality is binding.
* **PASS discipline:** **S5 PASS** required before reading weights; **S6 PASS** required before reading any S6 convenience surface; layer **egress PASS** governs `outlet_catalogue`. **No PASS â†’ no read.**

---

# 3) Inputs â€” datasets, schemas, partitions & gates **(Binding)**

**3.1 Required inputs (ID â†’ `$ref`, partitions, what S7 uses).**

* **Domestic count (fact):** `rng_event.nb_final` â†’ `schemas.layer1.yaml#/rng/events/nb_final` â€” **partitions:** `{seed, parameter_hash, run_id}`. S7 reads **`n_outlets (N) â‰¥ 2`** as the total to allocate; one record per resolved merchant.  
* **Order & domain base (sole authority):** `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` â€” **partitions:** `[parameter_hash]`. Guarantees a **total, contiguous** `candidate_rank` with **home=0**; S7 reads only order + admissible set.  
* **Foreign-target fact (for consistency checks):** `rng_event.ztp_final` â†’ `schemas.layer1.yaml#/rng/events/ztp_final` â€” **partitions:** `{seed, parameter_hash, run_id}`. S7 may assert `|membership| = min(K_target, |Eligible|)`; other fields remain audit-only. 
* **Weights authority:** `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache` â€” **partitions:** `[parameter_hash]`. Per-currency group sum **= 1 Â± 1e-6**; S7 **ephemerally** restricts/renormalises to the S7 domain (no persistence). **Gate:** **S5 PASS required.**  

**3.2 Conditional / optional inputs.**

* **Selected-foreign membership (convenience only):** `s6_membership` â†’ `schemas.1A.yaml#/s6/membership` â€” **partitions:** `{seed, parameter_hash}`. **Gate:** **S6 PASS** for same `{seed, parameter_hash}`. If absent, S7 reconstructs membership from `rng_event.gumbel_key` selections; **order still comes from S3.**    
* **Membership via events (authoritative log when needed):** `rng_event.gumbel_key` â†’ `schemas.layer1.yaml#/rng/events/gumbel_key` â€” **partitions:** `{seed, parameter_hash, run_id}`. Used only when `s6_membership` is not emitted; if `selected=true` then `1 â‰¤ selection_order â‰¤ K`.
* **Merchantâ†’currency map (if produced):** `merchant_currency` â†’ `schemas.1A.yaml#/prep/merchant_currency` â€” **partitions:** `[parameter_hash]`. If present, S7 **MUST NOT** override it when resolving the merchantâ€™s currency for the S5 weight vector. 

**3.3 Gates S7 MUST verify before reading.**

* **S6 PASS (convenience reads):** To read any S6-derived dataset (e.g., `s6_membership`), S7 verifies the **S6 receipt** at `data/layer1/1A/s6/seed={seed}/parameter_hash={parameter_hash}/(S6_VALIDATION.json, _passed.flag)` and checks the flagâ€™s content hash. **No PASS â†’ no read.** 
* **S5 PASS (weights):** To read `ccy_country_weights_cache`, S7 honours S5â€™s **parameter-scoped PASS** sidecar (`S5_VALIDATION.json` + `_passed.flag`) colocated under the weights partition. **No PASS â†’ no read.** 

**3.4 Partition keys, lineage, and equality (enforcement).**

* **Events/logs** are partitioned by `{seed, parameter_hash, run_id}`; **parameter-scoped tables** by `[parameter_hash]`. Embedded lineage (where present) **MUST byte-equal** path tokens (pathâ†”embed equality). 
* **Core RNG logs** (`rng_audit_log`, `rng_trace_log`) exist under the same event partitions and are used by validators; S7 does not need to read them to allocate counts. 

**3.5 FK & encoding baselines (domains).**

* **ISO / currency codes:** uppercase **ISO-3166-1 alpha-2** for `country_iso`, uppercase **ISO-4217** for `currency` across all inputs (FKs enforced where declared). 
* **Deprecated surfaces (MUST NOT read):** `country_set` (legacy, seed+parameter partitions) is **not** an order authority; S7 **MUST NOT** consume it. Use `s3_candidate_set` instead. 

---

# 4) Configuration & policy **(Binding)**

**4.1 Residual quantisation precision (binding).**
S7 **MUST** quantise residuals at **`dp_resid = 8`** **before** any tie-breaks or ranking. Quantisation uses the S0 numeric profile (binary64, RNE). This mirrors the binding residual-dp discipline already used for integerisation elsewhere. 

**4.2 Decimal rounding algorithm (binding).**
Quantise via the fixed **ties-to-even** decimal rule: let `s = 10^dp_resid`; compute `q = round_RNE(value * s) / s` in binary64, then use `q` for all downstream comparisons and ordering. 

**4.3 Deterministic tie-break order (binding).**
When ranking residuals to distribute the remainder, apply a **total** and **stable** order:

1. **Residual** (quantised) **descending**; 
2. **ISO-3166-1 alpha-2** code **Aâ†’Z**; 
3. **`candidate_rank` ascending**; 
4. stable input index. Persist `residual_rank` as the **1-based** position in this order.

**4.4 Optional bounds policy (Hamilton-style) (feature-flag; default: OFF).**
If enabled, S7 enforces per-country integer **floors/ceilings** and uses a bounded Hamilton procedure with a hard feasibility guard `Î£L_i â‰¤ N â‰¤ Î£U_i`; capacities restrict bumps and residual ranking is applied only to countries with remaining capacity. If infeasible at any step, S7 **MUST** fail the merchant (no partial outputs).

**4.5 Logging mode (binding).**
S7 **MUST** emit one **`rng_event.residual_rank`** per `(merchant_id, country_iso)` in the domain, with **non-consuming** envelope (i.e., `draws="0"`, `blocks=0`) and then append **exactly one** cumulative **`rng_trace_log`** row **after each** event append. Event files are **set-semantics** (readers must not assume file order).

**4.6 RNG lane switch (Dirichlet) (feature-flag; default: OFF).**
If the **Dirichlet lane** is enabled by policy, S7 **MAY** emit exactly one `rng_event.dirichlet_gamma_vector` per merchant (arrays for `{alpha[], gamma_raw[], weights[]}`) in addition to Â§4.5 logs. Î±-vector formation **MUST** produce strictly positive Î± and be **mean-anchored** to the S5 weights restricted to the S7 domain (policy defines Î±â‚€; this spec requires Î±>0 and domain-normalisation only). When this lane is **OFF** (default), S7 remains **deterministic-only** and **MUST NOT** consume RNG for allocation. 

**4.7 Pass-through of upstream authorities (binding).**
S7 **MUST NOT** persist any new weight surface and **MUST NOT** encode or imply inter-country order; any subset/renormalisation of S5 weights is **ephemeral** to the allocation step, and inter-country order **always** comes from S3 `candidate_rank`.

**4.8 Gates inherited by configuration (binding).**
Reading any S6 convenience surface requires a **valid S6 PASS**; reading S5 weights requires a **valid S5 PASS**. **No PASS â†’ no read.** (These gates are enforced even when S7 runs deterministic-only.)

**4.9 Enumerations & labels (binding, listed in Appendix A).**
`module`, `substream_label`, error codes, and tie-break keys are frozen literals. Producers **MUST** use the Appendix A values when emitting `rng_event.residual_rank` (and `dirichlet_gamma_vector` if enabled). (See also Â§2.4 for partition/lineage rules.) 

---

# 5) Outputs â€” datasets/logs & contracts **(Binding)**

**5.1 Event logs S7 MUST emit.**

* **`rng_event.residual_rank`** â€” one row **per (`merchant_id`, `country_iso`)** in the S7 domain; **non-consuming** envelope (**`draws="0"`, `blocks=0`**); **partition:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`; **schema:** `schemas.layer1.yaml#/rng/events/residual_rank`. Persist `residualâˆˆ[0,1)` and **`residual_rankâ‰¥1`** (1=largest). After **each** event append, S7 **MUST** append exactly one cumulative row to **`rng_trace_log`** for `(module, substream_label)`. **Module/Substream (normative):** `module="1A.integerisation"`, `substream_label="residual_rank"`.
  *Envelope fields follow the layer law: `ts_utc` is RFC3339 with **exactly 6 fractional digits**, lineage fields present, and pathâ†”embed equality holds.* 

* **(Feature-flag lane; default OFF)** **`rng_event.dirichlet_gamma_vector`** â€” **at most one** row **per merchant** when Dirichlet allocation is enabled by policy; **partition:** `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`; **schema:** `schemas.layer1.yaml#/rng/events/dirichlet_gamma_vector`. Arrays `{country_isos, alpha, gamma_raw, weights}` **MUST** be equal length; `weights` sum to **1 Â± 1e-6**. **Module/Substream (normative):** `module="1A.dirichlet_allocator"`, `substream_label="dirichlet_gamma_vector"`. **S7 does not emit** per-component `gamma_component` events.
  *Order of `country_isos` when S7 produces this event:* **home first, then foreigns in S3 `candidate_rank` order filtered to membership** (supersedes the current help-text wording; see Â§12 for the doc patch). 

**5.2 Core RNG logs S7 MUST update.**

* **`rng_trace_log`** â€” append **exactly one** cumulative row **after each S7 event append**; partitions `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`; **schema:** `schemas.layer1.yaml#/rng/core/rng_trace_log`. Totals reconcile (`events_total`, `draws_total`, `blocks_total`). **Reader semantics are set-based** (no reliance on file order). 

**5.3 Datasets S7 MUST/MUST NOT publish.**

* **MUST NOT** publish any **inter-country order** surface. Egress `outlet_catalogue` **does not encode** cross-country order; consumers **MUST** join S3 `candidate_rank`. 
* **MUST NOT** persist a new **weights** table. S5 remains the single authority. 
* **No counts table by default.** Integer counts flow forward into S8; any future S7 counts cache would require a **Dictionary ID** and **schema anchor** before use. (Note: the only registered counts table today is **`s3_integerised_counts`**, produced by S3, not S7.) 

**5.4 Partitions, lineage & equality (enforcement).**

* All S7 events/logs are partitioned by **`{seed, parameter_hash, run_id}`**; embedded lineage (when present) **MUST byte-equal** the path tokens. **`ts_utc`** MUST match the layer pattern with **6-digit microseconds**. **Hard-fail** on mismatches.

**5.5 Module/substream literals (frozen).**

* `rng_event.residual_rank` â†’ `module="1A.integerisation"`, `substream_label="residual_rank"`. (Dictionary shows producer lineage **1A.integerisation**.) 
* `rng_event.dirichlet_gamma_vector` (if enabled) â†’ `module="1A.dirichlet_allocator"`, `substream_label="dirichlet_gamma_vector"`. (Dictionary shows producer lineage **1A.dirichlet_allocator**.) 
Frozen literals are declared once in **Appendix A** (A.1 `module`, A.2 `substream_label`). Producers and validators **MUST** use exactly those values; do not introduce variants here. See Appendix A for the binding pairs used by S7.

**5.6 Publishing discipline & retention.**

* **Atomic publish:** stage â†’ fsync â†’ **atomic rename** into the Dictionary path; no partials. (Same discipline as S3/S6; inherited layer convention.) 
* **Retention (Informative):** event streams (e.g., `residual_rank`, `dirichlet_gamma_vector`) typically **180 days**; core RNG logs **365 days**.

**5.7 Prohibitions (isolation).**
S7 writes **only** the families above. It **MUST NOT** write S1â€“S6 event families (e.g., `gumbel_key`, `poisson_component`, `nb_final`, `ztp_*`) nor any S8 egress. Those are owned by their respective states. 

---

# 6) Deterministic processing specification â€” no pseudocode **(Binding)**

**6.0 Pre-flight (per merchant).**
S7 MUST confirm presence/schema-pass of: `nb_final` (read `N`), `s3_candidate_set` (order/domain base), `ccy_country_weights_cache` (weights), and either `s6_membership` (if emitted, with S6 PASS) **or** sufficient S6 RNG events to reconstruct membership; embedded lineage MUST byte-equal the path tokens. **No PASS â†’ no read.**   

---

**6.1 Domain assembly (ordered legal set).**
a) Start from **S3** candidates for the merchant; this is the **sole** inter-country order authority (`candidate_rank` total & contiguous; `home=0`). 
b) Membership of foreigns comes from **S6**: if the `s6_membership` convenience dataset is emitted (and PASSed), use it; else reconstruct **exactly** from S6 RNG events (selected flags in `gumbel_key`, or counter-replay per S6 rules). In all cases, **order remains from S3**.  
c) Define the **domain** $D$ = {home} âˆª (S6-selected foreigns) as an **ordered set** keyed by S3 `candidate_rank` (home first). If $K_{target}=0$ or S6 selected set is empty, set $D={\text{home}}$.  

> **Order is S3 `candidate_rank` (home=0). File order is non-authoritative.**

---

**6.2 Share vector for allocation (ephemeral; not persisted).**
a) Resolve the merchantâ€™s currency (from S5, e.g., `merchant_currency` if produced); read the **weights authority** `ccy_country_weights_cache`. 
b) **Restrict** the S5 weight vector to countries in $D$ and **ephemerally renormalise** (binary64, RNE) so that $\sum_{i\in D} s_i = 1.0$ (subject to rounding). **Do not persist** the restricted or renormalised vector. 
c) **Feasibility guard:** if $\sum_{i\in D} s_i = 0$ (should not occur given S5â€™s per-currency $\sum=1$), S7 **MUST** hard-fail this merchant (`E_ZERO_SUPPORT`). 

---

**6.3 Fractional targets (numeric profile inherited from S0).**
For each $i\in D$, compute $a_i = N \cdot s_i$ in **binary64 / RNE** (S0 numeric law). No stochasticity is involved. 

---

**6.4 Floor step and remainder law.**
Set $b_i = \lfloor a_i \rfloor$ (integer floors). Define the remainder $d = N - \sum_{i\in D} b_i$. It MUST hold that $0 \le d < |D|$. 

---

**6.5 Residuals and quantisation (binding dp).**
Define residuals $r_i = a_i - b_i$. Quantise each residual to **`dp_resid = 8`** using the S0 rounding rule (ties-to-even) and carry the quantised value forward for **all** downstream comparisons and logging (the unquantised residual MUST NOT be used for any ordering). Persist this quantised residual in the S7 event payload. 

---

**6.6 Deterministic bump rule (no new order is created).**
Distribute the remainder by awarding **+1** to exactly **$d$** countries, using the **total order defined in Â§4.3** (residual first, then the declared tie-breakers). The resulting per-country counts are $c_i = b_i + \mathbf{1}\{ i \text{ is in the top } d \}$.
**Persist** a `residual_rank` for every $i\in D$ as the **1-based** position in that total order (1 = highest residual after quantisation). **Inter-country order remains S3 `candidate_rank`; S7 writes no order surface.** 

---

**6.7 Optional bounded variant (feature-flag; default OFF).**
If a **bounds policy** is configured, S7 enforces integer floors/ceilings $L_i \le c_i \le U_i$:
a) **Feasibility check**: $\sum L_i \le N \le \sum U_i$; otherwise **hard-fail** the merchant (`E_BOUNDS_INFEASIBLE`).
b) Apply the floor step $b_i \leftarrow \max(b_i, L_i)$; recompute $d$.
c) During the bump, only countries with remaining **capacity** $b_i < U_i$ participate in the residual order; ties resolved by the same total order.
This variant MUST NOT change any other contract (no new datasets, no new order surface). 

---

**6.8 Event & trace discipline (write-side).**
a) Emit exactly **one** `rng_event.residual_rank` **per (`merchant_id`, `country_iso`) in $D$**, with **non-consuming** envelope (`draws="0"`, `blocks=0`).
b) After **each** event append, emit **one** cumulative `rng_trace_log` row for `(module="1A.integerisation", substream_label="residual_rank")`.
c) If the **Dirichlet lane** is enabled by policy, S7 MAY also emit exactly one `dirichlet_gamma_vector` **per merchant**; otherwise it MUST NOT consume RNG. Event files are **set-semantics**; readers MUST NOT rely on row/file order.  

---

**6.9 Degenerate/single-country path.**
If $D={\text{home}}$: set $s_{\text{home}}=1$, $a_{\text{home}}=N$, $b_{\text{home}}=N$, $d=0$, $c_{\text{home}}=N$. Emit a single `residual_rank` for home with residual **0.00000000** and **rank=1**; no events are emitted for absent countries. 

---

**6.10 Success conditions (checked again in Â§7/Â§9).**

* **Sum law:** $\sum_{i\in D} c_i = N$; each $c_i \ge 0$.
* **Proximity law:** $|c_i - N\cdot s_i| \le 1$ for all $i\in D$.
* **Authority boundaries:** S3 `candidate_rank` remains the only cross-country order; S5 remains the only weights authority; S7 wrote **no** new order/weight surface.  

---

# 7) Invariants & integrity constraints **(Binding)**

**7.1 Allocation laws (must hold per merchant).**

* **Sum law:** The per-country integer counts **MUST** sum to **`N`** and each **`count_i â‰¥ 0`**.
* **Proximity law:** For every country in the S7 domain, **`|count_i âˆ’ NÂ·s_i| â‰¤ 1`** (Largest-Remainder property under fixed dp). 
* **Bounds variant (if enabled):** If floors/ceilings are in force, S7 **MUST** satisfy **`Î£ L_i â‰¤ N â‰¤ Î£ U_i`** and **`L_i â‰¤ count_i â‰¤ U_i`**; otherwise S7 **FAILS** the merchant. 

**7.2 Domain & order authority.**

* **Domain law:** S7 allocates only over **`D = {home} âˆª (S6-selected foreigns)`**; when `K_target=0` or the foreign set is empty, S7 **MUST** allocate **all `N`** to **home**. 
* **Order authority separation:** S3â€™s `s3_candidate_set.candidate_rank` remains the **sole** inter-country order; S7 **MUST NOT** create, encode, or imply any cross-country order. Downstream consumers (incl. `outlet_catalogue`) **MUST** join S3 for order.

**7.3 Relationship to S4/S6 facts.**

* **Target vs. realised size:** S6 realises the membership size **`K_realized = min(K_target, |Eligible|)`**; S7 **MUST** accept that membership as given and **MUST NOT** reinterpret S4 fields beyond reading `K_target`.
* **No weight persistence:** S5 `ccy_country_weights_cache` is the weight authority; any restriction/renormalisation used by S7 is **ephemeral** and **MUST NOT** be persisted. **No PASS â†’ no read** for S5 surfaces. 

**7.4 Residual & ranking integrity.**

* **Residual range:** The residual recorded per country is in **`[0,1)`** (exclusive of 1.0) and is the **quantised** value used for ordering. 
* **Quantisation discipline:** Residuals **MUST** be quantised to **`dp_resid = 8`** under binary64 RNE **before** any ordering. 
* **Total & contiguous residual order:** `residual_rank` is a **1-based**, contiguous ranking within the domain; ties **MUST** break by **ISO Aâ†’Z** (then S3 `candidate_rank`), yielding a total, stable order consistent with S3. 

**7.5 Event/logging invariants.**

* **Per-domain coverage:** S7 **MUST** emit exactly **one** `rng_event.residual_rank` per `(merchant_id, country_iso)` in the S7 domain. (Non-consuming: `draws="0"`, `blocks=0`.) 
* **Trace cadence:** After **each** S7 event append, **exactly one** cumulative `rng_trace_log` row is appended; totals reconcile for the `(module, substream_label)` key. 
* **Envelope legality:** All S7 RNG events carry the layer envelope with **`ts_utc`** in RFC-3339 UTC with **exactly 6 fractional digits**, and counters satisfy the **blocks = after âˆ’ before** identity. 

**7.6 Partitions, lineage & path discipline.**

* **Partition law:** S7 events/logs are under `{seed, parameter_hash, run_id}`; any embedded lineage fields **MUST** byte-equal the path tokens (**pathâ†”embed equality**). Parameter-scoped tables (if any) are under `[parameter_hash]`. 
* **Set semantics:** Readers **MUST NOT** rely on file order for S7 event streams; semantics are set-based. (Ordering for joins comes from S3.) 

**7.7 Determinism & idempotence.**

* With identical `{seed, parameter_hash, run_id}` and identical upstream inputs, S7 **MUST** produce byte-identical outputs (events and values). Any input change **requires** a new `run_id` (see Â§10). 

**7.8 Gating & consumption.**

* **Upstream gates:** To read any S6 convenience surface, S7 **MUST** verify the **S6 PASS** receipt for the same `{seed, parameter_hash}`; to read S5 weights, S7 **MUST** verify S5 PASS for the same `parameter_hash`. **No PASS â†’ no read.** 
* **Downstream gate:** S8 **MUST** verify the presence of the complete S7 residual-rank event set and continue enforcing the layerâ€™s egress PASS when materialising `outlet_catalogue`. 

**7.9 Prohibitions (must never occur).**

* S7 **MUST NOT** publish a new inter-country order surface; **MUST NOT** persist a new weights table; and **MUST NOT** emit S1â€“S6 event families. (S7 writes only its own event family/families per Â§5.)

---

# 8) Error handling, edge cases & degrade ladder **(Binding)**

**Purpose.** Define what S7 must treat as **errors** (hard-fail per merchant / run), what counts as **deterministic non-errors** (degrade but valid), and what **gates** must be enforced before any read/write.

---

## 8.1 Pre-flight gates (hard requirements)

S7 **MUST** fail a merchant **before compute** if any of the following are missing or invalid:

* **PASS receipts:** Attempt to read an S6 convenience surface without a valid **S6 PASS** for the same `{seed, parameter_hash}`; or attempt to read S5 weights without a valid **S5 PASS** for the same `parameter_hash`. **No PASS â†’ no read.** â†’ `E_PASS_GATE_MISSING`.
* **Schema/lineage:** Any required input fails its `$ref` schema or **pathâ†”embed equality** (embedded lineage fields differ from partition tokens). â†’ `E_SCHEMA_INVALID` / `E_PATH_EMBED_MISMATCH`.
* **Authority presence:** `s3_candidate_set` not present/valid (total, contiguous `candidate_rank`, `home=0`) or S4/S2 fact streams (`ztp_final`, `nb_final`) absent/invalid. â†’ `E_UPSTREAM_MISSING`.

---

## 8.2 Domain & membership edge cases

* **Deterministic single-country domain (non-error):** If `K_target=0` **or** the S6-selected foreign set is empty, S7 **MUST** allocate all **`N`** to **home** and still emit one `residual_rank` (residual=0, rank=1). â†’ `DEG_SINGLE_COUNTRY` (diagnostic only). 
* **Membership not a subset of S3 (error):** If any S6-selected foreign ISO is not in S3â€™s admissible set for the merchant, S7 **MUST** fail the merchant (authority breach). â†’ `E_S6_NOT_SUBSET_S3`. 

---

## 8.3 Weight support & zero-mass checks

* **Zero support on domain (error):** If the S5 weight vector, **restricted to the S7 domain**, sums to 0 (should not occur given per-currency Î£=1), S7 **MUST** hard-fail the merchant and produce no outputs. â†’ `E_ZERO_SUPPORT`. 
* **Renormalisation (non-error):** Restrict-and-renormalise to domain (ephemeral) is allowed and **MUST NOT** be persisted by S7. (S5 remains the weight authority.) 

---

## 8.4 Bounds policy variant (feature-flag; default OFF)

When the **bounded Hamilton** variant is enabled:

* **Feasibility:** If `Î£ L_i > N` or `Î£ U_i < N`, S7 **MUST** fail the merchant; no partial writes. â†’ `E_BOUNDS_INFEASIBLE`.
* **Capacity during bump:** During remainder distribution, only countries with `b_i < U_i` participate; if capacity exhaustion prevents allocating all `d` units, S7 **MUST** fail the merchant. â†’ `E_BOUNDS_CAP_EXHAUSTED`.
* **No new authorities:** This variant **MUST NOT** create any new weight/order surface. (S3/S5 remain authorities.) 

---

## 8.5 RNG isolation & accounting (applies even when deterministic)

* **Residual-rank events:** `rng_event.residual_rank` **MUST** be **non-consuming** (`draws="0"`, `blocks=0`). Missing or malformed envelope/lineage is **FAIL**. â†’ `E_RNG_ENVELOPE`. 
* **Trace cadence:** After **each** S7 event append, append **exactly one** cumulative `rng_trace_log` row; totals reconcile for `(module, substream_label)`. Missing/misaligned trace rows are **FAIL**. â†’ `RNG_ACCOUNTING_FAIL`. 
* **Dirichlet lane (if enabled):** Arrays `{country_isos, alpha, gamma_raw, weights}` must be equal length; `alpha_i>0`; Î£`weights`=1Â±1e-6; otherwise **FAIL**. â†’ `E_DIRICHLET_SHAPE` / `E_DIRICHLET_NONPOS` / `E_DIRICHLET_SUM`. (Lane is **OFF by default**.) 

---

## 8.6 Integerisation integrity

* **Sum law breach:** If Î£ counts â‰  **N** or any `count_i<0`, S7 **MUST** fail the merchant. â†’ `INTEGER_SUM_MISMATCH`.
* **Ranking discipline:** Residuals **MUST** be quantised at `dp_resid=8` **before** ordering; `residual_rank` is 1-based, total & contiguous. Violations are **FAIL**. â†’ `E_RESIDUAL_QUANTISATION`. 

---

## 8.7 I/O integrity & publish atomics

* **Atomic publish:** Writers **MUST** stage â†’ fsync â†’ **atomic rename** into Dictionary paths; no partials. Any short write, partial instance, or partition mismatch is **FAIL**. â†’ `E_IO_ATOMICS`. 
* **Set semantics:** Readers **MUST NOT** rely on file order for event streams. (Order for joins continues to come from S3.) 

---

## 8.8 Per-merchant outcomes (closed set)

* **`SUCCESS`** â€” Merchant processed; all invariants in Â§7 hold; events logged; ready for S8 consumption once layer egress PASS is satisfied. 
* **`STRUCTURAL_FAIL`** â€” Any Â§8.1/Â§8.2/Â§8.7 failure (schema/lineage/gate/authority/IO).
* **`INTEGERISATION_FAIL`** â€” Any Â§8.6 breach (sum law, residual quantisation/ranking discipline).
* **`RNG_ACCOUNTING_FAIL`** â€” Any Â§8.5 envelope/trace reconciliation breach. 
* **`BOUNDS_FAIL`** â€” Any Â§8.4 infeasibility or capacity-exhaustion when bounds are enabled.

*(Numeric exit codes, if used by your runner, can be enumerated in Appendix A with their textual labels; this spec fixes the meanings.)*

---

## 8.9 Degrade ladder (non-error determinism)

S7 recognises the following **deterministic** conditions as **valid**, non-error outcomes. They **MUST** still satisfy Â§7 invariants and logging discipline:

* **`DEG_SINGLE_COUNTRY`** â€” Domain = {home}; all `N` allocated to home; one `residual_rank` emitted (residual=0, rank=1). 
* **`DEG_ZERO_REMAINDER`** â€” `d=0`; no bumps applied; residuals/ranks still logged for transparency.
* **`DEG_TIES_RESOLVED`** â€” Residual ties resolved by the binding tie-break order (ISO Aâ†’Z, then `candidate_rank`). *(Diagnostic only; not emitted in payloads.)*

---

## 8.10 Envelope timestamp & lineage strictness (reminder)

All S7 RNG events **MUST** carry `ts_utc` in RFC-3339 **UTC** with **exactly 6 fractional digits**, and embedded `{seed, parameter_hash, run_id, manifest_fingerprint}` **MUST** byte-equal the partition tokens. â†’ Mismatch **FAIL**. 

---

# 9) Validation battery & PASS gate **(Binding)**

**Purpose.** Prove that S7â€™s outputs are structurally correct, authority-compliant, and byte-replayable **before** S8 consumes them. S7 does **not** introduce a new receipt surface; the pre-read acceptance for S8 is defined here (S8 still obeys the layer egress PASS on `outlet_catalogue`). 

---

## 9.1 Structural & schema checks

The validator SHALL:

* Load all S7 event streams written by this state (at minimum `rng_event.residual_rank`) and assert **JSON-Schema pass** at their anchors, including envelope fields. For `residual_rank`: required fields, residual in **[0,1)** per description, `residual_rank â‰¥ 1`. 
* Enforce **`ts_utc` format with exactly 6 fractional digits** and RFC-3339 â€œZâ€, as required by the layer envelope. 

## 9.2 Lineage & partition discipline

* Assert **pathâ†”embed equality** for `{seed, parameter_hash, run_id}` on all S7 events (and any S6 convenience inputs read by the validator). 
* If the validator reads S6 or S5 convenience/authority surfaces, it MUST first verify their **PASS receipts** (S6 seed+parameter; S5 parameter). **No PASS â†’ no read.** 

## 9.3 Domain reconstruction & membership compliance

* Recompute the S7 **domain** $D$ from **S3** (`candidate_rank` total & contiguous; `home=0`) intersected with **S6 membership** (dataset if present, else reconstructed from `rng_event.gumbel_key` selection flags). Membership MUST be a subset of S3â€™s admissible set.
* If `K_target` exists (from S4), assert **`|membership| = min(K_target, |Eligible|)`** (informationalâ€”S7 does not reinterpret S4 beyond this). 

## 9.4 Weight authority & restriction

* Read **S5 `ccy_country_weights_cache`** (authority; parameter-scoped) and assert per-currency **Î£ weight = 1.0 Â± 1e-6** and domain legality (ISO FKs).
* **Restrict and renormalise ephemerally** to the S7 domain $D$ for re-derivation; validator MUST confirm that S7 **did not persist** any new weights surface. 

## 9.5 Integerisation re-derivation (deterministic)

Using **S0 numeric law** (binary64, RNE), the validator SHALL:

1. Compute $a_i=N\cdot s_i$ for all $i\in D$, then $b_i=\lfloor a_i\rfloor$ and $d=N-\sum b_i$.
2. Quantise residuals $r_i=a_i-b_i$ to **dp=8** (ties-to-even).
3. Order countries by the **binding tie-break** (residualâ†“, then ISO Aâ†’Z, then `candidate_rank`â†‘; stable) and award **+1** to the top $d$.
4. Reconstruct `residual_rank` and compare **byte-for-byte** to S7â€™s event payloads; assert **Î£ counts = N**, counts â‰¥ 0, and **$|c_i - N s_i|\le 1$**. 

## 9.6 RNG accounting & envelope legality

* For **`rng_event.residual_rank`**: assert **non-consuming** envelopes (`draws="0"`, `blocks=0`) and that **`rng_trace_log`** has **exactly one** cumulative append **after each** event; reconcile `events_total`, `draws_total`, and `blocks_total` for the `(module="1A.integerisation", substream_label="residual_rank")` key. 
* If the **Dirichlet lane** is enabled: assert equal-length arrays `{country_isos, alpha, gamma_raw, weights}`, **Î±áµ¢>0**, and **Î£ weights = 1 Â± 1e-6** at the event anchor. (S7 does **not** emit per-component `gamma_component` events.)

## 9.7 Bounds variant (when enabled)

* Verify feasibility **`Î£L_i â‰¤ N â‰¤ Î£U_i`**; apply capacity-aware bump checks; **fail** if allocating all $d$ units is impossible under capacity. (No new authority surfaces introduced.) 

## 9.8 Authority & isolation checks

* **Order:** Confirm S7 **did not** write any inter-country order surface; consumers must continue to join S3 `candidate_rank`. 
* **Weights:** Confirm S7 **did not** persist a new weights table; S5 remains authority. 
* **Legacy surfaces:** Ensure S7 does **not** revive `country_set` as an order authority (legacy; deprecated). 
* **Family isolation:** S7 wrote only its own event family (`residual_rank` and, if enabled, `dirichlet_gamma_vector`) and did **not** emit S1â€“S6 families. 

## 9.9 S8 pre-read acceptance (the â€œgateâ€)

S8 **MUST** verify, for the same `{seed, parameter_hash[, run_id]}`:

* Presence of a **complete** `residual_rank` set covering the S7 domain (one row per `(merchant_id,country_iso)`). 
* **PASS receipts** for any S6 convenience surfaces used by S8 (if any), and that S5 weights read by S8 are PASSed for the `parameter_hash`. 
* Layer egress rule still applies to `outlet_catalogue`: **no read** until the fingerprint PASS flag for that egress exists and matches its bundle hash. 

## 9.10 Validator results & failure mapping

* **SUCCESS** â€” All checks above pass; S8 may proceed.
* **STRUCTURAL_FAIL** â€” Any schema/lineage/gate breach.
* **INTEGERISATION_FAIL** â€” Any sum/proximity/quantisation/ranking breach.
* **RNG_ACCOUNTING_FAIL** â€” Envelope or trace reconciliation breach.
* **BOUNDS_FAIL** â€” Any infeasibility/capacity-exhaustion in the bounds variant. (Codes map 1:1 to Â§8.)

---

**Outcome.** A run is **validator-clean** when Â§9.1â€“Â§9.8 pass. S8 then performs Â§9.9 checks before materialising `outlet_catalogue` (which itself remains governed by the layer egress PASS). This preserves the authority boundaries: **S3 owns order**, **S5 owns weights**, **S7 allocates** deterministically with auditable logs.

---

# 10) Concurrency, sharding & determinism **(Binding)**

**10.1 Work partitioning (who does what, where).**

* **Shard-by-merchant.** Producers **MUST** assign **each merchant to exactly one worker** for S7; no two workers may emit S7 events for the **same merchant**. Sharding **MUST** depend only on stable inputs (e.g., IDs), not on scheduling or file listing order. Event partitions are always **`{seed, parameter_hash, run_id}`**. 
* **Read parallelism is free.** Inputs (`s3_candidate_set`, S5 weights, S6 membership/events, S2/S4 facts) **MAY** be read in parallel; readers **MUST NOT** rely on physical file order (Dictionary `ordering: []`). Authority for cross-country order **remains** S3 `candidate_rank`.

**10.2 Set semantics & stable merges.**

* **Set, not sequence.** S7 event streams (e.g., `rng_event.residual_rank`) have **set semantics**; physical row order is non-authoritative (`ordering: []` in the Dictionary). Any multi-part merge **MUST** be value-stable regardless of part ordering. 
* **Uniqueness within a merchant.** Exactly **one** `residual_rank` row per `(merchant_id, country_iso)` in the S7 domain; duplicates are **FAIL** at validation. (This mirrors S3â€™s â€œtotal & contiguousâ€ uniqueness discipline for `candidate_rank`.) 

**10.3 Idempotency & backfill.**

* **Same inputs â‡’ identical outputs.** Re-running S7 with the **same `{seed, parameter_hash, run_id}`** and identical upstream inputs **MUST** yield **byte-identical** S7 outputs. If any input or config changes, a **new `run_id`** is required. 
* **At-most-once publish.** If a target partition already exists, producers **MUST** verify content hash; if identical, treat as **no-op**; if different, **hard-fail** (no overwrite). 

**10.4 Atomic publish & immutability.**

* **Stage â†’ fsync â†’ atomic rename.** Writers **MUST** publish via a temporary path and **atomically** promote; partial contents **MUST NOT** become visible. After publish, partitions are **immutable**. (Same discipline as S5/S6.)

**10.5 Trace cadence under parallelism.**

* **One trace append per event.** After **each** S7 event append, producers **MUST** append **exactly one** cumulative row to `rng_trace_log` for the key `(module="1A.integerisation", substream_label="residual_rank")`. Totals **MUST** reconcile irrespective of writer concurrency. 
* **No double-emission.** A merchantâ€™s S7 events **MUST NOT** be emitted by multiple workers (would inflate `events_total`). Detect and fail on any concurrent write intent for the same merchant. 

**10.6 Lineage & partition equality (concurrent safety checks).**

* **Pathâ†”embed equality is binding.** Where lineage columns exist, embedded `{seed, parameter_hash, run_id}` **MUST** byte-equal the partition tokens; violations are **FAIL** (pre-flight and validator). 
* **Canonical paths.** Event and log paths **MUST** match the Dictionary patterns for their families; S7 uses the same run-scoped paths as other RNG families. 

**10.7 Determinism across worker counts & retries.**

* Changing the **number of workers** or task scheduling **MUST NOT** change any value or emitted row. Determinism is guaranteed by: (i) S3â€™s authoritative order; (ii) S5â€™s authority weights; (iii) S7â€™s **dp=8** quantisation & fixed tie-breaks; and (iv) set-semantics + atomic publish.
* **Retry semantics.** On failure, producers **MUST NOT** partially publish; they MAY retry the **same** `{seed, parameter_hash, run_id}` after cleaning temp paths. (If anything upstream changed, bump `run_id` per Â§10.3.) 

**10.8 Ownership & isolation.**

* **Producers & families.** S7 writes **only** its families: `rng_event.residual_rank` (and optional `dirichlet_gamma_vector` when the Dirichlet lane is enabled). Module/substream lineage for these families is frozen in the Dictionary.
* **No cross-state emissions.** S7 **MUST NOT** emit S1â€“S6 families (e.g., `gumbel_key`, `poisson_component`) nor any S8 egress. Those families are owned by their states. 

**10.9 Reader discipline.**

* **Never rely on file order.** Readers and validators **MUST** treat all S7 streams as unordered sets; join/order always comes from S3 `candidate_rank`.

**10.10 Dirichlet lane concurrency (feature-flag; default OFF).**

* When enabled, S7 **MAY** emit **one** `dirichlet_gamma_vector` per merchant under the same run-scoped partitions; arrays **MUST** be equal-length and Î£weights=1Â±1e-6. Concurrency rules above (atomic publish, set semantics, trace cadence) apply identically.

---

# 11) Observability & metrics **(SHOULD)**

**Aim.** Minimal, stable, values-only metrics for S7 health/cost/behaviour without PII or duplicating validator logic. Metrics are keyed to run lineage and do not change any authority boundaries (order remains S3; weights remain S5).

**11.1 Run-lineage dimensions â€” MUST**
Include on every metric line: `{ seed, parameter_hash, run_id, manifest_fingerprint }`.

**11.2 Counters & gauges â€” MUST**
- `s7.merchants_in_scope` â€” # merchants that passed S7 pre-flight.
- `s7.single_country` â€” # merchants with domain = {home}.
- `s7.events.residual_rank.rows` â€” total `residual_rank` rows emitted (should equal Î£|domain|).
- `s7.trace.rows` â€” total S7 trace appends (should equal `s7.events.residual_rank.rows` + `s7.events.dirichlet_gamma_vector.rows` when the feature-lane is ON).
- `s7.events.dirichlet_gamma_vector.rows` â€” rows of `dirichlet_gamma_vector` (feature-flag lane; default OFF).
- `s7.bounds.enabled` â€” # merchants processed with bounds variant enabled.
- `s7.failures.structural` Â· `s7.failures.integerisation` Â· `s7.failures.rng_accounting` Â· `s7.failures.bounds` â€” counts mapped to Â§8 outcome classes (expected 0).

**11.3 Histograms / distributions â€” SHOULD**
- `s7.domain.size.hist` â€” per-merchant |D|.
- `s7.remainder.d.hist` â€” per-merchant remainder d.
- `s7.ms.integerisation` â€” time spent in LRR step per merchant.

**11.4 Instrumentation invariants â€” SHOULD**
- `s7.events.residual_rank.rows = Î£|D|` over all merchants.
- `s7.trace.rows = s7.events.residual_rank.rows` when Dirichlet lane is OFF; add one per merchant when the lane is ON.

---

# 12) Schema & dictionary deltas **(Binding)**

**12.1 `residual_rank.residual` â€” tighten upper bound**
* **File:** `schemas.layer1.yaml`
* **Anchor:** `#/rng/events/residual_rank/properties/residual`
* **Change:** add `exclusiveMaximum: true` (keep description â€˜in [0,1)â€™).
* **Rationale:** align schema with spec (Â§5.1, Â§7.4).

**12.2 `dirichlet_gamma_vector.country_isos` help-text â€” fix order wording**
* **File:** `schemas.layer1.yaml`
* **Anchor:** `#/rng/events/dirichlet_gamma_vector/properties/country_isos/description`
* **Change:** replace â€œhome first, then foreigns in Gumbel order.â€ with â€œhome first, then foreigns in S3 `candidate_rank` order filtered to membership.â€
* **Rationale:** match Â§5.1 ordering note; prevent validator ambiguity.

**12.3 `rng_audit_log.record.ts_utc` â€” enforce microsecond precision**
* **File:** `schemas.layer1.yaml`
* **Anchor:** `#/rng/core/rng_audit_log/record/properties/ts_utc`
* **Change:** require RFC-3339 `Z` with exactly 6 fractional digits via the same `pattern` as the layer envelope.
* **Rationale:** make audit rows consistent with envelope strictness (Â§5.4, Â§7.5, Â§8.10, Â§9.1).

---

# Appendix A â€” Enumerations & literal labels (Normative)

All literals below are **case-sensitive** and **binding**. Producers and validators **MUST** use them exactly as written.

## A.1 `module` (RNG producer lineage)

* `1A.integerisation` â€” producer of `rng_event.residual_rank` (default S7 lane).
* `1A.dirichlet_allocator` â€” producer of `rng_event.dirichlet_gamma_vector` (**feature-flag; default OFF**).

## A.2 `substream_label` (RNG event families)

* `residual_rank` â€” deterministic, **non-consuming** S7 event (always ON).
* `dirichlet_gamma_vector` â€” stochastic Dirichlet snapshot (**feature-flag; default OFF**).

> Trace rows in `rng_trace_log` **MUST** key off the exact `(module, substream_label)` pairs above.

## A.3 Tie-break keys (total order for remainder bumps)

Order of precedence (**freeze this order**):

1. `residual` â€” **quantised** residual at `dp_resid=8`, **descending**.
2. `country_iso` â€” ISO-3166-1 alpha-2, **Aâ†’Z**.
3. `candidate_rank` â€” from S3, **ascending**.
4. *(implicit)* stable input index â€” implementation detail to guarantee stability; **not persisted**.

## A.4 Error / failure / degrade labels

**Errors (merchant-scoped FAIL):**

* `E_PASS_GATE_MISSING` â€” attempted read without required S5/S6 PASS.
* `E_SCHEMA_INVALID` â€” input failed schema validation.
* `E_PATH_EMBED_MISMATCH` â€” pathâ†”embed lineage inequality.
* `E_UPSTREAM_MISSING` â€” required S2/S3/S4 artefact absent/invalid.
* `E_S6_NOT_SUBSET_S3` â€” membership contains ISO not in S3 admissible set.
* `E_ZERO_SUPPORT` â€” restricted S5 weights sum to 0 on domain.
* `E_BOUNDS_INFEASIBLE` â€” Î£Láµ¢>N or Î£Uáµ¢<N in bounded variant.
* `E_BOUNDS_CAP_EXHAUSTED` â€” cannot allocate all remainder under Uáµ¢ caps.
* `E_RNG_ENVELOPE` â€” missing/malformed envelope on S7 events.
* `RNG_ACCOUNTING_FAIL` â€” trace totals donâ€™t reconcile (events/draws/blocks).
* `E_DIRICHLET_SHAPE` â€” Dirichlet arrays not equal length (feature-lane).
* `E_DIRICHLET_NONPOS` â€” any Î±áµ¢â‰¤0 (feature-lane).
* `E_DIRICHLET_SUM` â€” Î£weights â‰  1Â±1e-6 (feature-lane).
* `INTEGER_SUM_MISMATCH` â€” Î£countsâ‰ N or any count<0.
* `E_RESIDUAL_QUANTISATION` â€” residual not quantised @ dp=8 before ordering.
* `E_IO_ATOMICS` â€” atomic publish discipline violated.

**Outcome classes (validator mapping):**

* `STRUCTURAL_FAIL` Â· `INTEGERISATION_FAIL` Â· `RNG_ACCOUNTING_FAIL` Â· `BOUNDS_FAIL` Â· `SUCCESS`.

**Deterministic degrade (non-error diagnostics):**

* `DEG_SINGLE_COUNTRY` â€” domain={home}; all N to home.
* `DEG_ZERO_REMAINDER` â€” d=0; no bumps applied.
* `DEG_TIES_RESOLVED` â€” ties broken per binding order (ISO, then rank).

## A.5 Dataset & event IDs used by S7 (with roles)

**Read-only authorities / facts**

* `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` Â· **partitions:** `[parameter_hash]`
  *Sole inter-country order (`candidate_rank`, contiguous; home=0).*
* `ccy_country_weights_cache` â†’ `schemas.1A.yaml#/prep/ccy_country_weights_cache` Â· **partitions:** `[parameter_hash]`
  *Weights authority; Î£ per currency = 1Â±1e-6; **S5 PASS required**.*
* `rng_event.nb_final` â†’ `schemas.layer1.yaml#/rng/events/nb_final` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *Fact: `n_outlets = N â‰¥ 2` (non-consuming).*
* `rng_event.ztp_final` â†’ `schemas.layer1.yaml#/rng/events/ztp_final` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *Fact: `K_target` (others audit-only).*

**Membership sources**

* `s6_membership` (convenience) â†’ `schemas.1A.yaml#/s6/membership` Â· **partitions:** `{seed,parameter_hash}`
  *Use only with **S6 PASS**; order still from S3.*
* `rng_event.gumbel_key` (authoritative events) â†’ `schemas.layer1.yaml#/rng/events/gumbel_key` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *Reconstruct membership when `s6_membership` absent.*

**Optional helper**

* `merchant_currency` â†’ `schemas.1A.yaml#/prep/merchant_currency` Â· **partitions:** `[parameter_hash]`
  *If present, S7 MUST NOT override.*

**S7 emissions**

* `rng_event.residual_rank` â†’ `schemas.layer1.yaml#/rng/events/residual_rank` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *Non-consuming; one row per (merchant,country) in domain; `module="1A.integerisation"`, `substream_label="residual_rank"`.*
* `rng_event.dirichlet_gamma_vector` (**feature-flag**) â†’ `schemas.layer1.yaml#/rng/events/dirichlet_gamma_vector` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *At most one row per merchant; `module="1A.dirichlet_allocator"`, `substream_label="dirichlet_gamma_vector"`.*

**Core logs**

* `rng_trace_log` â†’ `schemas.layer1.yaml#/rng/core/rng_trace_log` Â· **partitions:** `{seed,parameter_hash,run_id}`
  *Append **exactly one** cumulative row after **each** S7 event append.*

**Downstream (consumer; not written by S7)**

* `outlet_catalogue` â†’ `schemas.1A.yaml#/egress/outlet_catalogue`
  *S8 materialises; egress **never** encodes inter-country order (consumers join S3).*

## A.6 Partition token names (used by S7)

* Events/logs: `{seed, parameter_hash, run_id}`.
* Parameter-scoped tables (reads): `[parameter_hash]`.

> **Pathâ†”embed equality is binding** wherever lineage columns are embedded; bytes must match partition tokens exactly.

---

# Appendix B â€” Worked examples (Informative)

Assume domain $D={\text{GB (home)}, \text{DE}, \text{FR}}$ with S3 `candidate_rank` fixed (home=0; others contiguous). Residuals are **quantised to dp=8** (ties-to-even) **before** ordering. Tie-break order: **residualâ†“, country_iso Aâ†’Z, candidate_rankâ†‘**.

---

## B1) Core LRR example (dp=8 quantisation)

* Inputs: $N=13$; restricted S5 weights on $D$: GB 0.58, DE 0.27, FR 0.15 (sum=1.00).
* Fractionals $a=N\cdot s$: GB 7.54, DE 3.51, FR 1.95
  Floors $b$: GB 7, DE 3, FR 1 â†’ remainder $d=13-(7+3+1)=2$
  Residuals $r=a-b$ (dp=8): GB **0.54000000**, DE **0.51000000**, FR **0.95000000**
* Order by residual: FR(0.95) â†’ GB(0.54) â†’ DE(0.51).
  Bump +1 to top **2**: FR and GB.
* **Final counts:** GB 8, DE 3, FR 2 (sum=13).
  **Residual ranks:** FR 1, GB 2, DE 3.

---

## B2) Tie on residuals (ISO tie-break)

* Inputs: $N=10$; weights: GB 0.35, FR 0.35, DE 0.30.
* $a$: GB 3.50, FR 3.50, DE 3.00 â†’ $b$: 3,3,3 â†’ $d=1$
  Residuals (dp=8): GB **0.50000000**, FR **0.50000000**, DE **0.00000000**
* Tie between GB and FR on residual â†’ ISO Aâ†’Z decides: **FR** < GB.
  Bump goes to **FR**.
* **Final counts:** GB 3, FR 4, DE 3.
  **Residual ranks:** FR 1, GB 2, DE 3.

---

## B3) Bounded variant (capacity restricts the bump)

* Inputs: $N=10$; weights: GB 0.34, DE 0.33, FR 0.33.
  Bounds: $L=(\text{GB}=3,\text{DE}=1,\text{FR}=2)$, $U=(\text{GB}=3,\text{DE}=4,\text{FR}=3)$.
  Feasible since $\sum L=6 \le 10 \le \sum U=10$.
* $a$: GB 3.40, DE 3.30, FR 3.30 â†’ $b$: 3,3,3 â†’ $d=1$
  Residuals (dp=8): GB **0.40000000**, DE **0.30000000**, FR **0.30000000**
  Capacity: GB $b{=}3=U$ (no room), FR $3=U$ (no room), DE $3<4$ (room).
* Although GB has the highest residual, only **DE** is capacity-eligible, so the +1 goes to **DE**.
* **Final counts:** GB 3, DE 4, FR 3.
  **Residual ranks (full domain):** GB 1, DE 2, FR 3. *(Allocation skips ineligible ranks.)*

---

## B4) Zero-remainder (diagnostic)

* Inputs: $N=10$; weights: GB 0.40, DE 0.30, FR 0.30.
  $a$: 4.00, 3.00, 3.00 â†’ $b$: 4,3,3 â†’ $d=0$.
  Residuals (dp=8): **0.00000000** each â†’ no bumps applied.
* **Final counts:** GB 4, DE 3, FR 3.
  **Residual ranks:** determined solely by ISO Aâ†’Z then `candidate_rank` (used only for tie bookkeeping; $d=0$).

These examples illustrate exactly how dp=8 quantisation, tie-breaking, and the bounded Hamilton variant behaveâ€”without any reliance on code execution.

---

# Appendix C â€” Storage conventions (Informative)

These are **non-binding** operational defaults that make S7 artefacts easy to store, move, and read at scale. Reader logic **must not** rely on any file order (set semantics still apply); paths and formats remain governed by the Dataset Dictionary. Treat everything here as â€œgood defaults,â€ not authority.

## C.1 File format & compression (suggested)

* **JSON Lines (NDJSON)**: simple, append-friendly.

  * Extension: `.jsonl.zst`
  * Compression: **Zstandard level 3** (fast, widely supported)
  * Line endings: `\n` (LF) only; **one JSON object per line**; no trailing commas / no pretty print.
* **Parquet**: columnar, efficient for analytics.

  * Compression: `zstd` **level 3**
  * Row group target: **128â€“256 MiB uncompressed** (choose a fixed value per family)
  * Encodings: **dictionary** for low-cardinality columns (e.g., `country_iso`, `module`, `substream_label`); `BYTE_ARRAY` stats on categorical fields; enable **statistics**.
* **Do not mix formats** within a single family/partition. Pick **one** per family (e.g., all `residual_rank` as JSONL **or** all as Parquet).

## C.2 Writer sort (advised; readers must not rely on it)

* Within each part file, write rows in a **stable canonical order** to aid diffs and compression:

  1. `merchant_id` â†‘
  2. `country_iso` â†‘
  3. *(if present)* `candidate_rank` â†‘
* This is **for compression & human diffability only**. Reader semantics remain **set-based**; never depend on file order.

## C.3 Part sizing & file naming

* **Compressed part size target:** **64â€“128 MiB**. Avoid â€œtiny filesâ€ (<8 MiB compressed).
* **Naming:** `part-00000-of-000NN.<ext>` for fixed counts, or `part-<uuid>.<ext>` for streaming emitters.
* **One family per directory**; no multi-family mixing in a single folder.

## C.4 Paths & partitions (reminder)

* Use the **run-scoped** partition law for S7 events/logs:
  `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`
* If you add convenience subfolders, keep them **purely cosmetic**, e.g.:
  `â€¦/rng/{module}/{substream_label}/seed=â€¦/parameter_hash=â€¦/run_id=â€¦/part-*.jsonl.zst`
  *(Module/substream names are frozen; see Appendix A.)*

## C.5 Checksums & manifests (recommended)

* Emit a per-part **SHA-256** sidecar: `part-â€¦.<ext>.sha256` (hex digest of the compressed bytes).
* Optionally write a folder **manifest**: `_MANIFEST.json` listing parts, sizes, SHA-256, and total logical rows.
* Keep a single **folder hash** (SHA-256 over the concatenated part hashes, in lexicographic name order) as a quick integrity anchor.

## C.6 Atomic publish (recap)

* **Stage â†’ fsync â†’ atomic rename** into the Dictionary path. Never expose partial contents.
* Write any `_MANIFEST.json` and checksum sidecars **before** the final atomic rename.
* After publish, treat partitions as **immutable**; backfills must go to a **new** `run_id`.

## C.7 Retention / TTL (typical defaults)

* **S7 event families** (e.g., `residual_rank`, optional `dirichlet_gamma_vector`): **180 days**.
* **Core RNG logs** (`rng_trace_log`, `rng_audit_log`): **365 days**.
* Implement lifecycle rules at the object store layer; compact small parts weekly before TTL expiry.

## C.8 Storage class & encryption (ops defaults)

* Object storage class: **standard** for the first 30 days, then transition to **infrequent access** if read rates drop.
* Encryption at rest: **SSE-KMS** (or equivalent) with a project-scoped key; bucket-level **deny** on unencrypted puts.
* Server-side checksums enabled; reject uploads without Content-MD5 (or use the SHA-256 sidecars from **C.5**).

## C.9 Metadata & headers

* Set `Content-Type` appropriately:

  * JSONL: `application/x-ndjson` (or `application/jsonl`)
  * Parquet: `application/vnd.apache.parquet`
* Add helpful custom headers/metadata:

  * `x-run-seed`, `x-parameter-hash`, `x-run-id`, `x-content-sha256`, `x-module`, `x-substream`.

## C.10 Compaction & housekeeping

* **Small-file compaction:** if a partition has >128 parts or >30% parts <8 MiB, compact to the target size.
* **Orphan cleanup:** delete any `_staging` subfolders older than 24 h; alert on dangling staging content.
* **Directory hygiene:** keep only `{parts, .sha256, _MANIFEST.json}` files in a partition directoryâ€”no temp or editor artefacts.

## C.11 Access patterns (for downstreams)

* Always **predicate** reads on the partition tokens (`seed`, `parameter_hash`, `run_id`) rather than listing entire buckets.
* For Parquet, **column-prune** to just the fields you need (`merchant_id`, `country_iso`, `residual`, `residual_rank`, lineage).
* For JSONL, read in **streaming mode** and avoid in-memory concatenation of entire partitions.

---
[[[MASTER-SEP-1A]]]

<a id="state-1a-s8-expanded"></a>
# state.1A.s8.expanded.txt

<!-- Source file: state.1A.s8.expanded.v3.1.txt | BYTE-EXACT EMBED -->

# State 8 (S8) â€” Materialise outlet stubs & sequences

# 0) Document metadata & status **(Binding)**

**State ID (canonical):** `layer1.1A.S8` â€” â€œMaterialise outlet stubs & sequencesâ€
**Document type:** Contractual specification (no code, no pseudocode)
**Primary egress governed by this spec:** `outlet_catalogue` (see dictionary + schema anchors).

---

## 0.1 Versioning (SemVer) & effective date

* **Versioning scheme:** **MAJOR.MINOR.PATCH** (Semantic Versioning).
* **Initial version:** `v1.0.0` (ratified 2025-10-14).  *(File name revisions do not imply SemVer changes.)*
* **Effective date:** 2025-10-14 (release tag and commit recorded alongside this document).

### What requires a **MAJOR** bump (breaking):

* Any change to **dataset IDs**, **schema `$ref` anchors**, or **column/PK/partition** contracts for `outlet_catalogue`. 
* Any change to **partition law** or lineage fields used by S8 (e.g., switching egress partitions away from `[seed, fingerprint]`). 
* Changing **â€œno cross-country order in egressâ€** (i.e., encoding inter-country order in `outlet_catalogue`). 
* Altering **PASS-gate semantics** for 1A hand-off (validation bundle and `_passed.flag` relationship). 

### What is **MINOR** (backward-compatible):

* Adding **nullable/optional columns** to `outlet_catalogue` that do not affect PK/UK/sort/partitions. 
* Adding **new instrumentation streams** (e.g., additional guardrail events) that donâ€™t change existing envelopes or required events. 
* Adding **informative** appendices, metrics, or validation outputs that do not alter the egress/table contract. 

### What is **PATCH** (non-behavioural):

* Editorial clarifications, typo fixes, and examples that **do not change** behaviour, schemas, paths, keys, partitions, or gates.

---

## 0.2 Normative language (RFC 2119/8174)

* Terms **MUST/SHALL/SHOULD/MAY** are normative.
* Unless explicitly labelled *Informative*, all clauses in this document are **Binding**.

---

## 0.3 Document scope & non-goals (status framing)

* This document **governs only** S8 behaviour and artefacts needed to materialise `outlet_catalogue` and its minimal instrumentation events. It **does not** define cross-country order, counts, or weights; those remain with S3/S7/S5 respectively and are referenced in later sections.
* S8 egress is **fingerprint-scoped** and partitioned `[seed, fingerprint]`; **pathâ†”embed equality** for `manifest_fingerprint` is enforced elsewhere in this spec. 

---

## 0.4 Lifecycle & ratification record

On ratification:

* Record **semver**, **effective_date**, **ratified_by**, and the **git commit** (and optional SHA-256 of this file) in the release notes and governance registry.
* Downstream consumers (e.g., 1B) **MUST** continue to verify the 1A **validation gate** before reading `outlet_catalogue` (`_passed.flag` content hash equals `SHA256(validation_bundle_1A)` for the same fingerprint). 

---

## 0.5 Cross-references (anchors used by S8)

* **Dataset Dictionary:** `dataset_dictionary.layer1.1A.yaml` â€” IDs/paths/partitions for `outlet_catalogue`, S3 candidate set, validation bundle, and RNG streams.
* **JSON-Schema (authority):**
  - `schemas.1A.yaml` â†’ `#/egress/outlet_catalogue`, `#/s3/candidate_set` (referenced later). 
  - `schemas.layer1.yaml` (RNG/core logs & event families used/observed by 1A, incl. `sequence_finalize`, `site_sequence_overflow`, `residual_rank`). 
  - `schemas.ingress.layer1.yaml` (FK targets such as `iso3166_canonical_2024`). 
For brevity, unqualified `$ref` anchors (e.g., `#/rng/events/sequence_finalize`) are resolved per Â§3.1 **Anchor resolution rule**.
---

## 0.6 House rules this document inherits

* **No PASS â†’ no read**: consumers of `outlet_catalogue` must verify the 1A validation gate for the same `fingerprint`. 
* **Deterministic math & environment**: numeric environment (IEEE-754 binary64, RNE, FMA off) is inherited from Layer-1 policy and S0; S8 will not weaken those guarantees. 

---

> **Status:** This section is **Binding**. Once you mark this doc `v1.0.0` and ratify, Â§0 governs change control for all future edits to the S8 spec.

---

# 1) Purpose & scope **(Binding)**

## 1.1 Purpose

S8 **materialises immutable outlet stubs** for each `(merchant_id, legal_country_iso)` by writing the **`outlet_catalogue`** dataset. For every country in the merchantâ€™s domain, S8 emits a **contiguous within-country sequence** `site_order = 1..final_country_outlet_count` and a deterministic **6-digit `site_id`** derived from that sequence. 
**Inter-country order is not encoded** in this egress; downstream MUST join S3â€™s `candidate_rank` when a cross-country order is required.

## 1.2 What S8 consumes (conceptual)

S8 **consumes** already-ratified facts and authorities; it does **not** derive them:

* **Counts (N and per-country integers):** `N` comes from S2 (via `nb_final` evidence), and per-country integer counts come from S7 residual-rank evidence (or `s3_integerised_counts` if S3 is designated to own integerisation).
* **Membership & domain:** the foreign membership is taken from S6 (convenience `s6_membership` if emitted, or reconstructable from S6 RNG events), joined with S3â€™s candidate set to align with order authority. 
* **Inter-country order authority:** **only** S3â€™s `s3_candidate_set.candidate_rank` (total, contiguous; `home` at rank 0).

> S8 does not require S5 weight surfaces. Weights authority remains with S5 (used upstream by S6/S7); any S5 artefact consumption elsewhere remains gated by its PASS policy.

**Single vs multi reminder.** S8 writes **only** multi-site merchants (`raw_nb_outlet_draw â‰¥ 2`, `single_vs_multi_flag=true`)â€”singles are out of scope for this egress.

## 1.3 What S8 produces

* **Primary egress:** `outlet_catalogue` at `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/` with partitions `[seed, fingerprint]`, PK/Sort `[merchant_id, legal_country_iso, site_order]`, and the column set fixed by the schema (incl. `manifest_fingerprint`, `site_order`, `site_id`). **No cross-country order is present.**
* **Instrumentation streams:**
  - `rng_event.sequence_finalize` per `(merchant,country)` block with `{site_count,start_sequence,end_sequence}` (for audit and replay accounting).
  - `rng_event.site_sequence_overflow` on overflow (guardrail â†’ merchant-scoped failure).

## 1.4 Scope constraints (non-goals)

S8 **MUST NOT**:

* invent or encode **inter-country order** (that remains with S3), nor reinterpret S3â€™s `candidate_rank`.
* change `N` or re-allocate per-country counts determined upstream (S7/S3). 
* read or persist S5 weights, or create any new weights/order surface. 
* weaken lineage/partition law or introduce side-channel ordering via file layout (PK/sort keys are normative; readers MUST NOT rely on file order). 

## 1.5 Consumers & gating

* **No PASS â†’ no read:** Consumers (e.g., 1B) **MUST** verify the 1A validation gate for the same `fingerprint` (`_passed.flag` content hash equals `SHA256(validation_bundle_1A)`) **before** reading `outlet_catalogue`. 
* S8 itself is **fingerprint-scoped** egress; all path tokens MUST match embedded lineage where present (defined later in lineage law). 

## 1.6 Success criteria (outcome statement)

On successful completion for a `fingerprint`, S8 yields:

1. a byte-stable `outlet_catalogue` partition with contiguous per-country `site_order` (and 6-digit `site_id`) for every `(merchant, legal_country_iso)` where `final_country_outlet_count â‰¥ 1`;
2. complete `sequence_finalize` coverage for those blocks; and 
3. no violation of the inter-country order boundary (all cross-country ordering recoverable by joining S3 `candidate_rank`).

**Status:** This section is **Binding**.

---

# 2) Definitions & notation **(Binding)**

This section freezes the vocabulary, symbols, and lineage tokens S8 uses. All terms below are **normative**.

## 2.1 Lineage & partition tokens

* **`seed`** â€” 64-bit unsigned master RNG seed; partitions **RNG logs/events** and appears in their paths. 
* **`parameter_hash`** â€” **lowercase hex64** (SHA-256) of the opened parameter bundle; partitions **parameter-scoped tables** and RNG logs/events; where embedded, bytes **MUST** equal the path token.
* **`run_id`** â€” run-scoped identifier (**lowercase hex 32-character string**) for RNG event/log partitions (as per layer schema `$defs.run_id`).  
* **`manifest_fingerprint`** (a.k.a. **`fingerprint`** in paths) â€” **lowercase hex64** lineage digest for the whole 1A run; it **partitions S8 egress** and is also stored per row in `outlet_catalogue` as `manifest_fingerprint`. **Naming rule:** any `fingerprint={â€¦}` path segment carries the value of `manifest_fingerprint`.

## 2.2 Entities & keys

* **`merchant_id`** â€” 64-bit ID for a merchant (`$ref: #/$defs/id64`). Appears in S3 and S8 schemas. 
* **`home_country_iso`** â€” ISO-3166-1 alpha-2 code for the onboarding/home country (FK â†’ canonical ISO registry). 
* **`legal_country_iso` / `country_iso`** â€” ISO-3166-1 alpha-2 code for the country a site or candidate belongs to (FK â†’ canonical ISO registry). 
* **`candidate_rank`** â€” **sole authority** for inter-country order from S3; **total and contiguous** per merchant with **`candidate_rank(home)=0`**. 
* **Domain `Dâ‚˜`** â€” the per-merchant legal set used by S8: `{home_country_iso} âˆª (S6-selected foreign ISO2s)`, aligned to S3â€™s candidate set. (`s6_membership` is convenience-only; S6 RNG events are authoritative for reconstruction.)

## 2.3 Upstream facts S8 treats as read-only

* **Domestic outlet count `N`** â€” the accepted Negative-Binomial draw **per merchant** from **`rng_event.nb_final`** (`n_outlets â‰¥ 2`, **non-consuming** event). Denoted `Nâ‚˜`. 
* **Foreign target count `K_target`** â€” the S4 single-acceptance outcome from **`rng_event.ztp_final`** (non-consuming); consumed by S6. Denoted `Kâ‚˜^*`.
* **Integer per-country counts** â€” from **S7 residual evidence** (`rng_event.residual_rank`) or, if designated, S3â€™s deterministic **`s3_integerised_counts`** (parameter-scoped).

## 2.4 S8 egress: `outlet_catalogue` column terms (all **Binding**)

* **Primary key (PK)** â€” `[merchant_id, legal_country_iso, site_order]`. **Unique key equals PK.** Sort keys are identical. Partition keys: `[seed, fingerprint]`. 
* **`manifest_fingerprint`** â€” per-row **lowercase hex64** equal to the egress `fingerprint` path token (lineage equality).
* **`site_order`** â€” **within-country** contiguous sequence `1..náµ¢` for each `(merchant_id, legal_country_iso)` block (**no gaps**). 
* **`site_id`** â€” **mandatory** 6-digit zero-padded string for the within-country sequence (`^[0-9]{6}$`). It encodes **only** the local sequence, not global order. 
* **`single_vs_multi_flag`** â€” boolean copy of the S1 hurdle decision at merchant level (1 if multi-site). 
* **`raw_nb_outlet_draw`** â€” the accepted S2 domestic draw `N` prior to cross-border allocation (`â‰¥ 2`). 
* **`final_country_outlet_count`** â€” integer outlets allocated to this `legal_country_iso` (`â‰¥ 1`, `â‰¤ 999,999`). Sum over a merchantâ€™s legal set equals `N`. 
* **`global_seed`** â€” 64-bit master seed persisted for audit/replay parity. 

> **Scope note:** `outlet_catalogue` **does not encode inter-country order**; consumers **MUST** join S3â€™s `candidate_rank` when a cross-country order is required. 

## 2.5 RNG events & logs S8 observes/emits (schema-anchored names)

* **Core logs (read-only by validators):**
  **`rng_audit_log`** (run-scoped audit) and **`rng_trace_log`** (cumulative counters; **append exactly one** trace row after **each** RNG event append). Partitions `{seed, parameter_hash, run_id}`. 
* **Upstream evidence consumed by S8 validators:**
  **`rng_event.nb_final`** (defines `N`), **`rng_event.residual_rank`** (S7 residual ordering evidence),
  **`rng_event.gumbel_key`** **and** **`rng_event.ztp_final`** (S6 membership reconstruction when needed).
* **S8 instrumentation (emitted by S8):**
  **`rng_event.sequence_finalize`** â€” per `(merchant_id, country_iso)` block: `{site_count, start_sequence, end_sequence}`; partitions `{seed, parameter_hash, run_id}`.
  **`rng_event.site_sequence_overflow`** â€” guardrail event on sequence exhaustion.

## 2.6 Sets, symbols & equalities (notation used later)

* **`zfill6(x)`** â€” left-pad integer `x` with ASCII `'0'` to 6 digits (e.g., `1â†’"000001"`).
* **`Dâ‚˜`** â€” merchantâ€™s legal domain set for S8 (home + selected foreigns; aligned to S3). **Cardinality:** `|Dâ‚˜| = 1 + |S6_selected|`. 
* **`Nâ‚˜`** â€” merchant-level domestic outlets from `nb_final.n_outlets`. **Invariant later (Â§9):** `Î£_{câˆˆDâ‚˜} nâ‚˜,c = Nâ‚˜`. 
* **`nâ‚˜,c`** â€” per-country final integer count in `outlet_catalogue.final_country_outlet_count` for merchant `m` and country `c`. 
* **`site_order` sequence** â€” for each `(m,c)`, the ordered list `âŸ¨1,â€¦,nâ‚˜,câŸ©`. `site_id` is the 6-digit rendering of this sequence. 
* **Pathâ†”embed equality** â€” whenever lineage columns are embedded: egress `manifest_fingerprint` **MUST** equal the `fingerprint` path token; event rows **MUST** embed `{seed, parameter_hash, run_id, manifest_fingerprint}` where `{seed, parameter_hash, run_id}` **MUST** equal their path tokens and `manifest_fingerprint` **MUST** equal the runâ€™s egress fingerprint (not a path token).

## 2.7 Consumption gates (terms used throughout)

* **S6 PASS** â€” the S6 validation receipt folder whose `_passed.flag` content hash equals `SHA256(S6_VALIDATION.json)` for the same `{seed, parameter_hash}`; required before reading S6 convenience surfaces.
* **1A PASS (hand-off to 1B)** â€” the `validation_bundle_1A` at `â€¦/validation/fingerprint={manifest_fingerprint}/`; consumers must verify `_passed.flag` content hash equals `SHA256(bundle)` before reading `outlet_catalogue`.

**Status:** All terms above are **Binding** and will be used verbatim in Â§Â§3â€“13.

---

# 3) Authority & precedence **(Binding)**

## 3.1 Precedence chain (normative)

**Anchor resolution rule (normative).** When a `$ref` omits the document prefix:
- `#/rng/**` resolves to `schemas.layer1.yaml`.
- `#/validation/validation_bundle` resolves to `schemas.1A.yaml`; `#/validation/s6_receipt` resolves to `schemas.layer1.yaml`.
- `#/s3/**` and `#/egress/**` resolve to `schemas.1A.yaml`.
- `#/iso**` and other ingress FK anchors resolve to `schemas.ingress.layer1.yaml`.

1. **JSON-Schema is the single schema authority** for all S8 inputs/outputs/logs: `schemas.1A.yaml`, `schemas.layer1.yaml`, `schemas.ingress.layer1.yaml`. **Avro (if any) is non-authoritative.**
2. The **Dataset Dictionary** (`dataset_dictionary.layer1.1A.yaml`) governs **dataset IDs, physical path templates, partitions, writer sort, PK/FK, lifecycle and retention**. 
3. **This S8 spec** defines the **behavioural rules** under (1) and (2). (Pattern established in S7/S6 carries forward unchanged.)

> If a dictionary entry and a schema disagree on **shape or typing**, the **schema wins** (dictionary must be fixed). If an implementation uses literal paths, it is non-conformantâ€”**all IO resolves via the dictionary**. 

## 3.2 What each authority decides (scope partitioning)

* **JSON-Schema (source of truth):** row/record **shape**, field domains & types, **PK/UK** definitions, event envelope fields, and required lineage columns.
* **Dataset Dictionary:** dataset **IDs â†’ schema `$ref`**, **partition keys** (e.g., `[seed, fingerprint]` for S8 egress; `[parameter_hash]` for parameter-scoped inputs), **writer sort**, and **consumer gates** text. 
* **This S8 spec:** behavioural rules (e.g., â€œwithin-country sequencing onlyâ€), **prohibitions**, invariants, error/degrade ladder, and **PASS-gate** expectations. 

## 3.3 Fixed upstream authorities S8 MUST honour

* **Inter-country order authority:** **only** S3 `s3_candidate_set.candidate_rank` (total, contiguous; `home=0`). S8 **MUST NOT** encode or alter cross-country order; consumers **MUST** join S3 when order is required.
* **Counts authority:** merchant-level `N` from **`rng_event.nb_final`** (S2, non-consuming) and **per-country integer counts** from S7 residual evidence (or `s3_integerised_counts` if S3 owns it). S8 **MUST NOT** re-derive either.
* **Gating principle:** **No PASS â†’ no read** remains in force for 1A consumers; the dictionaryâ€™s `outlet_catalogue` entry encodes this gate for 1B.

## 3.4 Prohibitions & legacy notes (binding)

* **Avro `.avsc`** files (if generated) are **non-authoritative** and **MUST NOT** be referenced by registry/dictionary entries. 
* **Legacy `country_set`** is **not** an order authority; using it for cross-country order is non-conformant. 
* **File order is non-authoritative** (RNG/event streams use counters & envelopes; tables rely on PK/sort defined in the dictionary). 

**Status:** Section 3 is **Binding**.

---

# 4) Compatibility window & numeric environment **(Binding)**

## 4.1 Baselines S8 binds to (v1.* line)

S8 v1.* is compatible withâ€”and **assumes**â€”the following authorities remain on their **v1.* line**; a **MAJOR** bump in any requires S8 re-ratification and a SemVer **MAJOR** increment for this spec:

* **Layer-wide RNG/log schemas:** `schemas.layer1.yaml v1.0`. 
* **1A tables & egress schemas:** `schemas.1A.yaml v1.0`. 
* **Ingress/reference schemas:** `schemas.ingress.layer1.yaml v1.0`. 
* **Dataset Dictionary:** `dataset_dictionary.layer1.1A.yaml` (IDs, path templates, partitions, writer sort). 

## 4.2 Lineage interaction with compatibility (fingerprints vs parameter scope)

* **`parameter_hash`** flips when **any governed parameter bytes** change (policy/config members of ð“Ÿ). **`manifest_fingerprint`** flips when **any opened artefact** (schemas, dictionary, ISO, governance files) or the **code commit** changes. These keys are **orthogonal** to SemVer and govern partitions and reproducibility for S8. 
* The **manifest** explicitly **includes** the pinned **numeric policy** and **math profile manifest**, so changing either will change the **`manifest_fingerprint`** for the run. 

## 4.3 Numeric environment (must hold for S8)

S8 **inherits** the Layer-1 numeric environment; producers and validators **MUST** attest it before publishing S8 egress:

* **Policy pins (governance):**
  - **Rounding:** **RNE** (round-to-nearest, ties-to-even)
  - **FMA:** **off**
  - **FTZ/DAZ:** **off** (no flush-to-zero, no denormals-are-zero)
  - **Subnormals:** **preserved**
  These are defined in `schemas.layer1.yaml#/governance.numeric_policy_profile` and pinned in the Artefact Registry as `numeric_policy_profile`.
* **Math library profile (deterministic libm):** function set/signatures are frozen via `math_profile_manifest` and participate in the manifest fingerprint.
* **Attestation artefact:** S0 writes `numeric_policy_attest.json` into the fingerprinted validation bundle; fields include `rounding_ok`, `fma_off_ok`, `subnormals_ok`, `libm_regression_ok`, `neumaier_ok`, `total_order_ok`, `passed`. S8 **MUST** run only under a fingerprint where this attestation **passed**.

> **Note:** S8â€™s egress (`outlet_catalogue`) is integer/string-typed; however, S8 **still** relies on this environment for deterministic validation and any numeric checks performed during sequencing and logging. 

## 4.4 S8 numeric constants & identifier limits (binding)

* **Six-digit sequence tokens:** any within-country sequence values exposed in events use the `$defs.six_digit_seq` pattern `^[0-9]{6}$`. 
* **Overflow guardrail:** if a per-country allocation would exceed the 6-digit ceiling, producers **MUST** emit `rng_event.site_sequence_overflow` with `{attempted_count, max_seq=999999, overflow_by}` and **fail the merchant**. 
* **Sequence finalize event:** per `(merchant_id,country_iso)` block, `rng_event.sequence_finalize` records `{site_count, start_sequence, end_sequence}` using `six_digit_seq`. 

## 4.5 Evolution rules (numeric/compatibility changes)

* **MAJOR (re-ratify S8):** changing any field/domain in `numeric_policy_profile` (e.g., enabling FMA), altering `six_digit_seq` width/range, or changing the required fields/semantics of `sequence_finalize` / `site_sequence_overflow`.
* **MINOR (backward-compatible):** adding optional **attestation** fields, or **diagnostic** event payload members that do not affect required fields or envelopes; updating `math_profile_manifest` contents **with** a fresh attestation (this flips `manifest_fingerprint` but does not break readers).

**Status:** Section 4 is **Binding**.

---

# 5) Identity, lineage & partition law **(Binding)**

This section fixes **what keys partition which artefacts**, how **path tokens must equal embedded lineage**, and the **atomic publish/idempotence** rules. All clauses here are **normative**.

## 5.1 Canonical partitions & paths (by artefact class)

**Egress (S8 output).**
`outlet_catalogue` is **fingerprint-scoped** under
`data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/` with partitions `[seed, fingerprint]` and writer sort `[merchant_id, legal_country_iso, site_order]`. Schema anchor: `schemas.1A.yaml#/egress/outlet_catalogue`.

**Parameter-scoped inputs (RNG-free; upstream).**
Examples: `s3_candidate_set`, `s3_integerised_counts`, `s3_site_sequence` when present. These live under `â€¦/parameter_hash={parameter_hash}/` (partition `[parameter_hash]`). Schema anchors: `schemas.1A.yaml#/s3/*`.

**RNG core logs & events (read by validators / instrumentation).**
All RNG JSONL streams (e.g., `rng_audit_log`, `rng_trace_log`, `rng_event.*` including `sequence_finalize`, `site_sequence_overflow`) are partitioned by `{seed, parameter_hash, run_id}` with canonical paths like
`logs/rng/<stream>/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`. Envelope fields are governed by `schemas.layer1.yaml` and **required** on every event row.

**Validation bundle & hand-off gate.**
The 1A validation bundle is **fingerprint-scoped** at
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` and supplies the `_passed.flag` that gates 1B consumption.

## 5.2 Pathâ†”embed equality (must hold)

**Egress rows.** `outlet_catalogue.manifest_fingerprint` **MUST byte-equal** the `fingerprint` path token for the same partition, and `global_seed` **MUST** equal the `seed` path token. **Pattern (for `manifest_fingerprint`):** `^[a-f0-9]{64}$`.

**Parameter-scoped tables.** Each row **MUST** embed `parameter_hash` and it **MUST equal** the `parameter_hash` path token. If present, `produced_by_fingerprint` is **informational only** (not a partition key nor part of equality).

**RNG logs/events.** Event rows **MUST** embed `{seed, parameter_hash, run_id, manifest_fingerprint}`. `{seed, parameter_hash, run_id}` **MUST** match their path tokens **byte-for-byte**. `manifest_fingerprint` **MUST** equal the runâ€™s egress fingerprint (it is **not** a path token).

## 5.3 Identity, immutability & atomic publish

**Identity of a partition.** *(â€œfingerprintâ€ path token equals `manifest_fingerprint` column value.)*

* Egress: `(dataset='outlet_catalogue', seed, manifest_fingerprint)`.
* Parameter-scoped: `(dataset_id, parameter_hash)`.
* RNG streams: `(stream_name, seed, parameter_hash, run_id)`.
  Publishing to an existing identity **MUST** result in **byte-identical content** or be a no-op. 

**Atomicity.** Producers **MUST** stage to a temp path, fsync, then perform a single **atomic rename** into the dictionary path. **No partial contents** may become visible.

**Immutability & idempotence.** A published partition is **immutable**; re-runs with identical inputs, numeric policy, and lineage **MUST** yield **bit-identical** outputs for egress and **value-identical** rows for streams (byte-identity if a writer policy is pinned). **File order is non-authoritative.**

## 5.4 Key formats & allowed values (schema-anchored)

* `seed` is `uint64`. `run_id` is **lowercase hex32**. `parameter_hash` and `manifest_fingerprint` are **lowercase hex64**. These formats are enforced in `schemas.layer1.yaml` `$defs`. 
* `site_id` follows `^[0-9]{6}$` and is **not** a partition key. 

## 5.5 Writer sort & non-authoritative physical order

* Egress writer sort is `[merchant_id, legal_country_iso, site_order]` as per **Dataset Dictionary**/**Schema**; readers **MUST NOT** rely on file order beyond these keys.
* RNG JSONL **row order across files is non-semantic**; equality is by **row set**. Within a file, line order reflects append order only. 

## 5.6 Multi-run semantics (logs)

`run_id` partitions **logs only** and does **not** alter modelling state/outcomes; multiple `run_id`s may coexist for the same `{seed, parameter_hash}` without changing dataset semantics. 

## 5.7 Receipt & gate placement (lineage consequences)

* Egress is **fingerprint-scoped** and consumed **only after** verifying the validation bundle `_passed.flag` for the **same** fingerprint (content hash equals `SHA256(bundle)`). 
* S8 MUST verify **upstream gates** before reading convenience surfaces (e.g., **S6 PASS** if reading `s6_membership`). Gate locations and partitions are defined in the dictionary. 

## 5.8 Retention & ownership (for completeness)

Retention periods and producer/consumer ownership are normative in the **Dataset Dictionary** and **Artefact Registry** (e.g., RNG events typically 180 days; core logs 365 days); S8 producers **MUST** respect these policies when publishing.

**Status:** Section 5 is **Binding**.

---

# 6) Read set & pre-read gates **(Binding)**

This section freezes **exactly what S8 is allowed to read** (IDs â†’ schema anchors â†’ partitions), and the **gates** S8 MUST verify *before* reading any convenience surface. All items below are **normative**.

## 6.1 Required inputs (IDs â†’ `$ref` â†’ partitions)

* **Inter-country order & domain (sole authority):**
  **`s3_candidate_set`** â†’ `schemas.1A.yaml#/s3/candidate_set` â†’ **partition:** `parameter_hash={â€¦}`.
  *Guarantees:* total & contiguous `candidate_rank` per merchant; `candidate_rank(home)=0`; embedded `parameter_hash` equals path key (pathâ†”embed equality). S8 MUST use this for **all** cross-country ordering.

* **Domestic count (fact `N` for each merchant):**
  **`rng_event.nb_final`** â†’ `schemas.layer1.yaml#/rng/events/nb_final` â†’ **partition:** `{seed, parameter_hash, run_id}`; **exactly one** per resolved merchant; **non-consuming** envelope. S8 uses `n_outlets` to populate `raw_nb_outlet_draw` and for sum checks.

* **Per-country integer counts (authority for `final_country_outlet_count`):**
  **Variant A (preferred, if present):** **`s3_integerised_counts`** â†’ `schemas.1A.yaml#/s3/integerised_counts` â†’ **partition:** `parameter_hash={â€¦}`. Contains `{merchant_id,country_iso,count,residual_rank}`; S8 MUST read this when it exists. 
  **Variant B (no S3 counts surface):** counts flow *in-process* from S7 into S8; S8 MUST NOT reconstruct counts from weights. (Validators will re-derive independently; see Â§11.) The deprecated `ranking_residual_cache_1A` is **not** an authority.

* **Membership of foreigns (domain members beyond home):**
  **Option 1 (convenience surface):** **`s6_membership`** â†’ `schemas.1A.yaml#/s6/membership` â†’ **partition:** `seed={seed}, parameter_hash={parameter_hash}`. **Gate required** (see Â§6.3). Order still comes from S3. 
  **Option 2 (authoritative log reconstruction):** **`rng_event.gumbel_key`** â†’ `schemas.layer1.yaml#/rng/events/gumbel_key` and **`rng_event.ztp_final`** â†’ `schemas.layer1.yaml#/rng/events/ztp_final` â†’ **partition:** `{seed, parameter_hash, run_id}`. Use keys + `K_target` to recover membership when `s6_membership` is absent. 

> **FK sources** are enforced by schema on egress (ISO2); S8 neednâ€™t read ISO directly. (FK target: `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`.) 

## 6.2 Conditional/variant inputs (read only if present)

* **If sequencing is owned upstream:** **`s3_site_sequence`** â†’ `schemas.1A.yaml#/s3/site_sequence` â†’ `parameter_hash={â€¦}`. When present, S8 **cross-checks** it but still writes `outlet_catalogue`; S8 **MUST NOT** change sequence semantics. 

## 6.3 Pre-read gates S8 MUST enforce

* **S6 gate (for any S6 convenience surface):** If reading **`s6_membership`**, verify the **S6 PASS receipt** at
  `data/layer1/1A/s6/seed={seed}/parameter_hash={parameter_hash}/` where `_passed.flag` content hash equals `SHA256(S6_VALIDATION.json)` for the **same** `{seed,parameter_hash}`. **No PASS â†’ no read.**

* **S5 gate:** S8 does **not** require S5 surfaces. If any implementation chooses to *touch* S5 artefacts, S8 MUST verify the **S5 parameter-scoped PASS** first. (By spec, S8 SHOULD NOT read S5.) 

* **Pathâ†”embed lineage equality:** For every read where lineage columns are embedded, bytes **must equal** the path tokens (e.g., `parameter_hash` on S3 datasets; `{seed,parameter_hash,run_id}` on RNG events). 

## 6.4 Input validity checklist (fail-fast; MUST pass before any write)

Per merchant, S8 SHALL assert:

1. **S3 candidate set** present and schema-valid; `candidate_rank` is total, contiguous; exactly one `home` with rank `0`. 
2. **`nb_final`** present (exactly one per merchant) and schema-valid. 
3. **Counts source available:** either `s3_integerised_counts` present (schema-valid) **or** an in-process counts handoff from S7 is active; **never** reconstruct from weights in S8. Deprecated `ranking_residual_cache_1A` MUST NOT be read.
4. **Membership resolved:** EITHER `s6_membership` is present **and** S6 PASS is verified, OR `gumbel_key` **and** `ztp_final` events exist to reconstruct; otherwise **abort** with `E_PASS_GATE_MISSING` (if S6 PASS missing) or `E_COUNTS_SOURCE_MISSING` (if counts source missing).
5. **Lineage parity:** all embeds equal their path partitions (S3 tables, RNG events). 

## 6.5 Prohibitions (read side)

* S8 MUST NOT read **S5 weight surfaces** to derive counts or order; S5 remains weights authority for S6/S7 only. 
* S8 MUST NOT use legacy **`country_set`** as an order authority; use S3 `candidate_rank` only. 

**Status:** Section 6 is **Binding**.

---

# 7) Write set & contracts **(Binding)**

This section fixes **exactly what S8 writes**, with schema anchors, partitions, PK/sort, column domains, and the **only** instrumentation events S8 emits.

---

## 7.1 Primary egress â€” `outlet_catalogue` (immutable)

**Dataset ID & schema.** `outlet_catalogue` â†’ `schemas.1A.yaml#/egress/outlet_catalogue`. 

**Path & partitions.** `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/` with partitions `[seed, fingerprint]`. **Writer sort** `[merchant_id, legal_country_iso, site_order]`. **No cross-country order is encoded** in this table. 

**Keys.** **PK** = **UK** = `[merchant_id, legal_country_iso, site_order]`. Rows are immutable within a `(seed,fingerprint)` partition. 

**Lineage column.** `manifest_fingerprint` **MUST** be a lowercase hex64 and **MUST byte-equal** the `fingerprint` path token for the partition. 

**Inter-country order boundary (binding).** Consumers that need cross-country order **MUST** join S3 `s3_candidate_set.candidate_rank` (home rank = 0). `outlet_catalogue` **MUST NOT** encode that order. 

---

## 7.2 Column contract (types, domains, FK)

S8 **MUST** write exactly the columns below with the stated domains:

* `manifest_fingerprint` â€” `string`, pattern `^[a-f0-9]{64}$` (**equals** partition `fingerprint`). 
* `merchant_id` â€” `$ref: #/$defs/id64`, non-null. 
* `site_id` â€” `string` (non-null), **6-digit zero-padded** per-(merchant, `legal_country_iso`) sequence, pattern `^[0-9]{6}$`.
* `home_country_iso` â€” `$ref: #/$defs/iso2`, FK â†’ `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`. 
* `legal_country_iso` â€” `$ref: #/$defs/iso2`, FK â†’ `schemas.ingress.layer1.yaml#/iso3166_canonical_2024`. 
* `single_vs_multi_flag` â€” `boolean` (copy of S1 hurdle outcome). 
* `raw_nb_outlet_draw` â€” `int32`, **minimum 2** (accepted NB draw `N` before cross-border allocation). 
* `final_country_outlet_count` â€” `int32`, **1..999,999** (integer outlets allocated to this `legal_country_iso`). 
* `site_order` â€” `int32`, **minimum 1**, contiguous `1..náµ¢` per `(merchant_id, legal_country_iso)` block. 
* `global_seed` â€” `$ref: #/$defs/uint64` (master seed retained for audit/replay). 

**Dictionary echo (normative).** The Dataset Dictionary restates the path, partitions, ordering, schema `$ref`, and the **â€œno cross-country orderâ€** note; 1B consumption is **gated** by the validation bundle for the same fingerprint. 

---

## 7.3 Instrumentation events S8 emits (logs)

S8 emits exactly two **rng_event** families, both partitioned at
`logs/rng/events/<family>/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` and validated by `schemas.layer1.yaml`. Gating in the Dictionary ties them to multi-site merchants. 

1. **`rng_event.sequence_finalize`** â€” final sequence allocation per `(merchant, country)` block.
   **Schema anchor:** `schemas.layer1.yaml#/rng/events/sequence_finalize` (required fields: `merchant_id, country_iso, site_count, start_sequence, end_sequence`). 
   **Dictionary entry & path pattern:** as above; gated by hurdle `is_multi==true`. 

2. **`rng_event.site_sequence_overflow`** â€” guardrail event when 6-digit sequence space would be exceeded; **severity = ERROR**; producer must abort the merchant.
   **Schema anchor:** `schemas.layer1.yaml#/rng/events/site_sequence_overflow` (required fields: `merchant_id, country_iso, attempted_count, max_seq=999999, overflow_by, severity`). 
   **Dictionary entry & path pattern:** as above. 

**Gating (both families).** Emitted **only** for merchants where the hurdle outcome is `is_multi == true` (as pinned in the Dataset Dictionary gating for S8 streams).

**Trace duty (binding).** After **each** event append above, emit **exactly one** cumulative row to `rng_trace_log` for the corresponding `(module, substream_label)`; partitions `{seed, parameter_hash, run_id}`; schema `schemas.layer1.yaml#/rng/core/rng_trace_log`. 

---

## 7.4 Lineage embedding & equality (write-time checks)

* **Egress rows:** `outlet_catalogue.manifest_fingerprint` **MUST equal** the `fingerprint` path token (hex64).
* **Events:** every event row **MUST** embed `{seed, parameter_hash, run_id, manifest_fingerprint}`. `{seed, parameter_hash, run_id}` **MUST** equal their path tokens; `manifest_fingerprint` **MUST** equal the egress fingerprint for this run. 

---

## 7.5 Physical format, writer sort & immutability

* `outlet_catalogue` **format:** Parquet; **writer sort:** `[merchant_id, legal_country_iso, site_order]`; partitioned `[seed, fingerprint]`; immutable once published. 
* **Event files:** JSONL; reader semantics are **set-based** (row order non-authoritative). Trace/audit logs use the core RNG schemas. 
* **Compression policy:** if the registry pins codecs/levels (e.g., ZSTD level 3), producers **MUST** adhere; otherwise value-identity suffices. (Outlet entry notes storage policy and gate.) 

---

## 7.6 Prohibitions & scope limits (write side)

* S8 **MUST NOT** write any artefact that **implies or encodes** inter-country order; consumers **MUST** obtain order from S3 `candidate_rank`. 
* S8 **MUST NOT** derive counts from weights or re-allocate across countries; `final_country_outlet_count` is an upstream fact (S7/S3). (Validators will cross-check in Â§11.) 

---

## 7.7 Consumer gate (egress)

While the **validator/PASS rules** are formalised in Â§11, the Dictionary **already** states the consumption gate: consumers (e.g., 1B) **MUST** verify that `_passed.flag` content hash equals `SHA256(validation_bundle_1A)` for the **same** fingerprint before reading `outlet_catalogue`. 

**Status:** Section 7 is **Binding**.

---

# 8) Behavioural rules â€” materialisation & authority boundaries **(Binding)**

This section fixes **how S8 behaves** when turning upstream facts into the immutable **`outlet_catalogue`** and what S8 is **forbidden** to do. All items are **normative**.

---

## 8.1 Domain & row emission (what becomes rows)

* **Domain source.** S8â€™s per-merchant legal domain is the **S3 candidate set** (`s3_candidate_set`) â€” the only authority for cross-country membership and order (home has `candidate_rank=0`).
* **Counts authority.** For each `(merchant_id, legal_country_iso)`, the integer count **`náµ¢`** comes from **S7 residual evidence** (or **`s3_integerised_counts`** if S3 owns it). S8 **MUST NOT** re-derive counts from weights or any other surface.
* **Emission rule.** S8 **emits rows only for countries with `náµ¢ â‰¥ 1`**. If `náµ¢ == 0`, S8 emits **no rows** for that `(merchant,country)`. 
* **Multi-site scope.** `outlet_catalogue.raw_nb_outlet_draw` is defined with **minimum 2**; therefore **S8 writes only multi-site merchants** (`is_multi==true`). Singles are out of scope for this egress. 

---

## 8.2 Within-country sequencing (what S8 constructs)

* **Contiguous local order.** For each `(merchant_id, legal_country_iso)` with `náµ¢â‰¥1`, S8 **MUST** produce a contiguous **`site_order = 1..náµ¢`** (no gaps, no duplicates). 
* **Deterministic `site_id`.** S8 **MUST** render `site_id = "{site_order:06d}"` (zero-padded 6-digit string; e.g., `1â†’"000001"`, `42â†’"000042"`). `site_id` uniqueness is **scoped to `(merchant_id, legal_country_iso)`**. 
* **No cross-country order.** S8 **MUST NOT** encode any inter-country order in `outlet_catalogue`. Consumers that need cross-country order **MUST** join S3 `candidate_rank`.

---

## 8.3 Instrumentation events (what S8 logs)

* **Finalize per block.** After materialising the rows for a `(merchant, country)` block with `náµ¢â‰¥1`, S8 **MUST** append exactly one **`rng_event.sequence_finalize`** with
  `site_count = náµ¢`, `start_sequence = "000001"`, `end_sequence = "{náµ¢:06d}"`. Event partitions `{seed, parameter_hash, run_id}`; schema `#/rng/events/sequence_finalize`.
* **Overflow guardrail.** If `náµ¢ > 999999`, S8 **MUST** emit **`rng_event.site_sequence_overflow`** (`attempted_count=náµ¢`, `max_seq=999999`, `overflow_by=náµ¢âˆ’999999`, `severity="ERROR"`) and **fail the merchant** (no egress rows for that merchant). 
* **Non-consuming law.** Both events above are **non-consuming** RNG events: **`before==after`, `blocks=0`, `draws="0"`** (envelope identity). **After each event append,** S8 **MUST** append **exactly one** cumulative row to `rng_trace_log`. 
* **Gating.** S8â€™s event families are **present iff** the merchant is multi-site (`is_multi==true`) as encoded in the dictionary **gating** for those streams. 

---

## 8.4 Egress row content (how values are filled)

For each persisted row in `outlet_catalogue`:

* `manifest_fingerprint` **MUST** equal the partition `fingerprint` (**hex64**).
* `raw_nb_outlet_draw` **MUST** copy S2â€™s **`nb_final.n_outlets (N â‰¥ 2)`** for the merchant (same value on all rows for that merchant). 
* `final_country_outlet_count` equals `náµ¢` for that `(merchant, legal_country_iso)`; **per-merchant sum** `Î£áµ¢ náµ¢ = N`. 
* `global_seed` **MUST** equal the runâ€™s master `seed` (uint64). 

---

## 8.5 Authority boundaries (what S8 must respect)

* **Order authority.** **Only** S3 `candidate_rank` may define cross-country order; S8 **MUST NOT** invent, persist, or imply any inter-country order. 
* **Counts authority.** S8 **MUST** treat per-country integer counts as **read-only facts** (S7 / `s3_integerised_counts`). **No renormalisation, no rounding, no re-allocation** in S8.
* **Weights authority.** S8 **MUST NOT** read or persist any weights surface for sequencing; S5 remains weights authority for S6/S7 only. 
* **Legacy surfaces.** `country_set` and any legacy RNG-dependent ranking surfaces are **not** order authorities; S8 **MUST NOT** consult them for order. 

---

## 8.6 Cross-checks S8 must perform before writing (behavioural)

* **Lineage parity.** For all inputs used, **embedded lineage bytes equal path tokens** (`parameter_hash` on S3 tables; `{seed,parameter_hash,run_id}` on RNG events). **Mismatch â‡’ abort.** 
* **S3 membership.** For each `(merchant, country)` with `náµ¢â‰¥1`, confirm that `country` exists in that merchantâ€™s `s3_candidate_set`. **Not in S3 â‡’ abort.** 
* **S6 gate (if used).** If S8 reads `s6_membership`, verify the **S6 PASS** receipt for the same `{seed,parameter_hash}` **before** use. **No PASS â‡’ no read.** 
* **Optional S3 cross-sequence.** If `s3_site_sequence` exists, S8 **MUST** cross-check contiguity/width (1..`náµ¢`) and (if present there) the 6-digit `site_id` format; any divergence is a **hard failure** (`E_SEQUENCE_DIVERGENCE`). S8 **MUST NOT** rewrite S3â€™s semantics. 

---

## 8.7 Prohibitions (hard â€œMUST NOTâ€)

* **No re-computation** of `N`, `náµ¢`, or S3/S6 membership from weights or heuristics. 
* **No cross-country ordering** in `outlet_catalogue` (only within-country `site_order`). 
* **No extra event families** beyond `sequence_finalize` and `site_sequence_overflow` for S8. 
* **No reliance on file order.** Physical file order is non-authoritative; PK/sort keys govern. 

---

## 8.8 Outcomes (deterministic, non-error cases)

S8 recognizes the following **valid** outcomes (still enforcing all invariants in Â§9):

* **`DEG_SINGLE_COUNTRY`** â€” Domain contains only home; S8 materialises `n_home=N`, others zero; still emits `sequence_finalize` for home. 
* **`DEG_ZERO_REMAINDER`** â€” All integer counts are exact floors; `site_order` remains contiguous; instrumentation still emitted. 

---

## 8.9 Publication discipline (write step coupling)

* **Atomicity & idempotence.** After all `(merchant,country)` blocks pass, publish `outlet_catalogue` once under `seed={seed}/fingerprint={manifest_fingerprint}`; content is **immutable** and **byte-stable** for identical inputs/lineage. 
* **Gate reminder.** Downstream (e.g., 1B) **MUST** verify that `_passed.flag` content hash equals `SHA256(validation_bundle_1A)` for the **same fingerprint** before reading `outlet_catalogue`. 

**Status:** Section 8 is **Binding**.

---

# 9) Invariants & integrity constraints **(Binding)**

All clauses below are **normative** and MUST hold for every `(seed,fingerprint)` partition of **`outlet_catalogue`** and its paired S8 instrumentation streams.

---

## 9.1 Row shape, keys, and FK integrity

* **PK/UK law.** Rows in `outlet_catalogue` are **unique** on `[merchant_id, legal_country_iso, site_order]`; writer sort is the same tuple. 
* **Contiguous local order.** For each `(merchant_id, legal_country_iso)` with rows, `site_order` is **exactly** the set `{1,â€¦, final_country_outlet_count}` (no gaps/dupes). 
* **`site_id` bijection.** Within each `(merchant_id, legal_country_iso)` block, `site_id == zfill6(site_order)` and is **unique** in that block; regex `^[0-9]{6}$`. 
* **ISO FKs.** `home_country_iso` and `legal_country_iso` are valid ISO-3166-1 alpha-2 codes (FK to canonical registry). 

---

## 9.2 Lineage equality & immutability

* **Pathâ†”embed equality (egress).** Every rowâ€™s `manifest_fingerprint` **MUST** byte-equal the egress path token `fingerprint` (hex64), and `global_seed` **MUST** equal the egress path token `seed`. **Rows are immutable** within a `(seed,fingerprint)` partition.
* **Pathâ†”embed equality (events).** Every S8 event row embeds `{seed, parameter_hash, run_id, manifest_fingerprint}`; `{seed, parameter_hash, run_id}` **MUST** equal their path tokens and `manifest_fingerprint` **MUST** equal the validation fingerprint for this bundle; envelope fields (`blocks`, `draws`) obey the family budgets in the layer schema.

---

## 9.3 Cross-state equalities (counts & sums)

* **Per-merchant sum law.** Let `N` be S2â€™s accepted draw from `rng_event.nb_final.n_outlets (â‰¥2)`. Summing `final_country_outlet_count` across all `legal_country_iso` for a merchant **MUST equal** `N`. Also, `raw_nb_outlet_draw` is **constant per merchant** and equals `N`.
* **Per-country row law.** For each `(merchant, legal_country_iso)`, the number of rows **equals** that row groupâ€™s `final_country_outlet_count`. (Combines with Â§9.1 contiguity.) 

---

## 9.4 Domain & membership integrity

* **No phantom countries.** Every `(merchant, legal_country_iso)` appearing in `outlet_catalogue` **must** exist in that merchantâ€™s **S3 `s3_candidate_set`**. 
* **Home consistency.** For a given merchant, `home_country_iso` is constant across all rows and equals the **S3 country whose `candidate_rank==0`**. 
* **Zero-count elision.** If an S7/S3 integerised count for a `(merchant,country)` is `0`, **no rows** for that pair appear in `outlet_catalogue`. (S7 integerisation yields non-negative counts with `Î£ count_i = N`.) 

---

## 9.5 Authority separation (order & weights)

* **No cross-country order encoded.** `outlet_catalogue` **does not** contain any cross-country ordering; consumers MUST join **S3 `candidate_rank`** when order is required. Presence of any cross-country rank field in egress is a **hard failure**.
* **No weight semantics.** Egress rows **MUST NOT** embed or imply S5 weights; S5 remains weights authority (used upstream by S6/S7 only). 

---

## 9.6 Event coverage & envelope invariants (S8 streams)

For each `(merchant, country)` with `final_country_outlet_count = n â‰¥ 1`:

* **Exactly one** `rng_event.sequence_finalize` with
  `site_count = n`, `start_sequence = "000001"`, `end_sequence = zfill6(n)`. 
* **Non-consuming law.** `sequence_finalize` and `site_sequence_overflow` (if any) are **non-consuming** events (`before==after`, `blocks=0`, `draws="0"`). 
* **Overflow rule.** If `n > 999999`, producer **must** emit `rng_event.site_sequence_overflow` with `{attempted_count=n, max_seq=999999, overflow_by=nâˆ’999999}` and **fail the merchant** (no egress rows for that merchant). 
* **Trace duty.** After **each** event append above, append **exactly one** cumulative `rng_trace_log` row for the corresponding `(module, substream_label)`. 

---

## 9.7 Column-level domain checks (egress)

* `single_vs_multi_flag == true` for all rows (S8 writes multi-site merchants only). 
* `raw_nb_outlet_draw â‰¥ 2`; `final_country_outlet_count âˆˆ [1, 999999]`; `site_order â‰¥ 1`; `site_id` matches `^[0-9]{6}$`; `global_seed` is a valid `uint64`. 

---

## 9.8 Join-back sanity (no permutation against S3)

* Join `outlet_catalogue` (distinct **`legal_country_iso`**) to S3 `s3_candidate_set` on `outlet_catalogue.(merchant_id, legal_country_iso) = s3_candidate_set.(merchant_id, country_iso)` and then:
  (a) succeed for **all** egress countries; and
  (b) show **no permutation** of cross-country order when sorted by `candidate_rank` (egress does not encode order, only that the **set** matches). 

---

## 9.9 Hand-off gate (consumer constraint)

* For a given `fingerprint`, consumers (e.g., 1B) **MUST** verify that the `_passed.flag` in `data/layer1/1A/validation/fingerprint={fingerprint}/` has **content hash equal to `SHA256(validation_bundle_1A)`** for the same fingerprint **before** reading `outlet_catalogue`. **No PASS â†’ no read.** 

**Status:** Section 9 is **Binding**.

---

# 10) Error handling, edge cases & degrade ladder **(Binding)**

This section fixes **how S8 fails, degrades, or proceeds deterministically**. All codes and actions below are **normative**.

---

## 10.1 Error classes (names, triggers, actions)

Each error has a **Trigger â†’ Emit â†’ Action** triad. â€œEmitâ€ refers to S8â€™s own streams (when applicable) or to writing a failure record into the fingerprintâ€™s validation bundle context; all emits must follow the schemas and dictionary paths for logs/validation.

**E_PASS_GATE_MISSING**

* **Trigger:** S8 attempts to read a convenience surface that requires a PASS (e.g., `s6_membership`) but the **S6 receipt** folder for the same `{seed,parameter_hash}` is absent or `_passed.flag` content hash â‰  `SHA256(S6_VALIDATION.json)`.
* **Emit:** Failure record in the S8 validator bundle context for this fingerprint.
* **Action:** **Abort** the run before any egress write. **No PASS â†’ no read.** 

**E_SCHEMA_INVALID**

* **Trigger:** Any required input fails its JSON-Schema (`s3_candidate_set`, `rng_event.nb_final`, `rng_event.gumbel_key`/`ztp_final` when reconstructing membership).
* **Emit:** Failure record (schema path, first violation).
* **Action:** **Abort**.

**E_PATH_EMBED_MISMATCH**

* **Trigger:** Any lineage column **bytes-not-equal** to its path token (e.g., `parameter_hash` in S3 tables, `{seed,parameter_hash,run_id}` in RNG events; `manifest_fingerprint` in egress).
* **Emit:** Failure record (dataset/stream, offending value vs token).
* **Action:** **Abort**.

**E_S3_MEMBERSHIP_MISSING**

* **Trigger:** A `(merchant,country)` appears in counts but **not** in `s3_candidate_set` for that merchant.
* **Emit:** Failure record listing the phantom `(merchant,country)`.
* **Action:** **Abort** (S3 is the sole order/membership authority). 

**E_COUNTS_SOURCE_MISSING**

* **Trigger:** Neither `s3_integerised_counts` (when designated) **nor** an in-process S7 counts handoff is available; or per-country counts cannot be recovered from the authoritative S7 evidence.
* **Emit:** Failure record (merchant list).
* **Action:** **Abort** (S8 MUST NOT derive counts from weights).

**E_DUP_PK**

* **Trigger:** Would-be `outlet_catalogue` contains duplicate PK `[merchant_id, legal_country_iso, site_order]`.
* **Emit:** Failure record (first duplicate).
* **Action:** **Abort**. (PK/UK are binding.) 

**E_SEQUENCE_GAP**

* **Trigger:** For any `(merchant, legal_country_iso)` with `nâ‰¥1`, proposed `site_order` set is **not exactly** `{1,â€¦,n}`.
* **Emit:** Failure record (first gap/dup).
* **Action:** **Abort**. 

**E_SITE_ID_OVERFLOW**

* **Trigger:** `n > 999,999` for a `(merchant,country)` block.
* **Emit:** **`rng_event.site_sequence_overflow`** with `{attempted_count, max_seq=999999, overflow_by, severity="ERROR"}` **and** a failure record.
* **Action:** **Abort the merchant** (no egress rows for that merchant). 

**E_ORDER_AUTHORITY_DRIFT**

* **Trigger:** Any attempt to **encode** or **imply** cross-country order in `outlet_catalogue`, or divergence from `s3_candidate_set.candidate_rank` when order is joined for checks.
* **Emit:** Failure record (fields that imply order).
* **Action:** **Abort**. (S3 is sole authority.) 

**E_SUM_MISMATCH**

* **Trigger:** For a merchant, `Î£ final_country_outlet_count â‰  rng_event.nb_final.n_outlets`.
* **Emit:** Failure record (merchant ID, observed sums).
* **Action:** **Abort**. 

**E_FK_ISO_INVALID**

* **Trigger:** `home_country_iso` / `legal_country_iso` not in canonical ISO registry.
* **Emit:** Failure record (first offending ISO).
* **Action:** **Abort**. 

**E_TRACE_COVERAGE_MISSING**

* **Trigger:** A required S8 event (`sequence_finalize` or `site_sequence_overflow`) was appended but **no** paired `rng_trace_log` row follows; or vice versa coverage counts donâ€™t tally.
* **Emit:** Failure record (event family, counts).
* **Action:** **Abort**. 

---

## 10.2 Edge cases (deterministic non-errors)

These are **valid** outcomes; S8 proceeds and still writes normal outputs and events:

* **DEG_SINGLE_COUNTRY.** Domain is only home; S8 writes `n_home=N`, emits one `sequence_finalize` for home. 
* **DEG_ZERO_REMAINDER.** All integer counts equal floors (no bumps); `site_order` still contiguous `1..náµ¢`; normal finalize events. 

---

## 10.3 Degrade ladder (when optional conveniences are missing)

S8 follows this **ordered** ladder; each step is **binding**:

1. **Prefer S3 parameter-scoped determinism when present.**
   If `s3_integerised_counts` exists, S8 **MUST** read it (authoritative counts) and proceed. 

2. **Otherwise, use in-process S7 counts handoff.**
   S8 **MUST NOT** reconstruct counts from S5 weights; counts must come from S7 evidence (residual ranks) if S3 did not emit counts. 

3. **Membership surface preference.**
   If `s6_membership` exists **and** S6 PASS is verified, use it; **else** reconstruct membership from `rng_event.gumbel_key` + `rng_event.ztp_final`. **Do not abort** simply because the convenience surface is absent.

4. **Optional upstream S3 sequencing.**
   If `s3_site_sequence` exists, S8 **cross-checks** only (does not change semantics). Divergence â‡’ `E_SEQUENCE_DIVERGENCE` (abort). 

---

## 10.4 Emit rules & envelopes (S8 streams)

* **`rng_event.sequence_finalize`**: **exactly one** per `(merchant,country)` with `nâ‰¥1`, with `site_count=n`, `start_sequence="000001"`, `end_sequence=zfill6(n)`; event is **non-consuming** (`blocks=0`, `draws="0"`). 
* **`rng_event.site_sequence_overflow`**: only when `n>999999`; severity=`"ERROR"`; **non-consuming** envelope. 
* **`rng_trace_log`**: after **every** append above, S8 appends **exactly one** cumulative trace row. Paths/partitions must match `{seed, parameter_hash, run_id}`. 

---

## 10.5 Abort & cleanup discipline

On any **Abort** action:

* **Do not** publish `outlet_catalogue` for the fingerprint (or the merchant, if the failure is merchant-scoped like overflow).
* Ensure partial temp paths are removed; **no partial contents** become visible (atomic publish discipline in Â§5). 
* Record the failure in the fingerprintâ€™s validation bundle context for post-hoc inspection; the consumer gate remains **FAILED** (no `_passed.flag`). 

---

## 10.6 Severity mapping (informative for ops)

* **ERROR (hard failure):** all `E_*` codes above.
* **INFO (deterministic outcome):** `DEG_SINGLE_COUNTRY`, `DEG_ZERO_REMAINDER`.

**Status:** Section 10 is **Binding**.

---

# 11) Validation battery & PASS gate **(Binding)**

**Purpose.** Prove that S8 wrote a correct, reproducible `outlet_catalogue` under the S0â€“S7 contracts; verify instrumentation coverage; and publish a **fingerprint-scoped** validation bundle whose `_passed.flag` is the consumption **gate** for 1B (**no PASS â†’ no read**). 

---

## 11.1 Inputs the validator MUST read (and their anchors)

* **Subject of validation:** `outlet_catalogue` â†’ `schemas.1A.yaml#/egress/outlet_catalogue` (PK/UK, partitions `[seed,fingerprint]`, writer sort). 
* **Order authority:** `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` (total, contiguous ranks; `home` at 0). 
* **Count facts:** `rng_event.nb_final` â†’ `schemas.layer1.yaml#/rng/events/nb_final` (exactly one per merchant; **non-consuming**). If present, also read `s3_integerised_counts` â†’ `schemas.1A.yaml#/s3/integerised_counts`. Otherwise, use S7 residual evidence (`rng_event.residual_rank`).
* **S8 instrumentation:** `rng_event.sequence_finalize`, `rng_event.site_sequence_overflow` (S8-emitted families). Also `rng_trace_log` and `rng_audit_log` for coverage.
* **Gates (if conveniences were used upstream):** `s6_validation_receipt` when `s6_membership` was read by S8. **No PASS â†’ no read.** 

---

## 11.2 Structural checks (schemas, partitions, lineage)

The validator **MUST** assert:

1. **Schema-validity & partitions** for all inputs above (tables/events match their `$ref`; paths match dictionary path templates & partitions).
2. **Pathâ†”embed equality:** every egress rowâ€™s `manifest_fingerprint` equals the `fingerprint` path token; every RNG/event row (audit/trace/S8 events) embeds `{seed, parameter_hash, run_id, manifest_fingerprint}` where `{seed, parameter_hash, run_id}` equal the path tokens and `manifest_fingerprint` equals the **validation fingerprint** for this bundle. **Any mismatch â‡’ fail.**
3. **S6 gate (if applicable):** if `s6_membership` was consumed by the producer, the S6 receipt folder exists and `_passed.flag` content hash equals `SHA256(S6_VALIDATION.json)` for the same `{seed,parameter_hash}`. **No PASS â†’ fail.** 

---

## 11.3 Content checks (egress invariants)

For each `(merchant_id, legal_country_iso)` group with rows:

* **Contiguity & keys:** `site_order` is exactly `{1..final_country_outlet_count}` with no gaps/dupes; `site_id` is zero-padded 6-digit rendering of `site_order` (regex `^[0-9]{6}$`). PK unique on `[merchant_id, legal_country_iso, site_order]`. 
* **Lineage fields:** `manifest_fingerprint` is lowercase hex64 and equals the partition token; `global_seed` **equals the `seed` path token** and is a valid `uint64`.
* **No cross-country order encoded:** the table contains **no** field implying inter-country order; dictionary note requires consumers to join S3 `candidate_rank`. Presence of such fields â‡’ fail. 

---

## 11.4 Cross-state equalities (counts, sums, membership)

Per merchant:

* **Sum law vs S2:** `Î£_c final_country_outlet_count == rng_event.nb_final.n_outlets` and egress `raw_nb_outlet_draw` equals that same `N`. 
* **Membership law vs S3:** every `(merchant, legal_country_iso)` present in egress must exist in that merchantâ€™s `s3_candidate_set`; exactly one `home` in S3 and `home_country_iso` constant across egress rows. 
* **Counts authority:** if `s3_integerised_counts` exists, its `{merchant,country,count}` matches egress `{final_country_outlet_count}`; otherwise, the multiset of per-country counts reconstructed from S7 `rng_event.residual_rank` equals egress counts. **Any discrepancy â‡’ fail.**

---

## 11.5 Event coverage & RNG envelope checks

For each `(merchant, country)` with `final_country_outlet_count = n â‰¥ 1`:

* **Exactly one** `rng_event.sequence_finalize` with `{site_count=n, start_sequence="000001", end_sequence=zfill6(n)}`. 
* **Overflow rule:** if `n > 999999`, there MUST be a `rng_event.site_sequence_overflow{attempted_count=n, max_seq=999999, overflow_by}` and **no** egress rows for that merchant (merchant-scoped abort). 
* **Non-consuming law:** both S8 event families are **non-consuming** (`before==after`, `blocks=0`, `draws="0"`); validator verifies envelopes. 
* **Trace duty:** after **each** event append above, **exactly one** cumulative `rng_trace_log` row exists (saturating totals; `draws_total` equals sum of event `draws`). 

---

## 11.6 Egress join-back sanity (order separation)

Join distinct egress countries back to S3 on `outlet_catalogue.(merchant_id, legal_country_iso) = s3_candidate_set.(merchant_id, country_iso)`; assert the set matches and that sorting by `candidate_rank` yields a consistent cross-country order (egress itself remains order-free).

---

## 11.7 Validator artefacts & PASS gate (fingerprint-scoped)

Write the **validation bundle** under:
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` (fingerprint partition). Bundle contains machine-readable results (e.g., schema checks, counts & sums, membership parity, RNG accounting, FK checks). Compute `_passed.flag` as:

* Single line: `sha256_hex = <hex64>`, where `<hex64>` is the SHA-256 over the **ASCII-lexicographic concatenation** of all other bundle filesâ€™ bytes (exclude `_passed.flag`). Publish atomically into the fingerprint folder.

**Gate rule (consumer binding):** 1B **MUST** verify that `_passed.flag` content hash equals `SHA256(validation_bundle_1A)` for the **same** fingerprint before reading `outlet_catalogue`. **No PASS â†’ no read.**

---

## 11.8 Exit semantics

* **PASS:** all checks in Â§Â§11.2â€“11.6 succeed; bundle written; `_passed.flag` valid. `outlet_catalogue` remains readable by 1B under the gate. 
* **FAIL:** any structural, lineage, count, membership, or RNG-coverage breach. Publish bundle with failure records; **do not** modify `outlet_catalogue`; gate remains **failed** (no valid `_passed.flag`). 

---

## 11.9 Determinism requirement (validator)

With identical inputs, schemas, dictionary, and numeric environment, the validator **MUST** produce a byte-identical bundle and the same `_passed.flag` hash (idempotent, atomic publish). 

**Status:** Section 11 is **Binding**.

---

# 12) Concurrency, sharding & determinism **(Binding)**

This section fixes how S8 may parallelise work and still produce **byte-stable** `outlet_catalogue` and **value-stable** logs. All clauses are **normative**.

---

## 12.1 Writer discipline (single identity, at-most-once)

* **Partition identity (egress):** `(dataset='outlet_catalogue', seed, fingerprint)`; this partition is **write-once**. If it already exists, producers **MUST** verify byte identity; if different, **hard-fail** (no overwrite). Egress path & sort are fixed by the Dictionary & schema.
* **Atomic publish:** **Stage â†’ fsync â†’ atomic rename** into the Dictionary location; **no partial contents** may become visible. After publish, the partition is **immutable**. (Discipline mirrors S7 Â§10.4.) 

## 12.2 Sharding model (how to split the work)

* **Shard key:** S8 **MUST** shard on `merchant_id` (ranges or hash buckets). Each worker owns a disjoint merchant set; **no merchant may be processed by two workers**. (Prevents duplicate events/rows.) 
* **Block atomicity:** The unit of emission is a **(merchant, legal_country_iso)** block with `nâ‰¥1`. A worker **MUST** emit exactly `n` rows with `site_order=1..n` for that block, then append **one** `sequence_finalize` event.
* **Set semantics across files:** Physical file order is non-authoritative; equality is by **row set**. Writers must honour the Dictionaryâ€™s **writer sort** for egress. 

## 12.3 Determinism w.r.t. worker counts, retries & scheduling

* **Worker-count invariance:** Changing the number of workers or task schedule **MUST NOT** change any value or emitted row. Determinism is guaranteed by: S3â€™s **candidate_rank** authority (order), S7/S3 **counts** authority, fixed egress **sort keys**, and atomic publish.
* **Retry semantics:** On failure, producers **MUST NOT** partially publish; they **MAY** retry after cleaning temp paths. Re-running with identical inputs and lineage **MUST** yield byte-identical egress. (Same discipline as S7 Â§10.3â€“10.4.) 

## 12.4 RNG logs under parallelism (events are non-consuming)

* **Families S8 emits:** `rng_event.sequence_finalize` and (guardrail) `rng_event.site_sequence_overflow`, both partitioned by `{seed, parameter_hash, run_id}` and validated by layer schemas.
* **Envelope law:** S8â€™s events are **non-consuming** (`before==after`, `blocks=0`, `draws="0"`); envelopes **MUST** populate `{seed, parameter_hash, run_id, manifest_fingerprint}` per schema. `manifest_fingerprint` **MUST** equal the egress fingerprint (there is no path token for it on event paths).
* **Trace duty (per event):** After **each** append to `sequence_finalize` or `site_sequence_overflow`, S8 **MUST** append **exactly one** cumulative row to `rng_trace_log` for the corresponding `(module, substream_label)`. Totals reconcile irrespective of concurrency (saturating sums).
* **No double-emission:** A given `(merchant, country)` **MUST NOT** produce multiple `sequence_finalize` events; detect and fail on concurrent write intent. (Same pattern as S7 Â§10.5.) 

## 12.5 Multi-run semantics (run_id)

* **`run_id` partitions logs only.** Multiple `run_id`s may coexist for the same `{seed, parameter_hash}` without changing model outcomes or egress semantics. Egress remains **fingerprint-scoped**. 
* **Audit first, then events:** Emit `rng_audit_log` once at run start, then events, then traces; all under `{seed, parameter_hash, run_id}` with schema-valid embeddings. 

## 12.6 Ownership & isolation

* **S8 writes only its families** (`sequence_finalize`, `site_sequence_overflow`) plus egress. It **MUST NOT** write S1â€“S7 families or any RNG core paths owned by other states except its trace/audit appends. (Ownership & schemas enumerated in the registry/dictionary.)
* **No cross-state emissions:** S8 does **not** emit selection keys (`gumbel_key`), NB/ZTP components, or residuals; those belong to S6/S2/S4/S7 respectively.

## 12.7 Lineage equality & canonical paths (concurrency checks)

* **Pathâ†”embed equality** is **binding** on every event/log row for `{seed, parameter_hash, run_id}`, and on egress for `manifest_fingerprint == fingerprint path token`. Mismatch â‡’ abort.
* **Canonical paths only:** All writes **MUST** target the Dictionary paths and partitions for their families/datasets; free-hand paths are non-conformant. 

## 12.8 Storage & writer policy (if pinned)

* **Egress Parquet:** honour Dictionary writer sort `[merchant_id, legal_country_iso, site_order]`; compression **as pinned** (e.g., ZSTD level 3) when specified by the registry; otherwise, value identity suffices.
* **JSONL events:** set semantics across parts; line order within a file has no semantic meaning; validators use cumulative **trace** totals and event counts. 

## 12.9 Consumer guarantees (what parallelism may not break)

Given Â§Â§12.1â€“12.8 and the invariants in Â§9, consumers are guaranteed that for any fixed `(seed,fingerprint)`:

* `outlet_catalogue` is **byte-stable** and **order-stable** by its sort keys;
* each `(merchant, country)` block contributes `n` rows with `site_order=1..n` and a single `sequence_finalize` event;
* RNG core logs reconcile (`draws_total`, `blocks_total`, `events_total`) regardless of producer concurrency.

**Status:** Section 12 is **Binding**.

---

# 13) Observability & metrics **(Binding)**

This section fixes **what S8 must emit/observe**, **the counters & coverage it must publish**, and **where those metrics live**. All clauses are **normative**.

---

## 13.1 Observability surfaces (streams & locations)

* **Core RNG logs (run-scoped):**
  **`rng_audit_log`** and **`rng_trace_log`** under
  `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl` and
  `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl`.
  The trace is **per-(module, substream_label)** with saturating totals; **emit exactly one cumulative trace row after each RNG event append**. 

* **S8 instrumentation events (merchantÃ—country blocks):**
  **`rng_event.sequence_finalize`** at
  `logs/rng/events/sequence_finalize/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` (final sequence per block), and
  **`rng_event.site_sequence_overflow`** at
  `logs/rng/events/site_sequence_overflow/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl` (guardrail).
  Both families are schema-anchored in `schemas.layer1.yaml` and **gated** to multi-site merchants (`gated_by: rng_event_hurdle_bernoulli; predicate: is_multi==true`).

* **Egress & hand-off context:** `outlet_catalogue` (fingerprint-scoped) and the **validation bundle** folder that gates consumption.

---

## 13.2 Trace & envelope duty (must hold)

* After **each** append to `sequence_finalize` or `site_sequence_overflow`, S8 **MUST** append **exactly one** cumulative row to `rng_trace_log` for the corresponding `(module, substream_label)`. The trace reconciles **events_total**, **draws_total**, and **blocks_total** (per schema: draws_total equals the sum of event-level draws; blocks via counters). 
* S8 event families are **non-consuming** (per Â§8/Â§9): validator reconciliation therefore expects **event counts to rise**, while **draws_total/blocks_total contributions from S8 families are zero**; the trace still logs the events_total increment. 

---

## 13.3 Metrics S8 MUST publish (in the validation bundle)

The validator **MUST** write the following artefacts under
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`:

1. **`rng_accounting.json`** â€” event and trace reconciliation:

   * `sequence_finalize_events` (count)
   * `site_sequence_overflow_events` (count)
   * `trace_events_total_delta` for S8 substreams (should equal the sum of the two counts)
   * `trace_draws_total_delta` and `trace_blocks_total_delta` for S8 substreams (expected **0**)
   * `audit_present` (boolean) and audit/trace **pathâ†”embed** parity results.
     *(The bundle is the basis of the consumer gate and already enumerated to contain RNG accounting/metrics.)* 

2. **`s8_metrics.json`** â€” egress & domain coverage:

   * `merchants_in_egress` (distinct `merchant_id`)
   * `blocks_with_rows` (count of `(merchant, legal_country_iso)` with `nâ‰¥1`)
   * `rows_total` (egress rows), checksum of PK tuple hashes, and `rows_total_by_country` (map `legal_country_iso â†’ rows`) â€” helpful for 1B pre-flight checks
   * `hist_final_country_outlet_count` (bucketed histogram of `n`)
   * `domain_size_distribution` (histogram of `|Dâ‚˜|`, joined from S3)
   * `overflow_merchant_count` and list (ids truncated or hashed)
   * `sum_law_mismatch_count` (should be 0)
   * `s3_membership_miss_count` (should be 0)
   * `iso_fk_violation_count` (should be 0).
     *(Validation bundle is defined to carry â€œmetrics, plots, diffsâ€; these keys are binding for S8.)* 

3. **`egress_checksums.json`** â€” stable hashes for reproducibility (e.g., SHA-256 per file and whole-partition composite) to support byte-identity assertions on re-runs. *(Lives in the same bundle as above.)* 

> The bundleâ€™s `_passed.flag` content hash **MUST** equal `SHA256(validation_bundle_1A)` for the same fingerprint; consumers verify this **before** reading `outlet_catalogue`. 

---

## 13.4 SLO-style thresholds (binding alerts)

The validator **MUST** hard-fail (Â§11) if any of the following non-exhaustive conditions are met (write into the bundle and withhold `_passed.flag`):

* `trace_events_total_delta â‰  sequence_finalize_events + site_sequence_overflow_events`. 
* `sum_law_mismatch_count > 0` or `s3_membership_miss_count > 0`. (Breaks core invariants.) 
* Any **pathâ†”embed** mismatch detected for audit/trace/events. 

---

## 13.5 Retention & access control (operational)

* **Retention:** `rng_audit_log` and `rng_trace_log`: **365 days**; S8 event streams (`sequence_finalize`, `site_sequence_overflow`): **180 days**; `outlet_catalogue` and the validation bundle: **365 days** (minimum). Producers **MUST** adhere to the dictionaryâ€™s retention.
* **Gate:** `outlet_catalogue` is readable **only** after the validation bundleâ€™s `_passed.flag` verifies for the same fingerprint (**no PASS â†’ no read**). 

---

## 13.6 Module & labels (log identity)

* S8 producers **MUST** populate the RNG envelopes with the `(module, substream_label)` values enumerated for S8 (see Appendix A). The dictionary lineage shows S8â€™s producer as **`1A.site_id_allocator`** for `sequence_finalize`; use the same module label across S8 events for consistent trace roll-up. 

**Status:** Section 13 is **Binding**.

---

# Appendix A â€” Enumerations & literal labels **(Normative)**

This appendix freezes the **exact strings** S8 producers/validators must use in logs, datasets, gates, and error reporting. Unless stated otherwise, all items are **binding**.

---

## A.1 RNG `module` / `substream_label` literals for S8

* **`module` (all S8-emitted events):**
  `1A.site_id_allocator`  â€” emitter of S8 instrumentation families. 

* **`substream_label` (per family):**
  `sequence_finalize` â€” final per-(merchant,country) sequence event. 
  `site_sequence_overflow` â€” guardrail when 6-digit space would overflow. 

> Conformance: these values **MUST** populate the RNG envelope fields `module` and `substream_label` for S8â€™s event rows (schema `#/rng_envelope`). 

---

## A.2 Event family names & canonical paths (S8)

* **`rng_event.sequence_finalize`**
  Path: `logs/rng/events/sequence_finalize/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
  Schema: `schemas.layer1.yaml#/rng/events/sequence_finalize`
  Gating: `gated_by: rng_event_hurdle_bernoulli`, `predicate: is_multi == true`. 

* **`rng_event.site_sequence_overflow`**
  Path: `logs/rng/events/site_sequence_overflow/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/part-*.jsonl`
  Schema: `schemas.layer1.yaml#/rng/events/site_sequence_overflow`
  Gating: same as above. 

* **Core RNG logs (read by validator):**
  `rng_audit_log` â†’ `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl` (schema `#/rng/core/rng_audit_log`)
  `rng_trace_log` â†’ `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl` (schema `#/rng/core/rng_trace_log`)
  *(Trace requires exactly one cumulative row after **each** RNG event append.)*

---

## A.3 Dataset IDs S8 reads/writes (IDs â†’ `$ref` â†’ partitions)

* **Egress (S8 writes):**
  `outlet_catalogue` â†’ `schemas.1A.yaml#/egress/outlet_catalogue` â†’ `[seed, fingerprint]`
  Path: `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/`.
  *(Does **not** encode cross-country order; consumers must join S3 candidate rank.)*

* **Order authority (read):**
  `s3_candidate_set` â†’ `schemas.1A.yaml#/s3/candidate_set` â†’ `[parameter_hash]`. 

* **Counts surface (read, variant if present):**
  `s3_integerised_counts` â†’ `schemas.1A.yaml#/s3/integerised_counts` â†’ `[parameter_hash]`. 

* **Optional upstream sequence (cross-check only, if present):**
  `s3_site_sequence` â†’ `schemas.1A.yaml#/s3/site_sequence` â†’ `[parameter_hash]`. 

* **Membership convenience (read if used):**
  `s6_membership` â†’ `schemas.1A.yaml#/s6/membership` â†’ `[seed, parameter_hash]`
  `s6_validation_receipt` â†’ `schemas.layer1.yaml#/validation/s6_receipt` â†’ `[seed, parameter_hash]` *(gate)*. 

---

## A.4 Gate & bundle identifiers (hand-off)

* **Validation bundle (fingerprint-scoped):** `validation_bundle_1A`
  Path: `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` (schema `schemas.1A.yaml#/validation/validation_bundle`).

* **Consumer gate flag:** `validation_passed_flag` (file: `_passed.flag`)
  Rule: content hash equals `SHA256(validation_bundle_1A)` for the **same** fingerprint (**no PASS â†’ no read**). 

---

## A.5 Payload field literals & constants (S8 events)

* **`sequence_finalize` payload keys:** `merchant_id`, `country_iso`, `site_count`, `start_sequence`, `end_sequence`.
  Domain: `start_sequence`, `end_sequence` âˆˆ `six_digit_seq` (`^[0-9]{6}$`). 
  Naming note: **Events** use `country_iso`; **egress** uses `legal_country_iso`; both FK â†’ `iso3166_canonical_2024`.

* **`site_sequence_overflow` payload keys:** `merchant_id`, `country_iso`, `attempted_count`, `max_seq`, `overflow_by`, `severity`.
  Constants: `max_seq = 999999`, `severity = "ERROR"`. 

---

## A.6 Lineage & path tokens (exact column/segment names)

* Path tokens used by S8: `seed`, `parameter_hash`, `run_id`, `fingerprint`.
* Embedded lineage columns that must **byte-equal** path tokens where present:
  `manifest_fingerprint` (egress row) â†” `fingerprint` (path);
  `{seed, parameter_hash, run_id}` (event rows) â†” their path segments;
  and for **event rows**, `manifest_fingerprint` **MUST** equal the runâ€™s egress fingerprint (not a path token).

---

## A.7 Error & outcome codes (S8)

**Errors (hard failures):**
`E_PASS_GATE_MISSING` Â· `E_SCHEMA_INVALID` Â· `E_PATH_EMBED_MISMATCH` Â· `E_S3_MEMBERSHIP_MISSING` Â· `E_COUNTS_SOURCE_MISSING` Â· `E_DUP_PK` Â· `E_SEQUENCE_GAP` Â· `E_SITE_ID_OVERFLOW` Â· `E_ORDER_AUTHORITY_DRIFT` Â· `E_SUM_MISMATCH` Â· `E_FK_ISO_INVALID` Â· `E_TRACE_COVERAGE_MISSING` Â· `E_SEQUENCE_DIVERGENCE` (if `s3_site_sequence` is present and disagrees). *(These are defined by this spec; severity = ERROR for all.)*

**Deterministic non-errors (informative outcomes):**
`DEG_SINGLE_COUNTRY` Â· `DEG_ZERO_REMAINDER`. *(Defined by this spec.)*

---

## A.8 Notes on deprecated/legacy IDs (do **not** use for authority)

* `country_set` (legacy RNG-dependent set; **not** an order authority).
* `ranking_residual_cache_1A` (deprecated; superseded by `s3_integerised_counts`). 

---

## A.9 External FK targets (for completeness)

* `iso3166_canonical_2024` â€” FK target for ISO-2 in `home_country_iso` / `legal_country_iso`. 

**Status:** Appendix A is **Normative**.

---

# Appendix B â€” Worked micro-examples **(Informative)**

These toy scenarios illustrate S8 behaviour. Values are illustrative only; they do **not** change any binding rule above.

---

## B.1 Normal multi-country merchant (three-country domain)

**Lineage tokens**
`seed=1234567890123456789` (uint64) Â· `parameter_hash=a1â€¦a1` (**hex64**) Â· `run_id=9fâ€¦9f` (**hex32**) Â· `fingerprint=0123456789abcdefâ€¦(**hex64**)`

**S3 candidate set (sole cross-country order, home rank=0)**
`GB(0), US(1), DE(2)` â€” total, contiguous.

**Upstream facts**
`N` (S2 `nb_final.n_outlets`) = **7**.
S7 integerised counts: `GB:4, US:2, DE:1` (sum = 7).
S6 membership agrees with S3 domain.

**S8 writes** `outlet_catalogue` (partitioned by `[seed, fingerprint]`; writer sort `[merchant_id, legal_country_iso, site_order]`):

| `merchant_id` | `home_country_iso` | `legal_country_iso` | `site_order` | `site_id` | `raw_nb_outlet_draw` | `final_country_outlet_count` | `manifest_fingerprint` |       `global_seed` |
|---------------|--------------------|---------------------|-------------:|----------:|---------------------:|-----------------------------:|------------------------|--------------------:|
| m42           | GB                 | GB                  |            1 |    000001 |                    7 |                            4 | â€¦fingerprintâ€¦          | 1234567890123456789 |
| m42           | GB                 | GB                  |            2 |    000002 |                    7 |                            4 | â€¦                      |                   â€¦ |
| m42           | GB                 | GB                  |            3 |    000003 |                    7 |                            4 | â€¦                      |                   â€¦ |
| m42           | GB                 | GB                  |            4 |    000004 |                    7 |                            4 | â€¦                      |                   â€¦ |
| m42           | GB                 | US                  |            1 |    000001 |                    7 |                            2 | â€¦                      |                   â€¦ |
| m42           | GB                 | US                  |            2 |    000002 |                    7 |                            2 | â€¦                      |                   â€¦ |
| m42           | GB                 | DE                  |            1 |    000001 |                    7 |                            1 | â€¦                      |                   â€¦ |

**S8 emits** instrumentation (non-consuming events; each followed by one `rng_trace_log` row):

* `sequence_finalize(merchant=m42,country=GB, site_count=4, start_sequence="000001", end_sequence="000004")`
* `sequence_finalize(merchant=m42,country=US, site_count=2, â€¦, end_sequence="000002")`
* `sequence_finalize(merchant=m42,country=DE, site_count=1, â€¦, end_sequence="000001")`

**Checks that pass**

* Per-merchant sum: `4+2+1 = 7 = N`.
* Per-country contiguity: each block has `site_order = 1..náµ¢`; `site_id = zfill6(site_order)`.
* No cross-country order encoded; consumers join S3 `candidate_rank` when needed.

---

## B.2 Single-country domain (degenerate but valid)

**S3 candidate set**: `NG(0)` only.
**Upstream facts**: `N = 3`; S7 counts: `NG:3`.
**S8 egress** (three rows) with `legal_country_iso=NG`, `site_order=1..3` (`site_id` 000001..000003).
**S8 events**: one `sequence_finalize(â€¦, country=NG, site_count=3, start="000001", end="000003")`.
**Outcome label**: `DEG_SINGLE_COUNTRY`.

---

## B.3 Overflow guardrail (merchant-scoped abort)

**S3 candidate set**: `CN(0)` only (or any single country).
**Upstream facts**: per-country integer count `n_CN = 1,000,001` (> 999,999 limit).
**S8 behaviour**

* Emit `site_sequence_overflow(merchant=mx, country=CN, attempted_count=1000001, max_seq=999999, overflow_by=2, severity="ERROR")`.
* **Do not** write any `outlet_catalogue` rows for merchant `mx`; mark merchant as failed in the validation bundle.
* Partition remains readable for other merchants; overall fingerprint may still PASS if failures are handled per policy (if policy is â€œabort merchant onlyâ€). *(Exact abort scope is as specified in Â§10.)*

---

## B.4 Using S3 integerised counts vs S7 evidence (both valid)

* **Variant A (preferred when present):** `s3_integerised_counts` says `BR:2, AR:1, UY:1` (N=4). S8 copies these counts verbatim; sequences are `1..2`, `1..1`, `1..1`.
* **Variant B (no S3 counts surface):** S8 receives the in-process S7 counts handoff (reconstructed by the validator from `rng_event.residual_rank`). Counts identical to above; S8 behaviour is the same.
* In **both** cases, S8 does **not** read weights and does **not** alter counts.

---

## B.5 Path & lineage parity (spot example)

Given path
`â€¦/outlet_catalogue/seed=1234567890123456789/fingerprint=0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef/part-000.parquet`,
every egress row **must** embed `manifest_fingerprint = "0123456789abcdefâ€¦"` and `global_seed = 1234567890123456789`. Any byte mismatch triggers `E_PATH_EMBED_MISMATCH` (see Â§10).

---

**Note:** These examples are **Informative**. The **Binding** behaviour, contracts, and gates are defined in Â§Â§0â€“13 and Appendix A.

---

# Appendix C â€” Storage conventions **(Informative)**

These are **non-binding** operational defaults for files, folders, and object-store hygiene. Authority for **paths, partitions, formats, retention** remains with the **Dataset Dictionary** and **Artefact Registry**; if those pin a storage policy (e.g., compression), that policy **wins**.

---

## C.1 File formats & compression (defaults; become binding if pinned)

* **Parquet (tables):** use **ZSTD level 3** unless the registry says otherwise; keep Parquet as the only format within a dataset/partition. 
* Suggested row-group target: **128â€“256 MiB** uncompressed; enable statistics; prefer dictionary encoding on low-cardinality columns (e.g., `legal_country_iso`).
* **JSONL (events/logs):** `.jsonl` (optionally **.jsonl.zst**); one JSON object per line, `\n` line endings; do not pretty-print. **RNG logs** are JSONL by dictionary. 

> If the registry publishes a compression profile (e.g., `compression_zstd_level3`), producers **should** use it and treat it as project policy. 

---

## C.2 Part sizing & naming (to avoid tiny files)

* Aim for **64â€“128 MiB** compressed per part; avoid parts < 8 MiB.
* Naming pattern: `part-00000-of-000NN.<ext>` (fixed batch) or `part-<uuid>.<ext>` (streaming). One family per folder. 

---

## C.3 Writer sort & non-authoritative order

* Follow the dictionaryâ€™s **writer sort** for egress (S8): `[merchant_id, legal_country_iso, site_order]`. Readers **MUST NOT** rely on physical file order; equality is by **row set**. RNG JSONL line order is append order **within a file** only.

---

## C.4 Canonical paths & partitions (reminder)

* **Egress (S8):** `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/` with partitions `[seed, fingerprint]` (Parquet). 
* **RNG events/logs:** `logs/rng/{audit|trace|events/<family>}/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦` (JSONL). 
* **Validation bundle:** `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`. Gate via `_passed.flag` content hash == `SHA256(bundle)` for the **same** fingerprint. 

---

## C.5 Checksums & manifests (recommended)

* Write a **per-part SHA-256** sidecar: `part-â€¦.<ext>.sha256` (hex of compressed bytes).
* Optional folder `_MANIFEST.json`: list parts + sizes + hashes + total logical rows.
* Optional **folder hash**: SHA-256 over part hashes in lexicographic order (quick integrity anchor). 

---

## C.6 Atomic publish (recap)

* **Stage â†’ fsync â†’ atomic rename** into the dictionary path; never expose partial contents. Publish any checksums/manifest **before** the final rename. **Partitions are immutable** after publish. 

---

## C.7 Retention / TTL (use dictionary; typical values)

* **`outlet_catalogue`**: **365 days**.
* **RNG events** (`sequence_finalize`, `site_sequence_overflow`): **180 days**; **core logs** (`rng_trace_log`, `rng_audit_log`): **365 days**.
  Treat these numbers as defaults; the dictionary is the authority.

---

## C.8 Storage class & encryption (ops defaults)

* Object storage: keep in **standard** for first ~30 days, then **infrequent access** if read rates drop.
* Encrypt at rest with **SSE-KMS** (project-scoped key); reject unencrypted puts; maintain server-side checksums (or rely on the SHA-256 sidecars). 

---

## C.9 HTTP headers / object metadata (helpful, not required)

* **Content-Type**: JSONL â†’ `application/x-ndjson`; Parquet â†’ `application/vnd.apache.parquet`.
* Add metadata helpful for debugging: `x-run-seed`, `x-parameter-hash`, `x-run-id`, `x-content-sha256`, `x-module`, `x-substream`. 

---

## C.10 Compaction & housekeeping

* **Small-file compaction:** if > 128 parts or > 30% parts < 8 MiB, compact to target size.
* **Orphan cleanup:** delete `_staging` dirs older than 24 h; alert on dangling staging content.
* Keep only `{parts, .sha256, _MANIFEST.json}` in partition dirsâ€”no temp/editor artefacts. 

---

## C.11 Access patterns (downstream hygiene)

* Always predicate reads on partition tokens rather than bucket-wide listings.
* For Parquet: **column-prune** (`merchant_id`, `legal_country_iso`, `site_order`, lineage).
* For JSONL: stream; avoid concatenating entire partitions in memory. 

---

## C.12 Path template configs (where ops keeps them)

* If ops exposes a **storage path pattern** or compression config in `configs/storage/*` (e.g., `storage_path_pattern.yaml`, `compression.yaml`), treat them as **operational policy**; theyâ€™re tracked in the Artefact Registry and participate in run manifesting. 

**Status:** Appendix C is **Informative** (operational guidance only).

---[[[MASTER-SEP-1A]]]

<a id="state-1a-s9-expanded"></a>
# state.1A.s9.expanded.txt

<!-- Source file: state.1A.s9.expanded.v2.0.txt | BYTE-EXACT EMBED -->

# S9 SPEC â€” Replay Validation & Publish Gate (Layer 1 Â· Segment 1A)

# 0) Document metadata & status **(Binding)**

## 0.1 State ID, SemVer, effective date

* **State ID (canonical):** `layer1.1A.S9` â€” â€œReplay Validation & Publish Gateâ€.
* **SemVer:** **MAJOR.MINOR.PATCH**.
  **MAJOR** when any binding interface changes, including (non-exhaustive):
  â€“ `_passed.flag` format or hashing rule; the location/partitioning of the validation bundle; consumer-gate semantics (**no PASS â†’ no read**); dataset IDs or `$ref` anchors for S9 inputs/outputs; lineage equality rules; RNG envelope/accounting laws used by the validator.  
  **MINOR** for backward-compatible additions (new optional bundle files/metrics, extra validator summaries) that do **not** alter existing contracts.
  **PATCH** for clarifications that do **not** change behaviour, schemas, or gates.
* **Effective date:** `YYYY-MM-DD` (set at ratification).

## 0.2 Normative language

This spec uses **RFC 2119/8174** key words (**MUST/SHALL/SHOULD/MAY**) with their normative meanings. Unless explicitly labelled **Informative**, every clause in S9 is **Binding**. (S7/S8 use the same convention for cross-state consistency.)  

## 0.3 Document status & section classes

* The default for all sections is **Binding**.
* **Informative** material (worked micro-examples, bundle layout illustrations) is confined to appendices and **MUST NOT** be used by implementers to weaken Binding rules.

## 0.4 Compatibility window (authorities & lines)

S9 v1.* assumes the following remain on their **v1.* line**; a **MAJOR** bump in any requires S9 re-ratification and a SemVer **MAJOR** increment here:

* `schemas.layer1.yaml` (layer-wide RNG/log/core schemas),
* `schemas.1A.yaml` (1A tables/egress/validation),
* `schemas.ingress.layer1.yaml` (ingress/reference),
* `dataset_dictionary.layer1.1A.yaml` (IDs, path templates, partitions, writer sorts).  

## 0.5 Numeric environment (inherited; MUST hold)

S9 **inherits S0.8 verbatim** and **MUST** attest the numeric regime before running validations: IEEE-754 **binary64**, **RNE** (round-to-nearest, ties-to-even), **FMA off**, **no FTZ/DAZ**, subnormals honoured; deterministic libm profile pinned by `math_profile_manifest.json`. These artefacts are enumerated in the S0 manifest; changing either flips the **`manifest_fingerprint`**.  

## 0.6 Run sealing & lineage (identifiers, partitions, equality)

* **Lineage keys:** `{seed, parameter_hash, run_id}` on RNG logs and validator reads; `{manifest_fingerprint}` for the validation bundle/flag partition. **Path tokens MUST equal embedded columns byte-for-byte** wherever both exist. 
* **Validation bundle location:** `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` (fingerprint partition). `_passed.flag` lives **inside** this folder. 
* **Gate semantics (consumer binding):** `_passed.flag` contains `sha256_hex = <hex64>`, where `<hex64>` is the SHA-256 over **all files listed in `index.json` (excluding `_passed.flag`)** in **ASCII-lexicographic order of the `index.json` `path` entries**; consumers **MUST** verify this for the same fingerprint **before** reading egress (**no PASS â†’ no read**).

## 0.7 Change control & ratification

* **Source of truth:** JSON-Schema (layer/segment/ingress) and the Dataset Dictionary remain the sole schema and path authorities; this S9 spec binds validator behaviour **under** those authorities. Any PR that changes Binding parts of S9 **MUST**:
  (a) bump SemVer per Â§0.1; (b) update anchors in the Dictionary/Registry where applicable; (c) attach the updated bundle schema entry; (d) re-ratify the consumer gate in CI.  

---

# 1) Purpose, scope, non-goals **(Binding)**

## 1.1 Purpose

S9â€™s role is to **re-derive and verify** the promises made by **S0â€“S8**, then **publish a fingerprint-scoped validation bundle** and a **single consumer gate flag**. If and only if all checks pass, S9 writes `validation_bundle_1A/` under
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` and a colocated `_passed.flag` whose **content hash equals `SHA256(validation_bundle_1A)`**. **Consumers MUST verify this flag for the same fingerprint before reading `outlet_catalogue`** (**no PASS â†’ no read**).   

## 1.2 Scope â€” what S9 MUST do

S9 is **read-only** over the produced data/streams and **MUST**:

**a) Structural & schema validation.**
Assert schema validity, partition law, PK/UK, and FK targets for all inputs in scope, including `outlet_catalogue` (egress; `[seed,fingerprint]` partitions), `s3_candidate_set` (sole inter-country order; `[parameter_hash]`), optional `s3_integerised_counts`, and the RNG families/core logs used across S1â€“S8 (`rng_event.*`, `rng_trace_log`, `rng_audit_log`).   

**b) Lineage equality & identity.**
Enforce **pathâ†”embed equality** for lineage tokens wherever both exist: e.g., `outlet_catalogue.manifest_fingerprint == fingerprint` path token; RNG events embed `{seed, parameter_hash, run_id}` equal to their path tokens. For parameter-scoped tables, embedded `parameter_hash` **MUST** equal the partition key. 

**c) RNG envelope accounting & trace coverage.**
Reconcile **every** RNG family touched in S1/S2/S4/S6/S7/S8:
`u128(after)âˆ’u128(before) == blocks` (per event), **non-consuming** families carry `draws="0", blocks=0`, and **exactly one** `rng_trace_log` row is appended **after each event**; final trace totals match the sum of event budgets. **Uniforms are strict-open** `uâˆˆ(0,1)` as fixed in S0.    

**d) Cross-state replay checks (facts re-derived from written inputs only).**

* **S1 hurdle:** exactly one decision per merchant; extremes consume zero; open-interval `u` and budget identity hold; trace totals reconcile. 
* **S2 NB:** one `nb_final` (non-consuming); Gamma/Poisson component coverage and budgets reconcile; accepted `Nâ‰¥2`. 
* **S3 order:** `candidate_rank` is **total, contiguous**, with **home=0**; S9 **never** invents order. 
* **S4 ZTP:** `ztp_final` unique; rejection attempts coherent with Poisson components. 
* **S6 membership:** if `s6_membership` was used, it **MUST** match re-derivation from `gumbel_key` (+S3/S4 facts); **S6 PASS is required** to read the convenience surface. 
* **S7 integerisation:** reconstruct floors + **`dp_resid=8` residual_rank** order and prove `Î£_i count_i = N`; no cross-country order created by S7. 
* **S8 egress & sequences:** per (merchant,country) block, `site_order = 1..n_i` with `site_id` `^[0-9]{6}$`; exactly one `sequence_finalize` (non-consuming) per block; overflow guard respected; **egress encodes no inter-country order** (join S3).  

**e) Gates & consumer publish.**
If S8 (or earlier states) read convenience surfaces, S9 **verifies** the corresponding **PASS receipts** (e.g., S6). On success, S9 publishes `validation_bundle_1A/` and `_passed.flag` **atomically**; on failure, S9 publishes the bundle **without** `_passed.flag`.  

## 1.3 Non-goals (what S9 MUST NOT do)

* **No new RNG draws, no reseeding, no counter advances.** S9 **MUST NOT** emit RNG events or consume counters. (It only reads/validates envelopes and traces.) 
* **No egress authoring or mutation.** S9 does **not** write or alter `outlet_catalogue` or any S3/S6/S7 surfaces; it only validates them. 
* **No new order or counts.** S9 does **not** define inter-country order (S3 is sole authority) or recompute authoritative counts; it only **re-derives to compare**. 
* **No weight computation or persistence.** S9 does **not** read or rewrite S5 weight surfaces unless a separate 4B harness is active (outside 1Aâ€™s S9 gate); the 1A S9 gate does **not** depend on S5. 
* **No heuristic â€œrepairs.â€** Any breach is a **fail-closed**; S9 does not auto-correct producer outputs. 

## 1.4 Decision & gate semantics (run outcome)

* **PASS:** all checks in scope succeed â†’ write `validation_bundle_1A/` and `_passed.flag` (content hash equals bundle SHA-256), enabling downstream reads for this **fingerprint**. 
* **FAIL:** any binding check fails â†’ write bundle (with failures) **without** `_passed.flag`; **consumers MUST NOT read `outlet_catalogue` for this fingerprint**. 

---

# 2) Sources of authority & precedence **(Binding)**

## 2.1 Schema authority (single source of shape truth)

S9 **MUST** treat JSON-Schema as the **sole authority** for shapes, required fields, domains, and envelope semantics. The following schema sets are **binding**:

* **Layer-wide logs & RNG events:** `schemas.layer1.yaml` â€” e.g., core logs `rng_audit_log`, `rng_trace_log`; event families used by 1A such as `hurdle_bernoulli`, `gamma_component`, `poisson_component`, `ztp_*`, `gumbel_key`, `residual_rank`, `sequence_finalize`, `site_sequence_overflow`; and governance objects (`numeric_policy_profile`, `math_profile_manifest`).   
* **Segment 1A tables/bundles:** `schemas.1A.yaml` â€” e.g., `s3/candidate_set`, `s3/integerised_counts`, optional `s3/site_sequence`, egress `egress/outlet_catalogue`, and the fingerprint-scoped `validation/validation_bundle`. 
* **Ingress & FK targets:** `schemas.ingress.layer1.yaml` (e.g., `iso3166_canonical_2024`), referenced by 1A tables and S8 egress. 

**Anchor-resolution rule (normative).** Bare anchors resolve as follows:
-  `#/rng/**` â†’ `schemas.layer1.yaml`
- `#/validation/validation_bundle` â†’ `schemas.1A.yaml`
- `#/validation/s6_receipt` â†’ `schemas.layer1.yaml` 
- `#/s3/**` and `#/egress/**` â†’ `schemas.1A.yaml`

## 2.2 Dataset Dictionary (IDs, paths, partitions, writer policy)

The **Dataset Dictionary** is authoritative for **dataset IDs, canonical paths, partitions, writer sort, and consumer gates**; S9 **MUST** obey it exactly when locating inputs and publishing outputs. Examples:

* **Egress** `outlet_catalogue`: `[seed,fingerprint]` partitions; writer sort `[merchant_id, legal_country_iso, site_order]`; **no cross-country order encoded**; consumers **MUST** verify the fingerprint-scoped gate before reads. 
* **Order authority** `s3_candidate_set`: `[parameter_hash]` partition; `candidate_rank` is the **sole** inter-country order surface. 
* **Core logs** `rng_audit_log`, `rng_trace_log`: `[seed,parameter_hash,run_id]` partitions; trace rows are **cumulative** and **one row is appended after each RNG event append**. 

## 2.3 Artefact Registry (runtime bindings & gates)

The **Artefact Registry** pins gate artefacts and their semantics used by S9:

* **Validation bundle (fingerprint-scoped)** `validation_bundle_1A` under `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`. 
* **Consumer flag** `_passed.flag` whose **content** is `sha256_hex = <SHA256(bundle)>`; **consumers must verify** this for the same fingerprint **before** reading `outlet_catalogue` (**no PASS â†’ no read**). 

## 2.4 Authority surfaces (what decides *what*)

S9 **MUST** enforce the following lines of authority; if any dependent surface disagrees, S9 **fails**:

1. **Inter-country order:** **S3 `candidate_rank` is single authority** (home rank = 0; ranks total & contiguous). Neither S7 nor S8 encodes or overrides cross-country order; S9 must never invent it.  
2. **Per-country integer counts:** Either **`s3_integerised_counts`** (if emitted) or counts reconstructed deterministically from **S7 `residual_rank`** over the S3 domain (S9 selects the configured path, but **does not** re-decide policy).  
3. **Egress content:** `outlet_catalogue` is **order-free across countries**, fingerprint-scoped, and must pass dictionary/schema checks; downstream join-back to S3 provides order. 
4. **RNG envelope & trace law:** Event rows **must** satisfy the layer envelope (`before/after/blocks/draws`) and trace obligations; **non-consuming** families (e.g., `sequence_finalize`, `site_sequence_overflow`, `residual_rank`) have `blocks=0`, `draws="0"`, and still cause a **single** trace append.  
5. **Numeric environment:** S0 binds **IEEE-754 binary64, RNE, FMA-off, no FTZ/DAZ**, and a pinned libm profile. S9 **inherits** this and validates under the same profile. 

## 2.5 Gating & read-before-use (MUST verify receipts)

* **Fingerprint gate (1A â†’ consumers):** The `_passed.flag` under `validation/fingerprint={fingerprint}/` **MUST** verify (content hash equals bundle SHA-256) **before** `outlet_catalogue` can be read. S9 publishes this flag only on PASS.  
* **Upstream convenience gates:** If S9 reads any convenience surface that is gated upstream (e.g., `s6/membership`), it **MUST** verify the corresponding **S6 PASS receipt** first. 

## 2.6 Precedence on conflict (descending)

When documents disagree, S9 **MUST** apply this precedence ladder:

1. **JSON-Schema** (layer + segment + ingress) â†’ shapes/domains/envelopes;
2. **Dataset Dictionary** â†’ dataset IDs, canonical paths/partitions, writer order, consumer gate;
3. **Artefact Registry** â†’ concrete publish locations and gate coupling;
4. **State specs S0â€“S8 (Binding)** â†’ semantics, invariants, and authority separation that schemas/dictionary alone donâ€™t express;
5. **Non-binding notes** (concept docs/previews) â†’ informative only.
   Examples: (i) If a fileâ€™s columns validate but its partition keys or writer sort donâ€™t match the dictionary, **dictionary wins**; (ii) if an event row exists but violates the envelope schema (e.g., non-consuming family with `drawsâ‰ "0"`), **schema wins**.   

## 2.7 Pathâ†”embed equality & identity (applies to all S9 reads/writes)

Where lineage appears **both** in the path and in embedded columns/fields, **byte-equality is binding** (e.g., `outlet_catalogue.manifest_fingerprint == fingerprint` (path), and for logs/events `{seed,parameter_hash,run_id}` equal their path tokens). **File order is non-authoritative.** 

---

*Status: this section is **Binding** and governs how S9 recognises truth and decides ties before executing any validation checks.*

---

# 3) Inputs â€” inventory & read-gates **(Binding)**

## 3.0 Overview (read-only stance)

S9 is **read-only**. It enumerates **exactly** which datasets/logs/events it may read, with their **IDs â†’ schema anchors â†’ partitions**, and the **gates** that **MUST** be verified **before** use. Pathâ†”embed lineage equality is **binding** for every read in scope.  

---

## 3.1 Fingerprint-scoped egress to validate

**Dataset ID:** `outlet_catalogue` â†’ **`schemas.1A.yaml#/egress/outlet_catalogue`**.
**Partitions:** `[seed, fingerprint]` at `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/`.
**Binding rules:** rows **MUST NOT** encode inter-country order; consumers later **MUST** join `s3_candidate_set.candidate_rank`. `manifest_fingerprint` (column) **MUST** byte-equal the `fingerprint` path token; `global_seed` **MUST** equal the `seed` token.  

---

## 3.2 Parameter-scoped authorities (order, counts, optional sequence)

**Required (order authority).**
`s3_candidate_set` â†’ **`schemas.1A.yaml#/s3/candidate_set`**; **partitions:** `[parameter_hash]`. **S3 is the single authority for inter-country order:** `candidate_rank` is **total & contiguous**, with **home=0**.  

**Counts surface (choose ONE path for S9â€™s replay):**
**Path A (if present):** `s3_integerised_counts` â†’ **`schemas.1A.yaml#/s3/integerised_counts`**; `[parameter_hash]`. Authoritative per-country integers `count` with `residual_rank`. 
**Path B (default):** re-derive counts deterministically from **S7 evidence** (`rng_event.residual_rank`) over the S3 domain and prove `Î£_i count_i = N`. (See Â§7/Â§8 in this spec for the replay law.) 

**Optional cross-check (if produced upstream):**
`s3_site_sequence` â†’ **`schemas.1A.yaml#/s3/site_sequence`**; `[parameter_hash]`. S9 **must not** require it; if present, only parity-check with S8 sequencing. 

---

## 3.3 RNG core logs (run-scoped) â€” required for accounting

* `rng_audit_log` â†’ **`schemas.layer1.yaml#/rng/core/rng_audit_log`**; path `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl`; **partitions:** `{seed, parameter_hash, run_id}`. 
* `rng_trace_log` â†’ **`schemas.layer1.yaml#/rng/core/rng_trace_log`**; path `logs/rng/trace/â€¦`; **emit exactly one cumulative row after each RNG event append** (S9 selects the **final** row per `(module,substream_label,run_id)`). 

**Run binding.** S9 **MUST** take the set of `{run_id}` values observed in the **event streams it validates** (below) and read the matching `rng_trace_log`/`rng_audit_log` partitions for those `(seed, parameter_hash, run_id)` tuples. (Trace is run-scoped; events embed lineage and, per S1/S0, include `manifest_fingerprint` for run-to-egress binding.)  

---

## 3.4 RNG event families in scope (S1â€“S8)

All event streams are **JSONL**, partitioned by `{seed, parameter_hash, run_id}`, and must carry the **layer envelope** (pre/post 128-bit counters; `blocks`; decimal-u128 `draws`). **Non-consuming families** have `blocks=0`, `draws="0"`. **One** `rng_trace_log` row is appended **after each event append**.  

**S1 (hurdle):** `rng_event.hurdle_bernoulli` â†’ `#/rng/events/hurdle_bernoulli`. Extremes consume **zero**; stochastic branch consumes **one**; envelope + trace discipline apply.  

**S2 (NB mixture):** `rng_event.gamma_component`, `rng_event.poisson_component`, and **non-consuming** `rng_event.nb_final` (finaliser). 

**S4 (ZTP target):** `rng_event.ztp_final` (non-consuming) + Poisson attempt components under the ZTP label. 

**S6 (selection keys):** `rng_event.gumbel_key` (single-uniform: `blocks=1`, `draws="1"`); optional `stream_jump` if registered; logs/trace updated. 

**S7 (integerisation evidence):** `rng_event.residual_rank` â€” **non-consuming**, residuals quantised to **dp=8**, rank â‰¥1, one per `(merchant,country)` in domain.  

**S8 (egress instrumentation):** `rng_event.sequence_finalize` (**non-consuming**; one per `(merchant,country)` with `{start_sequence="000001", end_sequence=zfill6(n)}`) and guardrail `rng_event.site_sequence_overflow` (**non-consuming**, `severity="ERROR"`).  

---

## 3.5 Membership surfaces (choose ONE; gate applies)

**Path M1 (preferred when present):** `s6_membership` â†’ **`schemas.1A.yaml#/alloc/membership`**; `[seed, parameter_hash]`. **Gate:** `s6_validation_receipt` (co-located) MUST be valid **PASS** before reading (`S6_VALIDATION.json` + `_passed.flag`). 
**Path M2 (default):** re-derive membership from `rng_event.gumbel_key` (+S3 domain and S4 `K_target`), supporting reduced logging by counter-replay where defined. (No S6 PASS required for events.) 

---

## 3.6 Foreign-count sources (choose ONE; no weights read)

**Path C1 (if present):** `s3_integerised_counts` (authoritative counts). 
**Path C2 (default):** reconstruct from S7 `residual_rank` evidence over the S3 domain; prove `Î£_i count_i = N` from S2 `nb_final`. **S9 does not read S5 weights.** 

---

## 3.7 Reference/FK targets (for schema/FK checks)

* `iso3166_canonical_2024` â†’ **`schemas.ingress.layer1.yaml#/iso3166_canonical_2024`** for `country_iso`/`legal_country_iso` FKs in S3/S8 surfaces. 

---

## 3.8 Read-gates & receipts (verify before use)

> **Coupling to layer schema.** All `module` and `substream_label` literals used by RNG events **MUST** be admitted by `schemas.layer1.yaml` (either via explicit enum sets or documented string patterns). If the layer schema later enumerates these values, the literals listed here **MUST** appear in those enums.

* **S6 PASS gate (membership convenience).** If `s6_membership` is used, S9 **MUST** verify the **co-located** S6 receipt (`â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/(S6_VALIDATION.json, _passed.flag)`) **before** reading membership. 
* **Fingerprint gate (consumer hand-off).** S9 itself publishes `validation_bundle_1A/` and `_passed.flag` under `validation/fingerprint={manifest_fingerprint}/`. Consumers **MUST** verify that `_passed.flag` content hash equals `SHA256(validation_bundle_1A)` for the same fingerprint **before** reading `outlet_catalogue`. *(Stated here for coupling; publish semantics live in Â§4.)* 

---

## 3.9 Pathâ†”embed equality (applies to **all** reads)

Where lineage appears **both** in the path and embedded fields, **byte-equality is mandatory**:

* Egress: `outlet_catalogue.manifest_fingerprint == fingerprint` (path), `global_seed == seed`. 
* Parameter-scoped tables: each row embeds `parameter_hash` equal to the path token. 
* RNG logs/events: embedded `{seed, parameter_hash, run_id}` **must equal** their path tokens on **every** row; events also carry the **layer envelope** (`before/after/blocks/draws`) and obey the **trace-after-each-event** rule.  

---

**Status:** Â§3 is **Binding**. It fixes the **complete input inventory**, **exact read gates**, **lineage equality**, and **partition laws** S9 must obey **before** performing any validation or replay.

---

# 4) Outputs â€” bundle & flag **(Binding)**

## 4.1 Validation bundle (fingerprint-scoped folder)

**Identifier:** `validation_bundle_1A`
**Location (partitioned):**
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`
**Authority anchors:** Dataset Dictionary ID `validation_bundle_1A`; schema anchor `schemas.1A.yaml#/validation/validation_bundle`.  

**Role.** The bundle is the machine-readable proof set for S9â€™s checks and the basis for the consumer gate; it **MUST** be written for exactly one **fingerprint** and **MUST** not contain any producer data mutations. 

**Required files (minimum set).** S9 **MUST** write at least:

* `MANIFEST.json` â€” run metadata (includes `manifest_fingerprint`, `parameter_hash`, created time, code id). 
* `parameter_hash_resolved.json` â€” resolved parameter set identity. 
* `manifest_fingerprint_resolved.json` â€” resolved fingerprint identity. 
* `rng_accounting.json` â€” per-family event/trace reconciliation, audit/trace presence & pathâ†”embed parity. 
* `s9_summary.json` â€” PK/UK/FK results, join-back stats, N-sum law, overflow list, lineage equality results (may include S8 checks carried forward). 
* `egress_checksums.json` â€” stable hashes for `outlet_catalogue` files in `[seed,fingerprint]` (per-file and composite) for byte-identity re-runs. 
* `index.json` â€” bundle index **conforming to** the schema: table with columns `{artifact_id, kindâˆˆ(plot|table|diff|text|summary), path, mime?, notes?}`; **every** non-flag file **MUST** appear exactly once with a relative `path`. 

**Folder-level invariants.**

* Partitioning is **[fingerprint]**; the embedded `manifest_fingerprint` in bundle files **MUST** equal the folder token. 
* All paths in `index.json` **MUST** be **relative** to the bundle root and ASCII-lexicographically orderable (used by Â§4.2 hashing). 
* Dependencies recorded in the Artefact Registry (at minimum `outlet_catalogue`, `rng_audit_log`) **MUST** be satisfied. 

## 4.2 Consumer gate flag (file)

**Identifier:** `validation_passed_flag`
**Path:** `â€¦/validation/fingerprint={manifest_fingerprint}/_passed.flag` (co-located with the bundle). 

**Content (exact).** One line:
`sha256_hex = <hex64>`
where `<hex64>` is the **SHA-256 over the concatenation of the raw bytes of all files listed in `index.json`** (excluding `_passed.flag`), in **ASCII-lexicographic order of the `index.json` `path` entries**. Hex is lower-case, 64 chars.

**Consumer rule (binding).** Downstream readers (e.g., `outlet_catalogue` consumers) **MUST** verify that `_passed.flag` **matches** `SHA256(validation_bundle_1A)` for the **same fingerprint** **before** any read. **No PASS â†’ no read.** The Dictionary entry for `outlet_catalogue` **repeats** this consumer obligation.  

## 4.3 Publish & atomicity

S9 **MUST** publish atomically: stage the entire bundle in a temporary directory under the validation path (e.g., `â€¦/validation/_tmp.{uuid}`), compute `_passed.flag` **in the staged folder**, then perform a **single atomic rename** to `fingerprint={manifest_fingerprint}/`. **Partial contents MUST NOT become visible**. On failure, delete the temp. 

**PASS vs FAIL outcome.**

* **PASS:** write the full bundle **and** `_passed.flag` (computed as above). 
* **FAIL:** write the bundle **without** `_passed.flag`; the gate remains failed for that fingerprint. 

## 4.4 Idempotency & equivalence

Re-running S9 for the same `{seed, parameter_hash, manifest_fingerprint}` under identical inputs **MUST** produce **byte-identical** bundle contents; two bundles are **equivalent** iff `MANIFEST.json` matches byte-for-byte, all files listed in `index.json` (excluding `_passed.flag`) match byte-for-byte, and `_passed.flag` hashes match. 

## 4.5 Retention & lineage

Retention/TTL for `validation_bundle_1A` follows the Dictionary; lineage within bundle files **MUST** embed the same `manifest_fingerprint` as the path token. (Additional lineage like `parameter_hash` may be included per S0â€™s enumerations.)  

---

**Status:** Â§4 is **Binding**. It fixes the **what/where** of S9â€™s outputs, the **exact flag hashing rule**, **atomic publish**, and the **consumer gate** that protects `outlet_catalogue`.

---

# 5) Structural validation (schemas, partitions, FK) **(Binding)**

## 5.1 Scope (what S9 validates structurally)

S9 **MUST** validate, for every subject in scope, that **(a)** rows conform to the JSON-Schema anchor, **(b)** files live under the **Dictionary** path with the declared **partitions**, **(c)** embedded lineage **byte-equals** path tokens wherever both exist, **(d)** declared **PK/UK** constraints hold **per partition**, **(e)** **FKs** resolve to their targets. Subjects:

* **Egress:** `outlet_catalogue` â†’ `schemas.1A.yaml#/egress/outlet_catalogue` (partitions `[seed,fingerprint]`). 
* **Authorities (parameter-scoped):** `s3_candidate_set` (required), optional `s3_integerised_counts`, optional `s3_site_sequence`.   
* **Membership (if used):** `s6_membership` (+ S6 receipt gate checked in Â§3). 
* **RNG core logs:** `rng_audit_log`, `rng_trace_log`. 
* **RNG event families (S1â€“S8 used by 1A):** hurdle/gamma/poisson/ztp/gumbel/residual_rank/sequence_finalize/site_sequence_overflow. (Schema anchors under `schemas.layer1.yaml#/rng/*`.)  

---

## 5.2 JSON-Schema conformance (shapes & domains)

For each dataset/log/event in Â§5.1, S9 **MUST** validate rows against the declared `$ref`:

* **Bundle schema:** `validation_bundle_1A` (for S9â€™s own output index and file descriptors) â†’ `schemas.1A.yaml#/validation/validation_bundle`.  
* **Egress & S3 tables:** anchors in `schemas.1A.yaml` (e.g., `#/egress/outlet_catalogue`, `#/s3/candidate_set`, `#/s3/integerised_counts`, `#/s3/site_sequence`).  
* **Logs & events:** anchors in `schemas.layer1.yaml` for `rng_audit_log`, `rng_trace_log`, and all 1A event families (`#/rng/events/*`). 

**Notes (binding examples).**

* `manifest_fingerprint`/other SHA-256 fields must match the schema **pattern** (64 lowercase hex) where defined. 
* Event envelopes must contain the layer fields (`before`, `after`, `blocks`, `draws`, lineage, module/substream). (Accounting rules are verified in Â§7; presence/shape is structural here.) 

---

## 5.3 Partition law & pathâ†”embed equality

S9 **MUST** verify that each subject lives under its **Dictionary path** with the declared **partition keys**, and where lineage fields are embedded they **byte-equal** the path tokens:

* **Egress `outlet_catalogue`:** path `â€¦/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/`; partitions `[seed,fingerprint]`; enforce **`global_seed == seed`** and **`manifest_fingerprint == fingerprint`**. 
* **S3 datasets:** `â€¦/parameter_hash={parameter_hash}/`; enforce embedded `parameter_hash` equals path token. 
* **S6 membership (if used):** `â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/`; enforce pathâ†”embed equality; **gate verified in Â§3**. 
* **Core logs:** `rng_audit_log` and `rng_trace_log` under `â€¦/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦`; **every row** embeds `{seed, parameter_hash, run_id}` equal to the path. 
* **Event families (e.g., `sequence_finalize`, `site_sequence_overflow`):** paths per Dictionary/Registry; verify lineage equals path tokens.  

File order is **non-authoritative**; partition keys and PKs define truth. 

---

## 5.4 Primary/unique keys (per partition)

S9 **MUST** enforce the PK/UK constraints specified by schema/dictionary on a per-partition basis:

* **`outlet_catalogue`** â€” **PK/Sort:** `[merchant_id, legal_country_iso, site_order]`; enforce **uniqueness** per `(seed,fingerprint)` partition. 
* **`s3_candidate_set`** â€” uniqueness over `[merchant_id, candidate_rank, country_iso]` per `parameter_hash` partition (order authority is replay-checked in Â§8; here we enforce structural uniqueness). 
* **`s3_integerised_counts`** (if present) â€” uniqueness over `[merchant_id, country_iso]` per `parameter_hash`. 
* **`s3_site_sequence`** (if present) â€” uniqueness over `[merchant_id, country_iso, site_order]` per `parameter_hash`. 
* **RNG logs/events** â€” JSONL streams **MUST NOT** contain duplicate rows for the same event identity fields as defined by the event schema (module/substream + envelope counters + payload identity); S9 treats duplicate physical files/lines with identical content as a **structural error**.

---

## 5.5 Foreign keys (referential integrity)

S9 **MUST** check FKs exactly as declared by schema/dictionary:

* **ISO-2 codes:** all `country_iso`/`legal_country_iso` fields in S3/S6/S8 surfaces **FK** to `iso3166_canonical_2024.country_iso` (uppercase ISO-3166-1 alpha-2; placeholders forbidden by the ingress schema).  
* **Event vs egress naming:** **events** use `country_iso`; **egress** uses `legal_country_iso`; both **FK** to the same ISO table (S9 enforces FK resolution under both names). 
* Any additional schema-declared FKs (e.g., to merchant seed lists) **MUST** resolve if present in the anchors (S9 uses the anchorâ€™s `$ref` list to drive checks). 

---

## 5.6 Writer policy & file invariants

Where the Dictionary declares a **writer sort**, S9 **MUST** verify monotonicity **within each file** and **across file boundaries** in a partition:

* **`outlet_catalogue` writer sort:** `[merchant_id, legal_country_iso, site_order]`. 
  For JSONL streams, only **partitioning** and **schema** are binding (no sort requirement), but S9 **MUST** verify **one** cumulative `rng_trace_log` append **after each event append** exists (presence/placement is structural for trace; accounting is Â§7). 

---

## 5.7 Structural failure classes (binding)

On any breach below, S9 **fails** the run structurally (bundle written **without** `_passed.flag`):

* `E_SCHEMA_INVALID` â€” row violates its JSON-Schema. (Includes pattern/domain failures such as non-hex fingerprints.) 
* `E_PATH_EMBED_MISMATCH` â€” path tokens and embedded lineage differ (e.g., `manifest_fingerprint` mismatch). 
* `E_PARTITION_MISPLACED` â€” files not under Dictionary path/partitions. 
* `E_DUP_PK` â€” duplicate PK within a partition. (Applies to subjects in Â§5.4.) 
* `E_FK_ISO_INVALID` â€” ISO FK does not resolve (either `country_iso` or `legal_country_iso`). 
* `E_TRACE_COVERAGE_MISSING` â€” missing final `rng_trace_log` row(s) corresponding to event appends (structural presence check; numeric reconciliation in Â§7). 

---

**Status:** Â§5 is **Binding**. It defines exactly how S9 proves **shape**, **placement**, **identity**, and **referential** correctness **before** it performs RNG accounting (Â§7) or cross-state replay checks (Â§8).

---

# 6) Lineage & determinism checks **(Binding)**

## 6.1 Recompute & attest lineage keys (must match exactly)

S9 **MUST** recompute the lineage identifiers and prove equality to what producers wrote:

* **`parameter_hash`** â€” Recompute from the governed set **ð“Ÿ** using S0.2.2â€™s **UER + tuple-hash** procedure over canonical basenames; compare to the **partition key** and any embedded `parameter_hash` in parameter-scoped inputs (e.g., S3 tables). **Equality is mandatory.**  
* **`manifest_fingerprint`** â€” Recompute using S0.2.3 over the actually opened artefacts (ð“), `git_32`, and `parameter_hash_bytes`; the result **MUST** byte-equal the `fingerprint` path token for `outlet_catalogue` and the bundle folder, and any embedded `manifest_fingerprint` fields.  
* **`run_id` (logs-only)** â€” Verify `run_id` presence and uniqueness per `{seed, parameter_hash}` using S0.2.4 (UER payload with bounded collision loop). S9 **MUST** assert that `run_id` partitions **only** logs/events and that egress/parameter-scoped tables **do not** depend on `run_id`. 

S9 writes `parameter_hash_resolved.json` and `manifest_fingerprint_resolved.json` into the bundle as the attestation artefacts. 

---

## 6.2 Pathâ†”embed identity (all subjects; byte-equality)

For **every** dataset/log/event S9 reads, **embedded lineage fields MUST byte-equal path tokens** where both appear:

* **Egress:** `outlet_catalogue.manifest_fingerprint == fingerprint` and `global_seed == seed`. 
* **Parameter-scoped inputs (e.g., S3):** embedded `parameter_hash == parameter_hash` path token. 
* **RNG logs & events:** each row embeds `{seed, parameter_hash, run_id}` that **must equal** the `{seed, parameter_hash, run_id}` in its path. (Event envelopes also satisfy layer schema presence; accounting is checked in Â§7.)  

Any mismatch â‡’ `E_PATH_EMBED_MISMATCH` (FAIL). *(Structural rules in Â§5 apply; this section enforces lineage equality as a determinism prerequisite.)* 

---

## 6.3 Partition identity, immutability & idempotence (must hold)

S9 **MUST** confirm the identity/immutability rules the producers were bound to:

* **Egress identity:** `(dataset='outlet_catalogue', seed, manifest_fingerprint)` is **write-once**; if the partition existed prior to the validated run, byte content **must** be identical. S9 records stable per-file and composite hashes in `egress_checksums.json`.  
* **Parameter-scoped identity:** `(dataset_id, parameter_hash)` instances are immutable once published. 
* **Logs identity:** `(stream, seed, parameter_hash, run_id)` instances are immutable; S9 treats duplicate physical lines/files for the *same* event identity as structural errors. 

Re-running S9 with identical inputs **MUST** yield a **byte-identical** bundle and `_passed.flag`. 

---

## 6.4 Determinism w.r.t. concurrency, sharding & scheduling (evidence checks)

S9 cannot observe worker counts; instead it proves outcomes are **independent** of them by checking invariants guaranteed by S7â€“S8:

* **Egress row-set determinism:** within each `(seed,fingerprint)` partition, `outlet_catalogue` obeys the Dictionary **writer sort** and encodes no cross-country order; equality is by **row set**, not file order.  
* **S8 block atomicity:** per `(merchant, legal_country_iso)` there is **exactly one** `sequence_finalize` event (non-consuming) with `{start="000001", end=zfill6(n)}`; overflow emits `site_sequence_overflow` and **no** egress rows for that merchant. 
* **Join-back stability:** distinct `(merchant, legal_country_iso)` in egress join 1:1 to S3 on `(merchant_id, country_iso)`, and sorting by `candidate_rank` yields one consistent cross-country order (egress itself remains order-free). 

---

## 6.5 No reliance on file order; set semantics

S9 **MUST** treat Parquet/JSONL physical order as **non-authoritative**; equality and checks are defined by schema keys and totals (plus writer sort where declared for egress). *(Inherited from S0/S8 determinism and the Dictionary.)*  

---

## 6.6 Roles of lineage keys (non-interchangeable; enforced)

S9 **MUST** enforce that lineage keys are used only in their scoped roles:

* **`seed`** drives RNG; partitions **all** RNG logs/events (never S3/S5). 
* **`parameter_hash`** versions parameter-scoped inputs/outputs (e.g., S3, S5). Changing any **ð“Ÿ** memberâ€™s bytes flips it. 
* **`manifest_fingerprint`** versions egress/validation; consumers **must** verify the fingerprint-scoped gate before reading egress. 
* **`run_id`** partitions logs only; **never** influences model state or egress. 

Any misuse (e.g., `run_id` in an egress partition, or `seed` on parameter-scoped S3 tables) â‡’ `E_PARTITION_MISPLACED`. 

---

**Status:** Â§6 is **Binding**. It fixes how S9 **recomputes lineage**, enforces **pathâ†”embed identity**, and proves **determinism/idempotence** independent of concurrency, ensuring the validated run is fully reproducible under the S0â€“S8 contracts.

---

# 7) RNG accounting & envelope invariants **(Binding)**

## 7.1 Per-event envelope checks (family-independent) â€” **MUST**

For **every** RNG event row S9 validates (S1/S2/S4/S6/S7/S8 families in scope):

* **Envelope presence & types.** Row **MUST** conform to the layer envelope (`rng_envelope`): `{ts_utc, module, substream_label, seed, parameter_hash, run_id, rng_counter_before_{lo,hi}, rng_counter_after_{lo,hi}, blocks:uint64, draws:dec_u128}`. 
* **Counter delta identity.** `blocks == u128(after) âˆ’ u128(before)` in **unsigned 128-bit** arithmetic. **Fail** if not equal. 
* **Non-consuming invariants.** Families declared non-consuming **MUST** have `before == after`, `blocks = 0`, `draws = "0"`. **Fail** if any differs. 
* **Draws = actual uniforms.** `draws` **MUST** equal the samplerâ€™s **actual** U(0,1) count for that event (independent of `blocks`). **Fail** on mismatch.  
* **Lane policy is implied by budgets.** Single-uniform families advance **one** block (low lane used, high lane discarded); two-uniform families consume **both lanes** of **one** block. 

**Failure classes (per row):** `E_RNG_COUNTER_MISMATCH` (blocksâ‰ afterâˆ’before); `E_RNG_BUDGET_VIOLATION` (drawsâ‰ budgeted); `E_NONCONSUMING_CHANGED_COUNTERS` (non-consuming but beforeâ‰ after). 

---

## 7.2 Budget table by family â€” **MUST**

S9 applies the following **normative budgets** when reconciling `draws` and counter deltas (`blocks`). Family schemas further constrain payload/fields.

**S1 â€” hurdle_bernoulli** (`module=1A.hurdle_sampler`, `substream_label=hurdle_bernoulli`)

* **Deterministic branch** (Ï€âˆˆ{0,1}): `blocks=0`, `draws='0'`, `u=null`.
* **Stochastic branch** (0<Ï€<1): `blocks=1`, `draws='1'`.
* Schema enforces `drawsâˆˆ{'0','1'}`, `blocksâˆˆ{0,1}` and `uâˆˆ(0,1)` when present.  

**S2 â€” NB mixture attempts & final** (modules per family; see Appendix A.1)

* **gamma_component** (`module="1A.nb_and_dirichlet_sampler"`, `substream_label="gamma_nb"`): **variable** draws (exact actual-use from Marsagliaâ€“Tsang; includes 2 uniforms per Boxâ€“Muller normal + 1 uniform where required).
* **poisson_component** (`module="1A.nb_poisson_component"`, `substream_label="poisson_nb"`, `context="nb"`): **variable**; regime per S0 (Â§PTRS vs inversion) governs typical usage.
* **nb_final** (`module="1A.nb_sampler"`): **non-consuming** â‡’ `blocks=0`, `draws='0'`.
* Attempt structure: exactly **one** gamma then **one** poisson per attempt; finaliser once (accepted `Nâ‰¥2`).  

**S4 â€” ZTP target** (`module=1A.ztp_sampler`)

* **poisson_component (context='ztp')**: **consuming**; regime fixed per merchant: **inversion** if Î»<10, **PTRS** if Î»â‰¥10.
* **ztp_rejection / ztp_retry_exhausted / ztp_final**: **non-consuming** â‡’ `blocks=0`, `draws='0'`.
* Attempts are **1-based**, strictly increasing; **exactly one** `ztp_final` when resolved (unless policy=`abort`). Trace append after **each** event.   

**S6 â€” selection keys** (`module=1A.foreign_country_selector`, `substream_label=gumbel_key`)

* **gumbel_key**: **single-uniform** â‡’ `blocks=1`, `draws='1'`.
* Optional `stream_jump` markers (if present): **non-consuming** â‡’ `blocks=0`, `draws='0'`.  

**S7 â€” integerisation evidence**

* **residual_rank**: **non-consuming** â‡’ `blocks=0`, `draws='0'`; one per `(merchant_id,country_iso)` in domain; residuals quantised to **dp=8**.
* Optional **dirichlet_gamma_vector** (feature-flag): variable (sum of Gamma component budgets). Trace append after each event.  

**S8 â€” sequencing instrumentation** (`module=1A.site_id_allocator`)

* **sequence_finalize**: **non-consuming** â‡’ `blocks=0`, `draws='0'`; one per `(merchant,country)` with `nâ‰¥1`.
* **site_sequence_overflow** (guardrail): **non-consuming** â‡’ `blocks=0`, `draws='0'`. Trace append after each event.  

---

## 7.3 Open-interval uniform law â€” **MUST**

Where a family exposes a uniform **value** (e.g., S1 payload `u`), S9 **MUST** verify **strict-open** `uâˆˆ(0,1)`; exact 0.0 or 1.0 is **forbidden**. (Budget/trace checks do **not** require logging all uniforms; counters and `draws` carry authority.)  

---

## 7.4 Attempt/order invariants (families with loops) â€” **MUST**

* **S2 NB:** per attempt **exactly one** `gamma_component` then **one** `poisson_component`; on first `Kâ‰¥2`, **exactly one** `nb_final` (non-consuming). 
* **S4 ZTP:** attempts are **1-based** and **monotone**; each `poisson_component` (consuming) is followed by either acceptance (`ztp_final`, non-consuming) or a **non-consuming** rejection marker; cap policy produces either `ztp_retry_exhausted` (non-consuming; **no** final) or `ztp_final{K_target=0}` (non-consuming). Envelope counters within a merchantâ€™s substream are **monotone, non-overlapping**; replay by **counters**, not file order. 

**Failure classes:** `E_S4_SEQUENCE_INVALID` (attempt index/order breach), `E_FINALISER_CARDINALITY` (0/>1 where exactly one required). 

---

## 7.5 Trace coverage & reconciliation â€” **MUST**

For each `(module, substream_label)`:

* **Coverage duty.** After **every** event append, there is **exactly one** cumulative `rng_trace_log` row appended (saturating totals). **Fail** if any event lacks a following trace row.  
* **Totals reconciliation.** On the **final** trace row per key (selection per schema note), verify:
  `draws_total == Î£ parse_u128(draws)`;
  `blocks_total == Î£ blocks`;
  `events_total ==` event count. *(No identity is implied between draws and blocks totals.)*  
* **Isolation.** Only the families owned by that state/module appear under that key (e.g., S6 trace keys only cover `gumbel_key`/`stream_jump`). 

**Failure classes:** `E_TRACE_COVERAGE_MISSING` (coverage), `E_TRACE_TOTALS_MISMATCH` (totals), `E_TRACE_ISOLATION_BREACH`. 

---

## 7.6 Audit presence & lineage parity â€” **MUST**

* **rng_audit_log** **MUST** exist for each `{seed, parameter_hash, run_id}` observed in events/trace; pathâ†”embed lineage equality holds; algorithm is `philox2x64-10`.  
* **Pathâ†”embed equality** for `{seed, parameter_hash, run_id}` on **every** event/log row (see Â§6 for lineage checks). 

---

## 7.7 Numeric profile & overflow guards â€” **MUST**

* Validation assumes S0â€™s numeric profile: **binary64, RNE, FMA-off, no FTZ/DAZ**; Boxâ€“Muller uses the pinned **hex-float TAU** constant and **two uniforms per normal** (no caching).  
* Trace counters are **uint64 saturating**; emitters **MUST** avoid overflow (else **budget violation**). 

---

**Status:** Â§7 is **Binding**. It fixes how S9 reconciles **per-event envelopes**, **family budgets**, **loop discipline**, and **trace totals**, enforcing the strict-open uniform law and non-consuming semantics before declaring the run PASS.

---

# 8) Cross-state replay checks **(Binding)**

S9 **re-derives facts from written inputs only** (events, tables, logs) and **fails closed** on any mismatch. This section fixes the per-state checks S9 MUST performâ€”beyond structural (Â§5) and envelope/budget law (Â§7).

---

## 8.1 S1 â€” Hurdle (single vs multi) **MUST**

For each merchant within `{seed, parameter_hash, run_id}`:

* **Cardinality & gating.** Exactly **one** `rng_event.hurdle_bernoulli`; downstream **1A RNG streams** (S2/S4/S6/S7/S8) **exist iff** `is_multi=true`.  
* **Deterministic vs stochastic.**
  â€“ If `piâˆˆ{0.0,1.0}`: `draws='0'`, `blocks=0`, `u=null`, `deterministic=true`.
  â€“ If `0<pi<1`: `draws='1'`, `blocks=1`, `uâˆˆ(0,1)`, and `(u < pi) == is_multi`.  
* **Failure classes.** `E_S1_CARDINALITY` (â‰ 1 row), `E_S1_U_OUT_OF_RANGE`, `E_S1_GATING_VIOLATION`. 

---

## 8.2 S2 â€” NB mixture â†’ `Nâ‰¥2` (logs) **MUST**

For each merchant with S1 `is_multi=true`:

* **Attempt discipline.** Per attempt: **one** `gamma_component(context='nb')` then **one** `poisson_component(context='nb')`; counters monotone/non-overlapping.  
* **Finaliser.** Exactly **one** **non-consuming** `nb_final` echoing `Î¼,Ï†` and fixing `n_outlets=Nâ‰¥2` and `nb_rejections=râ‰¥0`. 
* **Join to egress.** In `outlet_catalogue`, `raw_nb_outlet_draw` **equals** `nb_final.n_outlets` for the merchant. 
* **Failure classes.** `E_S2_COMPONENT_ORDER`, `E_S2_FINAL_MISSING_OR_DUP`, `E_S2_N_LT_2`. 

---

## 8.3 S3 â€” Candidate set (sole cross-country order) **MUST**

* **Order authority.** For each merchant: `candidate_rank` is **total & contiguous** with **home=0**; S9 **never invents order**. 
* **FKs & uniqueness.** One row per `(merchant_id,country_iso,candidate_rank)`. (Structural checks in Â§5.) 
* **Failure classes.** `E_S3_RANK_GAPS`, `E_S3_HOME_NOT_ZERO`. 

---

## 8.4 S4 â€” ZTP target (`K_target`) **MUST**

For eligible multi-site merchants:

* **Attempt loop.** `poisson_component(context='ztp')` attempts are **1-based**, strictly increasing; each attempt followed by **either** a non-consuming `ztp_rejection` **or** a single non-consuming `ztp_final`. Cap policy respected: `"abort"` â‡’ `ztp_retry_exhausted` and **no** final; `"downgrade_domestic"` â‡’ `ztp_final{K_target=0, exhausted:true}`.  
* **Uniqueness.** â‰¤1 `ztp_final` per resolved merchant. Regime (`inversion` if Î»<10 else `ptrs`) **constant per merchant**. 
* **Failure classes.** `E_S4_SEQUENCE_INVALID`, `E_S4_FINAL_CARDINALITY`, `E_S4_POLICY_VIOLATION`. 

---

## 8.5 S6 â€” Membership realisation (by events or convenience) **MUST**

S9 must choose **one** path (as declared in Â§3):

* **M1 â€” Convenience surface (`s6_membership`)**: **Require S6 PASS** receipt, then assert rows **equal** the top-`K_target` **eligible** countries by **Gumbel key** order (ties: lower S3 `candidate_rank`, then ISO Aâ†’Z per schema); `selected=true â‡’ selection_orderâˆˆ[1..K]`; `weight==0 â‡’ key=null âˆ§ selected=false`. 
* **M2 â€” Event replay (`gumbel_key`)**: From `rng_event.gumbel_key` rows (one uniform each), reconstruct keys and select exactly
  `K_realized = min(K_target, |Eligible|)`; **eligible** means considered with `w>0` after policy filters/caps.  
* **Failure classes.** `E_S6_PASS_MISSING` (when M1 chosen), `E_S6_MEMBERSHIP_MISMATCH`, `E_S6_ZERO_WEIGHT_SELECTED`. 

---

## 8.6 S7 â€” Integer allocation parity (dp=8 residuals) **MUST**

Using `{home} âˆª S6-selected foreigns` in **S3 `candidate_rank` order**:

* **Reconstruct counts.** Apply **largest-remainder** with **dp_resid=8** residuals and the fixed tie-break (residualâ†“, ISO Aâ†’Z, then `candidate_rankâ†‘`), then prove:
  (i) `Î£_i count_i = N` (from S2), and (ii) per-country `residual_rank` equals the persisted evidence.  
* **Failure classes.** `E_S7_PARITY` (residual/order/Î£ law mismatch). 

---

## 8.7 S8 â€” Egress & sequencing **MUST**

For the `(seed,fingerprint)` partition:

* **Per-block sequencing.** For each `(merchant, legal_country_iso)` with `count_iâ‰¥1`: `site_order = 1..count_i` contiguous; `site_id = zfill6(site_order)`; **exactly one** non-consuming `sequence_finalize{start="000001", end=zfill6(count_i)}`; overflow â‡’ `site_sequence_overflow` and **no** egress rows for that merchant.  
* **Sum law & lineage.** Per merchant: `Î£_i final_country_outlet_count_i = N` (from S2). Egress encodes **no cross-country order** (join S3 when needed). `manifest_fingerprint` and `global_seed` **equal** their path tokens.  
* **Failure classes.** `E_S8_SEQUENCE_GAP`, `E_SITE_ID_OVERFLOW`, `E_SUM_MISMATCH`, `E_ORDER_AUTHORITY_DRIFT`.  

---

## 8.8 Cross-state joins & global invariants **MUST**

* **Join-back uniqueness.** `outlet_catalogue` joins **1:1** to S3 on `(merchant_id, country_iso)` (egress uses `legal_country_iso`; both FKs hit canonical ISO).  
* **Cardinality chain.** For each merchant:
  `N (S2) â†’ K_target (S4) â†’ K_realized (S6) â†’ {count_i} (S7) â†’ sequences 1..count_i (S8)`; each stepâ€™s equality/inequality laws must hold (e.g., `K_realized = min(K_target, |Eligible|)`).  
* **No weights in S9.** S9 **does not** read S5 weight surfaces; it uses S6 events (or gated membership) and S7 evidence to replay selection/allocation. 

---

**Status:** Â§8 is **Binding**. It fixes the **per-state replay predicates**, **cross-state joins**, and **failure classes** S9 MUST apply before issuing the PASS decision.

---

# 9) Acceptance thresholds & PASS decision **(Binding)**

## 9.1 What â€œPASSâ€ means (run-level)

S9 **issues PASS** for a `{seed, manifest_fingerprint}` only if **all** Binding checks in Â§Â§5â€“8 succeed for **every** merchant in scope. On PASS, S9 **publishes** `validation_bundle_1A/` under `â€¦/validation/fingerprint={manifest_fingerprint}/` **and** a colocated `_passed.flag` whose content hash equals `SHA256(validation_bundle_1A)` (ASCII-lexicographic order of the `index.json` **`path`** entries, excluding `_passed.flag`). **Consumers MUST verify this before reading `outlet_catalogue`** (**no PASS â†’ no read**).   

## 9.2 What â€œFAILâ€ means (run-level)

S9 **withholds** `_passed.flag` (bundle still written) if **any** Binding check fails in:
(a) **Structural** (Â§5: schema/partition/pathâ†”embed/PK/UK/FK/writer policy),
(b) **Lineage/Determinism** (Â§6: recomputed `parameter_hash`/`manifest_fingerprint`, idempotence, writer sort, join-back stability),
(c) **RNG envelope/accounting** (Â§7: counters, `draws`, non-consuming invariants, trace coverage/totals, attempt order),
(d) **Cross-state replay** (Â§8: S1â†’S8 facts). **No partial PASS** is allowed.    

## 9.3 Tolerated (non-error) cases

The following **do not** prevent PASS when all other checks succeed (they are explicitly defined as non-errors upstream):

* **S6 deterministic empties/shortfalls**: `NO_CANDIDATES`, `K_ZERO`, `ZERO_WEIGHT_DOMAIN`; **shortfall** where (|Eligible|<K_{target}) (select all eligible). S9 records these as **informative** in the bundle. 
* **S8 degenerate but valid**: single-country domain (`DEG_SINGLE_COUNTRY`) and zero-remainder label (`DEG_ZERO_REMAINDER`).  

## 9.4 Optional/absent surfaces (NA semantics)

S9 **does not fail** due to absence of optional convenience surfaces, provided the mandated replay path is followed instead:

* `s6_membership` absent â‡’ replay membership from `gumbel_key` + S3/S4 facts; **S6 PASS** is only required when reading the convenience surface. 
* `s3_integerised_counts` absent â‡’ reconstruct per-country counts from S7 `residual_rank` over S3 domain and enforce Î£-law to `N` (S2). 

## 9.5 Hard-fail classes (non-exhaustive)

S9 **MUST** treat each of the following as **FAIL** for the fingerprint:

**Structural (Â§5):**
`E_SCHEMA_INVALID`, `E_PARTITION_MISPLACED`, `E_PATH_EMBED_MISMATCH`, `E_DUP_PK`, `E_FK_ISO_INVALID`, `E_TRACE_COVERAGE_MISSING`. 

**Lineage/Determinism (Â§6):**
Mismatch in recomputed `parameter_hash`/`manifest_fingerprint`; non-idempotent egress content for same `(seed,fingerprint)`; egress writer sort broken; S8 block atomicity breach (missing/duplicate `sequence_finalize`). 

**RNG envelope/accounting (Â§7):**
`E_RNG_COUNTER_MISMATCH` (blocksâ‰ afterâˆ’before), `E_RNG_BUDGET_VIOLATION` (`draws` mismatch), `E_NONCONSUMING_CHANGED_COUNTERS` (non-consuming but counters moved), `E_TRACE_TOTALS_MISMATCH`, `E_S4_SEQUENCE_INVALID`, `E_FINALISER_CARDINALITY`. 

**Cross-state replay (Â§8):**
S1: `E_S1_CARDINALITY`, `E_S1_U_OUT_OF_RANGE`, `E_S1_GATING_VIOLATION`.
S2: `E_S2_COMPONENT_ORDER`, `E_S2_FINAL_MISSING_OR_DUP`, `E_S2_N_LT_2`.
S3: `E_S3_RANK_GAPS`, `E_S3_HOME_NOT_ZERO`.
S4: `E_S4_FINAL_CARDINALITY`, `E_S4_POLICY_VIOLATION`.
S6: `E_S6_PASS_MISSING` (when using membership surface), `E_S6_MEMBERSHIP_MISMATCH`, `E_S6_ZERO_WEIGHT_SELECTED`.
S7: `E_S7_PARITY` (residual/order/Î£-law mismatch).
S8: `E_S8_SEQUENCE_GAP`, `E_SITE_ID_OVERFLOW`, `E_SUM_MISMATCH`, `E_ORDER_AUTHORITY_DRIFT`.  

## 9.6 Gate publication behaviour

* **PASS:** S9 writes `validation_bundle_1A/` **and** `_passed.flag` (one line: `sha256_hex = <hex64>`, computed over the raw bytes of all files listed in `index.json` (excluding `_passed.flag`) in ASCII-lexicographic order of the **`path`** entries), performing an **atomic rename** into `fingerprint={manifest_fingerprint}/`. 
* **FAIL:** S9 writes the bundle (with failure records) **without** `_passed.flag`. **Consumers MUST NOT** read `outlet_catalogue` for that fingerprint. 

## 9.7 Summary: PASS checklist (must all be TRUE)

1. All subjects pass **schema**/$ref validation. 
2. **Partitions & pathâ†”embed** equality hold for every read subject. 
3. **PK/UK** constraints hold; **FKs** resolve (ISO). 
4. Recomputed `parameter_hash` and `manifest_fingerprint` **match**. 
5. RNG events satisfy **envelope invariants**, **budgets**, and **trace coverage/totals**. 
6. Cross-state replay equalities hold (S1â†’S8), incl. S8 **sequence_finalize** per (merchant,country) and **Î£-law** to S2 `N`. 
7. S6 **PASS receipt** verified **if** membership convenience surface was used. 
8. Bundle contains required files; `_passed.flag` content hash equals `SHA256(validation_bundle_1A)`. 

---

**Status:** Â§9 is **Binding**. It defines the **exact PASS/FAIL criteria**, tolerated non-errors, NA semantics for optional surfaces, and the **gate publication** that governs downstream access to `outlet_catalogue`.

---

# 10) Error handling, edge cases & degrade ladder **(Binding)**

## 10.1 Failure scope & actions (normative)

S9 classifies breaches by **scope** and applies the following actions:

| Scope               | What it means                                                                                                                                                                                | Action                                                                                                                   |
|---------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------|
| **Run-scoped**      | Configuration/authority violations that make the whole fingerprint untrustworthy (schema/dictionary/registry conflicts, lineage recompute mismatch, label registry drift, partition misuse). | **FAIL run** â†’ publish **bundle only** (no `_passed.flag`).                                                              |
| **Merchant-scoped** | A specific merchantâ€™s producer outputs/logs violate binding laws (e.g., S2 attempt order broken, S4 attempt sequence invalid, S8 sequence gap).                                              | Mark merchant as **failed** in bundle; **FAIL run** (no `_passed.flag`). *(S9 is a **gate**, not a best-effort linter.)* |

**Run-scoped examples (non-exhaustive):** schema/partition FK violations; pathâ†”embed inequality; label/stream registry breach; dictionary writer-policy breach; recomputed `parameter_hash`/`manifest_fingerprint` mismatch.   

**Merchant-scoped examples (non-exhaustive):** S1 cardinality/gating; S2 component order; S4 attempt/order/policy; S6 membership mismatch; S7 residual parity; S8 sequence gaps/overflow policy breach (see Â§10.4).      

---

## 10.2 Edge cases (deterministic **non-errors**)

The following outcomes are **valid** when upstream states behaved per spec; S9 **MUST NOT** fail solely due to their occurrence:

* **S6 deterministic empties/shortfalls.** `NO_CANDIDATES`, `K_ZERO`, or (|Eligible|<K_{target}) (select all eligible). Record as **informative** in the bundle. 
* **S8 degenerate domains.** `DEG_SINGLE_COUNTRY` and `DEG_ZERO_REMAINDER` (per-country blocks still 1..náµ¢; finalize events present). 
* **S4 gated zero-target paths.** `A=0` (no admissible foreigns) or policy `downgrade_domestic` resulting in `ztp_final{K_target=0, exhausted:true}`.  

---

## 10.3 Degrade ladder (when optional conveniences are absent)

S9 **MUST** follow this ladder; absence of an optional surface is **not** a failure if the next step is followed correctly:

1. **Counts:** If `s3_integerised_counts` exists, use it; **else** reconstruct counts from S7 `residual_rank` over the S3 domain and enforce Î£-law to S2 `N`. **Never** read S5 weights.  
2. **Membership:** If `s6_membership` exists, **verify S6 PASS** then use it; **else** replay from `gumbel_key` (+ S3/S4 facts). 
3. **Upstream sequence (if present):** `s3_site_sequence` is **cross-check only**; divergence is a **failure** (see below). 

---

## 10.4 Overflow & policy-specific rules (S8)

S8 defines a **guardrail** for per-country site counts `n>999,999`:

* **Correctly handled overflow (merchant-scoped abort; non-error):** S8 **emitted** one **non-consuming** `site_sequence_overflow{â€¦, max_seq=999999, severity="ERROR"}` **and** wrote **no** `outlet_catalogue` rows for that merchant. S9 records the merchant in the bundle and **does not** fail solely for the overflow condition.  
* **Policy breach (failure):** any egress rows exist for an overflowed merchant **or** the overflow event is missing/inconsistent â†’ `E_OVERFLOW_POLICY_BREACH` (**merchant-scoped**) and **FAIL run**. 

---

## 10.5 S4 cap & policy handling

S4â€™s zero-draw cap and policy are **governed**:

* **Allowed policies:** `abort` or `downgrade_domestic` (part of `parameter_hash`). 
* **Validator checks:** attempts are **1-based**; `ztp_retry_exhausted` appears only at cap; **either** no `ztp_final` when policy=`abort` **or** `ztp_final{K_target=0, exhausted:true}` when policy=`downgrade_domestic`. Any other combination â‡’ **merchant-scoped failure** (cap/policy violation).  

---

## 10.6 Failure vocabulary (canonical S9 codes)

S9 **MUST** use the following failure codes in bundle records (non-exhaustive, aligned to Â§Â§5â€“8):

* **Structural:** `E_SCHEMA_INVALID`, `E_PARTITION_MISPLACED`, `E_PATH_EMBED_MISMATCH`, `E_DUP_PK`, `E_FK_ISO_INVALID`, `E_TRACE_COVERAGE_MISSING`.   
* **Lineage/Determinism:** `E_LINEAGE_RECOMPUTE_MISMATCH`, `E_WRITER_SORT_BROKEN`, `E_S8_BLOCK_ATOMICITY`.   
* **RNG envelope/accounting:** `E_RNG_COUNTER_MISMATCH`, `E_RNG_BUDGET_VIOLATION`, `E_NONCONSUMING_CHANGED_COUNTERS`, `E_TRACE_TOTALS_MISMATCH`, `E_S4_SEQUENCE_INVALID`, `E_FINALISER_CARDINALITY`.  
* **Cross-state replay:** `E_S1_CARDINALITY`, `E_S1_GATING_VIOLATION`, `E_S2_COMPONENT_ORDER`, `E_S2_N_LT_2`, `E_S3_RANK_GAPS`, `E_S3_HOME_NOT_ZERO`, `E_S6_MEMBERSHIP_MISMATCH`, `E_S7_PARITY`, `E_S8_SEQUENCE_GAP`, `E_ORDER_AUTHORITY_DRIFT`, `E_SUM_MISMATCH`, `E_OVERFLOW_POLICY_BREACH`.    

---

## 10.7 Bundle logging (required fields)

S9 **MUST** write failure/intel rows into `s9_summary.json` and index them in `index.json`, using stable keys:

```
s9.fail.code, s9.fail.scope âˆˆ {"RUN","MERCHANT"},
s9.fail.reason, s9.fail.dataset_id?, s9.fail.anchor?,
s9.run.seed, s9.run.parameter_hash, s9.run.manifest_fingerprint,
s9.fail.merchant_id?, s9.fail.country_iso?, s9.fail.attempt?, s9.fail.expected?, s9.fail.observed?
```

These mirror upstream producer diagnostics (e.g., S4 failure keys) and enable 1:1 correlation with validator checks.  

---

## 10.8 No partial visibility & atomicity

On any **run-scoped** or **merchant-scoped** failures, S9 **MUST** still write a complete bundle; `_passed.flag` is **withheld** on FAIL. Publish uses **stage â†’ compute hash â†’ atomic rename**; **no partial contents** may become visible.  

---

**Status:** Â§10 is **Binding**. It fixes the **scopeâ†’action** rules, enumerates **non-error edge cases**, defines the **degrade ladder**, sets overflow/policy handling precisely, and standardises **failure vocabulary and logging** for the S9 validation bundle.

---

# 11) Concurrency, sharding & atomics **(Binding)**

## 11.1 Execution model (read-parallel, order-agnostic)

S9 is a **read-only** validator. It **MAY** scan inputs in parallel but **MUST NOT** rely on physical file order. For JSONL logs/events the Dataset Dictionary declares **set semantics** (`ordering: []`), so S9â€™s checks **MUST** be defined by keys and totals, not by line/file sequence. Egress order is governed by the Dictionary **writer sort** and is verified as a constraint (see Â§5).  

## 11.2 Sharding & run binding

* **Run binding (logs).** RNG events and core logs are partitioned by `{seed, parameter_hash, run_id}`. S9 **MUST** derive the set of observed `{run_id}` from the event streams in scope and validate **matching** `rng_trace_log` and `rng_audit_log` partitions for each tuple. 
* **Multi-run coexistence.** Multiple `run_id`s may exist for the same `{seed, parameter_hash}`; S9 treats each independently when reconciling envelopes/trace and then aggregates per the specâ€™s totals rules. (Egress remains fingerprint-scoped.) 

## 11.3 Deterministic reductions (commutative/associative)

All S9 aggregations **MUST** be deterministic regardless of worker count/scheduling:

* **Trace reconciliation.** Select the **final** cumulative `rng_trace_log` row per `(module,substream_label,run_id)` using this deterministic key:
  `ORDER BY events_total DESC, ts_utc DESC, rng_counter_after_hi DESC, rng_counter_after_lo DESC LIMIT 1`.
  This selection is independent of file arrival order and filesystem chunking.
* **Row-set equality.** Where S9 compares tables across files (e.g., egress partitions), equality is by **PK/UK and content**, not physical sequence; writer-sort monotonicity is checked per Â§5.6. 
* **Join-back checks.** S9 computes join/permutation checks using S3â€™s **`candidate_rank`** as the single order authority; the computation is key-driven and stable. 

## 11.4 Atomic publish (bundle & flag)

S9 **MUST** publish the validation bundle **atomically**: build under a temporary directory (e.g., `â€¦/validation/_tmp.{uuid}`), compute `_passed.flag` over **all files listed in `index.json` (excluding `_passed.flag`)** in **ASCII-lexicographic order of the `path` entries**, then perform a **single atomic rename** to `fingerprint={manifest_fingerprint}/`. **No partial contents** may become visible; on failure, remove the temp.  

## 11.5 Idempotent re-runs & equivalence

Re-running S9 with identical inputs and authorities **MUST** produce a **byte-identical** bundle and the same `_passed.flag` content. Two bundles are **equivalent** iff `MANIFEST.json` and **all** other files match byte-for-byte and the flagâ€™s SHA-256 equals `SHA256(validation_bundle_1A)` for the same fingerprint. 

## 11.6 Concurrency-safety checks S9 MUST enforce

* **Trace coverage under parallelism.** For every validated event append, there is **exactly one** subsequent cumulative `rng_trace_log` row for its `(module, substream_label, run_id)`; totals reconcile on the final row. **Any gap or double-append is FAIL** (see Â§7). 
* **Egress monotonicity across files.** Within each `(seed,fingerprint)` egress partition, S9 verifies Dictionary **writer sort** `[merchant_id, legal_country_iso, site_order]` **within files and across file boundaries**. 
* **Set semantics for logs/events.** JSONL streams are treated as **sets**; duplicate identity rows are structural errors; physical order is non-authoritative. 

## 11.7 No reliance on producer worker count

S9â€™s outcomes **MUST NOT** change with producer/validator worker counts or scheduling. This is guaranteed by:

* dictionary-pinned partitions and writer sort (egress),
* key-based joins to S3 order authority,
* set-based event/log semantics with cumulative trace, and
* atomic, fingerprint-scoped publish of the bundle/flag.   

---

**Status:** Â§11 is **Binding**. It fixes how S9 stays deterministic under parallel reads, enforces **set semantics**, and publishes the **bundle + gate** atomically and idempotently.

---

# 12) Bundle contents & metrics **(Binding)**

## 12.1 Bundle root & index (what the folder MUST contain)

* **Location (partitioned):**
  `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` (fingerprint partition). 
* **Every non-flag file MUST be listed once in `index.json`** using the schema below; `path` entries are **relative** to the bundle root; `kind âˆˆ {plot|table|diff|text|summary}`. **`artifact_id` MUST be unique.**
* **Index field hygiene:** `artifact_id` **MUST** match `^[A-Za-z0-9._-]+$` (ASCII only). `path` **MUST** be **relative** (no leading slash, no `..` segments) and ASCII-normalised.
* **Hashing precondition:** The gate hash (Â§9) is computed over the byte contents of **all files listed in `index.json`** (excluding `_passed.flag`) in **ASCII-lexicographic order of the `path` entries**.
* **Gate coupling (reminder):** `_passed.flag` sits in the same folder and contains `sha256_hex = <hex64>` computed over the raw bytes of **all files listed in `index.json` (excluding `_passed.flag`)**, in **ASCII-lexicographic order of the `path` entries**. Consumers **MUST** verify this for the same fingerprint **before** reading `outlet_catalogue`.

**`index.json` (schema â€” Binding):**

```
{ artifact_id: string, kind: "plot"|"table"|"diff"|"text"|"summary",
  path: string, mime?: string, notes?: string }
```

(Per `schemas.1A.yaml#/validation/validation_bundle.index_schema`.) 

---

## 12.2 Required artifacts (minimum set; MUST exist)

S9 **MUST** write at least the files below; all MUST appear in `index.json` (except `_passed.flag`):

1. **`MANIFEST.json`** â€” run identity & environment
   Required fields (non-exhaustive):
   `version="1A.validation.v1"`, `manifest_fingerprint`, `parameter_hash`, `git_commit_hex`, `artifact_count`, `math_profile_id`, `compiler_flags`, `created_utc_ns`.  
2. **`parameter_hash_resolved.json`** â€” canonical list of governed parameters (ð“Ÿ) with basenames in ASCII-lexicographic order.
3. **`manifest_fingerprint_resolved.json`** â€” derivation inputs (e.g., `git_commit_hex`, `parameter_hash`). 
4. **`rng_accounting.json`** â€” per-family RNG accounting & coverage (see Â§12.4).  
5. **`s9_summary.json`** â€” structural & replay verdicts (by check & by merchant); failure codes; gate decision summary (see Â§12.5).
6. **`egress_checksums.json`** â€” stable per-file & composite SHA-256 for `outlet_catalogue` in `[seed,fingerprint]` (see Â§12.6).
7. **`index.json`** â€” bundle index per Â§12.1. 

> **Hashing rule for the gate** (normative, repeated): `_passed.flag` = `sha256_hex` of the concatenation of the raw bytes of **all files listed in `index.json`** (excluding `_passed.flag`) in **ASCII-lexicographic order of the `path` entries**. 

---

## 12.3 Recommended/optional artifacts (included in flag hash when present)

* **`param_digest_log.jsonl`** â€” one line per governed parameter file `{filename,size_bytes,sha256_hex,mtime_ns}`. 
* **`fingerprint_artifacts.jsonl`** â€” one line per artefact opened into the fingerprint `{path,sha256_hex,size_bytes}`. 
* **`numeric_policy_attest.json`** â€” attestation of numeric policy (IEEE-754 binary64, RNE, FMA-off, no FTZ/DAZ) and S0.8 self-tests. 
* **`DICTIONARY_LINT.txt`, `SCHEMA_LINT.txt`** â€” optional lints; if emitted, they are part of the flag hash. 

---

## 12.4 `rng_accounting.json` (Binding â€” content & metrics)

Purpose: prove **envelope compliance**, **budget reconciliation**, and **trace coverage** for every RNG family used by 1A (S1/S2/S4/S6/S7/S8), per Â§7 rules.

**Shape (minimum fields):**

```
{
  "runs": [ { "seed": uint64, "parameter_hash": hex64, "run_id": string } ... ],
  "families": {
    "<family>": {
      "events_total": int64,
      "draws_total_u128_dec": string,   // Î£ event.draws as decimal u128
      "blocks_total_u64": int64,        // Î£ event.blocks
      "nonconsuming_events": int64,     // events with blocks=0, draws="0"
      "trace_rows_total": int64,        // rows seen in rng_trace_log for this key
      "trace_totals": {                 // from the final cumulative trace row
        "events_total": int64,
        "draws_total_u128_dec": string,
        "blocks_total_u64": int64
      },
      "audit_present": boolean,         // rng_audit_log partition exists for every run_id
      "coverage_ok": boolean            // exactly one trace append after each event append
    }, ...
  }
}
```

**Requirements.**

* **Families in scope** at minimum: `hurdle_bernoulli`, `gamma_component`, `poisson_component{contextâˆˆ[nb,ztp]}`, `ztp_*` finals/rejections, `gumbel_key` (and optional `stream_jump`), `residual_rank`, `sequence_finalize`, `site_sequence_overflow`. (Bound by the Dictionary & layer schemas.)  
* **Trace coverage:** for each `(module, substream_label, run_id)` key, **exactly one** cumulative `rng_trace_log` row **after each** event append (coverage_ok = true). 
* **Totals reconciliation:** `draws_total_u128_dec` and `blocks_total_u64` in `trace_totals` **equal** the set-sums over the validated events (open-interval uniforms never equal {0,1}).  
* **Audit presence:** `rng_audit_log` exists and matches `{seed,parameter_hash,run_id}` partitions. 

---

## 12.5 `s9_summary.json` (Binding â€” acceptance summary & failures)

Purpose: one machine-readable summary of **structural**, **lineage/determinism**, **RNG accounting**, and **replay** outcomes that determine PASS vs FAIL.

**Shape (minimum fields):**

```
{
  "run": {
    "seed": uint64,
    "parameter_hash": hex64,
    "manifest_fingerprint": hex64,
    "decision": "PASS"|"FAIL"
  },
  "merchants_total": int64,
  "merchants_failed": int64,
  "failures_by_code": { "E_*": int64, ... },  // counts per canonical code
  "counts_source": "s3_integerised_counts"|"residual_rank",
  "membership_source": "s6_membership"|"gumbel_key",
  "checks": {
    "schema_pk_fk": true|false,
    "path_embed_equality": true|false,
    "rng_envelope": true|false,            // per Â§7.1
    "rng_trace_coverage": true|false,      // per Â§7.5
    "s1..s8_replay": true|false,           // aggregate of Â§8 checks
    "egress_writer_sort": true|false
  },
  "notes"?: string
}
```

* **Failure codes** MUST use the canonical vocabulary in Â§10.6 (e.g., `E_RNG_COUNTER_MISMATCH`, `E_S7_PARITY`, `E_S8_SEQUENCE_GAP`). (Consumer tools rely on these exact strings.)
* **`decision`** MUST match the publication behaviour in Â§9 (bundle always written; `_passed.flag` only on PASS).

(While `s9_summary.json` has no cross-file anchor, the above fields are **Binding** for S9; the **index.json** entry advertises it as `kind:"summary"`.) 

---

## 12.6 `egress_checksums.json` (Binding â€” stability & idempotence)

Purpose: prove **byte-stability** of `outlet_catalogue` under re-runs for the same `(seed,fingerprint)`.

**Shape (minimum fields):**

```
{
  "dataset_id": "outlet_catalogue",
  "seed": uint64,
  "manifest_fingerprint": hex64,
  "files": [ { "path": "part-....parquet", "sha256_hex": hex64, "size_bytes": int64 }, ... ],
  "composite_sha256_hex": hex64          // SHA-256 over concatenation of raw bytes of all listed files in ASCII-lexicographic order of the `path` entries
}
```

* File list MUST cover **all** files in `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/`. **Writer sort** verification lives in Â§5; this file establishes byte-identity. 
* The **composite hash rule** mirrors the flagâ€™s lexicographic concatenation pattern for determinism. 

---

## 12.7 Metrics (normative definitions the validator MUST compute)

S9 **MUST** compute and persist (via `rng_accounting.json` and `s9_summary.json`) at least:

* **`events_total` / `draws_total_u128_dec` / `blocks_total_u64` per family** (see Â§12.4) with reconciliation against the **final** cumulative `rng_trace_log` row for that key. 
* **`coverage_ok`** per family (exactly one trace append after each event append). 
* **`merchants_total` / `merchants_failed`** and **`failures_by_code`** (canonical codes per Â§10.6).
* **`counts_source`** = `"s3_integerised_counts"` or `"residual_rank"` (per chosen path in Â§3/Â§8). 
* **`membership_source`** = `"s6_membership"` (S6 PASS verified) or `"gumbel_key"` (events path). 
* **`egress_writer_sort`** boolean (PK/Sort `[merchant_id, legal_country_iso, site_order]` per Dictionary). 

---

## 12.8 Indexing rules (Binding)

* **All** bundle files except `_passed.flag` **MUST** appear in `index.json`.
* `artifact_id` values are **unique** within the bundle.
* `path` entries are **relative** and **ASCII-sortable**; S9 computes the gateâ€™s hash over that lexicographic order.  

---

## 12.9 Retention & lineage (Binding)

* Retention/TTL for `validation_bundle_1A` is governed by the Dictionary (default 365 days). `index.json` and all JSON/JSONL within **embed the same `manifest_fingerprint`** as the path token. 

---

**Status:** Â§12 is **Binding**. It freezes the **required bundle files**, their **minimum schemas**, the **metrics** S9 MUST compute, and the **hashing/index rules** that couple the bundle to the consumer gate.

---

# 13) Consumer gate & HashGate coupling **(Binding)**

## 13.1 Consumer obligation (egress read rule)

Downstream consumers (e.g., 1B) **MUST NOT** read `outlet_catalogue` for a given `fingerprint` unless the **co-located** `_passed.flag` under
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` **exists** and its **content** equals `SHA256(validation_bundle_1A)` **for the same fingerprint**. This is the canonical **no PASS â†’ no read** gate for 1A egress. The Dataset Dictionary and Artefact Registry restate this consumer duty.  

## 13.2 What consumers MUST verify (exact checks)

Before any read of `outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/â€¦`, a conformant consumer **MUST**:

1. **Locate the bundle** at `â€¦/validation/fingerprint={manifest_fingerprint}/`. Assert that the egress partitionâ€™s path token `fingerprint` **byte-equals** `manifest_fingerprint` embedded in egress rows (pathâ†”embed equality). 
2. **Verify the flag hashing rule.** Read `_passed.flag` (single line `sha256_hex = <hex64>`), list **all files listed in `index.json` (excluding `_passed.flag`)** in the bundle **in ASCII-lexicographic order of the `path` entries**, concatenate their raw bytes, compute SHA-256, and assert equality to `<hex64>`. *(The flag itself is excluded from the hash.)*  
3. **(Optional but recommended)**: re-hash `fingerprint_artifacts.jsonl` / `param_digest_log.jsonl` advertised by S0 to harden supply-chain checks. Failure of any step â‡’ treat the run as **invalid** and **abort** the read. 

## 13.3 Scope boundaries (what the gate does/does not cover)

* The **only** egress gate that governs `outlet_catalogue` consumption is the **fingerprint-scoped** `_passed.flag` described above; parameter-scoped receipts (e.g., S5 PASS) remain **independent** and are **not** substitutes for the egress gate. 
* If consumers read any **S6 convenience surface** (e.g., `s6_membership`), they **MUST** also verify the **S6 PASS receipt** (`â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/(S6_VALIDATION.json,_passed.flag)`) **before** use. This is separate from, and does not weaken, the S9 egress gate.  

## 13.4 HashGate coupling (CI/runtime metadata; optional)

Projects **MAY** couple the consumer gate to a central **HashGate** metadata service for CI/runtimes. When enabled:

* **Publish:** After a **PASS**, S9 (or CI) **MAY** POST a record keyed by `manifest_fingerprint` with at least: `{dataset_id:"outlet_catalogue", fingerprint, sha256_hex_of_bundle, artifact_count, created_utc_ns, git_commit_hex}`. *(Authoritative truth remains the on-disk bundle; HashGate is a convenience index.)*  
* **Enforce:** CI **MAY** block merges/deploys unless HashGate returns a record whose `sha256_hex` **matches** the `_passed.flag` content and whose `fingerprint` matches the partition being promoted. 
* **Read-time use:** A consumer **MAY** cache a HashGate **URI/receipt** to accelerate lookups, but **MUST** still succeed the **local** flag verification in Â§13.2 before reading egress. *(HashGate cannot override a failing local flag.)* 

## 13.5 Revocation & drift handling

* If the bundle exists but `_passed.flag` is **missing** or its hash **mismatches**, consumers **MUST** treat the partition as **failed** and refuse reads. *(S9 writes bundles without a flag on FAIL.)* 
* If any consumer detects a **pathâ†”embed mismatch** (e.g., egress row `manifest_fingerprint` â‰  path token), that is a **hard error** equivalent to an invalid gate; refuse reads. 
* Re-publishing a fingerprint with different bytes is **disallowed**; partitions are **immutable**. Any byte drift is a violation; consumers should fail closed. 

## 13.6 Minimal consumer API (normative steps)

A conformant consumer library **MUST** expose (at minimum):

1. `verify_fingerprint_gate(fingerprint) -> PASS|FAIL` implementing Â§13.2.
2. `require_gate_then_open(dataset_id="outlet_catalogue", seed, fingerprint)` that **fails closed** on any gate/lineage breach.
3. `verify_receipt(path="â€¦/s6/â€¦") -> PASS|FAIL` for S6 where relevant.  

---

**Status:** Â§13 is **Binding**. It fixes the **consumerâ€™s read-gate duty**, the **exact hashing check**, clarifies **scope boundaries** (egress vs parameter-scoped receipts), and defines an **optional HashGate coupling** for CIâ€”without weakening the mandatory local `_passed.flag` verification.  

---

# 14) Observability & SLOs **(Binding)**

## 14.1 Signals & sinks (what S9 MUST expose)

S9 **MUST** emit machine-readable observability into the **validation bundle** (fingerprint-scoped) and **MAY** mirror selected counters to an ops sink. Required bundle artefacts and their shapes are fixed in Â§12 (`rng_accounting.json`, `s9_summary.json`, `egress_checksums.json`, `index.json`). These files live under:
`data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`.  

**Upstream surfaces S9 reads for observability:**

* **Core RNG logs** (`rng_trace_log`, `rng_audit_log`) â€” JSONL, partitioned by `{seed, parameter_hash, run_id}`, **one cumulative trace row appended after each RNG event append**.  
* **S8 instrumentation families** (`sequence_finalize`, `site_sequence_overflow`) â€” **non-consuming**; used for coverage and overflow diagnostics; paths and gating as declared for 1A.  

## 14.2 Required counters & gauges (values S9 MUST compute)

S9 **MUST** compute and persist (via Â§12 artefacts) at least:

* **RNG coverage & totals** (per family used by 1A): `events_total`, `draws_total_u128_dec`, `blocks_total_u64`, `coverage_ok`, `audit_present`, and **final trace** reconciliation (`trace_totals == set-sums of events`). (See `rng_accounting.json` Â§12.4.) 
* **Run decision & failures:** `decision âˆˆ {PASS, FAIL}`, `merchants_total`, `merchants_failed`, and `failures_by_code{E_*}` (canonical codes from Â§10.6) in `s9_summary.json`. 
* **Source declarations:** `counts_source âˆˆ {"s3_integerised_counts","residual_rank"}`, `membership_source âˆˆ {"s6_membership","gumbel_key"}` (tie S9â€™s replay route to concrete sources).  
* **Egress stability:** per-file and composite SHA-256 for `outlet_catalogue` in the `(seed,fingerprint)` partition (`egress_checksums.json`). 

## 14.3 Lineage for metrics (run keys that MUST label metrics)

Every metric line S9 emits **MUST** carry `{seed, parameter_hash, run_id, manifest_fingerprint}` so that dashboards and forensics are keyed to immutable lineage (values-only; bytes-safe). 

## 14.4 SLO envelope (binding expectations S9 MUST attest)

The following are **SLO-style invariants** S9 **MUST** check and record (PASS requires all of them; see Â§9):

* **Gate integrity SLO.** `_passed.flag` exists **only** on PASS and its `sha256_hex` equals `SHA256(validation_bundle_1A)` (ASCII-lexicographic over all files listed in `index.json` (excluding `_passed.flag`)). Atomic publish: stage â†’ compute â†’ **single rename**; **no partial visibility**.  
* **Trace coverage SLO.** For each `(module, substream_label, run_id)` validated, there is **exactly one** cumulative `rng_trace_log` row **after each** event append; final trace totals reconcile with event sums. 
* **Determinism SLO.** Re-running S9 on identical inputs produces a **byte-identical** bundle and the same `_passed.flag`; egress file hashes are stable per `(seed,fingerprint)`.  
* **Order & partition SLO.** Egress obeys writer sort `[merchant_id, legal_country_iso, site_order]` within the `(seed,fingerprint)` partition; lineage **pathâ†”embed equality** holds for all subjects. 

## 14.5 Alerting conditions (emit + record; MUST fail run)

S9 **MUST** record these conditions in `s9_summary.json` and **FAIL** the fingerprint (bundle written, flag withheld):

* Gate mismatch or partial publish (hash inequality / missing flag / non-atomic publish). 
* Trace coverage gap or totals mismatch for any family in scope. 
* Any structural, lineage, RNG-envelope, or replay failure listed in Â§9.5 (use canonical `E_*` codes). 

## 14.6 Optional latency & throughput (recommended)

S9 **SHOULD** add timing fields to `s9_summary.json` (or a separate `s9_timings.json` indexed in `index.json`):
`started_utc_ns`, `completed_utc_ns`, `duration_ms`, `events_validated_total`, `throughput_events_per_s` (values-only; no paths/PII). *(Optional metrics do not alter the gate hash rule beyond normal inclusion in the bundle.)* 

## 14.7 Retention & hygiene (binding via Dictionary)

Retention and storage hygiene for the bundle and logs follow the **Dataset Dictionary** (typical: bundles 365 days; core RNG logs 365 days; event families 180 days). JSONL streams are **set-semantics**; equality is by row set, not file order.  

---

**Status:** Â§14 is **Binding**. It fixes the **signals**, **required counters**, **lineage labels**, **SLO-style invariants** S9 must attest, **alerting conditions**, and the **retention/hygiene** rulesâ€”anchored to the same bundle/log authorities used across 1A.

---

# 15) Schema & Dictionary anchors in scope **(Binding)**

## 15.1 Schema sets in force & anchor resolution (normative)

* **Segment schemas:** `schemas.1A.yaml` (1A tables, egress, bundle). 
* **Layer schemas:** `schemas.layer1.yaml` (RNG events, core logs, validation receipts). 
* **Ingress schemas:** `schemas.ingress.layer1.yaml` (FK targets like ISO). 
* Anchor rule:
  - `#/rng/**` â†’ layer schema
  - `#/validation/validation_bundle` â†’ 1A schema
  - `#/validation/s6_receipt` â†’ layer schema
  - `#/s3/**` & `#/egress/**` â†’ 1A schema
  - ingress FKs (e.g., `#/iso3166_canonical_2024`) â†’ ingress schema

## 15.2 Segment-1A schema anchors S9 touches

* **Egress:** `#/egress/outlet_catalogue`. (PK `[merchant_id,legal_country_iso,site_order]`; partitions `[seed,fingerprint]`.)  
* **Order authority:** `#/s3/candidate_set` (total & contiguous `candidate_rank`, home=0).  
* **Counts (optional path):** `#/s3/integerised_counts`.  
* **Sequence (optional cross-check):** `#/s3/site_sequence`. 
* **Membership (convenience surface):** `#/alloc/membership`.
* **Validation bundle (output of S9):** `#/validation/validation_bundle` + its `index_schema`.  

## 15.3 Layer-wide RNG & validation anchors S9 validates

* **Core logs:** `#/rng/core/rng_audit_log`, `#/rng/core/rng_trace_log`.  
* **S1:** `#/rng/events/hurdle_bernoulli`. 
* **S2:** `#/rng/events/gamma_component`, `#/rng/events/poisson_component`, `#/rng/events/nb_final`.  
* **S4 (ZTP):** `#/rng/events/poisson_component` (context â€˜ztpâ€™), `#/rng/events/ztp_rejection`, `#/rng/events/ztp_final`. 
* **S6:** `#/rng/events/gumbel_key` (and `#/rng/events/stream_jump` if emitted).  
* **S7:** `#/rng/events/residual_rank`. 
* **S8 instrumentation:** `#/rng/events/sequence_finalize`, `#/rng/events/site_sequence_overflow`.  
* **S6 receipt (gate):** `#/validation/s6_receipt`. 

## 15.4 Ingress / FK anchors

* **ISO FK target:** `schemas.ingress.layer1.yaml#/iso3166_canonical_2024` (uppercase ISO-2; placeholders forbidden).  

## 15.5 Dataset Dictionary IDs (IDs â†’ path â†’ partitions â†’ `$ref`) used by S9

* **`outlet_catalogue`** â†’ `data/layer1/1A/outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/` â†’ `[seed,fingerprint]` â†’ `schemas.1A.yaml#/egress/outlet_catalogue`. *(Writer sort `[merchant_id,legal_country_iso,site_order]`; â€œno PASS â†’ no readâ€.)*  
* **`s3_candidate_set`** â†’ `â€¦/s3_candidate_set/parameter_hash={parameter_hash}/` â†’ `[parameter_hash]` â†’ `#/s3/candidate_set`. 
* **`s3_integerised_counts`** (optional) â†’ `â€¦/s3_integerised_counts/parameter_hash={parameter_hash}/` â†’ `[parameter_hash]` â†’ `#/s3/integerised_counts`. 
* **`s3_site_sequence`** (optional cross-check) â†’ `â€¦/s3_site_sequence/parameter_hash={parameter_hash}/` â†’ `[parameter_hash]` â†’ `#/s3/site_sequence`.  
* **`s6_membership`** (if used) â†’ `â€¦/s6/membership/seed={seed}/parameter_hash={parameter_hash}/` â†’ `[seed,parameter_hash]` â†’ `#/alloc/membership` (**gate**: `s6_validation_receipt`).
* **`s6_validation_receipt`** â†’ `â€¦/s6/seed={seed}/parameter_hash={parameter_hash}/` â†’ `[seed,parameter_hash]` â†’ `schemas.layer1.yaml#/validation/s6_receipt`. 
* **`rng_audit_log`** â†’ `logs/rng/audit/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_audit_log.jsonl` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/core/rng_audit_log`. 
* **`rng_trace_log`** â†’ `logs/rng/trace/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/rng_trace_log.jsonl` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/core/rng_trace_log`. 
* **`rng_event.sequence_finalize`** â†’ `logs/rng/events/sequence_finalize/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/events/sequence_finalize`. 
* **`rng_event.site_sequence_overflow`** â†’ `logs/rng/events/site_sequence_overflow/â€¦` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/events/site_sequence_overflow`. 
* **`rng_event.residual_rank`** â†’ `logs/rng/events/residual_rank/â€¦` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/events/residual_rank`. 
* **`rng_event.gumbel_key`** â†’ `logs/rng/events/gumbel_key/â€¦` â†’ `[seed,parameter_hash,run_id]` â†’ `#/rng/events/gumbel_key`. 
* **`rng_event.gamma_component` / `rng_event.poisson_component` / `rng_event.nb_final` / `rng_event.ztp_rejection` / `rng_event.ztp_final`** â†’ `logs/rng/events/{family}/seed={seed}/parameter_hash={parameter_hash}/run_id={run_id}/â€¦` â†’ `[seed,parameter_hash,run_id]` â†’ corresponding `#/rng/events/*` anchors.  
* **`validation_bundle_1A`** (output of S9) â†’ `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/` â†’ `[fingerprint]` â†’ `schemas.1A.yaml#/validation/validation_bundle`. *(Flag `_passed.flag` co-located; content hash equals `SHA256(bundle)`.)*  

---

**Status:** Â§15 is **Binding**. It freezes the **exact anchors** and **Dictionary IDs/paths/partitions** S9 recognises and enforces during validation and publish.

---

# Appendix A) Enumerations & literal labels **(Normative)**

This appendix freezes the **exact strings/enums** S9 relies on when validating S0â€“S8 and publishing the bundle/flag. Everything here is **binding**.

## A.1 RNG `module` / `substream_label` pairs (by state; S9 reads only)

* **S1 Hurdle**

  * `module="1A.hurdle_sampler"`, `substream_label="hurdle_bernoulli"`. 

* **S2 NB mixture**

  * `gamma_component`: `module="1A.nb_and_dirichlet_sampler"`, `substream_label="gamma_nb"`.
  * `poisson_component` (context `"nb"`): `module="1A.nb_poisson_component"`, `substream_label="poisson_nb"`.
  * `nb_final` (non-consuming): `module="1A.nb_sampler"`. 

* **S4 ZTP target**

  * `poisson_component` (context `"ztp"`): `module="1A.ztp_sampler"`, `substream_label="poisson_component"`.
  * `ztp_rejection` / `ztp_retry_exhausted` / `ztp_final` (non-consuming): `module="1A.ztp_sampler"`; `substream_label âˆˆ {"ztp_rejection","ztp_retry_exhausted","ztp_final"}`.  

* **S6 Selection keys**

  * `module="1A.foreign_country_selector"`, `substream_label âˆˆ {"gumbel_key","stream_jump"}` (`stream_jump` optional). 

* **S7 Integerisation (evidence)**

  * `residual_rank`: `module="1A.integerisation"`, `substream_label="residual_rank"`.
  * `dirichlet_gamma_vector` (if enabled): `module="1A.dirichlet_allocator"`, `substream_label="dirichlet_gamma_vector"`. 

* **S8 Sequencing instrumentation (non-consuming)**

  * `module="1A.site_id_allocator"`, `substream_label âˆˆ {"sequence_finalize","site_sequence_overflow"}`. 

> **Note.** **Budget literals** follow the layer envelope: single-uniform families `(blocks=1, draws="1")`, two-uniform Boxâ€“Muller `(blocks=1, draws="2")`, non-consuming `(blocks=0, draws="0")`. S9 enforces these in Â§7.  

---

## A.2 RNG family names & fixed payload enums

* **Families (S9 validates):**
  `hurdle_bernoulli`, `gamma_component`, `poisson_component{contextâˆˆ{"nb","ztp"}}`, `nb_final`, `ztp_rejection`, `ztp_retry_exhausted`, `ztp_final`, `gumbel_key`, `stream_jump` (optional), `residual_rank`, `sequence_finalize`, `site_sequence_overflow`, and the layer helpers (e.g., `normal_box_muller`).  

* **S4 fixed enums (payload):**
  `context="ztp"`; `regime âˆˆ {"inversion","ptrs"}`; optional `reason="no_admissible"` on `ztp_final` (when present in the schema version). 

* **S6 fixed semantics (payload excerpts):**
  `gumbel_key`: `blocks=1`, `draws="1"`; if `weight==0` â‡’ `key=null`, `selected=false`, no `selection_order`. 

---

## A.3 Dataset Dictionary IDs â†’ partitions â†’ `$ref` (S9 read/write set)

* **Egress:** `outlet_catalogue` â†’ partitions `[seed,fingerprint]` â†’ `schemas.1A.yaml#/egress/outlet_catalogue`. *(No inter-country order encoded.)* 
* **Order authority (required):** `s3_candidate_set` â†’ `[parameter_hash]` â†’ `#/s3/candidate_set`. *(Home rank=0; ranks total & contiguous.)* 
* **Counts (optional path):** `s3_integerised_counts` â†’ `[parameter_hash]` â†’ `#/s3/integerised_counts`. 
* **Optional sequence cross-check:** `s3_site_sequence` â†’ `[parameter_hash]` â†’ `#/s3/site_sequence`. 
* **Membership convenience:** `s6_membership` â†’ `[seed,parameter_hash]` â†’ `#/alloc/membership` (gate = `s6_validation_receipt`).  
* **Core logs:** `rng_audit_log`, `rng_trace_log` â†’ `[seed,parameter_hash,run_id]` â†’ layer `#/rng/core/*`. 
* **Validation outputs (S9 writes):**
  `validation_bundle_1A` (folder) & `validation_passed_flag` (file `_passed.flag`) under `validation/fingerprint={manifest_fingerprint}/`. 

---

## A.4 Gate & bundle literals

* **Flag filename:** `_passed.flag`
  **Content (one line):** `sha256_hex = <hex64>` where `<hex64>` is **SHA-256 over the raw bytes of all files listed in `index.json`**, in **ASCII-lexicographic order of the `path` entries**. *(Flag file excluded from the hash.)*

* **Bundle root:** `data/layer1/1A/validation/fingerprint={manifest_fingerprint}/`
  **Index schema kind:** `kind âˆˆ {"plot","table","diff","text","summary"}`. 

* **Required bundle filenames:**
  `MANIFEST.json`, `parameter_hash_resolved.json`, `manifest_fingerprint_resolved.json`, `rng_accounting.json`, `s9_summary.json`, `egress_checksums.json`, `index.json`. 

---

## A.5 S8 sequencing constants (validated by S9)

* **`six_digit_seq` regex:** `^[0-9]{6}$` for `site_id`, `start_sequence`, `end_sequence`.
* **Overflow guardrail:** `max_seq = 999999`; `site_sequence_overflow.severity="ERROR"`; event is **non-consuming**.  

---

## A.6 Closed vocabularies & result labels

* **S4 policy enums:** `ztp_exhaustion_policy âˆˆ {"abort","downgrade_domestic"}`. 
* **S4 regime enum:** `regime âˆˆ {"inversion","ptrs"}`. 
* **S6 reason codes (diagnostic, non-error):** `NO_CANDIDATES`, `K_ZERO`, `ZERO_WEIGHT_DOMAIN`, `CAPPED_BY_MAX_CANDIDATES`. 
* **S8 outcome labels (informative):** `DEG_SINGLE_COUNTRY`, `DEG_ZERO_REMAINDER`. 
* **S9 run decision:** `PASS` | `FAIL`. *(Gate behaviour in Â§9; flag as above.)*

---

## A.7 Canonical S9 failure codes (write into bundle; see Â§10)

* **Structural:** `E_SCHEMA_INVALID`, `E_PARTITION_MISPLACED`, `E_PATH_EMBED_MISMATCH`, `E_DUP_PK`, `E_FK_ISO_INVALID`, `E_TRACE_COVERAGE_MISSING`. 
* **Lineage/Determinism:** `E_LINEAGE_RECOMPUTE_MISMATCH`, `E_WRITER_SORT_BROKEN`, `E_S8_BLOCK_ATOMICITY`. 
* **RNG envelope/accounting:** `E_RNG_COUNTER_MISMATCH`, `E_RNG_BUDGET_VIOLATION`, `E_NONCONSUMING_CHANGED_COUNTERS`, `E_TRACE_TOTALS_MISMATCH`, `E_S4_SEQUENCE_INVALID`, `E_FINALISER_CARDINALITY`. 
* **Cross-state replay:**
  `E_S1_CARDINALITY`, `E_S1_U_OUT_OF_RANGE`, `E_S1_GATING_VIOLATION`;
  `E_S2_COMPONENT_ORDER`, `E_S2_N_LT_2`;
  `E_S3_RANK_GAPS`, `E_S3_HOME_NOT_ZERO`;
  `E_S6_MEMBERSHIP_MISMATCH`, `E_S6_ZERO_WEIGHT_SELECTED`;
  `E_S7_PARITY`;
  `E_S8_SEQUENCE_GAP`, `E_SITE_ID_OVERFLOW`, `E_SUM_MISMATCH`, `E_ORDER_AUTHORITY_DRIFT`.  

---

## A.8 Envelope & lineage field names (must-match)

* **Envelope (layer-wide):** `ts_utc`, `seed`, `parameter_hash`, `manifest_fingerprint`, `run_id`, `module`, `substream_label`, `rng_counter_before_lo`, `rng_counter_before_hi`, `rng_counter_after_lo`, `rng_counter_after_hi`, `blocks`, `draws`. *(Row names, not order.)* 
* **Lineage equality (pathâ†”embed):** where both exist, **byte-equality is mandatory**:
  e.g., `outlet_catalogue.global_seed == seed` & `manifest_fingerprint == fingerprint` path token; events/logs `{seed,parameter_hash,run_id}` equal to path tokens. 

---

## A.9 Writer sort & PKs (egress)

* **`outlet_catalogue`** writer sort: `[merchant_id, legal_country_iso, site_order]`; PK/UK identical tuple. *(File order non-authoritative; sort is a constraint.)* 

---

**This appendix is Binding.** Any deviation from these exact literals/enums is a **FAIL** under S9 (Â§Â§5â€“10).

---

# Appendix B) Bundle layout **(Informative)**

This appendix shows the **expected folder shape**, **example filenames**, and **hashing order** for the validation bundle. (Binding rules live in Â§Â§4 & 12; paths/IDs come from the Dictionary/Registry and 1A schemas.)   

## B.1 Where the bundle lives (fingerprint-scoped)

Root (partitioned by fingerprint):

```
data/layer1/1A/validation/fingerprint={manifest_fingerprint}/
```

This folder is the **single source** of validation artifacts for that fingerprint; the **consumer gate** `_passed.flag` is co-located here. (Dictionary + Registry)  

**Naming note.** Any path segment `fingerprint={â€¦}` carries the runâ€™s `manifest_fingerprint` value (S0 lineage rule). 

## B.2 Minimal bundle tree (PASS case)

```
validation/
â””â”€ fingerprint={manifest_fingerprint}/
   â”œâ”€ MANIFEST.json
   â”œâ”€ parameter_hash_resolved.json
   â”œâ”€ manifest_fingerprint_resolved.json
   â”œâ”€ rng_accounting.json
   â”œâ”€ s9_summary.json
   â”œâ”€ egress_checksums.json
   â”œâ”€ index.json
   â””â”€ _passed.flag              # content: "sha256_hex = <hex64>"
```

* The **files above (except `_passed.flag`) MUST be indexed** in `index.json` per the 1A **bundle index schema**; `artifact_id` unique; `path` **relative**. (Schema anchor: `schemas.1A.yaml#/validation/validation_bundle.index_schema`.) 
* `_passed.flag` content equals **SHA-256 over the raw bytes of all files listed in `index.json` (excluding `_passed.flag`) in this folder** in **ASCII-lexicographic order of the `path` entries**. (Dictionary/Registry notes + S9 Â§Â§4 & 12.)  

## B.3 Example `index.json` entries (shape only)

```json
[
  {"artifact_id":"manifest","kind":"text","path":"MANIFEST.json"},
  {"artifact_id":"rng_accounting","kind":"table","path":"rng_accounting.json","notes":"Per-family coverage & totals"},
  {"artifact_id":"summary","kind":"summary","path":"s9_summary.json"},
  {"artifact_id":"egress_hashes","kind":"table","path":"egress_checksums.json"},
  {"artifact_id":"catalog","kind":"table","path":"index.json"}
]
```

(Index schema fields are defined in `schemas.1A.yaml`.) 

## B.4 Optional extras (if present, they **are** part of the flag hash)

```
â””â”€ fingerprint={manifest_fingerprint}/
   â”œâ”€ param_digest_log.jsonl          # one line per governed parameter
   â”œâ”€ fingerprint_artifacts.jsonl     # one line per artefact in the fingerprint
   â”œâ”€ numeric_policy_attest.json      # S0 numeric profile attestation
   â”œâ”€ DICTIONARY_LINT.txt             # optional
   â””â”€ SCHEMA_LINT.txt                 # optional
```

(These are listed in S0 as lineage/attestation artefacts; still indexed in `index.json` when present.) 

## B.5 Lexicographic hashing order (worked example)

Given this file set:

```
egress_checksums.json
MANIFEST.json
manifest_fingerprint_resolved.json
parameter_hash_resolved.json
rng_accounting.json
s9_summary.json
index.json
```

The ASCII-lexicographic order is:

```
MANIFEST.json
egress_checksums.json
index.json
manifest_fingerprint_resolved.json
parameter_hash_resolved.json
rng_accounting.json
s9_summary.json
```

Compute `SHA256(concat(raw_bytes(files_in_order)))` â†’ write `_passed.flag` as:

```
sha256_hex = <hex64>
```

(Flag rule per Registry/Dictionary; consumers **must verify** before reading `outlet_catalogue`.)  

## B.6 What goes into the required bundle files (recap)

* **`MANIFEST.json`** â€” run identity: `manifest_fingerprint`, `parameter_hash`, `git_commit_hex`, `created_utc_ns`, etc.
* **`parameter_hash_resolved.json` / `manifest_fingerprint_resolved.json`** â€” canonical derivations.
* **`rng_accounting.json`** â€” per-family event totals, draws/blocks reconciliation, **trace coverage** (one cumulative `rng_trace_log` row **after each** event append) and **audit presence**. (Layer log paths/keys and coverage rule in the Dictionary.) 
* **`s9_summary.json`** â€” PASS/FAIL, failure counts by **canonical `E_*` codes**, counts/membership source used.
* **`egress_checksums.json`** â€” per-file and composite SHA-256 for `outlet_catalogue` under `[seed,fingerprint]`. (Egress path/partitions/sort per Dictionary.) 

## B.7 Atomic publish (one-shot move)

S9 **stages** the bundle in a temp dir (e.g., `â€¦/validation/_tmp.{uuid}`), computes `_passed.flag` **inside** the staged folder, then **renames atomically** to `fingerprint={manifest_fingerprint}/`. **No partial contents** may become visible. (S0 write semantics + S9 Â§Â§4 & 11.) 

## B.8 Consumer read sequence (at a glance)

1. Locate `validation/fingerprint={manifest_fingerprint}/`.
2. Read `_passed.flag`; recompute SHA-256 over **all files listed in `index.json` (excluding `_passed.flag`)** in ASCII-lexicographic order of the `path` entries; compare to `sha256_hex`.
3. Only on success, read `outlet_catalogue/seed={seed}/fingerprint={manifest_fingerprint}/â€¦` (Dictionary explicitly repeats this consumer duty). 

---

**Status:** Appendix B is **Informative**. Shape/paths and the gate rule are governed by the Dictionary/Registry and 1A schemas cited above.   

---

# Appendix C) Worked micro-examples **(Informative)**

## C.1 â€œHappy-pathâ€ multi-site with 2 foreigns

**Lineage (one merchant):** `seed=42`, `parameter_hash=â€¦aa11`, `manifest_fingerprint=â€¦bb22`, `run_id="r1"`.

**S1 (hurdle).** One event (stochastic): `draws="1"`, `blocks=1`, `u=0.43`, `is_multi=true`. Open-interval `uâˆˆ(0,1)` holds; budget identity holds.  

**S2 (NB mixture â†’ N).** Attempts (Gammaâ†’Poisson per attempt), then one non-consuming `nb_final{n_outlets=N=7, nb_rejections=2}` (`blocks=0`, `draws="0"`).  

**S3 (order authority).** `s3_candidate_set` for merchant `m42`:

| `candidate_rank` | `country_iso` | `is_home` |
|-----------------:|:-------------:|:---------:|
|                0 |      GB       |   true    |
|                1 |      US       |   false   |
|                2 |      DE       |   false   |

Ranks are total & contiguous; **home=0**. 

**S4 (ZTP target).** Attempt 1: `poisson_component(context="ztp", k=0)` â†’ `ztp_rejection`. Attempt 2: `poisson_component(k=2)` â†’ `ztp_final{K_target=2, exhausted:false}` (non-consuming). Attempts are 1-based, counters monotone. 

**S6 (selection, Gumbel keys).** Considered = `{US, DE}`; keys written in **S3 rank order**; budgets: each `gumbel_key` has `blocks=1`, `draws="1"`. Top-K (K=2) â‡’ selected `{US, DE}`. (Tie-breaks: S3 rank, then ISO.)  

**S7 (integerisation over `{home}âˆªselected`).** Let ephemeral weights within the domain be `{GB:0.60, US:0.25, DE:0.15}`; with `N=7` â†’ floors `{4,1,1}`, remainder `d=1`. Quantised residuals at **dp=8**: `{0.20000000, 0.75000000, 0.05000000}`; bump goes to `US`. Final counts: `{GB:4, US:2, DE:1}`; non-consuming `residual_rank` emitted for each country.  

**S8 (egress & instrumentation).**
`outlet_catalogue` rows for each `(country, site_order=1..náµ¢)` with `site_id` `^[0-9]{6}$`. S8 emits three **non-consuming** `sequence_finalize` events:

* `sequence_finalize(m42, GB, site_count=4, start="000001", end="000004")`
* `sequence_finalize(m42, US, site_count=2, â€¦, end="000002")`
* `sequence_finalize(m42, DE, site_count=1, â€¦, end="000001")`  

**What S9 verifies (samples).**

* Pathâ†”embed equality on all reads; schema conformance for egress & events. 
* RNG envelopes & budgets: per-event `afterâˆ’before==blocks`; `sequence_finalize`/`residual_rank` non-consuming. One **trace** append **after each** event; final trace totals match set-sums. 
* Counts: `4+2+1 == N==7` from `nb_final`. **No cross-country order** encoded in egress; join-back to S3 gives order.  

---

## C.2 Single-country domain (A=0) â€” **valid degenerate**

**S3.** Candidate set contains **home only**: `NG (rank 0)`; **A=0**. 

**S4.** **Short-circuit:** write **one** non-consuming `ztp_final{K_target=0, attempts:0, exhausted:false [,reason:"no_admissible"]?}` (if the field exists in this schema version). No Poisson attempts written. 

**S6.** Skipped (domestic-only path). 

**S7.** Counts = `{NG:N}`; one `residual_rank` with residual `0.00000000`, rank `1`. Sum law holds. 

**S8.** Three egress rows if `N=3` with `site_order=1..3` and one `sequence_finalize(â€¦, country=NG, start="000001", end="000003")`. Label `DEG_SINGLE_COUNTRY` is **informative**. 

**S9.** PASS when all other checks pass; zero-target via **A=0** is tolerated. 

---

## C.3 Shortfall: `K_target=3` but only 2 eligible

**Setup.** S3 foreigns in rank order `{FR, DE, ES, IT}`; policy includes a cap & zero-weight handling such that only `{ES, DE}` have `w>0`. 

**S4.** `ztp_final{K_target=3}` (non-consuming). 

**S6.** Considered size `A_filtered=4`; **eligible** size `|Eligible|=2`. With `log_all_candidates=true`, four `gumbel_key` events (one per considered) are written (each `blocks=1`, `draws="1"`). Realisation law:
`K_realized = min(3, 2) = 2` â‡’ selected `{ES, DE}`.  

**S7.** Integerise over `{home}âˆª{ES,DE}` to sum to `N` from `nb_final`; `residual_rank` persisted per country. 

**S8/S9.** Egress has only `{home, ES, DE}`; S9 proves membership from events or (if used) gated `s6_membership` and checks Î£-law to `N`. Shortfall is **tolerated** (not an error). 

---

## C.4 Overflow guardrail â€” **merchant-scoped abort, non-error if handled**

**Scenario.** A single country gets `n=1,000,001` (> `999,999` max).

**S8 behaviour.** Emit **non-consuming** `site_sequence_overflow{attempted_count=1000001, max_seq=999999, overflow_by=2, severity="ERROR"}` and **write no egress rows** for the merchant.  

**S9 handling.** Records the merchant in the bundle; this condition **by itself** is a **non-error** if the overflow event exists and no egress rows were written. (Policy breachâ€”overflow without the event, or rows written anywayâ€”would be `E_OVERFLOW_POLICY_BREACH` and fail the run.) 

---

## C.5 Zero-target via policy (â€œdowngrade_domesticâ€) â€” **valid**

**S4.** Cap reached; policy=`"downgrade_domestic"` â‡’ emit **one** non-consuming `ztp_final{K_target=0, exhausted:true}`; **no** `ztp_retry_exhausted` is written under this policy. 

**S6.** Skipped (domestic-only path). **S7/S8** proceed as domestic-only; S9 treats this as **tolerated** (non-error) when all other checks pass. 

---

### What these examples teach the implementer (at a glance)

* **Order is S3 only.** Every display/order need joins `candidate_rank`; egress never encodes cross-country order. 
* **Facts chain:** `N` (S2) â†’ `K_target` (S4) â†’ membership (S6) â†’ integer counts (S7) â†’ sequences (S8). S9 re-derives each from written inputs only.    
* **Budgets & trace:** consuming vs non-consuming envelopes and â€œtrace append after each eventâ€ are universal; S9 reconciles totals from the **final** trace rows. 

---[[[MASTER-SEP-1A]]]

