Here’s the **TTS-friendly narration of the second half of S0.9**, covering the abort procedure, merchant-abort logging, validator duties, examples, and the reference abort routine — all preserved in detail but expressed for listening:

---

Section two point three. Abort procedure, deterministic.

Step one. Stop emitting any new random number events or datasets immediately.
Step two. Flush and seal the validation bundle at the path we just described, writing two files: failure dot J S O N, which is mandatory, and underscore F A I L E D dot sentinel dot J S O N, which is a duplicate of the forensic header for quick scanning. Both are written atomically, by creating them in a temporary location and renaming them into place.
Step three. Mark incomplete outputs. Delete any temporary directories. If any partial partition escaped into its target location, write a sibling file named underscore F A I L E D dot J S O N inside that partition. This file must contain the dataset identifier, the partition keys, and the reason.
Step four. Freeze the random number generator. No further draws or events are allowed. The last counter values remain as they were in the failing envelope.
Step five. Exit with a non-zero status, and the orchestrator halts all downstream states.

Section two point four. Merchant-abort log, when a state explicitly allows soft aborts.

This log is parameter-scoped. It lives under the path “prep slash merchant underscore abort underscore log slash parameter underscore hash equals … slash part star dot parquet.”

Each row has the merchant id, the state, the module, the reason, and the UTC timestamp.

This log never substitutes for a run-abort. It is only used to record permitted per-merchant fallbacks.

---

Section three. Validator responsibilities. These checks are hardened and must all pass.

One, ingress schema, corresponding to failure class F one.
Two, lineage recomputation of parameter hash and manifest fingerprint, corresponding to F two.
Three, randomness envelopes and counter conservation for every event, including per-family budgets, corresponding to F four.
Four, partition equivalence, corresponding to F five. For parameter-scoped data, the partition key is parameter hash. For logs, the keys are seed, parameter hash, and run id. For egress and validation, the key is the fingerprint, and often also the seed.
Five, numeric attestation, corresponding to F seven. Run the self-tests from state zero point eight, verify the numeric policy attest file, and reject mismatches.
Six, coverage and corridor guarantees per state, corresponding to F eight.
Seven, dictionary path checks, corresponding to F nine.
Eight, instance completeness and atomic commit checks, corresponding to F ten.

---

Section four. Where each failure is first detected.

Failure class F one, ingress schema errors, are detected first by the state zero point one loader, secondarily by the validator pass.
Failure class F two, parameters and fingerprint errors, are detected first by state zero point two hashing, secondarily by validator recomputation.
Failure class F three, features or hurdle non-finite outputs, are detected first by the evaluators in state zero point four, five, or seven, secondarily by the validator recomputation.
Failure class F four, envelope or counter errors, are detected first by the event emitters with runtime guards, secondarily by the validator envelope pass.
Failure class F five, partitioning or lineage mismatches, are detected first by the dataset writer at path and embed check, secondarily by the validator’s partition lint.
Failure class F six, schema authority breaches, are detected first by the registry or dictionary linter, secondarily by validator schema reference checks.
Failure class F seven, numeric policy violations, are detected first by the self-tests in state zero point eight, secondarily by validator re-attestation.
Failure class F eight, coverage or corridor breaches, are detected first by the invariants in states one, two, four, and others, secondarily by validator coverage checks.
Failure class F nine, dictionary or path drift, is detected first by the writer and dictionary linter, secondarily by validator path lint.
Failure class F ten, input or output atomicity failures, are detected first by the writer at commit time, secondarily by validator completeness.

---

Section five. Examples.

First example. A missing audit row, which is failure class F four a. The first random event is a hurdle Bernoulli, but the randomness audit log has no entry for that run id. The failure code is rng underscore audit underscore missing underscore before underscore first underscore draw. This causes a run-abort.

Second example. A partition mismatch, which is class F five. You write the outlet catalogue under a directory with fingerprint X, but the embedded row has fingerprint Y. Failure code partition underscore mismatch. This is a run-abort.

Third example. A non-finite hurdle, class F three b. The linear predictor eta becomes not a number due to malformed coefficients. Failure code hurdle underscore nonfinite. Run-abort.

---

Section six. Reference abort routine.

Function abort underscore run, with inputs failure class, failure code, and context.

First, stop all emitters, so no new random numbers or events are generated.
Second, build the failure payload from the failure class, the code, and the context, including lineage keys.
Third, compute the path to the validation directory using the manifest fingerprint, the seed, and the run id. Write the failure dot J S O N file atomically, and also write the underscore F A I L E D dot sentinel file containing just the header.
Fourth, mark incomplete partitions using the list of inflight outputs from the context.
Finally, exit with a non-zero code. The orchestrator must halt downstream.

---

Section seven. Determinism and idempotency guarantees.

If you run with identical inputs and environment, a failing run always produces the same failure class, the same failure code, and a bit-identical failure dot J S O N.

Re-running without changing the manifest fingerprint or the parameter hash yields the same abort artefacts.

Only the first detected failure is recorded. Later symptoms are suppressed so that the forensic record remains clean.

---

Bottom line.
State S0 point nine is the unified fail-fast contract for the whole merchant-location realism layer. It defines one vocabulary of failure classes, F one through F ten, each with explicit failure codes. It requires a uniform failure record schema. It enforces atomic, validated placement under the fingerprint, seed, and run id path. It provides a clear crosswalk from earlier error codes to the F classes. And it specifies a deterministic abort routine. With this in place, any deviation from schema, lineage, numeric policy, randomness rules, or partitioning will terminate the run in a consistent, auditable way, leaving behind a reproducible forensic record.

---

That wraps up **S0.9** in full, in TTS-friendly narrated form.
Do you want me to continue with **S0.10** next?
