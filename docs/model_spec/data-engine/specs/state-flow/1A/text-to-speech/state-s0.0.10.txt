Here’s the **TTS-friendly narration of S0.10** — expressed in a natural, spoken flow with all the technical details intact and the file names read naturally:

---

State S0 point ten. Outputs, partitions, and the validation bundle. This section is normative and fixed.

Section ten point one. Lineage keys, recap and scope of use.

Consumer note. The egress dataset, outlet catalogue, does not encode cross-country order. Consumers must join against the country set rank from state zero point one, where rank equals zero for the home country, and foreigns follow the Gumbel order.

The keys are as follows.
Parameter hash, a sixty-four character hex string, partitions parameter-scoped artefacts, as defined in state zero point two point two.
Manifest fingerprint, also a sixty-four character hex string, partitions egress and validation artefacts, as defined in state zero point two point three.
Seed, an unsigned sixty-four bit integer, is the modelling seed, and is used in RNG log partitions and in state zero point three derivations.
Run ID, a thirty-two character hex string, is for logs only. It partitions the randomness audit, trace, and event logs, as defined in state zero point two point four.

Embedding rule at the row level.
If a schema includes a parameter hash column, its value must equal the directory key.
If a schema includes a manifest fingerprint column, its value must equal the run’s manifest fingerprint. For egress or validation datasets, which are fingerprint-scoped, it must also equal the directory key fingerprint equals manifest fingerprint.
If both columns are present, both constraints must hold simultaneously.
Any mismatch triggers a run-abort under failure class F five.

---

Section ten point two. Artefact classes produced by state zero.

First, parameter-scoped model inputs and caches. These are deterministic and reusable across runs that share the same parameter hash. They include the crossborder eligibility flags dataset from state zero point six, the hurdle pi probabilities dataset from state zero point seven, which is optional and diagnostic, and optionally the hurdle design matrix, which may be transient and is not authoritative.

Second, lineage and attestation files, which are fingerprint-scoped. This is the validation bundle directory, described in section ten point five. It contains several files: MANIFEST dot json, parameter hash resolved dot json, manifest fingerprint resolved dot json, param digest log dot json lines, fingerprint artefacts dot json lines, numeric policy attest dot json, and optionally dictionary lint dot text and schema lint dot text. Finally, a passed dot flag file, which is the gate.

Third, randomness logs, which are produced from state zero point three onward, and are log-scoped. These include the randomness audit log, the randomness trace log, and each randomness event stream.

---

Section ten point three. Partitioning and paths. This is authoritative.

Naming rule. Any path segment named fingerprint equals something always carries the value of the manifest fingerprint. The column name is manifest fingerprint, but the path label is fingerprint equals that value.

Randomness logs.
The randomness audit log is written under logs slash rng slash audit slash seed equals seed, parameter hash equals the hash, run underscore id equals the run id, then audit dot json lines.
The randomness trace log is under logs slash rng slash trace slash seed equals seed, parameter hash equals hash, run underscore id equals run id, then rng underscore trace underscore log dot json lines.
Each randomness event family is written under logs slash rng slash events slash family, then seed, parameter hash, run id, and part star dot json lines.
The partitioning for all three is seed, parameter hash, and run id. The dataset dictionary remains authoritative for any extra fields.

Now parameter-scoped data, partitioned by parameter hash.

The dataset crossborder eligibility flags lives under data slash layer one slash one A slash crossborder underscore eligibility underscore flags slash parameter hash equals hash slash part star dot parquet. Schema is at schemas dot one A dot yaml, anchor prep slash crossborder underscore eligibility underscore flags. Row key is merchant id. The embedded lineage rule: parameter hash must be present and equal to the path key. Produced by fingerprint is optional and only informational, never part of equality or partitioning.

The optional dataset hurdle pi probabilities lives under data slash layer one slash one A slash hurdle underscore pi underscore probs slash parameter hash equals hash slash part star dot parquet. Schema is at schemas dot one A dot yaml, anchor model slash hurdle underscore pi underscore probs. Row key is merchant id. Same lineage rule applies.

Write semantics for both. Overwrite atomically per partition. That means stage the data into a temporary directory named underscore tmp dot UUID, then publish with a single rename system call. Partial contents must never be visible. Violations trigger failure class F ten.

Fingerprint-scoped validation bundle. The directory is validation underscore bundle one A, under data slash layer one slash one A slash validation slash fingerprint equals manifest fingerprint. Its contents are listed in section ten point five.

Log-scoped randomness data. These include the audit log, the trace log, and each event stream, with the path template logs slash rng slash stream name, then seed, parameter hash, run id, and part star dot json lines.

Physical row order rule. Within a Parquet partition, the order of rows and row groups is unspecified. Consumers must not rely on it. Equality is defined on sets of rows, not on file ordering.

Each randomness event envelope includes the seed, the parameter hash, the manifest fingerprint, the run id, the module, the substream label, the counters before and after, the blocks, the draws, the timestamp U T C, and the payload. The randomness trace log aggregates blocks across events.

---

Section ten point four. Immutability, idempotence, and retention.

First, immutability. A concrete partition directory is immutable. Re-runs with the same keys either do nothing, or they atomically replace with byte-identical content.

Second, idempotence. With identical inputs and numeric policy, outputs are bit-identical. File order inside a Parquet partition is not part of the contract.

Third, retention. Parameter-scoped data: keep the last five generations of parameter hash. Validation bundles: keep all generations of manifest fingerprint. Randomness logs: retain per compliance, for example ninety days.

---

Section ten point five. Validation bundle, its structure, hashing, and the gate.

The path is validation slash fingerprint equals manifest fingerprint. It contains the following files.

MANIFEST dot json.
Parameter hash resolved dot json.
Manifest fingerprint resolved dot json.
Param digest log dot json lines.
Fingerprint artefacts dot json lines.
Numeric policy attest dot json.
Optionally, dictionary lint dot text and schema lint dot text.
And finally, the passed dot flag file.

The manifest file contains at least these fields: version, for example one A dot validation dot v one. The manifest fingerprint. The parameter hash. The git commit hex, either forty or sixty-four characters. The artefact count, for example one hundred twenty three. The math profile identifier, such as mlr dash math one point two point zero. The compiler flags, with f m a false, flush to zero false, rounding R N E, fast math false, blas none. And created underscore U T C underscore n s, which is the timestamp in nanoseconds since the epoch.

The parameter hash resolved file contains the parameter hash and the sorted list of governed file names.
The manifest fingerprint resolved file contains the manifest fingerprint, the git commit hex, the parameter hash, and the artefact count.
The param digest log file has one json line per governed parameter file, with filename, size in bytes, sha two fifty six hex, and modification time in nanoseconds.
The fingerprint artefacts file has one json line per opened artefact, with path, sha two fifty six hex, and size in bytes.
The numeric policy attest file is the one produced by state zero point eight.

Finally, the passed dot flag file is mandatory. It contains one line, “sha two fifty six hex equals …”. The hash is computed over the raw concatenation of all the other files in the bundle, in strict ASCII lexicographic order by filename. The passed flag file itself is excluded from that hash.

Downstream consumers must verify this hash. Any mismatch is treated as invalid and triggers failure class F ten.

---

Section ten point six. Writer behavior, atomicity and lints.

Atomic publish. Write the bundle into a temporary directory under validation, named underscore tmp dot UUID. Compute the passed dot flag. Then atomically rename that directory into fingerprint equals manifest fingerprint. If the rename fails, delete the temporary directory.

Optional lints. Dictionary lint dot text, which is a diff of dictionary versus observed writer paths and schema references. Schema lint dot text, which is the results of schema validation of produced datasets. By default, both are included in the gate hash. You may exclude them only if documented, and if so, they must also be omitted consistently from the hash computation.

---

Section ten point seven. Idempotent re-runs and equivalence.

Two bundles are equivalent if the manifest dot json matches byte for byte, all other files also match byte for byte, and the passed flag hashes are equal.

---

Section ten point eight. Reference pseudocode.

Function S0 underscore ten underscore emit underscore outputs underscore and underscore bundle, with input context.

First, assert that the parameter-scoped partitions exist. The crossborder eligibility flags must be present. If hurdle pi probabilities are to be emitted, assert that partition also exists.

Second, build the bundle in a temporary directory.
Write manifest dot json with version, manifest fingerprint, parameter hash, git commit hex, artefact count, math profile identifier, compiler flags, and the created timestamp in nanoseconds.
Write parameter hash resolved dot json with the parameter hash and the sorted file names.
Write manifest fingerprint resolved dot json with manifest fingerprint, git commit hex, parameter hash, and artefact count.
Write the param digest log as json lines.
Write the fingerprint artefacts file as json lines.
Write the numeric policy attest file.

Third, compute the gate. List all files in ASCII lexicographic order, except the passed dot flag itself. Concatenate their raw bytes, compute the sha two fifty six hash, and write the passed dot flag file containing that hash.

Finally, publish the temporary directory atomically into the path data slash layer one slash one A slash validation slash fingerprint equals manifest fingerprint.

---

Section ten point nine. Validation requirements.

Partition lint. Parameter-scoped datasets must live under parameter hash directories; rows must embed the same parameter hash. Randomness logs must use seed, parameter hash, and run id. Validation bundles must live under fingerprint directories.

Bundle integrity. All required files must be present. The passed dot flag hash must match the recomputed hash.

Schema conformance. Produced datasets must validate against their JSON schema anchors.

Lineage recomputation. Parameter hash and manifest fingerprint recomputed must equal the resolved json values in the bundle.

Numeric attestation. The numeric policy attest file must indicate that all state zero point eight self-tests passed.

---

Section ten point ten. Downstream consumption rules.

For parameter-scoped readers, such as states one, two, or three: always key by parameter hash only, and ignore run id.

For egress and validation consumers. First, locate the directory fingerprint equals manifest fingerprint.
Second, verify the passed flag.
Third, optionally re-hash the fingerprint artefacts file and the parameter digest log file. Any failure means treat the run as invalid and halt according to state zero point nine.

---

Bottom line.
State S0 point ten locks state zero’s outputs into clear, non-overlapping partitions. Parameter-scoped datasets embed only the parameter hash, with optional produced by fingerprint. Randomness logs are keyed by seed, parameter hash, and run id. The validation bundle is fingerprint-scoped and protected by the passed flag. All outputs are atomic, idempotent, and continuously validated. Downstream can rely on them with confidence.

---