Here’s the **TTS-friendly narration** of the **second half of S0.6**, keeping the detail but making it smooth to listen to:

---

Determinism and contracts.

No randomness is used here. The output depends only on the merchant tuple and the parameter bundle.

Schema and partitioning rules. Rows must conform to the schema at anchor prep slash crossborder underscore eligibility underscore flags. The dataset is partitioned by parameter hash. Each row must embed the exact same parameter hash as the directory key. The field produced underscore by underscore fingerprint, if present, is informational only. It is never compared to any path key and never used in partitioning or equality checks.

---

Failure semantics, with precise aborts.

During parameter load:
Error E eligibility rule set id empty, if the rule set id is missing or empty.
Error E eligibility default invalid, if the default decision is not one of allow or deny.
Error E eligibility rule duplicate id, if a rule identifier repeats.
Error E eligibility rule bad channel, if a channel value is not CP, not CNP, and not the wildcard star.
Error E eligibility rule bad ISO, if an ISO code is not in the country set or is not uppercase ASCII.
Error E eligibility rule bad MCC, if the merchant category code is not in the MCC domain or if a range is malformed. For ranges, the format must be four-digit dash four-digit, with the first less or equal to the second.

During evaluation and persistence:
Error E eligibility missing merchant, if required fields are missing in the merchant ids table.
Error E eligibility write fail, with the path and error number, if writing a row fails.
Error E partition mismatch, if the embedded parameter hash does not match the directory key.

On any such error, abort state S0. Partial output is not acceptable.

---

Validation and continuous integration hooks.

First, schema conformance. Every row must match the schema at prep slash crossborder underscore eligibility underscore flags.
Second, coverage and uniqueness. There must be exactly one row per merchant id, enforced as primary key.
Third, determinism. Rerunning state S0 point 6 with the same inputs yields byte-identical rows, ignoring file order.
Fourth, policy lint. Report counts by decision source—deny, allow, or default—so shifts in rule sets are visible when parameters change.
Fifth, partition lint. The dataset path and the embedded parameter hash must match. Produced by fingerprint, if present, is ignored by validators.

---

Reference pseudocode, language-agnostic.

Function S0 underscore 6 underscore apply underscore eligibility underscore rules, with inputs merchants, params, parameter hash, and optionally produced by fingerprint.

Step one. Load the eligibility configuration. Extract the rule set id and assert it is non-empty, otherwise raise the empty rule set id error. Read the default decision. Store whether it equals allow. Parse, validate, and expand the rules, which checks domains, ranges, duplicates, and vocabulary.

Step two. Build two indices: one for deny rules, one for allow rules. Each index is keyed by channel and home ISO, and merchant category ranges are kept in an interval set.

Step three. Open a partitioned writer for crossborder eligibility flags, under the parameter hash partition.

Step four. For each merchant:
Form the key of merchant category code, channel symbol, and home country ISO.
Match deny rules using the index. Match allow rules likewise.

If the deny set is not empty, pick the best by minimum priority and then ASCII identifier. Set is eligible to false, and reason to that id.
Else if the allow set is not empty, pick the best. Set is eligible to true, reason to that id.
Else, set is eligible to the default decision, and reason to default allow or default deny.

Then construct a row with parameter hash, merchant id, is eligible, reason, and the rule set id. If produced by fingerprint is present, include it. Write the row.

Step five. Close the writer.

---

Complexity, concurrency, and I O.

Time complexity is proportional to the number of merchants times the logarithm of the number of rules, if indices are used. Naive matching is proportional to merchants times rules.
Space complexity is constant aside from holding the rule indices.
Parallelism is embarrassingly parallel. Determinism holds because the function depends only on the merchant tuple and the versioned rule set.

---

Bottom line.
State S0 point 6 writes a parameter-scoped, authoritative gate that determines whether each merchant can attempt cross-border expansion. It uses a stable conflict-resolution order, includes an explicit reason field, carries the versioned rule set identifier, and is completely independent of the manifest fingerprint. No randomness is involved. State 3 will consume this dataset verbatim to decide the cross-border branch.

---

That completes the **TTS-ready narration of S0.6**. Would you like me to move on to **S0.7** next, again splitting it into manageable chunks for Read Aloud?
