Here’s the **TTS-friendly narration of S0.8, part one**, with all the technical detail preserved but spoken clearly for listening:

---

State S0 point 8. Numeric policy and determinism controls. This section is normative and fixed.

Cross-reference. All samplers and transforms from state S0 point 3 must use IEEE 754 binary sixty-four floating point, with rounding mode round-to-nearest ties-to-even, fused multiply-add turned off, and no flush-to-zero or denormals-are-zero. They must also use the pinned deterministic math library profile, which is declared in the files numeric underscore policy dot J S O N and math underscore profile underscore manifest dot J S O N. Any computation that affects a branch or an ordering — such as acceptance tests, sort keys, or integerisation — must be executed in a serial, fixed-order kernel. Self-tests and attestation are described later in this section, and they are part of the validation bundle.

Purpose.
This state guarantees that numerically sensitive computations in 1A are bit-stable across machines, compilers, and different parallelisation strategies. In other words, you will get identical results no matter where or how you run the engine.

It defines five things.
First, the floating-point environment: format, rounding, and subnormals.
Second, the deterministic math profile for functions like exponential, log, log one plus x, exp minus one, square root, sine, cosine, arctangent two, power, and hyperbolic tangent.
Third, compiler and runtime flags that forbid fast math and fused multiply-add.
Fourth, reduction and sorting rules that fix evaluation order and tie-breaking.
Fifth, tolerances for validation, distinguishing internal checks from external checks.

Runtime self-tests ensure that these rules hold; if not, the run is aborted.

No randomness is consumed here.

Artefactisation. Two files are required and included in the manifest enumeration of state S0 point 2. Changing either flips the manifest fingerprint.

First, numeric underscore policy dot J S O N, which declares the environment, flags, and kernel policies.
Second, math underscore profile underscore manifest dot J S O N, which pins the vendored math library and its version and digest set.

---

Section S0 point 8.1. Floating-point environment, requirements.

Format. Use IEEE 754 binary sixty-four for all computations that can affect decisions or order. Diagnostics may downcast only when a state explicitly allows it, such as in state S0 point 7.

Rounding mode. Round to nearest with ties to even, set and verified at startup.

Fused multiply-add. Disabled on any ordering-critical path. It is permitted only in non-critical code that never influences branching or ordering.

Subnormals. Honour subnormals. Flush-to-zero and denormals-are-zero must be off.

Exceptions. Mask signals. Any not-a-number or infinity in model computations is a hard error, as specified in section S0 point 8 point 8.

Endianness. Use little-endian. Where relevant, such as hashing or random number generator counters, byte order is pinned per state.

The numeric underscore policy J S O N file has a normative minimum structure. It declares binary format as I triple E seven-fifty-four binary sixty-four. Rounding mode is R N E. F M A allowed is false. Flush to zero is false. Denormals are zero is false. Sum policy is serial Neumaier. Parallel decision kernels are disallowed. Version one point zero.

---

Section S0 point 8.2. Deterministic math profile for library functions.

The scope covers the functions exponential, log, log one plus x, exp minus one, square root, sine, cosine, arctan two, power, hyperbolic tangent, and error function if used.

Normative requirements. The selected implementations must be bit-identical across platforms. Square root must be correctly rounded according to I triple E. All the other listed functions must be deterministic to the last bit under the selected profile.

Operationalisation. Ship a vendored deterministic math layer behind a sealed application programming interface, for example mlr underscore math dot exp. Or pin an exact libm build with its content digest set. Toolchains must not substitute the system math library on decision-critical code paths. Record a math underscore profile underscore id, and include the math profile manifest J S O N file in the S0 point 2 artefact set.

An example math profile manifest J S O N looks like this.
It contains a math underscore profile underscore id, here “mlr dash math dash one dot two dot zero.”
A vendor field, here “acme deterministic lib m.”
A build identifier, such as glib c two point three eight toolchain two thousand twenty-five dash zero four dash ten.
A list of functions covered, such as exp, log, log one p, exp minus one, square root, sine, cosine, arctan two, power, tanh, and log gamma.
And an array of artefact records, for example lib m l r underscore math dot so with its sha two fifty six hex digest, and headers dot T G Z with its digest.

---

Section S0 point 8.3. Reductions, accumulations, and linear algebra.

Sums and dot products. Always use serial fixed-order accumulation with Neumaier compensation for any totals or dot products that feed into decisions or orderings. Never use parallel reductions in these cases.

Products and ratios. Multiply in binary sixty-four unless a state explicitly mandates a log-sum. Always check denominators against zero with strict guards where required.

B L A S and L A P A C K. Do not call external BLAS or LAPACK on decision-critical paths. If such calls are ever required, then pin a deterministic backend and include it in the math profile identifier.

Reference kernels are given in section S0 point 8 point 10.

---

Section S0 point 8.4. Compiler and interpreter flags, the build contract.

For C or C plus plus, example flags are:
Dash f no fast math, dash f no unsafe math optimisations.
Dash f f p contract equals off, which disables fused multiply-add contraction.
Dash f excess precision equals standard, and dash f rounding math.
Also dash f no associative math, dash f no reciprocal math, and dash f no finite math only.
On legacy x eight seven, use dash f float store if needed to avoid excess precision.

For LLVM or Clang intermediate representation. Disable fast-math flags, and use constrained floating point intrinsics with round to nearest even and masked exceptions.

For Python, NumPy, Java virtual machine, and similar. Avoid calling NumPy sum on decision-critical reductions. Instead, call the scalar kernels we supply. Pin environment variables such as M K L underscore num underscore threads equals one, and OpenBLAS underscore num underscore threads equals one. Disable auto-vectorisation where it would change summation order.

For GPUs. Do not offload decision-critical kernels, unless a deterministic math profile is pinned with fused operations disabled.

All effective flags and environment variables must be serialised into the file numeric underscore policy underscore attest dot J S O N, described later in section S0 point 8 point 9. The digest of that file is included in the manifest enumeration.

---

Section S0 point 8.5. Sorting, comparisons, and total order for floats.

Total order. For sorting and for keys, use the I triple E seven-fifty-four total order semantics. Not a number values are forbidden. Encountering a NaN is a hard error. Negative zero sorts before positive zero.

Tie-breakers. If float keys compare equal, then break ties by a deterministic secondary key. First by ISO string in ASCII order, then by merchant id.

Equality. Use exact equality only where it is guaranteed, for counters and integers.

Nearly equal. In self-tests, use an ULP-based check, meaning unit in the last place difference less than or equal to one. Do not fudge model decisions with epsilon comparisons.

Portable key mapping. Given a float, take its raw sixty-four bit pattern. If the sign bit is set, meaning negative, then take the bitwise complement. Otherwise, OR it with hexadecimal eight zero followed by fifteen zeroes. This guarantees that negative zero sorts before positive zero, and preserves numeric order everywhere else.

---

That completes **part one of S0.8**. The next part, section S0 point 8.6 onward, will cover tolerances, self-tests, and attestation.
