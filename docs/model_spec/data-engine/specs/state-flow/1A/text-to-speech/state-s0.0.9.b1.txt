Here’s the **TTS-friendly narration of S0.9** — all detail kept, but spoken in a smooth, clear flow:

---

State S0 point nine. Failure modes and abort semantics. This section is normative and fixed.

Purpose.
This state defines a single, deterministic failure contract for the entire merchant-location realism layer. That means: if there is a violation of schema, lineage, numeric policy, random number generator envelopes, or partitioning, the run halts in exactly the same way every time, and it always leaves behind an actionable forensic record.

Scope.
State zero point nine governs the whole of layer one A, from state zero through state seven. Any failure in those earlier states is captured here, classified into one of ten failure classes, labeled F one through F ten, and surfaced through a uniform failure record.

---

Definitions and severity.

There are two types of abort.
First, a run-abort, which is hard. This stops the entire run immediately; no further states execute.
Second, a merchant-abort, which is soft. That is allowed only where a later state explicitly permits it, for example in state four under the corridor policy. Soft aborts are logged separately to a merchant-abort log. They never override a required run-abort.

---

Failure catalog, F one through F ten.

Failure class F one. Ingress schema violation, that is, the merchant ids table fails its schema, such as bad types, missing required fields, a duplicate primary key, or an invalid ISO code. This is a run-abort. Example codes: ingress underscore schema underscore violation, ingress underscore p k underscore duplicate, and ingress underscore iso underscore bad.

Failure class F two. Parameter or fingerprint formation failure in state zero point two. This is also a run-abort.
Subcase F two a, parameters. This covers missing, duplicate, or unreadable governed files, and any hash race during reading. Example codes include param file missing, param file duplicate, param file unreadable, or changed during hash.
Subcase F two b, fingerprint. This covers an empty artefact set, an unreadable artefact, invalid commit bytes, or bad hex encoding. Example codes: fingerprint underscore empty underscore artifacts, artifact underscore unreadable, git underscore bytes underscore invalid, and bad underscore hex underscore encoding.

Failure class F three. Non-finite or out-of-domain features or model outputs. This is a run-abort.
Subcase F three a, from state zero point four, nonpositive GDP or bucket out of range.
Subcase F three b, from state zero point five or seven, hurdle non-finite, meaning eta or pi was not a valid number.

Failure class F four. Randomness bootstrap, envelope, or draw-accounting failures. This is a run-abort.
Subcase F four a. Randomness audit missing before the first draw.
Subcase F four b. Randomness envelope violation, meaning required fields are missing.
Subcase F four c. Randomness counter mismatch, when the after counter minus the before counter does not equal the blocks value.
Subcase F four d. Randomness budget violation, as defined in state zero point three.

Failure class F five. Partitioning or lineage mismatch in dictionary-backed data. This is a run-abort. Example codes include partition underscore mismatch, and log underscore partition underscore violation.

Failure class F six. Schema authority breach. In layer one A, only JSON schema is authoritative. Any non-authoritative reference, such as an Avro schema, causes a run-abort. Example code: non underscore authoritative underscore schema underscore ref.

Failure class F seven. Numeric policy violation, as defined in state zero point eight. That means if binary sixty-four arithmetic with round to nearest even is not enforced, or if fused multiply-add is detected, or flush to zero is enabled, or the deterministic math profile does not match, or a parallel reduction occurs on a decision-critical path. All are run-abort. Example codes include numeric underscore rounding underscore mode, f m a underscore detected, f t z underscore or d a z underscore enabled, lib m underscore profile underscore mismatch, and parallel underscore reduce underscore on underscore ordering underscore path.

Failure class F eight. Event coverage or corridor guarantees. If a required event family is missing or inconsistent, or if a corridor is breached. This is a run-abort for structural gaps, though a state may additionally log merchant-abort events if allowed. Example codes include event underscore family underscore missing, and corridor underscore breach.

Failure class F nine. Dictionary or path drift. If a dataset path or lineage semantics deviate from what the dictionary prescribes, it is a run-abort. Example code: dictionary underscore path underscore violation.

Failure class F ten. Input or output integrity and atomics. That means short writes, partial instances, or non-atomic commits. This is a run-abort. Example codes include I O underscore write underscore failure, and incomplete underscore dataset underscore instance.

---

Crosswalk between earlier state errors and S0.9 failure classes.

To preserve earlier E underscore codes, every failure record must carry both the failure class, which is one of F1 through F10, and the concrete failure code in snake case.

Examples.
An ingress schema error from state zero point one maps to class F one, with failure code ingress underscore schema underscore violation.
A missing parameter file or bad commit bytes from state zero point two map to class F two, with failure codes param file missing or git bytes invalid.
A non-finite hurdle result from state zero point seven maps to class F three, with failure code hurdle underscore nonfinite.
An authority breach from state zero point one maps to class F six, with code non authoritative schema ref.
A numeric policy error such as fused multiply-add detected maps to class F seven.
A partition mismatch, from several states, maps to class F five.
And a run ID collision exhausted from state zero point two maps to class F two, with code run I D collision exhausted.

---

Section two. Abort artefacts, paths, and atomic behaviour.

Subsection two point one. Where the failure record lives, inside the validation bundle.

On the first failure, create the directory path “data slash layer one slash 1A slash validation slash failures, fingerprint equals manifest fingerprint, then seed equals seed, then run underscore id equals run id.” Inside, write a file called failure dot J S O N, which is mandatory and single. Also write a file called underscore F A I L E D dot sentinel dot J S O N. This sentinel duplicates just the forensic header, so that quick scans are possible.

The directory is created and committed atomically: first as a temporary directory, then renamed into place. If you rerun and hit the same failure with the same lineage, the temporary directory may be overwritten, but the committed failure file remains unchanged.

Subsection two point two. The failure record schema.

The schema requires the following fields: failure class, failure code, state, module, parameter hash, manifest fingerprint, seed, run id, timestamp U T C, and detail.

Properties.
Failure class is a string and must be one of F1 through F10.
Failure code is a string in snake case.
State is a string such as S0 point three.
Module is a string such as “1A dot S6 dot gumbel.”
Dataset underscore id is optional.
Merchant id can be a string or null.
Parameter hash is a sixty-four character lowercase hex string.
Manifest fingerprint is also a sixty-four character lowercase hex string.
Seed is a non-negative integer.
Run id is a thirty-two character lowercase hex string.
Timestamp U T C is an unsigned integer, nanoseconds since the Unix epoch in UTC.
Detail is an object, with structure depending on the failure code.

Typed detail payloads include, for example:
For randomness counter mismatch, record the before and after counters, the blocks, and the draws.
For partition mismatch, record dataset identifier, path key, and embedded key.
For ingress schema violation, record the row primary key, the field name, and a message.
For artifact unreadable, record the path and error number.
For dictionary path violation, record the expected value and the observed value.
For hurdle non-finite, record merchant id, which field was invalid, either logit or pi, and the value string.

---

That finishes **part one of S0.9**. The next part will cover the abort procedure, merchant-abort logging, validator responsibilities, and the reference abort routine. Want me to continue with that second half now?
