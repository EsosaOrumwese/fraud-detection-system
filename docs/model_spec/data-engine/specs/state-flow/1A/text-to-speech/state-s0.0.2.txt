State S0 point 2. Hashes and identifiers. Parameter set, manifest fingerprint, run ID.

Purpose.
This state creates the three lineage keys that make subsegment 1A reproducible and auditable.

First, the parameter hash. This versions all parameter-scoped datasets. It changes whenever the raw bytes of any governed parameter file change.

Second, the manifest fingerprint. This versions all egress and validation outputs. It changes whenever any artefact opened by the run changes, or the code commit changes, or the parameter bundle changes.

Third, the run ID. This is only used to partition logs. It is not part of the modelling state and never influences random number generation or outputs.

No randomness is consumed in S0 point 2. These identifiers are pure functions of bytes. Only the run ID also uses time, and even then, only as a log partitioner.

---

Section S0 point 2.1. Hash primitives and encoding, normative rules.

Digest. SHA-two-fifty-six of x returns a raw thirty-two-byte digest.
Concatenation. Double pipe means byte concatenation of already-encoded fields.
Hex encodings. Hex sixty-four of thirty-two bytes produces a sixty-four character lowercase hex string, zero-left-padded, with no “zero x” prefix. Hex thirty-two of sixteen bytes produces a thirty-two character lowercase hex string, also zero-left-padded, no prefix.
Universal encoding rule. Strings are UTF-8, prefixed by a thirty-two-bit little-endian length. No normalization, no path cleanup, case-sensitive. Integers are little-endian sixty-four. Arrays or sets are sorted by the specified key, then each element is encoded and concatenated, with no delimiters other than the length prefixes.
Byte domain. Always hash the exact file bytes as opened in binary mode. Do not translate newlines or parse them.

This universal encoding rule applies everywhere in 1A where S0 point 2 says “concatenate” or “encode.”

---

Section S0 point 2.2. Parameter hash, canonical and normative.

The governed set call it script P, consists of three canonical basenames: hurdle underscore coefficients dot yaml, nb underscore dispersion underscore coefficients dot yaml, and crossborder underscore hyperparams dot yaml.

The algorithm is a tuple-hash that includes the file names.

Step one. Validate that basenames are ASCII and unique. Abort on error.
Step two. Sort the set P by basename, using ASCII bytewise lexicographic order. That yields p1 through pn, where n equals three here.
Step three. For each file p sub i:
– Compute d sub i equals SHA-two-fifty-six of the file’s raw bytes. That yields thirty-two bytes.
– Then compute t sub i equals SHA-two-fifty-six of the concatenation of the encoded name using the universal encoding rule, followed by d sub i. This yields thirty-two bytes.
Step four. Concatenate all t sub i in order, yielding C of length thirty-two times n bytes.
Step five. Compute the parameter hash bytes equals SHA-two-fifty-six of C. That yields thirty-two bytes.
Step six. The parameter hash is hex sixty-four of those bytes.

Properties. This is deterministic, resists name or byte collisions, and is future-proof if the set P grows.

Storage effect. All parameter-scoped datasets must partition by parameter underscore hash equals that value. Examples include crossborder eligibility flags, country set, ranking residual cache 1A, and the optional hurdle pi probs.

Errors that abort state S0. E underscore param underscore empty if missing. E underscore param underscore IO with name and errno. E underscore param underscore nonascii underscore name. E underscore param underscore dup underscore basename.

Audit rows. One called param underscore digest underscore log records filename, size in bytes, SHA-two-fifty-six hex, and modification time in nanoseconds for each p sub i. Another called parameter underscore hash underscore resolved records the final parameter hash and the sorted file names.

---

Section S0 point 2.3. Manifest fingerprint, for egress and validation lineage.

Purpose. A single lineage key that flips if anything material to the run changes.

Inputs are exact. The set script A consists of all artefacts actually opened during the run up to S0 point 2. This includes parameter files, ISO list, GDP map, bucket map, schema files, numeric policy, and so on.

For each artefact a with basename name sub a:
– D of a equals SHA-two-fifty-six of the file bytes. Thirty-two bytes.
– T of a equals SHA-two-fifty-six of the encoded basename, concatenated with D of a. Thirty-two bytes.

Also input is git underscore thirty-two: thirty-two raw bytes representing the repository commit id. If the version control system uses SHA-two-fifty-six, take the raw bytes as is. If it uses SHA-one, which is twenty bytes, left-pad with twelve zero bytes to make thirty-two. Never ASCII-hex; it must be raw or padded raw.

Also input is parameter underscore hash underscore bytes from section S0 point 2.2. That is thirty-two raw bytes.

Algorithm, which is a sorted tuple-hash. No XOR.

Step one. Validate that basenames in script A are ASCII and unique within the set. Abort on duplicates.
Step two. Sort script A by ASCII basename.
Step three. Build U equals the concatenation of all T of a sub i, followed by git underscore thirty-two, followed by the parameter hash bytes.
Step four. Compute manifest fingerprint bytes equals SHA-two-fifty-six of U. The manifest fingerprint is hex sixty-four of those bytes.

Properties. Any change to the bytes or name of an opened artefact, any change to the commit, or any change to the parameter bundle flips the fingerprint. There is no XOR cancellation risk.

Storage effect. All egress and validation datasets must partition by fingerprint equals that value, often alongside the seed.

Errors. E underscore artifact underscore empty. E underscore artifact underscore IO with name and errno. E underscore artifact underscore nonascii underscore name. E underscore artifact underscore dup underscore basename. E underscore git underscore bytes. E underscore param underscore hash underscore absent.

Audit rows. Manifest underscore fingerprint underscore resolved records the manifest fingerprint, the artefact count, the git commit in lowercase hex, and the parameter hash.

---

Section S0 point 2.4. Run ID, logs only, not modelling state.

Goal. Give each execution its own log partition key. Must not affect randomness or outputs.

Inputs. Manifest fingerprint bytes, which are thirty-two. Seed, an unsigned sixty-four. Start time T in nanoseconds, an unsigned sixty-four, measured in UTC.

Algorithm. Payload equals the encoding of the string “run colon 1A” with the universal encoding rule, concatenated with the manifest fingerprint bytes, then the seed encoded as little-endian sixty-four, then the start time as little-endian sixty-four. Then compute r equals SHA-two-fifty-six of the payload, take the first sixteen bytes. Run ID equals hex thirty-two of r.

Uniqueness rule. If the newly computed run ID already exists in the target log directory for the given pair of seed and parameter hash, then deterministically adjust T in nanoseconds by adding one, and recompute. Repeat until the run ID is unused. The loop must be bounded by two to the power sixteen steps. Exceeding that is a hard failure. Run ID never influences modelling outputs.

Scope and invariants. Run ID partitions only the RNG audit log, the RNG trace log, and RNG event tables, as the triple of seed, parameter hash, and run ID. Run ID never enters randomness seeding or model state. All determinism and outputs depend only on seed, parameter hash, and manifest fingerprint.

---

Partitioning contract, authoritative.

Parameter-scoped datasets partition by parameter hash.
Egress and validation datasets partition by manifest fingerprint.
RNG logs and events partition by seed, parameter hash, and run ID.

Row-embedded key columns must equal their path keys byte-for-byte.

---

Operational requirements.

Streaming digests. Always compute file digests by streaming, and hash the exact bytes.
Race guard. Stat the file size and modification time before and after hashing. If it changed, re-read or fail with error code E underscore param underscore race or E underscore artifact underscore race.
Basename semantics. Sort by basename only, never by directory. Basenames must be ASCII and unique. Abort on duplicates.
Immutability. After S0 point 2, treat parameter hash and manifest fingerprint as final for the run. Embed them in all envelopes and partitions.

---

Failure semantics.

On any error code starting with E underscore param, E underscore artifact, or E underscore git, or on a race error, abort the run as per S0. Or if run ID collision exhaustion occurs—meaning the uniqueness loop exceeded two to the power sixteen—abort the run as per state S0 point 9 point 9. On abort in S0 point 2, do not emit randomness audit or trace logs; S0 point 3 has not begun.

---

Validation and CI hooks.

Recompute. Continuous integration recomputes the parameter hash from set P and the manifest fingerprint from enumerated set A, git thirty-two, and parameter hash bytes. These must match the logged “resolved” rows.
Partition lint. The dictionary enforces the partition table described above. Randomness logs must use the triple of seed, parameter hash, and run ID.
Uniqueness. Within the pair of seed and parameter hash, run ID must be unique. This is practically guaranteed, but it guards against clock bugs.

---

Reference pseudocode, language-agnostic, with explanations.

First, the universal encoding helpers. Function enc underscore str of s: encode s into UTF-8, prefix with its length as little-endian thirty-two, then append the bytes. Function enc underscore u sixty-four of x: return x as little-endian sixty-four.

For the parameter hash. Function compute underscore parameter underscore hash with input P underscore files, a list of basenames and paths.
Step one. Assert there is at least one file, else raise E underscore param underscore empty.
Step two. Assert all basenames are ASCII and unique, else raise errors for non-ASCII or duplicate names.
Step three. Sort files by basename ASCII.
Step four. For each file, compute d equals SHA-two-fifty-six of its streamed bytes, then compute t equals SHA-two-fifty-six of the concatenation of the encoded name plus d. Append t to a list.
Step five. Concatenate all t values into C. Compute H equals SHA-two-fifty-six of C. Return the hex sixty-four lowercase string of H, plus the raw thirty-two bytes H.

For the manifest fingerprint. Function compute underscore manifest underscore fingerprint with inputs artifacts, git thirty-two, and param underscore bytes.
Step one. Assert artifacts is not empty, else error.
Step two. Assert git thirty-two has length thirty-two, else E underscore git underscore bytes.
Step three. Assert param underscore bytes length is thirty-two, else E underscore param underscore hash underscore absent.
Step four. Assert all artifact basenames are ASCII and unique.
Step five. Sort artifacts by basename.
Step six. For each artifact, compute d equals SHA-two-fifty-six of its streamed bytes, then t equals SHA-two-fifty-six of the encoded name concatenated with d. Append t to parts.
Step seven. Build U equals the concatenation of all parts, followed by git thirty-two, followed by param underscore bytes. Compute F equals SHA-two-fifty-six of U. Return the lowercase hex sixty-four string of F and the raw thirty-two bytes.

For the run ID. Function derive underscore run underscore id with inputs fingerprint bytes, seed as unsigned sixty-four, and start time in nanoseconds.
Build payload equals the encoded string “run colon 1A,” concatenated with the fingerprint bytes, the seed as little-endian sixty-four, and the start time as little-endian sixty-four. Compute r equals SHA-two-fifty-six of payload, then take the first sixteen bytes. Return hex thirty-two of r.

---

Where this shows up next.
State S0 point 3 derives the master randomness seed and counters using the manifest fingerprint bytes and the seed. Therefore S0 point 2 must complete before any randomness events are emitted.

---

Bottom line.
S0 point 2 now uses a tuple-hash that is name-aware and length-prefixed. There is no XOR. It follows the universal encoding rules and uses raw commit bytes. The partitioning contract is crystal clear. The run ID is log-only. This is ready to hand straight to an implementer.