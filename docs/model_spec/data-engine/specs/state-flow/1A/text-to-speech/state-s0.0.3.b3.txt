Here’s the TTS-friendly rendering of **S0.3.9 and S0.3.10, plus the pseudocode and closing summary**. I’ve kept the detail exact but spoken in a natural, flowing style.

---

Section S0 point 3.9. Draw accounting and logs, for auditable replay.

In addition to the per-event logs, there are two cross-cut logs.

First, the randomness audit log. This has exactly one row at the start of the run, before any randomness event. The row includes the seed, manifest fingerprint, parameter hash, run ID, the root key and counter, the code version, and the UTC timestamp. The schema is defined in the authoritative file “schemas dot layer1 dot yaml, hash slash rng slash audit.” The normative minimum fields are: timestamp UTC, seed, parameter hash, manifest fingerprint, run ID, algorithm, random key high and low, random counter high and low, and code version.

Second, the randomness trace log. This has one row per module and substream label pair. It records cumulative blocks, as unsigned sixty-four bit totals, along with the current counter before and after.

Reconciliation rule. For each module and substream label, the trace log’s blocks total must be monotone non-decreasing across emissions. The final blocks total must equal the sum of per-event blocks over all randomness events in the same combination of seed, parameter hash, and run ID. Budget checks, however, use event draws, not the trace.

There is a practical bound. The blocks total in the trace log is a sixty-four bit unsigned integer. Emitters must ensure totals fit this width. If not, they must abort with a randomness budget violation.

Per-event budget rules are enforced exactly as specified in section S0 point 3.1’s budget table.

Envelope invariants.
Philox blocks advance consistently with the lane policy. Single uniform events advance one block, discarding the high lane. Two uniform events consume both lanes of one block. The after counter is always greater than or equal to the before counter in lexicographic order. Non-consuming events keep them equal.

---

Section S0 point 3.10. Determinism and failure semantics.

These must hold.
One, order-invariant. Keyed substreams make outputs independent of execution order or sharding.
Two, open-interval uniforms. Uniform values are strictly between zero and one, per section S0 point 3.4.
Three, budget correctness. Each event satisfies its budget rules, as defined for normals in section 3.5, for Gamma in section 3.6, and for Poisson and zero-truncated Poisson in section 3.7.
Four, numeric profile. Binary64 arithmetic, no fused multiply-add, serial reductions, per section S0 point 8.

Abort the run if any of these occur.
An event’s blocks disagrees with the one hundred and twenty-eight bit counter delta implied by its envelope.
Any sampler yields a NaN or an infinity.
A non-consuming event changes counters.
Or a Gamma or Dirichlet event’s draws mismatches the recomputed exact budget from section 3.6.

---

Reference pseudocode, language-agnostic, with explanations.

First, Philox.
Define a stream structure with a sixty-four bit key and a one hundred and twenty-eight bit counter. Function philox underscore block takes such a stream, calls Philox two by sixty-four with ten rounds, returns x zero, x one, and increments the counter by one.

Uniform mapping on the open interval. Function u zero one of x maps a sixty-four bit word to a double in strictly zero to one. The formula is: u equals x plus one, times two to the minus sixty-four. If u equals one point zero, then return one minus two to the minus fifty-three. This guarantees open interval, never zero, never one.

Single uniform with lane policy. Function uniform one takes a stream, uses the low lane x zero, maps it with u zero one, and returns the value with draws equal one.

Normal Z via Box–Muller. Function normal takes a stream, draws u one and u two from x zero and x one. Compute r equals the square root of minus two times natural log of u one. Multiply Tau, which is the constant two pi pinned as a binary64 hex literal, by u two. Then return r times cosine of theta, with draws equal two.

Gamma distribution with budget discipline. Function gamma underscore m t of alpha.
If alpha is greater or equal to one, set d equals alpha minus one third, and c equals one over the square root of nine d. Initialise total draws to zero. Loop. Draw a normal, costing two uniforms. Compute v equals one plus c times z, cubed. If v less or equal to zero, reject and continue. Otherwise draw a uniform U, add one to draws. Accept if natural log U is less than or equal to half z squared plus d minus d v plus d log v. If accepted, return d times v and the total draws used. This ensures exact actual-use budgeting.
If alpha is less than one, recurse to alpha plus one to get y and its draw count. Then draw one uniform u. Return y times u to the power one over alpha, with draws equal draws from y plus one.

Poisson scaffolding, sketched. Function poisson of lambda.
If lambda is less than ten, set L equals exp of minus lambda, k equals zero, p equals one, draws equals zero. Loop: draw a uniform u, increment draws, multiply p by u. If p less or equal to L, return k and draws. Else increment k and repeat.
If lambda is greater or equal to ten, then use the PTRS attempt method, drawing u and v as two uniforms per attempt, repeating until acceptance.

---

Guarantees to downstream states.
Any module that declares a substream label and ID tuple will always receive a stable and independent substream. Outputs are order- and shard-invariant.
Samplers have pinned budgets, constant where possible, fully logged where variable.
Given the tuple of seed, parameter hash, manifest fingerprint, and run ID, plus the event envelopes, every draw is exactly replayable.

---

Summary.
State S0 point 3 fixes the following. The pseudo-random generator is Philox two by sixty-four with ten rounds. Single uniforms use the low-lane policy. Substreams are derived by the universal encoding rule. Uniforms are mapped to the open interval strictly between zero and one. Normals are generated by Box–Muller with no caching. Gamma sampling uses Marsaglia–Tsang with exact actual-use budgeting. Poisson sampling uses a fully specified inversion or PTRS split. Strict draw accounting is tied to counters. Everything is deterministic and auditable, and is ready to implement. Gumbel keys break ties by ISO code, then merchant id.