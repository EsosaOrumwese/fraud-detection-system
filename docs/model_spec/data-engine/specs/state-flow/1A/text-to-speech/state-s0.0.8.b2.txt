Here’s the **TTS-friendly narration of S0.8, part two** — all the technical details are kept intact, but expressed for listening clarity:

---

Section S0 point 8.6. Tolerances and quantisation.

Internal tolerances, used in self-tests. For sums and dot products, the unit in the last place difference must be less than or equal to one. For transcendental functions such as exponential, logarithm, sine, cosine, and so on, the results must be bit exact under the pinned math profile.

External tolerances, used when reporting or comparing persisted float thirty-two values. When you compare diagnostics that are stored as float thirty-two, to recomputed values in float sixty-four that are then downcast to float thirty-two, you require that the maximum of the absolute difference and the relative difference is less than or equal to ten to the power negative six.

Quantisation. When a state requires downcasting, such as in state S0 point seven, you must use IEEE round to nearest, ties to even. No other quantisation method is allowed, unless a state explicitly says so.

---

Section S0 point 8.7. Determinism under concurrency.

Order invariance is achieved by construction, because random number streams are keyed as specified in state S0 point three.

Numeric kernels. Any computation that feeds into a sort or a branch must run in a single-threaded scalar loop, with a fixed iteration order and Neumaier compensation.

Map-style parallelism is allowed when results are per row and are never aggregated into a decision or ordering without passing through the serial kernel.

For input and output, the order of files emitted is unspecified. Equality is defined by the set of rows, not by the file ordering. Partitions are unambiguous because of the hashes and fingerprints.

---

Section S0 point 8.8. Failure semantics, the abort codes.

Error E numeric F M A on, if fused multiply-add contraction is detected in a guarded kernel.
Error E numeric F T Z on, if flush-to-zero or denormals-are-zero is detected.
Error E numeric rounding mode, if the rounding mode is not round-to-nearest, ties to even.
Error E numeric lib m profile, if the math profile does not match the pinned one or a non-deterministic library is detected.
Error E numeric nan or infinity, with a context, if a Na N or an infinity is produced in a model computation.
Error E numeric parallel reduce, if a decision-critical reduction is executed in parallel or with a non-pinned topology.
Error E numeric total order nan, if a Na N is encountered in a total-order sort key.
Error E numeric ulp mismatch, with the function name, if recomputation differs beyond the allowed U L P budget.
Error E numeric profile artefact missing, with the artefact name, if a required numeric policy, profile, or attest file is missing.

On any of these, abort the run.

---

Section S0 point 8.9. Self-tests. These must run before state one, and after state zero point two, before any random draw.

First, rounding and flush-to-zero. Assert that the rounding mode is round to nearest, ties to even. Create a subnormal number, for example two to the power negative one thousand and seventy-five, multiply it by one, and assert that it is not flushed to zero.

Second, fused multiply-add detection. Evaluate a triple, for example a times b plus c, where the fused and non-fused results differ. Assert that the non-fused result is obtained, meaning contraction is disabled.

Third, the math profile. Run a fixed regression suite for the functions exponential, log, log one plus, exp minus one, square root, sine, cosine, arctan two, power, hyperbolic tangent, and log gamma. Compare results against the vendored expected bit patterns. Fail on any mismatch.

Fourth, Neumaier audited sum. Sum an adversarial sequence, for example the list one and one times ten to the minus sixteen, repeated N times, followed by minus one repeated N times. Assert that both the sum and the compensation match the expected values.

Fifth, total order sanity. Sort a crafted float array including negative zero, positive zero, and extreme values. Verify the ordering and tie-breakers are correct.

Attestation. The state writes a file named numeric underscore policy underscore attest dot J S O N. This file contains the numeric policy version, for example one point zero. It records the math profile identifier, such as mlr dash math dash one point two point zero. It records the platform details, such as operating system Linux, libc version glib c two point three eight, and compiler Clang eighteen. It records the compiler flags, such as fast math false, F P contract off, rounding mode R N E, flush-to-zero false, denormals-are-zero false. It records the results of the self-tests, each as pass or fail. Finally, it lists the digests of the numeric policy JSON file and the math profile manifest JSON file.

This attest file’s digest is included in the manifest enumeration of state zero point two.

---

That completes **part two of S0.8**. The next part, section S0 point 8.10, will cover the reference kernels and how they must be implemented for deterministic behaviour.
