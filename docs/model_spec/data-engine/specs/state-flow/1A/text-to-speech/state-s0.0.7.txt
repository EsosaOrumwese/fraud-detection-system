Here’s the **TTS-friendly narration of S0.7** in one continuous spoken flow, with all formulas and rules explained:

---

State S0 point 7. Hurdle pi diagnostic cache. Deterministic, optional, normative, and fixed.

Purpose.
This state materialises a read-only diagnostics table containing, for each merchant, the logistic hurdle outputs. Specifically, the merchant id, the linear predictor eta sub m, and the probability pi sub m. Eta is beta transposed times the design vector x sub m. Pi is sigma of eta, which is the logistic function, and it lies between zero and one.

This table exists so that monitoring and validation can inspect the hurdle surface without recomputing on the hot path. It is never consulted by any sampler. It is optional and lives under the parameter-scoped partition.

The dataset is called hurdle underscore pi underscore probs, with path “layer one slash 1A slash hurdle underscore pi underscore probs slash parameter underscore hash equals …”, and it follows the schema at “schemas dot 1A dot yaml, anchor model slash hurdle underscore pi underscore probs.”

In the registry, its role is “logistic hurdle pi, single versus multi, per merchant.” It depends on the hurdle design matrix and on the hurdle coefficients.

State S0 point ten lists this as an optional output of state zero. Its presence or absence has no effect on any downstream state.

Inputs, frozen by states S0 point 1 through point 5.
The design vector x sub m, which is one, followed by the MCC one-hot, the channel one-hot, and the bucket one-hot, from state 0 point 5. The column order is frozen by the fitting bundle.
The hurdle coefficients beta, a single YAML vector matching the layout of x sub m.
Lineage keys. The parameter hash, which serves as both the partition path and an embedded column. The field produced by fingerprint is optional and informational.

No randomness is consumed.

Output, schema, typing, and keys.
The output is a Parquet table with exactly one row per merchant.

The primary key is merchant id.
The partition key is parameter hash at the directory level.

The columns, as defined in the schema, are:
Parameter hash, a sixty-four character hex string that must equal the path key.
Produced by fingerprint, a sixty-four character hex string, optional and informational.
Merchant id, an id sixty-four integer per ingress schema.
Logit, a float thirty-two number, which is the narrowed eta.
Pi, a float thirty-two number, the narrowed logistic probability between zero and one.

Canonical definitions and numeric policy.
Eta sub m equals beta transposed times x sub m, using the exact frozen column order.

The logistic is evaluated with the overflow-stable branch form. If eta is greater than or equal to zero, sigma of eta equals one divided by one plus e to the minus eta. If eta is less than zero, sigma equals e to the eta divided by one plus e to the eta.

Computation uses IEEE binary sixty-four floating point. No fused multiply-add, and evaluation order is fixed as written, consistent with state S0 point 8.

At extreme values, pi may be exactly zero or one, and that is allowed. These values must be persisted as such.

For storage, both logit and pi are narrowed to float thirty-two with round to nearest, ties to even, after computing them in double precision. This narrowing is part of the contract, and it is only for storage.

Determinism and scope rules.
No randomness. Results depend only on x sub m and beta.
Diagnostics only. No production sampler or allocation routine may ever read this table.
Parameter-scoped. Changing any governed parameter file changes the parameter hash and thus the partition path; there is no implicit overwrite across partitions.
Produced by fingerprint, if present, is informational and does not affect partitioning or equality.

Failure semantics, precise aborts.
Error pi shape mismatch if the length of beta does not equal the dimension of x sub m. This is a double guard beyond state S0 point 5.
Error pi nan or infinity, if eta or pi is non-finite for a merchant.
Error pi partition, if the embedded parameter hash does not match the directory key.
Error pi write failure if persisting a row fails.

On any such failure, abort state zero. The cache must either be wholly correct or entirely absent.

Validation and continuous integration hooks.
One, schema conformance. The table must match the hurdle pi probs schema.
Two, coverage. Exactly one row per merchant id, equal to the size of the merchant set.
Three, recompute check. Rebuild the design vector from state S0 point 5 and recompute eta and pi from beta. Then assert that the stored float thirty-two values match bit for bit.
Four, partition lint. Path includes parameter hash equals the hash. The embedded parameter hash must equal the path key. No other required lineage fields.
Five, downstream isolation. Static analysis and policy checks ensure that states one through nine never read this cache.

Algorithm, exact and streaming-safe.
For each merchant m in the merchant set:
Step one, load or deterministically construct x sub m, as defined in state S0 point 5. Assert dictionary and shape alignment.
Step two, compute eta in binary sixty-four as the dot product of beta and x. Then compute pi using the branch-stable logistic.
Step three, assert both eta and pi are finite. If not, raise the nan or infinity error.
Step four, narrow deterministically to float thirty-two with round-to-nearest ties to even. Store logit as eta, pi as the probability.
Step five, emit a row with parameter hash, merchant id, logit, pi, and optionally produced by fingerprint. Persist under the hurdle pi probs dataset path keyed by parameter hash. File ordering is unspecified.

Complexity. Order of the merchant count dot products, constant space, trivially parallel.

Downstream connections.
State one recomputes eta and pi itself to draw the Bernoulli hurdle. It does not read this cache. State S0 point ten treats this artefact as optional; its presence does not affect the manifest fingerprint beyond what is already captured in the parameter hash.

Summary.
State S0 point 7 produces a parameter-scoped deterministic diagnostics cache, with no coupling to the run fingerprint. It uses consistent logistic semantics, with pi between zero and one, and allows exact zero or one in extreme cases. It narrows values to float thirty-two for storage in a deterministic way. Validation is strict. The cache is safe to generate or to skip, and it never influences stochastic behaviour downstream.

---

That’s the **TTS-ready S0.7**. Do you want to proceed to **S0.8** next, and should we chunk it the same way as before?
