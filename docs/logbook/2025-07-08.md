# Logbook
### Date: 8th July 2025
### Project: Fraud Detection System
### Issues Resolved: [SD-01](https://github.com/EsosaOrumwese/fraud-detection-system/issues/24) `in-progress`
### Reference commits: Check commits on this date (if any)

* 6:09am
  * Began working on the tests for stage 2
  * Test added and passed successfully, on to the next stage.

* 6:45pm
  * Skipped stage 3 as there was no point adding that much complexity. At the moment, my `NumPy` implementation of `sample_entities` works just fine.
    * **Catalogs are built once** (v2) and injected into every worker via a picklable initializer.
    * **Chunk loop** now reuses those in-memory catalogs in both multi- and single-proc modes.
    * **Entity sampling** stays on the battle-tested NumPy path (since Polars 1.30.0 has no weighted-sampling API), which is just as fast for your small catalogs.

* 7:27pm
  * Begin working on stage 4
  
* 9:15pm
  * replace MCC-prefix hack with merchant_country→EUR/USD mapping 
  * normalize country codes to uppercase before lookup 
  * retain mcc_code as string and emit currency_code alongside it 
  * produce hyphenated UUIDv4 strings instead of raw hex 
  * reinforce label_fraud burst logic:
    • guard against all-zero merchant risk
    • preserve ±burst_window_s clustering per wave
    • fill per-wave shortfalls immediately, then final global fill

* 9:47pm
  * Added `test_label_fraud_burst_clustering.py` which contains these two tests:
    1. **`test_label_fraud_exact_count_and_boolean`**
       * **What it checks:** After running `label_fraud` on a 200-row DataFrame at 20% fraud rate, you get exactly 40 frauds, and every label is a Python `bool`.
       * **Why it matters:** Ensures the clamp logic always hits the target count and returns the right data type.
    2. **`test_label_fraud_burst_clusters_within_window`**
       * **What it checks:** When frauds are clustered around 2-hour windows (burst\_window\_s) with a max burst size of 4, no group of consecutive frauds closer than 2 hours apart exceeds 4.
       * **Why it matters:** Verifies your “bursty” fraud behavior actually produces tightly grouped spikes of at most `burst_factor` transactions.
  * Added `tests/unit/test_catalog_skew.py` which contains one focused test:
    1. **`test_customer_zipf_top_10_percent_skew`**
       * **What it does:**
         * Calls `generate_customer_catalog(num_customers, zipf_exponent)` to produce a Polars DataFrame of `(customer_id, weight)`.
         * Verifies the catalog has exactly `num_customers` rows and that all `weight` values sum to 1.0.
         * Sorts the weights descending, takes the top 10 % (i.e. the heaviest customers), and asserts their combined weight exceeds 50 %.
       * **Why it matters:**
         * Ensures your Zipf distribution is sufficiently heavy-tailed—so that a small group of customers truly drives the majority of transactions, as expected for realistic fraud modeling.

    


