# Logbook
### Date: 27th August 2025
### Project: Fraud Detection System
### Issues Resolved: [SD-02](https://github.com/EsosaOrumwese/fraud-detection-system/issues/25) `in-progress`
### Reference commits: Check commits on this date (if any)

* 3:06am
  * S1: align envelope budget with S0; finalize B11–B15
    - Restore S0-required envelope fields `blocks` (int) and `draws` (JSON base-10 uint128).
    - State and enforce equalities: `u128(after)-u128(before) == blocks == parse_u128(draws) == trace_draws == draws_expected`.
    - Keep single-budget primitive `d_m` for math; for hurdle, `blocks = d_m ∈ {0,1}`.
    - Validator V5 updated to check `delta==blocks` and reconcile envelope/trace.
    - Error payloads: rename `draws_observed` → `trace_draws`.
    - No change to downstream semantics; no optional stream_jump in normative text.

* 3:51am
  * S1: finalize C16–C19 — logistic math and numeric policy
    * C16 (codomain/emission): Keep logistic map sigma\:R->(0,1) in math; add Emission contract for binary64 two-branch evaluation with emitted pi in \[0,1]. Define deterministic := (pi == 0.0 || pi == 1.0) using exact binary64 comparison. When deterministic, emit u\:null; otherwise require 0\<u<1.
    * C17 (precision/serialization): Pin pi (and eta if present) to JSON numbers that round-trip to binary64 (shortest round-trippable decimal, <=17 significant digits; scientific notation allowed). Enforce 0.0 <= pi <= 1.0 and annotate the payload pi field accordingly.
    * C18 (no clipping in compute/emit): Explicitly forbid clamping or clipping of eta or pi during compute or emission; move any display-only clipping to a non-normative UI note (must not alter emitted values).
    * C19 (shape and encoders, self-contained): Add “Feature vector construction (logistic, normative)”: fixed order \[intercept] + onehot(MCC) + onehot(channel) + onehot(GDP\_bucket); channel labels/order \[CP, CNP]; GDP buckets/order \[1,2,3,4,5]; MCC column order equals the order of mcc: coefficients in hurdle\_coefficients.yaml. Enforce |x| = |beta| = 1 + C\_mcc + 2 + 5 and one-hot sum == 1. Update V4 to reference this subsection and re-assert bounds.

* 6:29am
  * Currently on issue set D out of A to M. Plan to finish all today

* 6:02pm
  * Still working on ironing out errors in `state.1A.s1.expanded.md` and aligning it to the flow from state-0
    * Decided to change my approach of fixing the whole doc issue by issue (I have 66 issues!)
    * Instead, I have now outlined all the issues, gotten their proposed resolutions and will pass the doc section by section for an error free rewrite.

* 6:39pm
  * Rewrote S1.1 of state.1A.s1.expanded.md with S0-anchored contracts; fix RNG envelope & inputs
    * Rewrote **S1.1 — Inputs, Preconditions, and Write Targets** to remove ambiguity
      and align strictly with **State-0** by **explicitly citing S0-owned rules**
      (timestamp policy, keyed-substream PRNG, id64 mapping, numeric profile).
    * Clarified **design vector**: column order frozen by S0.5; S1 no longer derives
      MCC order from YAML map iteration; reiterated shape invariant |x| = 1+Cmcc+2+5.
    * Clarified **β loading**: atomic load; enforced exact shape alignment to x.
    * Locked **order-invariant RNG model**: **no cross-label counter chaining**;
      each label derives its base counter solely via S0’s keyed-substream mapping.
    * Made the **envelope contract** explicit and complete:
      * Required fields: `ts_utc` (per S0), `module`/`substream_label` (registry),
        `seed`, `parameter_hash`, `manifest_fingerprint`, `run_id`,
        `rng_counter_before_hi/lo`, `rng_counter_after_hi/lo`, `blocks` (int),
        `draws` (u128 as decimal string).
      * Budget law: `after − before = parse_u128(draws) = blocks` (unit = one 64-bit uniform);
        for hurdle specifically: `blocks ∈ {0,1}`, `draws ∈ {"0","1"}`.
      * Clarified `(hi,lo)` semantics; JSON key order is non-semantic.
    * Set **preconditions** minimal and S0-consistent: shape/alignment, numeric
      environment, and presence of the **rng\_audit\_log** before first emission.
    * Bound **event stream target**: dataset id via registry; partitions are
      `{seed, parameter_hash, run_id, module, substream_label}` (no fingerprint in path);
      schema via layer anchor for `rng/events/hurdle_bernoulli`.
    * Defined **uniqueness & completeness**: exactly one hurdle event per merchant
      in a run; count equals S0 merchant universe for the partition.
    * Clarified **trace model**: cumulative per `(module, substream_label, merchant)`,
      totals equal sum of event budgets (no per-event echo).
    * Stated **forward contracts** only (logistic with fixed saturation threshold,
      RNG usage, payload discipline) and deferred downstream math/CI to their docs.

* 7:04pm
  * Finalize S1.2 probability map; pin saturation T; align math & RNG contracts with S0
    * Rewrote **S1.2 — Probability map (η → π)** in two chunks for clarity and rigor.
    * **Pinned math**:
      * Fixed-order **Neumaier** dot product for η over frozen columns.
      * Overflow-safe **two-branch logistic** with explicit binary64 **saturation threshold T=37.5** ⇒ π ∈ {0.0,1.0} only via this rule.
      * Defined **deterministic** ⇔ (π==0.0 ∨ π==1.0) (binary64 equality).
    * **RNG coupling**:
      * Handoff to S1.3 now states **uniform budget** precisely: `draws=1` iff 0<π<1, else `draws=0`.
      * Kept substreaming/order-invariance as S0-owned; S1.2 references, does not redefine.
    * **I/O rules**:
      * `pi` must **round-trip** to identical binary64 (shortest or 17-digit acceptable); consumers parse as binary64.
      * Clarified `eta` is **diagnostic-only** (non-authoritative), not a normative payload field.
    * **Validator hooks** (single source):
      * Recompute η, π bit-exact under S0 numeric profile.
      * Assert determinism equivalences and budget prediction; reconcile with hurdle trace totals.
    * **Failure semantics (operational only)**:
      * Abort on non-finite η/π or π∉\[0,1]; shape/order mismatches are S1.1 preconditions.
    * **De-scoped** CI/monitoring and downstream algorithm restatements (NB/ZTP/Dirichlet) per scope rules.
    * **Process note**: Verified against **State-0** by opening the S0 spec directly (no memory reliance).
