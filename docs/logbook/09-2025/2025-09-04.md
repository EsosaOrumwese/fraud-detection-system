# Logbook
### Date: 4th September 2025
### Project: Fraud Detection System
### Issues Resolved: [SD-02](https://github.com/EsosaOrumwese/fraud-detection-system/issues/25) `in-progress`
### Reference commits: Check commits on this date (if any)


* 6:30am
    * state-0/L3: finalize read-only validator; fix glob & paths; align failure taxonomy; pin lineage inputs; freeze shim surface
      * WHY
        - Prevent implementer drift and contradictions in the State-0 validator (L3) by locking scope to read-only byte checks, aligning paths and taxonomy with L0/L1/L2 + the expanded spec, and removing any optional success writes that would invalidate the gate hash. 
      * WHAT CHANGED (spec-true fixes)
        1) Read-only scope (no bundle mutations)
           - Removed all mentions and code paths that write `validator_passed.json` inside the fingerprint bundle.
           - Non-goals + DoD now state success is by process status (or external log), and L3 must never add or modify files in the bundle nor rewrite `_passed.flag`. 
        2) RNG event absence check: correct path shape
           - V3 now globs under `logs/rng/events/*/seed=…/parameter_hash=…/run_id=…/part-*.jsonl`, i.e., family-aware, so the “no events in S0” assertion actually inspects the right directories. 
        3) Failure record placement aligned with L0
           - Clarified DoD and routines: exactly one failure record lives under `{fingerprint, seed, run_id}` (directory path), with `{parameter_hash}` remaining in the JSON payload for lineage. 
        4) Failure taxonomy: RNG audit mismatches → F4a
           - Key/counter/algorithm mismatches and any S0 event presence now map to **F4a** (RNG audit/envelope), not F3. DoD table reflects the mapping. 
        5) Lineage inputs: pin git commit handling
           - V1 sources `git_commit_hex` from `manifest_fingerprint_resolved.json` and **decodes to raw 32 bytes** before recomputing the fingerprint (never hashes hex text). Inputs & Appendix reflect this; removed mention of a separate “raw 32-byte context file.” 
        6) Host shim surface: exact, read-only, and used
           - Declared only the shims L3 actually calls (read-only): `read_json`, `read_bytes`, `list_files`, `glob`, `list_parameter_files` (+ optional `read_lines`, and `exists` where applicable). Tightened wording in DoD to match the list. 
           - Kept Parquet/JSONL row iteration as a **local** adapter over `read_bytes`/`read_lines` (no new shims).
        7) Gate hash & atomic publish (verify-only)
           - V5 replays `_passed.flag` exactly (ASCII-sorted filenames; concat raw bytes of all files except `_passed.flag`; SHA-256), and checks the bundle file set against `MANIFEST.json`. L3 does not re-gate or mutate the bundle. 
        8) Partition & schema authority checks
           - V4 verifies parameter-scoped datasets embed `parameter_hash` equal to the path key; schema refs must resolve to registered **JSON-Schema** anchors (no Avro in 1A), matching L0/L1/L2 policy. 

* 6:31pm
  * Currently trying to move all the general functions/helpers/primitives defined in places apart from L0 to L0 and ensure reference is made to the doc instead. This is to avoid conflict of func definitions

* 10:00pm
  * feat(s0/l0-l3): centralize cross-state helpers in L0; make L1/L3 delegate only (no drift)
    * Why:
      - Prevent implementer drift by putting *all* reusable helpers in L0 and making state docs (L1/L3) consume them rather than re-define variants.
    * What:
      * L1 — S0 kernels
        * Add “Helper policy” header: if it isn’t strictly state-local glue, do not define it in L1; call L0 instead.&#x20;
        * Refactor RNG event wrappers to forward to L0 (library use for later states; S0 still audit-only):
          `event_normal_box_muller`, `event_poisson_component`, `event_gumbel_key`, `event_gamma_component`, `event_ztp_rejection`, `event_ztp_retry_exhausted`, plus `reconcile_trace_vs_events` delegate stubs.&#x20;
      * L3 — S0 validator
        * Add “Validator uses L0 helpers” header (read-only).&#x20;
        * Remove local bytes/hex/JSON helpers and use L0 equivalents: `bytes_to_ascii`, `split_bytes_on_lf`, `parse_json_strict`, `hex64_to_raw32`, `enc_u64` (LE64), `_passed.flag` hash extractor, and ASCII ordering via `sort_ascii`/`list_ascii_sorted`.&#x20;
      * L0 — helper capsule expansions
        * House canonical RNG event wrappers & trace glue used by higher states (Box–Muller, Gumbel key, Gamma, Poisson, ZTP markers).&#x20;
        * Provide the control-file parsing + bytes/hex primitives consumed by L3 (strict JSON/UTF-8, hex↔bytes, ASCII sort, gate flag read).&#x20;
      * L2 — orchestrator
        * Keep state-specific shims/orchestration only; reiterate “no helpers here” policy in header.&#x20;
    - Outcome
      * Single source of truth for helpers in L0; L1/L3 contain only state logic and adapters.
      * No behavior change to S0: RNG remains audit-only, bundle/gate semantics unchanged.
      * Cross-doc consistency verified: L1/L3 import/use L0 helpers exclusively; no local duplicates remain (see citations above).