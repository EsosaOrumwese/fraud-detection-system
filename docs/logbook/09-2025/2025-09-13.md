# Logbook
### Date: 13th September 2025
### Project: Fraud Detection System
### Issues Resolved: [SD-02](https://github.com/EsosaOrumwese/fraud-detection-system/issues/25) `in-progress`
### Reference commits: Check commits on this date (if any)


* 5:24am
  * Solving critical batch-2 issues
  * Resolved batch 2 critical issues in the state-2 expanded doc

* 6:29am
  * feat(1A/S2): close Critical #1–#16 — RNG/accounting, lanes, u01, envelope, nb\_final, emit-after-guard
    * **What changed (critical fixes, fully applied to `state.1A.s2.expanded`):**
      * **Per-event law (#1):** bind counters to **blocks** and keep **draws** independent (uniforms used). Rewrote S2.6 per-event rule; removed any “`draws = after−before`” guidance; aligned S2.3 comments and S2.5 example language.
      * **Trace totals (#2):** trace now holds **cumulative** `blocks_total = Σ blocks_event` and `draws_total = Σ draws_event`; counters certify **blocks only**.
      * **Pseudocode derivation (#3):** `draws` comes from sampler budgets, **never** from counter deltas; updated reference notes.
      * **Lane policy (#4):** single-uniform uses **x0** and **discards x1**; Box–Muller consumes **both lanes from one block**; **no caching** across events. Ref impl updated to block-indexed helpers; removed high-lane cache.
      * **u01 mapping & clamp (#5, #6):** use the **binary64 hex literal** `0x1.0000000000000p-64`; added strict-open-interval clamp (`u==1.0 → 0x1.fffffffffffffp-1`) in text and helper.
      * **Numeric policy (#7):** removed permissive “fused ops” wording; require **S0.8** (binary64, RNE, **FMA-OFF**, no FTZ/DAZ, fixed-order **Neumaier**).
      * **Envelope completeness (#8):** envelope inventories now explicitly include **`blocks (uint64)`** and **`draws ("uint128-dec")`**; envelope/payload split preserved.
      * **`nb_final` example hygiene (#9–#15):** fixed to be schema-true:
        `ts_utc` RFC-3339 with **6 dp**; `seed` **uint64** (int); `run_id` **hex32**; `rng_counter_*` **uint64** numbers; `parameter_hash` & `manifest_fingerprint` **hex64**; **non-consuming** envelope → `"blocks": 0`, `"draws": "0"`.
      * **Abort semantics (#16):** **emit after guard** — draw Γ, compute/guard λ, **no events on abort**; only then emit `gamma_component`, followed by `poisson_component`; `nb_final` remains non-consuming.
    * **Assurance:**
      * No schema/partition/path changes; no S0/S1 drift; examples are schema-true.
      * Grep/coverage checks: no “one increment ⇒ one uniform”, no `(x+1)/(2^64+1)`, no “draws = after−before”; lane caching removed; clamp present.
    * **What remains (Major/High, tracked next):**
      * Replace “**interleave by time/counter**” with **counter-interval pairing only** (strict lexicographic order on `rng_counter_before` and ordering constraint); confirm `index=0` semantics for NB Gamma are documented as a **scalar placeholder** (if not already).

* 9:30am
  * feat(1A/S2): close Major/High set — counter-interval pairing; registry-closed module literals; `index=0` semantics
    * What changed (Major/High):
      * Pairing rule (validator + KATs + notes): Remove all time/file-order phrasing; pairing is now solely by counter intervals with the ordering constraint
        `u128(before)_Γ[t] < u128(after)_Γ[t] ≤ u128(before)_Π[t] < u128(after)_Π[t]`.
        Added explicit “No reliance on time/file order.” across validator replay step, reference algorithm, KATs, and S2.4 notes.&#x20;
      * Component metadata alignment: Pin `module` literals to registry-closed values (data dictionary) everywhere S2 mentions `module` (normative text, pseudocode envelopes, examples, and retention/lineage recap):
        `gamma_component` → `"1A.nb_and_dirichlet_sampler"`,
        `poisson_component` → `"1A.nb_poisson_component"`,
        `nb_final` → `"1A.nb_sampler"`.
        Removed any `1A.nb_*` placeholders and single-literal assumptions; added a one-line authority pointer to the dictionary.&#x20;
      * Index semantics (NB Gamma): Added binding one-liner: for `gamma_component (context="nb")` the Gamma is scalar per attempt; `index` is fixed `0` (scalar placeholder), not a selector.&#x20;
    * Why this matters:
      * Eliminates any chance of divergent attempt pairing under concurrency (order-invariant by counters).
      * Keeps S2’s producer metadata in perfect lockstep with the governed dictionary (no drift between spec and lineage).
      * Removes implementer guesswork around `index`.
    * Assurance (no regressions):
      * Critical set (#1–#16) remains intact: per-event law (blocks vs draws), cumulative trace totals, lane policy (BM = 2-from-1, no caching), u01 hex-literal + clamp, emit-after-guard, envelope completeness, and non-consuming `nb_final` example.
      * No new Minor/Low/Polish items introduced by these edits.

* 9:42am
  * All minor errors have already been resolved in recent state-2 expanded file.

* 10:55am
  * feat(docs/1A/S2): finalize State-2 expanded spec — close Critical (#1–#16), Major/High, Minor; apply final Polish & Nits
    * Why
      - Turn S2 into an implementer-proof, ambiguity-free, mathematically explicit spec that replays bit-for-bit under S0/S1; eliminate all remaining drift and readability foot-guns.
    * What changed
      * Critical (all #1–#16 closed)
        * Per-event law: bind counters to `blocks = u128(after) − u128(before)`; keep `draws` = uniforms used (independent).
        * Trace totals: cumulative `blocks_total = Σ blocks_event`, `draws_total = Σ draws_event`; counters certify blocks only.
        * Pseudocode guidance: `draws` comes from sampler budgets (never derived from counters).
        * Lane policy: single-uniform uses x0 and discards x1; Box–Muller uses both lanes from one block; no caching.
        * u01 mapping & clamp: hex-float `0x1.0000000000000p-64`; strict (0,1) via `if u == 1.0: u := 0x1.fffffffffffffp-1`.
        * Numeric policy: binary64, RNE, FMA-OFF, no FTZ/DAZ, fixed-order Neumaier; deterministic libm.
        * Envelope completeness: explicit `blocks (uint64)` and `draws ("uint128-dec")` on every RNG event.
        * `nb_final` example (non-consuming): `before==after`, `"blocks": 0`, `"draws": "0"`, RFC-3339 `ts_utc` (6 dp), `seed` uint64, `run_id` hex32, counters as uint64, digests as hex64.
        * Emit-after-guard: draw Γ → compute/guard λ → no events on abort; only then emit `gamma_component` (then `poisson_component`).
      * Major/High (all closed)
        * Attempt pairing: solely by counter intervals with the ordering constraint; no reliance on time/file order (validator, reference algorithm, KATs, notes aligned).
        * Component metadata: `module` literals pinned to registry-closed values (dictionary):
          `gamma_component` → `"1A.nb_and_dirichlet_sampler"`, `poisson_component` → `"1A.nb_poisson_component"`, `nb_final` → `"1A.nb_sampler"`;
          Index semantics: for NB Gamma, `index` is fixed `0` (scalar placeholder), not a selector.
      * Minor (closed)
        * Envelope vs payload grouping: `merchant_id` appears only in payload; envelope lists are lineage/counters/stream keys only.
      * Polish (QoL, non-semantic)
        * Added a one-screen operation capsule at the S2 on-ramp.
        * Inserted a tiny labels/producers legend; echoed in retention/lineage.
        * Added note: examples use shortest binary64 round-trippable decimals; consumers parse as binary64.
        * Standardized JSON example ordering to envelope → payload (flat record unchanged).
        * Cross-referenced S0.3.3 for keyed substream mapping (no local restatement).
      * Nits (non-semantic)
        * Removed stale clamp comment; eliminated duplicate `struct Substream`; normalized quotes; trimmed trailing whitespace.
    * Assurance
      * Aligned with S0 (RNG constitution, numeric policy, mapping/clamp) and S1 (envelope/trace discipline).
      * Grep guard: no `(x+1)/(2^64+1)`, no “draws = (after − before)”, no “one increment ⇒ one uniform”, no time/file-order pairing language, no `1A.nb_*` placeholders.
      * Examples are schema-true; envelope/payload grouping consistent.
    * Docs touched
      * `state.1A.s2.expanded` (latest snapshot) — normative text, reference pseudocode notes, JSON examples, validator/KAT sections.
    * Result
      * S2 is unambiguous, mathematically specific, and implementer-ready; reproducible under S0/S1; zero open Critical/Major/Minor items; final Polish applied.