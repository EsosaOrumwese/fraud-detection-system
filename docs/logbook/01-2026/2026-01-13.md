# Logbook
### Date: 13th January 2026
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)

* 12:03am
   - Completed full read of 1B expanded specs (S0-S9) and reviewed 1B contract authorities (dataset dictionary, artefact registry, schemas) plus the 1A validation bundle schema anchor.
   - Logged a detailed S0 pre-implementation plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`, including gate verification flow, sealed_inputs_1B digest strategy options, outlet_catalogue path-embed checks, atomic publish steps, and performance logging requirements.
   - Flagged contract gaps to resolve before coding: world_countries license mismatch (dictionary vs spec), tz_world_2025a consumed_by mismatch vs S0 sealing requirement, and partition key naming consistency (fingerprint vs manifest_fingerprint).

* 12:25am
   - Resolved S0 contract gaps with user decisions: `world_countries` license authority set to Public-Domain (dictionary wins), `tz_world_2025a` consumed_by updated to include 1B, receipt partition key uses `manifest_fingerprint`, outlet_catalogue digest reuses 1A bundle `egress_checksums.json` when identity matches, and sealed_inputs_1B includes `validation_bundle_1A` + `_passed.flag`.
   - Logged the detailed rationale and required pre-code updates in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 12:28am
   - Updated `docs/model_spec/data-engine/layer-1/specs/state-flow/1B/state.1B.s1.expanded.md` to align `world_countries` licence text with the Dictionary (Public-Domain).
   - Updated `docs/model_spec/data-engine/layer-1/specs/contracts/1B/dataset_dictionary.layer1.1B.yaml` so `tz_world_2025a` is marked `consumed_by: [1B]` and described as sealed by 1B.S0.
   - Logged the pre-code alignment actions in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 12:34am
   - Documented the concrete S0 implementation decisions (run identity source, gate hash flow, outlet_catalogue row-group checks, digest strategy per asset, schema validation, and atomic publish plan) in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md` before coding.

* 12:48am
   - Added Segment 1B S0 gate runner (`packages/engine/src/engine/layers/l1/seg_1B/s0_gate/runner.py`), CLI (`packages/engine/src/engine/cli/s0_gate_1b.py`), and module scaffolding.
   - Wired Makefile support for `segment1b-s0` and associated CLI args.
   - Logged the implementation actions in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 12:49am
   - First `make segment1b-s0` failed due to incorrect ingress schema pack name (`schemas.ingress.yaml` not found).
   - Fixed S0 runner to load `schemas.ingress.layer1.yaml` via `load_schema_pack(..., \"ingress.layer1\")`.
   - Logged the correction and prepared to re-run S0.

* 12:51am
   - `make segment1b-s0` failed at receipt validation because the generic JSON schema adapter cannot handle array-of-object columns.
   - Added a local receipt row-schema converter in `seg_1B/s0_gate/runner.py` and validated with `Draft202012Validator`.
   - Re-ran `make segment1b-s0` successfully; outputs published for `s0_gate_receipt_1B` and `sealed_inputs_1B`.

* 12:52am
   - Noted a spec gap: S0 requires licence coverage checks against `license_map`, but the 1B Dictionary has no `license_map` entry, so the check cannot be contract-resolved.
   - Logged the gap and the decision needed (add dictionary entry vs defer) in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 12:57am
   - Recorded the user-approved plan to add `license_map` to the 1B Dictionary and wire S0 to include its hash in `sealed_inputs_1B`.
   - Logged the planned dictionary + runner changes in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md` before editing code.

* 12:58am
   - Added `license_map` to `docs/model_spec/data-engine/layer-1/specs/contracts/1B/dataset_dictionary.layer1.1B.yaml` with schema_ref `schemas.layer1.yaml#/governance/license_map`.
   - Updated the 1B S0 runner to load `schemas.layer1.yaml`, accept layer1 schema refs, and seal `license_map` with a file hash.
   - Logged the completed wiring in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 12:59am
   - Re-running `make segment1b-s0` produced a logging format error in the contracts summary line and hit the immutable-partition guard for `sealed_inputs_1B` (previous output exists without license_map).
   - Logged the issues and planned fixes in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 1:00am
   - Fixed the S0 contracts-summary log format string to include the additional schema path after adding `schemas.layer1.yaml`.
   - Logged the fix in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 1:10am
   - Investigated `make segment1a` preflight failure: `tools/preflight_seg1a_contracts.py` was hard-coded to the legacy `contracts/` layout while dev runs use `docs/model_spec/...`.
   - Updated preflight to respect `ENGINE_CONTRACTS_LAYOUT` (default `model_spec`) and to fall back to the alternate layout so switching to production won't break the check.

* 1:15am
   - Added `license_map` to the 1A dataset dictionary so S5/governance checks have a contract-backed input in dev runs.
   - Relaxed the 1A preflight dataset-id scan to ignore non-dataset IDs that are used only for policy/attestation/error reporting (`hurdle_coefficients`, `nb_dispersion_coefficients`, `numeric_policy_attest`, `parameter_hash`, `manifest_fingerprint`, `policy.s3.integerisation.yaml`, `s7_integerisation_policy`).

* 1:24am
   - Reviewed the 1B S1 expanded spec plus the 1B dictionary/registry/schema anchors for `tile_index`, `tile_bounds`, and `s1_run_report`.
   - Logged a detailed S1 pre-implementation plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`, including predicate handling, antimeridian strategy, determinism receipt, PAT counters, and failure-event requirements.

* 1:33am
   - Recorded the confirmed S1 decisions (CLI predicate flag with default `center`, 0..360 antimeridian handling, per-country summaries as log JSON-lines, determinism receipt only for `tile_index`) in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 1:55am
   - Audited the draft S1 runner and documented pre-run compliance gaps: incorrect `s1_run_report` path handling, incomplete antimeridian handling for `"center"`, missing PAT counters (`chunk_size`, `io_baseline_vectors_bps`), missing bounds/area/duplicate validations, and lossy world_countries geometry mapping.
   - Logged a detailed fix plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md` covering antimeridian splitting, PAT baseline measurement, report path corrections, and explicit `S1_ERROR` failures.

* 2:05am
   - Implemented the S1 runner updates: antimeridian split processing, world_countries geometry union, bounds/area/duplicate validation with `S1_ERROR` propagation, and complete PAT counters (`chunk_size=0`, vector baseline bps).
   - Fixed `s1_run_report` publishing to treat the dictionary path as a file and added raster/vector baseline logs.
   - Added the S1 CLI (`engine.cli.s1_tile_index`) and Makefile wiring (`segment1b-s1`, `SEG1B_S1_*` args).
   - Logged the implementation details in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 2:14am
   - Ran `python -m py_compile` on `packages/engine/src/engine/layers/l1/seg_1B/s1_tile_index/runner.py` and `packages/engine/src/engine/cli/s1_tile_index.py` to sanity-check syntax (no errors).

* 2:48am
   - Investigated `world_countries` coverage mismatch: NE shapefile has 258 rows but 22 entries use ISO_A2/ISO_A3 = -99 (including France, Norway), and the current build path drops those plus ISO2s absent from NE (BQ, GF, etc.), yielding only 236 rows.
   - Logged a detailed rebuild plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`: read the shapefile zip directly, map ISO2 via ISO_A2 → ISO_A3 → ADM0_A3, add synthetic geometries for ISO2s absent from NE (including AN/CS), and regenerate the 2024 `world_countries.parquet` plus QA/provenance.

* 2:53am
   - Updated `scripts/build_world_countries.py` to accept zip sources, add ISO_A3/ADM0_A3 fallback mapping, and synthesize geometries for AN/CS in addition to existing missing ISO2s.
   - Rebuilt `reference/spatial/world_countries/2024/world_countries.parquet` from the NE zip; coverage now matches ISO (251/251).
   - Updated QA/manifest/SHA256SUMS outputs and refreshed `world_countries.provenance.json` with new counts and output hash.
   - Logged the rebuild actions and required S0 reseal in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 3:05am
   - Logged the PROJ/GDAL mismatch diagnosis for S1: `PROJ_LIB` points at PostGIS `proj.db` with an incompatible layout version, causing raster CRS resolution to fail.
   - Captured the planned runtime fix in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`: detect bad `proj.db` and override to the pyproj data dir before opening the raster.

* 3:06am
   - Implemented the S1 runtime PROJ fix: detect `proj.db` layout version < 4 (or missing) and override `PROJ_LIB`/`PROJ_DATA` to the pyproj data dir before rasterio opens the raster.
   - Recompiled `packages/engine/src/engine/layers/l1/seg_1B/s1_tile_index/runner.py` to confirm syntax.

* 3:09am
   - Logged the plan to create a fresh run folder with a new `run_receipt.json` (clone latest receipt, update run_id + created_utc) so 1B.S0 can reseal updated world_countries without immutable partition conflicts.

* 3:11am
   - Created new run folder `runs/local_full_run-5/446496814c08456c874beb9638fc6cfb/` with a cloned `run_receipt.json` updated for the new run_id and current UTC timestamp.

* 3:16am
   - Logged the S1 failure analysis for raster dtype handling: `dataset.dtypes[0]` is a string, so `.itemsize` fails. Planned fix is `np.dtype(...).itemsize` and rerun S1.

* 3:17am
   - Implemented the dtype conversion fix in the S1 runner (`np.dtype(dataset.dtypes[0]).itemsize`) and prepared to rerun S1.

* 3:18am
   - Attempted `make segment1b-s1` with the fresh run_id, but the run_receipt.json was missing at the expected path; logged the plan to recreate a new run folder and rerun S0/S1.

* 3:19am
   - Created new run folder `runs/local_full_run-5/d12d2f6268a74b2988524e98d82315f9/` with an updated run_receipt.json cloned from the latest receipt.

* 3:22am
   - Logged the S0 gate dependency issue for the fresh run_id: the new run root lacks 1A outputs (`validation_bundle_1A`, `_passed.flag`, `outlet_catalogue`, `s3_candidate_set`), causing `E_BUNDLE_MISSING`.
   - Recorded the pre-action plan to stage the required 1A outputs from the most recent compatible run (matching manifest_fingerprint/parameter_hash/seed) into the new run root before rerunning S0.

* 3:23am
   - Verified `run_receipt.json` for source run `559b467dedd77fa576b488f92583d513` matches the new run_id on `manifest_fingerprint`, `parameter_hash`, and `seed`.
   - Copied `data/layer1/1A/validation`, `outlet_catalogue`, and `s3_candidate_set` from the source run into `runs/local_full_run-5/d12d2f6268a74b2988524e98d82315f9/` to satisfy S0 gate dependencies.

* 3:24am
   - Ran `make segment1b-s0 RUN_ID=d12d2f6268a74b2988524e98d82315f9` and confirmed S0 gate PASS, outlet_catalogue parity checks, and sealed_inputs_1B + s0_gate_receipt_1B publication for the new run_id.

* 3:25am
   - Ran `make segment1b-s1 RUN_ID=d12d2f6268a74b2988524e98d82315f9` and hit a Shapely `TopologyException` during antimeridian splitting.
   - Validity scan of `world_countries.parquet` shows one invalid geometry (`country_iso=EG`), so S1 must emit `E001_GEO_INVALID` unless the reference dataset is repaired.
   - Logged the plan to repair invalid geometries during the world_countries build, add explicit `E001_GEO_INVALID` enforcement in S1, then reseal S0 and rerun S1.

* 3:27am
   - Updated `scripts/build_world_countries.py` to detect invalid geometries and repair them with `shapely.make_valid`, and to emit invalid-geometry QA fields.
   - Rebuilt `reference/spatial/world_countries/2024/world_countries.parquet` from the NE zip, updating manifest/QA/SHA256SUMS outputs; invalid geometries are now repaired (EG).
   - Refreshed `reference/spatial/world_countries/2024/world_countries.provenance.json` with the new output hash and repair note.

* 3:28am
   - Added explicit `E001_GEO_INVALID` enforcement in `seg_1B/s1_tile_index/runner.py` (invalid geometry check + GEOSException guard during antimeridian split).

* 3:29am
   - Generated a new run_id `869381446fd74b49bd7f7a4735ab873f` after rebuilding world_countries so S0 can reseal updated hashes without immutable partition conflicts.
   - Cloned the latest run_receipt.json into the new run folder and staged the required 1A outputs (`validation`, `outlet_catalogue`, `s3_candidate_set`) into the new run root.

* 3:30am
   - Ran `make segment1b-s0 RUN_ID=869381446fd74b49bd7f7a4735ab873f` and confirmed S0 gate PASS plus publication of `sealed_inputs_1B` and `s0_gate_receipt_1B` for the new run_id.

* 3:31am
   - Re-ran `make segment1b-s1 RUN_ID=869381446fd74b49bd7f7a4735ab873f` and hit `E001_GEO_INVALID` for `country_iso=AQ` due to a GEOS TopologyException during the antimeridian split.
   - Determined that `AQ` is valid in original coordinates but becomes invalid after the shift-to-360 step; planned a localized `make_valid` on the shifted geometry to stabilize intersections without mutating the input geometry.

* 3:32am
   - Implemented the shifted-geometry normalization in `_split_antimeridian_geometries` (apply `shapely.make_valid` when the 0..360 geometry is invalid).

* 3:38am
   - Re-ran `make segment1b-s1 RUN_ID=869381446fd74b49bd7f7a4735ab873f`; the CLI run exceeded the tool timeout but completed successfully in the background.
   - Verified in `runs/local_full_run-5/869381446fd74b49bd7f7a4735ab873f/run_log_869381446fd74b49bd7f7a4735ab873f.log` that S1 completed and published `tile_index` (rows_emitted=221253340) with no geometry errors.

* 5:35am
   - Reviewed S2 expanded spec plus 1B contracts (`schemas.1B.yaml`, `dataset_dictionary.layer1.1B.yaml`, `artefact_registry_1B.yaml`) and logged a detailed S2 pre-implementation plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.
   - Flagged open decisions: where to source governed `basis` and `dp` for S2 (tied to parameter_hash) and how to encode `ingress_versions` in the run report.

* 5:55am
   - Confirmed the S2 spec does not name a concrete policy/config file for `basis` and `dp`; recorded the recommendation to add a new 1B policy config and include it in parameter_hash.
   - Recommended using Dictionary path version tokens for `ingress_versions` in the S2 run report to avoid contract changes.

* 6:01am
   - Logged the detailed pre-implementation plan to add `policy.s2.tile_weights.yaml`, wire it into parameter_hash inputs, add dictionary/registry/schema anchors, seal it in 1B.S0, and rerun the S0→S2 pipeline under a new parameter_hash.

* 6:08am
   - Created the S2 weights policy config file `config/layer1/1B/policy/policy.s2.tile_weights.yaml` with governed `basis` + `dp` (deterministic fixed-decimal posture).
   - Added the `policy/s2_tile_weights_policy` schema anchor to `docs/model_spec/data-engine/layer-1/specs/contracts/1B/schemas.1B.yaml`.
   - Added `s2_tile_weights_policy` to the 1B dataset dictionary and 1B artefact registry with path/schema/licence/retention metadata.
   - Added `policy.s2.tile_weights.yaml` to the 1A artefact registry and parameter hash inputs, and updated 1B S0 to seal `s2_tile_weights_policy`.
   - Next actions queued: update the 1B S0/S2 expanded specs to include the new policy in sealed inputs and S2 inputs, then implement S2 runner/CLI/Makefile and rerun S0->S2 with a new parameter_hash.

* 6:20am
   - Updated `state.1B.s0.expanded.md` to list `s2_tile_weights_policy` as a sealed input across the external references list, inputs list, sealed_inputs examples, and failure references.
   - Updated `state.1B.s2.expanded.md` to add `s2_tile_weights_policy` as a required input, renumbered inputs sections, and bound `basis`/`dp` sourcing to the policy file.
   - Added an explicit rule that `ingress_versions` must be derived from Dictionary path version tokens (and set population_raster to null when basis != population).
   - Prepared to implement S2 runner/CLI/Makefile with per-country streaming, fixed-dp quantization, and required PAT counters.

* 6:29am
   - Implemented the 1B S2 runner (`seg_1B/s2_tile_weights/runner.py`) with per-country streaming, governed basis/dp policy validation, fixed-dp quantisation, determinism receipt, and PAT counters.
   - Added the S2 CLI (`engine.cli.s2_tile_weights`) and Makefile wiring (`SEG1B_S2_*` + `segment1b-s2`).
   - Logged the S2 implementation details and next rerun steps in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.

* 6:30am
   - Ran `make segment1a-s0` to regenerate parameter_hash after adding the S2 policy; new run_id `f079e82cb937e7bdb61615dbdcf0d038`, parameter_hash `56d45126eaabedd083a1d8428a763e0278c89efec5023cfd6cf3cab7fc8dd2d7`, manifest_fingerprint `9673aac41b35e823b2c78da79bdf913998e5b7cbe4429cf70515adf02a4c0774`.

* 6:36am
   - Ran `make segment1a-s9` and the validation bundle published `decision=FAIL` for run_id `f079e82cb937e7bdb61615dbdcf0d038`.
   - `s9_summary.json` reports `E_LINEAGE_RECOMPUTE_MISMATCH`: missing required parameter file `policy.s2.tile_weights.yaml`, causing manifest_fingerprint recompute mismatch.
   - Plan: update S9 lineage recompute parameter list to include `policy.s2.tile_weights.yaml`, then rerun S9 to regenerate the PASS bundle.

* 6:37am
   - Updated `seg_1A/s9_validation/runner.py` to include `policy.s2.tile_weights.yaml` in the parameter-file mapping so S9 recomputes parameter_hash/manifest_fingerprint with the new policy input.
   - Next step: rerun `make segment1a-s9` for run_id `f079e82cb937e7bdb61615dbdcf0d038` and confirm PASS.

* 6:38am
   - Re-ran `make segment1a-s9` for run_id `f079e82cb937e7bdb61615dbdcf0d038`; validation bundle published decision=PASS after adding `policy.s2.tile_weights.yaml` to the recompute mapping.

* 6:50am
   - Re-ran 1B S1 for the new parameter_hash run_id `f079e82cb937e7bdb61615dbdcf0d038` (after adding the S2 policy). The CLI exceeded the tool timeout, but `runs/local_full_run-5/f079e82cb937e7bdb61615dbdcf0d038/run_log_f079e82cb937e7bdb61615dbdcf0d038.log` shows S1 completed and published `tile_index` with `rows_emitted=221253340` and no S1_ERRORs.
   - Ran 1B S2 on the same run_id; the CLI again exceeded the tool timeout, but the run log confirms completion and `s2_run_report.json` was written under `reports/layer1/1B/state=S2/parameter_hash=56d45126eaabedd083a1d8428a763e0278c89efec5023cfd6cf3cab7fc8dd2d7/`.
   - Inspected the S2 run report: `basis=area_m2`, `dp=6`, `countries_total=249`, `rows_emitted=221253340`, determinism receipt present, and `ingress_versions` uses Dictionary version tokens (population_raster null because basis is not population). No S2_ERROR entries observed in the run log.

* 6:52am
   - Completed S3 expanded spec + contract review (schemas.1B.yaml, dataset_dictionary.layer1.1B.yaml, artefact_registry_1B.yaml) and logged a detailed pre-implementation plan in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`.
   - Captured the deterministic streaming plan: gate receipt validation (no bundle rehash), single-pass outlet_catalogue grouping with `site_order` contiguity checks, coverage assertion against `tile_weights`, strict schema validation, atomic publish, and required `s3_run_report` + determinism receipt outside the dataset partition.

* 4:42pm
   - Logged explicit S3 performance risk notes and mitigations in `docs/model_spec/data-engine/implementation_maps/segment_1B.impl_actual.md`, emphasizing single-pass streaming, coverage set pre-scan, and no full joins/materialization.
