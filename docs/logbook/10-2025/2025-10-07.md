# Logbook
### Date: 7th October 2025
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)


* 11:01pm
   * Started implementing state-0 to work with the preview data because ingestion pipelines are yet to be created and hooked up.
		- Run context & schema validation follow S0.1: ingress rows are normalised, channel symbols constrained to CP/CNP, ISO/GDP/bucket refs pinned, and lineage slots prepared (merchant_u64, etc.) in build_run_context.
		- Lineage hashing and run identifiers obey the tuple-hash spec from S0.2, and numeric policy artefacts are validated/digested before inclusion.
		- RNG scaffolding and logging meet S0.3 expectations: Philox substreams derive from fingerprint+seed with open-interval uniforms and budget guards.
		- Design matrices, diagnostics, and eligibility are deterministic per S0.4–S0.7: dictionaries enforce channel/bucket order, leakage guards, and logistic evaluation with numeric policy constraints.
		- Output materialisation, validation bundles, RNG audit trails, and failure recording follow S0.8–S0.10: numeric self-tests feed attestation, parquet writers enforce partition lineage, validation bundles gate on _passed.flag, validator re-opens artefacts, and failure records land under fingerprint/seed/run.
		- Unit coverage exists for the main kernels, lineage sealing, RNG logging, output round-trip, and corruption detection.
		- Added an authoritative JSON schema bundle for state‑0 outputs (contracts/schemas/l1/seg_1A/s0_outputs.schema.json) and wired SchemaAuthority to resolve segment pointers, letting validators load dataset contracts directly.
		- Hardened the L3 validator with JSON-Schema checks plus a dedicated error code so persisted parquet now fails fast on contract drift.
		- Introduced a high-level orchestration path that seals, writes, validates, and records failures in one call, exposing S0RunResult via the package init and covering it with an end-to-end fixture-driven test.

* 11:30pm
	* Added the missing state‑0 contract so validation can bind to concrete schemas (contracts/schemas/l1/seg_1A/s0_outputs.schema.json).
	* Extended the authority helper with segment_schema to resolve 1A dataset pointers.
	* Introduced a full orchestration entrypoint plus S0RunResult to seal, write, and validate runs from on-disk inputs.
	* Hardened the validator with JSON-Schema checks, deterministic comparisons, digest verification that matches the writer’s ordering, and relaxed RNG-event expectations for S0.
	* Mapped the new validation schema error to the failure taxonomy.
	* Updated fixtures and added an end-to-end test covering the new run helper.
	* Wired pytest for this test suite into pre-commit so it runs automatically before commits.
	* `run_from_paths` now emits a deterministic RNG event before any artefacts are written by wiring in `RNGLogWriter`/`rng_event` and logging a seeded anchor substream, so RNG traces exist for validation runs.
	* Added lineage and numeric attestation verification to the validator: it re-hashes artefact digests, recomputes `parameter_hash`/`manifest_fingerprint`, enforces numeric self-tests, and still gates on `_passed.flag` and RNG event presence.
	* Extended the failure taxonomy with `E_VALIDATION_NUMERIC` for numeric policy regressions.
	* Adjusted unit tests to log the anchor RNG event when driving `write_outputs` directly so contract checks succeed under the stricter validation.

* 12:10am
	* Promoted the S0 orchestrator by adding a CLI entry point (`engine.cli.s0_foundations:main`) and exposing it as the `engine-s0-run` console script for deterministic runs.
	* Created the `engine.cli` package scaffold to house future tooling wrappers.
	* Published layer-wide RNG schemas and a minimal S0 dataset dictionary inside `contracts/` so downstream consumers can rely on authoritative artefacts.
	* Extended S0 state contracts to cover the RNG anchor event emitted by the orchestrator.
