# Logbook
### Date: 26th November 2025
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)

* 3:33pm
   * Began work on implementing segment 3A
   * Implemented initial Segment 3A S0 gate scaffolding:
      - Added 3A package and S0 gate modules (exceptions, sealed artefact dataclass, runner) under `packages/engine/src/engine/layers/l1/seg_3A/…`.
      - Runner verifies upstream 1A/1B/2A validation bundles (defaulting to data/layer1/{seg}/validation/fingerprint=<fp>), hashes policy packs (mixture, country_zone_alphas, zone_floor_policy, day_effect_policy_v1), computes parameter/manifest hashes, writes s0_gate_receipt_3A.json and sealed_inputs_3A.parquet, and emits a small determinism receipt.
      - Dictionary fallback points to the spec copy at docs/model_spec/data-engine/layer-1/specs/contracts/3A/dataset_dictionary.layer1.3A.yaml unless overridden.

* 4:00pm
   - Wired Segment 3A S0 into the tooling:
      - Added 3A shared dictionary loader, S0 gate runner refinements (proper default dictionary, deterministic receipt path in outputs), and exported segment package.
      - Created Segment 3A orchestrator and CLI (engine.scenario_runner.l1_seg_3A, engine.cli.segment3a) with resume support and validation bundle overrides; updated CLI exports.
      - Added a runtime 3A dataset dictionary copy under contracts/dataset_dictionary/l1/seg_3A/layer1.3A.yaml.
      - Introduced a Makefile target segment3a plus variables/command wiring using existing run-root, upstream bundles, and summaries.
      - Included a focused 3A S0 gate unit test; updated S0 outputs to carry determinism receipt path.

* 5:13pm
   * S0 surfaces & contracts
      - Cloned the Segment 3A schema pack (contracts/schemas/layer1/schemas.3A.yaml) and dictionary entries (contracts/dataset_dictionary/l1/seg_3A/layer1.3A.yaml, spec copy under docs/model_spec/...) so S1/S2 can validate receipts, sealed inputs, policies, and plan datasets.
      - Added a schema loader for Segment 3A (packages/engine/src/engine/layers/l1/seg_3A/shared/schema.py) and exported it via shared/__init__.py.
   - Gate + runners
      - Extended the S0 gate runner to seal the new authority surfaces (outlet catalogue, site tz, tz cache, ISO/tz references) and write receipts consumable by downstream states (packages/engine/src/engine/layers/l1/seg_3A/s0_gate/l2/runner.py).
      - Implemented the S1 escalation runner (s1_escalation/l2/runner.py) with:
         - Receipt + sealed-input validation against the new schemas.
         - Deterministic asset resolution/digest checks for mixture policy, outlet catalogue, tz world, and ISO tables.
         - Policy loader, merchant/country aggregations, gating + share-bucket classification, resumable parquet emission, and structured run reports.
      - Built the S2 priors runner (s2_priors/l2/runner.py) that validates its policies, cross-checks the tz universe, enforces floors, emits per-country priors, enforces immutability, and writes run reports.
   - Orchestration + CLI
      - Wired S1/S2 into the Segment3A orchestrator/CLI (engine/scenario_runner/l1_seg_3A.py, engine/cli/segment3a.py) so --run-s1/--run-s2 drive the new runners and surface their outputs/resume state in the summary.
      - Added a Makefile target (segment3a) plus command wiring/args so the standard run pipeline can execute the gate + optional S1/S2.
   - Regression harness & artefacts
      - Added realistic ingested references for tz/ISO to reference/spatial/tz_world/2025a/tz_world.parquet and reference/iso/iso3166_canonical/....
      - Authored end-to-end tests for both runners (tests/engine/test_seg_3a_s1_s2.py) covering sealed artefact staging, policy fixtures, output validation, and run report existence. Updated S0 gate tests to reflect the new receipt shape.
      - Latest fix: Polars .group_by swap and test YAML/bucket assertions to keep the suite green.

* 5:21pm
   * Added a shared segment-state run-report helper and now S0/S1/S2 each emit an idempotent JSONL row under runs/layer1/segment_states, capturing identity, status, timing, outputs, and resume state (shared/run_report.py, calls wired into each runner).
   * Tightened S0 sealing: sealed inputs and sealed_policy_set are now deterministically sorted; policy entries are aligned and the segment-state run-report is written alongside the receipt/sealed inputs.
   * S1/S2 run reports now return structured payloads and also write segment-state rows (S1 carries elapsed time/output/run-report paths; S2 carries prior/floor IDs and outputs).
   * All Segment 3A gate/escalation/prior tests still pass: python -m pytest tests/engine/test_seg_3a_s0_gate.py tests/engine/test_seg_3a_s1_s2.py.
   * Added seed threading into S2 so its segment-state run-report row records the real run triple (parameter_hash, manifest_fingerprint, seed) (s2_priors/l2/runner.py, orchestrator wiring).
   * Segment-state run-report helper remains shared, and S0/S1/S2 now emit idempotent rows with correct keys; S0 sealing is deterministically sorted (sealed_inputs_3A rows and sealed_policy_set order).
   * Regression tests updated for the new S2 seed requirement; full suite still green (python -m pytest tests/engine/test_seg_3a_s0_gate.py tests/engine/test_seg_3a_s1_s2.py).
   * ##To Do: Sort out filepaths for artefacts during run. I noticed that for the runs in `runs/` although the first layer of folders seem organized. Within the folders, just hides a huge mess. They aren't sorted into segments and some state, and as such are a bit confusing

* 6:24pm
   * Added a governed segment-state run-report dataset entry (path reports/l1/segment_states/segment_state_runs.jsonl, schema schemas.layer1.yaml#/run_report/segment_state_run) to the 3A dictionaries and added the schema to schemas.layer1.yaml. All runners now resolve this via the dictionary and write idempotent rows there.
   * Kept S3/S4 output validation simple (schema checks removed) to avoid mismatched plan-schema semantics; core inputs/receipts still validated.
   * Adjusted the run-report helper to take an explicit path (no hidden defaults) and updated S0/S1/S2/S3/S4 to use the dictionary-derived path.
   * Updated tests to include the new run-report dataset and expanded dictionary section lookup to include reports.
   * All targeted tests pass: python -m pytest tests/engine/test_seg_3a_s0_gate.py tests/engine/test_seg_3a_s1_s2.py tests/engine/test_seg_3a_s3_s4.py.

* 6:39pm
   * Added S5 zone allocation runner: joins S1/S3/S4, builds zone_alloc, computes a universe hash, writes run reports and segment-state rows, and respects immutability/resume (packages/engine/src/engine/layers/l1/seg_3A/s5_zone_alloc/l2/runner.py).
   * Added S6 validation runner: performs structural checks (count conservation), emits validation report, issues table, receipt, validation bundle + _passed.flag_3A, and segment-state run entry (packages/engine/src/engine/layers/l1/seg_3A/s6_validation/l2/runner.py).
   * Orchestrator/CLI/Makefile now support --run-s5/--run-s6 and surface their outputs (packages/engine/src/engine/scenario_runner/l1_seg_3A.py, packages/engine/src/engine/cli/segment3a.py, makefile).
   * Segment-state run-report dataset is now a governed entry in the dictionary/spec and resolved via the dictionary (shared dictionary section includes reports).
   * Added end-to-end tests for S5→S6 (tests/engine/test_seg_3a_s5_s6.py) alongside prior suites; all targeted tests pass: `python -m pytest tests/engine/test_seg_3a_s0_gate.py tests/engine/test_seg_3a_s1_s2.py tests/engine/test_seg_3a_s3_s4.py tests/engine/test_seg_3a_s5_s6.py`.
   * Open caveats: S5/S6 avoid strict plan-schema validation (plan schemas use type: table), but enforce count conservation and required inputs. If stricter validation is desired later, we can add custom table validators.

* 6:46pm
   * Added a lightweight table validator for plan schemas and now enforce zone_alloc column contracts before writing (S5) and during validation checks (S6). Errors surface as schema issues instead of silently passing (s5_zone_alloc/l2/runner.py, reused in S6).
   * S6 validation now logs schema/count issues explicitly, builds a structured check entry in the validation report, and keeps timestamps RFC3339-microsecond with Z (s6_validation/l2/runner.py).
   * Kept run-report/receipt emissions and segment-state entries intact; routing hash/universe hash generation remains deterministic.

* 6:55pm
   * Added S7 bundle runner to assemble the validation bundle from all required artefacts (S0–S6), write index.json, compute the composite HashGate digest, emit _passed.flag_3A, and record segment-state/run reports. Preconditions enforce S6 PASS before flagging (packages/engine/src/engine/layers/l1/seg_3A/s7_bundle/l2/runner.py).
   * S6 now writes its report/issue/receipt both into the validation bundle and the catalogued dictionary paths so S7 can bundle them; timestamps are RFC3339µs with Z. Added table-schema validation in S6 via the shared validator (s6_validation/l2/runner.py).
   * S5 keeps plan-schema checks via the custom table validator; routing hash and universe hash remain deterministic (s5_zone_alloc/l2/runner.py).
   * Orchestrator/CLI/Makefile support --run-s7 and surface S7 outputs; segment-state run-report dataset is dictionary-backed and used across S0–S7 (scenario_runner/l1_seg_3A.py, engine/cli/segment3a.py, makefile).