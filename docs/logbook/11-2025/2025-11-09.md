# Logbook
### Date: 9th November 2025
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)

* 4:00am
   - Changes made to align 2A with the rest of Layer‑1 and teach the tooling about its own manifest:
      - Segment 2A S0 gate: reverted the temporary fingerprint guard so the gate once again seals its own inputs, as the spec requires.
      - Scenario runner & CLI: Segment2AResult now carries the segment’s parameter_hash; the CLI summary includes it, and there’s a new optional --result-json flag that writes runs/.../segment2a_result.json capturing S0–S5 outputs, fingerprints, and resume status. Resume mode now reads the receipt to recover the hash.
      - Makefile workflow: added SEG2A_RESULT_JSON (default runs/local_layer1_regen0/segment2a_result.json). make segment2a now emits this file automatically. make segment2b loads the manifest/parameter hash from that summary (while still using the 1A fingerprint to locate the 1B validation bundle), so S3 resolves site_timezones under the correct {seed,fingerprint}. clean-results now deletes both segment summaries.

* 6:44am
   - Segment 2B now understands the 2A fingerprint.
      - segment2b CLI accepts a new --seg2a-manifest-fingerprint flag and surfaces it in its JSON summary.
      - The scenario runner and S3 day‑effects runner both take this second fingerprint; S3 uses it when resolving site_timezones (and, if pinned, tz_timetable_cache) while continuing to verify 1B artefacts under the 1B fingerprint.
      - The 2B S0 gate also pins those civil‑time optional assets under the 2A fingerprint rather than the 1B one.
   - Segment 2A emits its own summary.
      - segment2a CLI has an optional --result-json. The make target now passes runs/local_layer1_regen0/summaries/segment2a_result.json (I also had the CLI create parent directories before writing).
      - That summary holds the S0 manifest + parameter hash so downstream code doesn’t have to peek into receipt JSON manually.
   - Makefile orchestration reads the right fingerprints.
      - Result JSONs now live under $(RUN_ROOT)/summaries/ (segment1a_result.json, segment2a_result.json), and make clean-results wipes both.
      - make segment2a ensures the summaries directory exists before running.
      - make segment2b now:
         - Verifies both summaries are present.
         - Loads the Segment 2A manifest/parameter hash from segment2a_result.json.
         - Derives the current Segment 1B fingerprint by inspecting data/layer1/1B/site_locations/seed=$(SEED)/fingerprint=*.
         - Uses the 1B fingerprint for --manifest-fingerprint and validation bundle, and the 2A fingerprint for --seg2a-manifest-fingerprint.
   - segment1a still drops its summary, but it now writes it to runs/.../summaries, keeping the run root tidy.

* 7:06am
   - Added a focused helper to turn the two summary receipts into shell-safe exports, while also validating parameter-hash alignment plus the existence of the site_locations partition and validation bundle (scripts/make_helpers/resolve_seg2b_env.py (line 16), scripts/make_helpers/resolve_seg2b_env.py (line 86)).
   - Rewired the segment2b target to call that helper instead of embedding brittle inline Python, so fingerprint/parameter inputs are always sourced from the receipts before invoking the CLI (makefile (line 220)).
   - Extended the S3 tests to generate civil-time fixtures under a distinct Segment 2A manifest and pass the new seg2a_manifest_fingerprint argument, ensuring the runner now exercises the dictionary-only resolution path (tests/engine/test_seg_2b_s3_day_effects.py (line 120), tests/engine/test_seg_2b_s3_day_effects.py (line 175)).

* 7:23am
   - Updated the S3 runner to coerce both s1_site_weights and site_timezones join keys into aligned types before joining. merchant_id, legal_country_iso, and site_order are now cast (with validation) to eliminate the u64 vs str mismatch; any rows that fail coercion raise a clear schema error instead of tripping the Polars join (packages/engine/src/engine/layers/l1/seg_2B/s3_day_effects/l2/runner.py (line 458)).
   - Relaxed the helper so Segment 2B takes the parameter hash straight from the Segment 2A summary (no longer forcing a 1A/2A hash match) and kept the temporary-file sourcing approach (scripts/make_helpers/resolve_seg2b_env.py (line 72), makefile (line 220)).
   - Quoted all path-like CLI args in SEG2B_ARGS, preventing Windows paths with spaces from being split when invoking the Python CLI (makefile (line 132)).

* 3:28pm
   - State‑4 Runner
      - Added a full S4 implementation (packages/engine/src/engine/layers/l1/seg_2B/s4_group_weights/l2/runner.py (lines 1-465)). It resolves gate receipts/dictionary assets (including the Seg 2A fingerprint for site_timezones), enforces 1:1 joins, aggregates base shares, blends γ factors, renormalises per merchant/day, writes s4_group_weights via atomic staging, and records a structured run-report/resume flow.
      - Exported the new runner publicly (packages/engine/src/engine/layers/l1/seg_2B/s4_group_weights/__init__.py (lines 1-6), packages/engine/src/engine/layers/l1/seg_2B/__init__.py (lines 1-37)).
   - Orchestration & CLI
      - Extended the Segment 2B orchestrator/DTOs to carry S4 flags, resume/quiet controls, runner instantiation, and summary outputs (packages/engine/src/engine/scenario_runner/l1_seg_2B.py (lines 12-189)).
      - Updated the CLI to accept --run-s4/--s4-resume/--s4-quiet-run-report, pass them through to the orchestrator, and expose S4 paths in the summary JSON (packages/engine/src/engine/cli/segment2b.py (lines 18-175)).
   - Makefile & Helper Flags
      - Defaulted S4 execution/resume/quiet knobs and wire them into the Segment 2B command so make segment2b now triggers S4 automatically (makefile (lines 101-145)).
   - Tests & Fixtures
      - Added targeted unit coverage for the S4 runner, including deterministic output checks and resume semantics with synthetic dictionaries/artefacts (tests/engine/test_seg_2b_s4_group_weights.py (lines 1-184)).
      - Full focused test run: .venv/Scripts/python.exe -m pytest tests/engine/test_seg_2b_s3_day_effects.py tests/engine/test_seg_2b_s4_group_weights.py.
   - Verification Notes
      - Attempted make segment2b inside the Codex shell, but the bundled Git Bash lacks a python shim, so the recipe stops at /bin/bash: python: command not found. Please rerun make segment2b (or PY=.venv/Scripts/python.exe make segment2b) from your normal MINGW64 shell where python lives on PATH to regenerate real artefacts and confirm end-to-end.

* 3:37pm
   - Added deterministic tolerance management (NORMALISATION_EPS) and enforced every binding invariant: base-share sums per merchant must equal 1 (E_S4_BASE_SHARE_SUM), every merchant/day emits exactly one row per tz group (E_S4_COVERAGE_GAP), denominators stay positive, and p-group totals per day re-normalise (with tiny-negative clamping) before writing (E_S4_P_GROUP_SUM, E_S4_ZERO_NORM_TOTAL, etc.). Coverage now explicitly checks all merchants/days against the Cartesian expectation.
   - Upgraded the runner outputs: new validator metrics capture max abs deltas and expected rows, run-report counts now include rows_expected, and the publication path is only accepted when coverage and sums pass.
   - Extended the test harness with deterministic fixtures that cover happy-path, resume, and the new failure scenarios (base-share mismatch, missing tz-group day rows) so regressions surface immediately.

* 3:47pm
   - Added full schema enforcement for the s4_group_weights dataset. The runner now loads the contract schema, verifies the DataFrame is fields‑strict, and checks column dtypes before publishing (packages/engine/src/engine/layers/l1/seg_2B/s4_group_weights/l2/runner.py:16-33,178-467,579-615). This closes the “fields‑strict”/schema gap from the spec.
   - Upgraded the artefact contract so the schema pack actually exposes plan/s4_group_weights (contracts/schemas/layer1/schemas.2B.yaml (lines 310-360)). Without this addition the schema pointer couldn’t resolve.
   - Enhanced the runner’s validator/reporting surface: run reports now track expected vs actual row counts plus max absolute deltas for both base-share and p-group totals, matching the spec’s validator catalogue. (See _build_run_report updates.)
   - Extended the unit suite with negative cases (base-share drift, tz-group coverage gaps) so regressions trip immediately (tests/engine/test_seg_2b_s4_group_weights.py (lines 1-204)).

* 3:59pm
   - Schema pack wired up: the authoritative definition for s4_group_weights now lives in the published contract (contracts/schemas/layer1/schemas.2B.yaml (line 310)). That let us point the runners at a real anchor instead of a missing pointer.
   - S1 (weights freezer) – before writing the Parquet slice we now validate the frame against the spec’s column set/types (packages/engine/src/engine/layers/l1/seg_2B/s1_weights/l2/runner.py:223,287). Any drift immediately raises E_S1_SCHEMA_COLUMNS/E_S1_SCHEMA_TYPES, so the output is guaranteed to match schemas.2B.yaml#/plan/s1_site_weights.
   - S2 (alias builder) – the alias index JSON is schema‑checked via #/plan/s2_alias_index prior to publishing (packages/engine/src/engine/layers/l1/seg_2B/s2_alias/l2/runner.py (line 219)). An invalid payload now aborts with E_S2_INDEX_SCHEMA, keeping the metadata contract in sync with the spec.
   - S3 (day-effects) – the data frame is validated against the table contract before the atomic publish step (packages/engine/src/engine/layers/l1/seg_2B/s3_day_effects/l2/runner.py:528,714). Any missing/extra columns or dtype mismatches surface as E_S3_SCHEMA_* errors.
   - S4 (group weights) – kept the earlier numeric/coverage guards and added schema enforcement; no change needed here beyond the contract entry already added.

* 8:30pm
   - The validator was still using the old “signed 63‑bit” upper bound because schemas.layer1.yaml (where id64 is defined) capped max at 2^63‑1. I’ve expanded that primitive to the full unsigned range (max = 18446744073709551615) so any legitimate 64‑bit merchant id now passes schema validation. contracts/schemas/layer1/schemas.layer1.yaml (lines 14-18) is updated, and the S2 alias index schema (which references id64) picks it up automatically. 
   - Segment 2B dictionary didn’t know about the new s4_group_weights dataset, so render_dataset_path failed when S4 tried to resolve its output location. I fixed that by adding a proper dictionary entry (status/description/path/schema/linkage) under contracts/dataset_dictionary/l1/seg_2B/layer1.2B.yaml, pointing it at data/layer1/2B/s4_group_weights/seed={seed}/fingerprint={manifest_fingerprint}/ with the schemas.2B.yaml#/plan/s4_group_weights anchor.

* 9:00pm
   - Added s5_selection_log with the policy-gated path/partition spec (seed, parameter_hash, run_id, utc_day) and schema reference.
   - Introduced a logs section for S5 RNG artefacts: rng_event_alias_pick_group, rng_event_alias_pick_site, plus the run-scoped rng_audit_log and rng_trace_log, each bound to the Layer‑1 schema anchors and the {seed, parameter_hash, run_id} partitions the spec mandates.
   - contracts/schemas/layer1/schemas.2B.yaml now exposes #/trace/s5_selection_log_row, a fields-strict definition with the required columns (merchant_id, utc_timestamp, tz_group_id, counters, etc.).
   - contracts/schemas/layer1/schemas.layer1.yaml gained the new RNG event families alias_pick_group and alias_pick_site, both reusing the Philox envelope with draws='1'/blocks=1 and the payload fields we need to log (merchant, day, tz-group/site, optional selection_seq).

* 9:53pm
   - Built a full S5 implementation (packages/engine/src/engine/layers/l1/seg_2B/s5_router/l2/runner.py (lines 1-386)): dictionary-only resolution, sealed-policy validation (route + alias), Philox substream derivation, alias caching, RNG event/audit/trace writers, optional selection logs, and the spec-compliant run-report. It now reads the sealed inventory via the new helpers in packages/engine/src/engine/layers/l1/seg_2B/shared/receipt.py (lines 1-136), reuses the RNG trace helper added at packages/engine/src/engine/layers/l1/seg_2B/shared/rng_trace.py (lines 1-69), and exposes the new surfaces through packages/engine/src/engine/layers/l1/seg_2B/__init__.py (lines 1-33).
   - Orchestration/CLI/make integration: packages/engine/src/engine/scenario_runner/l1_seg_2B.py (lines 120-294) now wires S5 (auto-deriving arrivals unless a JSONL is provided, with _load_arrivals_from_file), carries the extra result metadata, and exposes quiet-selection logging controls. packages/engine/src/engine/cli/segment2b.py (lines 120-255) adds `--run-s5`, `--s5-selection-log`, and `--s5-arrivals-jsonl`, and the summary prints the new artefact paths/run_id. makefile (lines 98-176) gains `SEG2B_RUN_S5`, `SEG2B_S5_SELECTION_LOG`, and `SEG2B_S5_ARRIVALS_JSONL` knobs so make segment2b can rerun S5 deterministically.
   - Regression safety: added tests/engine/test_seg_2b_s5_router.py (lines 1-175) with two focused cases (default auto-arrivals + custom arrivals file) to assert RNG evidence, selection logging, and run-report structure.