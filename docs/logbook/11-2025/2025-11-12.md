# Logbook
### Date: 12th November 2025
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)

* 6:00am
   - 2B.S0 now emits the spec-compliant run-report (component 2B.S0) and prints it to STDOUT while also persisting it under reports/l1/s0_gate/fingerprint=<manifest>/run_report.json. The runner tracks gate/inventory/publish timings, bundle/flag digests, policy IDs, inventory stats, deterministic samples, id map, and validator statuses (packages/engine/src/engine/layers/l1/seg_2B/s0_gate/l2/runner.py). A GateWriteResult helper captures receipt/inventory artefacts so the run-report has publish targets and bytes, and the determinism receipt now flows into both the receipt and the run-report.
   - All S0 failure points now raise canonical 2B-S0-XXX codes. Gate input validation, bundle hash mismatches, dictionary resolution, missing assets/policies, and hashing errors are mapped to their spec identifiers (e.g., 2B-S0-011 for flag mismatches, 2B-S0-020 for catalogue failures, 2B-S0-022 for undeclared asset access). Optional pin detection feeds validator V‑05 with a WARN if the all-or-none rule is violated.
   - To keep the test harness in sync, the 2B S0 unit test seeds the required seg2a_manifest_fingerprint, covers the new run-report file, and expects 2B-S0-011 on flag mismatch. The test dictionary fixture now includes the virtual_rules_policy_v1 entry (tests/engine/test_seg_2b_s0_gate.py).
   - S2 runner now mirrors S1’s sealed-input gating. S2AliasRunner loads sealed_inputs_v1, requires alias_layout_policy_v1 to be present, resolves the exact sealed path (data-root fallback to repo), and re-hashes it to confirm the digest matches S0’s inventory. Missing/mismatched assets raise the canonical 2B-S2-022. The run-report now echoes the sealed policy path via the updated AliasLayoutPolicy.policy_path.
   - Added shared helpers in the S2 runner to load the inventory map and perform the path/digest checks, so future sealed assets (e.g., optional pins) can reuse them.
   - Test coverage (tests/engine/test_seg_2b_s2_alias.py) now synthesizes a sealed_inputs_v1 inventory and matching S0 receipt before running the state, ensuring the new checks are exercised. The dictionary fixture also advertises the inventory dataset so the loader can resolve it.
   - For completeness, S1’s new behaviour is still covered; both S1/S2 suites (plus S0) pass: `python -m pytest tests/engine/test_seg_2b_s0_gate.py tests/engine/test_seg_2b_s1_weights.py tests/engine/test_seg_2b_s2_alias.py`

* 6:10am
   - `s3_day_effects` now consumes the sealed inventory for both the policy and the 2A site_timezones pin; the runner captures the resolved sealed path (packages/engine/src/engine/layers/l1/seg_2B/s3_day_effects/l2/runner.py (line 176)) and _ensure_optional_pin now returns a verified filesystem target so downstream reads never bypass the gate (same file (line 542)).
   - All E_S3_* placeholders were swapped for the canonical 2B-S3-XXX identifiers so runtime failures now emit spec-compliant codes (e.g., run-identity checks at packages/engine/src/engine/layers/l1/seg_2B/s3_day_effects/l2/runner.py (line 93) and IO/schema traps around lines 578‑901).
   - s4_group_weights mirrors the sealed-input enforcement: it loads the S0 inventory, validates the optional site_timezones pin, and resolves its path straight from the sealed manifest before any read (packages/engine/src/engine/layers/l1/seg_2B/s4_group_weights/l2/runner.py:89,119). A dedicated helper block now wraps inventory loading/path resolution (same file (line 542) onwards).
   - S4’s error surface also uses the official 2B-S4-XXX codes for config validation, joins, coverage, and schema checks (packages/engine/src/engine/layers/l1/seg_2B/s4_group_weights/l2/runner.py (line 46), 111, 258–498), and the tests were updated to expect the new identifiers (tests/engine/test_seg_2b_s4_group_weights.py:266,322).
   - S3/S4 integration tests now mint sealed inventories/receipts so the runners prove they will refuse unsealed inputs (tests/engine/test_seg_2b_s3_day_effects.py:108,203 and tests/engine/test_seg_2b_s4_group_weights.py:94,158), including real SHA digests for policies and the cross-segment pin.
   - Canonical error codes are now aligned across the engine. I introduced translation tables in packages/engine/src/engine/layers/l1/seg_2A/s0_gate/exceptions.py and packages/engine/src/engine/layers/l1/seg_2B/s0_gate/exceptions.py; every legacy E_Sx_*/E_* identifier is rewritten at raise-time to the published 2A-Sx-XXX or 2B-Sx-XXX code. I verified coverage by walking every err("…") call in both segments and confirming the translator never returns an E_* code, so downstream logging, run-reports, and tests all see the canonical IDs without touching each runner.

* 6:20am:
   - Updated the Segment 2A gate runner so it now fully emits the spec’d observability surfaces:
      - packages/engine/src/engine/layers/l1/seg_2A/s0_gate/l2/runner.py (lines 93-670) now captures run timing, writes a deterministic partition receipt (hashed over the receipt + inventory), builds the §11 run-report payload (upstream gate proof, sealed-input stats, tz artefact metadata, determinism hash, warnings, validator skeleton, etc.), persists it under reports/l1/s0_gate/fingerprint=…/run_report.json, and returns both the run-report path and determinism receipt on S0GateOutputs. The determinism helper lives in _write_determinism_receipt (… (line 498)) and the report builder in _build_run_report (… (line 528)). Translators feed 2A-S0-070 when optional pins are partial so the warnings section stays spec-compliant.
      - The S0 test (tests/engine/test_seg_2a_s0_gate.py (lines 272-285)) now asserts that the new determinism receipt exists, the run-report is written, and the reported fingerprint/determinism hash match what the runner returned.
   - Added a reusable sealed-input enforcement helper (packages/engine/src/engine/layers/l1/seg_2A/shared/sealed_assets.py (line 1)) and threaded it through S2–S5 runners so every cross-layer read now resolves via the S0 inventory, re-checks digests, and captures the S0 determinism receipt in each run report (s2_overrides:94‑520, s3_timetable:90‑260, s4_legality:73‑210, s5_validation:95‑205).
   - Extended Segment 2B runners to surface determinism: router/day-edge/audit reports now include the S0 receipt payload (s5_router/l2/runner.py:508‑915, s6_virtual_edge/l2/runner.py:708‑780, s7_audit/l2/runner.py:240‑280), and the S8 bundler now writes a new JSON run-report alongside its bundle plus validation helpers (s8_validation/l2/runner.py:90‑210 & 318‑380). Updated the strict S7 schema to allow the new determinism block (contracts/schemas/layer1/schemas.2B.yaml:140‑205).
   - Scenario orchestrators capture the determinism receipt path so both Segment 2A/2B CLI summaries expose s0_determinism_receipt and, for S8, the new run-report path (scenario_runner/l1_seg_2A.py:74 & 308‑336, scenario_runner/l1_seg_2B.py:97 & 330‑405, cli/segment2a.py:62‑87, cli/segment2b.py:40‑110). Segment 2A’s S1 invocation now suppresses run-report stdout to keep CLI JSON parseable (scenario_runner/l1_seg_2A.py:180‑200).

* 3:25pm
   - Segment 1B blew up inside S6 because the jitter cache builds a python dict entry per tile when priming each ISO. In this run the dict comprehension at packages/engine/src/engine/layers/l1/seg_1B/s6_site_jitter/l2/aggregate.py (lines 147-169) tried to materialise millions of tile IDs, which triggered the MemoryError you saw in runs/local_layer1_regen2/run_log_regen2.log (lines 9466-9486).
   - I refactored both _TileBoundsArray and _TileCentroidArray (see aggregate.py (lines 121-179)) to keep the tile IDs sorted and use np.searchsorted for point lookups instead of storing index_map dictionaries. That shrinks the per-country memory footprint down to a few NumPy arrays and eliminates the runaway allocations during prime_iso.
   - Targeted regression: python -m pytest tests/engine/layers/l1/seg_1B/test_s6_site_jitter.py

* 3:30pm
   - Segment 2A blew up during S1 because the runner now expects the S0 sealed manifest/determinism receipt plumbing we added earlier. The unit harness hadn’t been updated, so the CLI run hit two gaps:
      1. ProvisionalLookupRunner._resolve_run_report_path was referenced but never defined after the refactor, which triggered the AttributeError.
      2. The S1 plumbing tests that fabricate receipts/dictionaries didn’t include the new sealed artefacts (sealed_inputs_v1, tz_nudge, etc.) or the updated run-report shape, so they didn’t catch the problem before you ran the CLI.
   - Fixes done
      - Reintroduced _resolve_run_report_path in s1_provisional/l2/runner.py (lines 260‑273) so the runner can stage its report deterministically.
      - Updated tests/engine/test_seg_2a_s1_plumbing.py to:
         - Include sealed_inputs_v1 in the fake dictionary.
         - Write a determinism receipt and a sealed_inputs parquet that lists site_locations, tz_world_2025a, tz_nudge, and tz_overrides.
         - Use build_sealed_asset_map/load_determinism_receipt when calling _prepare_context.
         - Assert against the new run-report structure (counts nested under counts, S0 metadata under "s0").

* 3:36pm
   - Added a central sealed-digest verifier so every Segment 2B state re-hashes inputs exactly the way S0 recorded them (packages/engine/src/engine/layers/l1/seg_2B/shared/sealed_assets.py (line 15)). S1, S2, S3, and S4 now call this helper for both mandatory policies and optional pins before reading any cross-segment artefact, which closes the alias-layout mismatch that killed S1 and ensures the optional tz caches are checked as well (packages/engine/src/engine/layers/l1/seg_2B/s1_weights/l2/runner.py (line 284), s2_alias/l2/runner.py (line 306), s3_day_effects/l2/runner.py (line 401) & 551, s4_group_weights/l2/runner.py (line 596)).
   - Trimmed the noisy JSON dump by having S0 save the run-report to disk and log a single pointer instead of printing the whole payload; _write_run_report now returns the path so downstream callers (and operators reading the log) can link straight to it (packages/engine/src/engine/layers/l1/seg_2B/s0_gate/l2/runner.py (line 187), 639).
   - Updated the Segment 2B unit fixtures to emit the same aggregated digests that S0 writes, so the new checks have representative data (tests/engine/test_seg_2b_s1_weights.py (line 206), test_seg_2b_s2_alias.py (line 147), test_seg_2b_s3_day_effects.py (line 178), test_seg_2b_s4_group_weights.py (line 141)). This keeps the tests meaningful while exercising the stricter sealing rules.
   - S3 now insists that any cross-segment asset it touches is sealed by S0. Your latest make segment2b run still used the old S0 receipt, which never pinned site_timezones, so _ensure_optional_pin bailed with 2B-S3-022 (runs/local_layer1_regen2/run_log_regen2.log: Segment2B S3 starting … sealed asset 'site_timezones' not present in S0 sealed_inputs_v1).
   - The fix is to rerun Segment 2B S0 with the “civil-time pins” enabled so site_timezones (and tz_timetable_cache if present) are written into sealed_inputs_v1. The CLI flag is `--pin-tz-assets`; the Makefile already exposes it through SEG2B_PIN_TZ.
      1. One-off run: `SEG2B_PIN_TZ=1 make segment2b`.
      2. Permanent change: set `SEG2B_PIN_TZ ?= 1` near the top of the Makefile (line ~150) so every invocation passes `--pin-tz-assets`.

* 3:45pm
   - S8 was loading the S0 determinism receipt emitted by the new gate and validating it against the schema baked into s8_validation. That schema only allows engine_commit, policy_ids, and policy_digests, but our S0 update added extra “python_version” and “platform” fields, so the JSON-schema check failed before S8 could start. The fix was to strip those non-spec keys from the receipt payload while keeping the richer environment info in the run-report (packages/engine/src/engine/layers/l1/seg_2B/s0_gate/l2/runner.py (lines 389-395)).

* 6:04pm
   - Finish up implementation of segments 2A and 2B. Tested it and it runs smoothly. Here's the run summary:
      - Segment 1A:
         - Orchestrator staged refs at 17:38:46 and ran straight through all nine states without retries; S0→S9 spanned roughly 6½ min (17:38:47→17:45:21) with every validation gate reporting PASS (runs/local_layer1_regen2/run_log_regen2.log (lines 8-52)).
         - Key outcomes: S1 validated 4 228 multi-merchant records, S2 completed with all merchants accepted and no residual validation issues (… (lines 22-34)), S5/S6 generated the currency weight cache and RNG events (… (lines 46-48)), and the outlet catalogue plus validation bundle finalized successfully in S8/S9 (… (lines 49-50)). Performance looks healthy; no warnings or throttling noted.
      - Segment 1B:
         - S0 sealed immediately after 1A (17:45:25) and all downstream states finished by 18:00:07 (… (lines 76-9763)).
         - S1 tile index consumed ~98 s (17:45:25→17:47:03) with ~6.3 M rows flushed; this is the heaviest CPU/memory stage and matches expectations for 12 workers (… (line 9308)).
         - S2 quantisation logged a 221 M-row scan but completed in ~2 ¾ min after a single progress heartbeat (… (lines 9346-9347)). S3/S4 produced requirements and allocation plans without shortfall anomalies (… (lines 9353-9381)).
         - S5 router, S6 jitter, and S7/S8 synthesis all reported normal RNG counts and tiny wall-clock times once their inputs were staged (… (lines 9383-9761)). Validation bundle emitted at S9 with failures=0 (… (line 9762)). Earlier crash you saw was just the OOM from rerunning S1 with too many workers; the successful pass shows the base implementation is sound.
      - Segment 2A (states S0–S5):
         - Gate validated the 1B manifest and resealed civil-time assets at 18:00:12; every downstream state finished within ~16 s total (… (lines 9765-9810)).
         - S1 streamed 30 086 site rows without nudges (… (lines 9768-9772)), S2 applied zero overrides (good signal that MCC/country policies were already aligned) and emitted site_timezones (… (lines 9773-9784)).
         - S3 built the tz timetable cache for 598 TZIDs, S4 legality checked 30 086 sites across 189 TZIDs, and S5 stamped a clean validation bundle (… (lines 9785-9809)). No warnings surfaced—determinism receipts/resume flags all read “False”.
      - Segment 2B (states S0–S8):
         - S0 now logs only the run-report path; it completed at 18:00:30 and immediately fed S1–S4, which each finished inside ~5 s thanks to the sealed-input enforcement and determinism context (… (lines 9812-9821)).
         - Router S5 remains the long pole (~3 min wall clock to emit 259 840 selections), but RNG accounting and selection logs completed cleanly (… (line 9837)).
         - Virtual-edge S6 and audit S7 both wrapped in <10 s, publishing the audit report with 14 validators (… (lines 9850-9852)).
         - Final S8 bundle published at 18:03:45 with the determinism receipt schema satisfied after we trimmed the extra metadata (… (lines 9853-9855)). No failures or WARN validators recorded in the summary JSON.