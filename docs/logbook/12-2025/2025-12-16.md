# Logbook
### Date: 14th December 2025
### Project: Fraud Detection System
### Reference commits: Check commits on this date (if any)

* 1:28pm
   - Currently working on drafting the plan for the entire fraud platform
   - Also crafted the DAGs for segment2A


* 1:34pm - #TODO (with regards to fixing the specs):
	- Below is the **TODO list of “conceptual breaks” / spec↔contract contradictions / integration drifts** I’ve seen across the full engine set you passed. These are the items that would force an implementer/validator/consumer to *guess* (or would produce non-reproducible or inconsistent behaviour) unless resolved.

	- Cross-cutting TODOs (engine-wide)
			* **Unify HashGate “law” across segments (or explicitly version it).**
			Some segments define `_passed.flag` as SHA-256 over **raw bytes of indexed files**, while others define it as SHA-256 over the **concatenation of member digests**. This is a conceptual fork in what “HashGate” means, and it will leak into platform ingestion rules.
			* **Standardise `created_utc` vs idempotency semantics.**
			Multiple S0 receipts talk about “current UTC timestamp” *and* “byte-identical reruns for same identity.” Those can’t both be true unless the spec says “reuse existing created_utc if already present” (or exclude it from equality checks). Needs one consistent rule.
			* **Make “contract packs / policy packs / priors” consistently first-class (or consistently implicit).**
			Some segments enumerate policy artefacts explicitly in dictionary/registry (good for sealing), while others rely on a vague “contracts pack” dependency without enumerating what’s inside. This breaks the “sealed inputs = only reality” discipline unless clarified.
			* **Standardise naming: `fingerprint` vs `manifest_fingerprint` (fields vs partitions vs prose).**
			Several segments are consistent on paths (`fingerprint={manifest_fingerprint}`), but differ in column/partition naming (`fingerprint` vs `manifest_fingerprint`). This creates consumer/validator ambiguity.
			* **Fix lineage/consumer drift:** “consumed_by” lists don’t always match actual state behaviour.
			Where a dictionary/registry claims a downstream consumer that does not actually read the artefact (per state specs), either the consumer must be updated or lineage must be corrected. Otherwise enterprise wiring will be wrong.
			* **Fix any schema-pack anchors referenced by dictionaries but missing in schema files.**
			Any dangling schema refs are a hard conceptual break: validators cannot be implemented without inventing missing schema anchors.
			* **Resolve type-range drift for core IDs (`id64` / uint64).**
			If different schema packs disagree on the valid numeric range for “id64”, you get cross-segment incompatibility (and potential inability to read/join).

	- Segment 1A TODOs
			* **RNG keying vocabulary mismatch:** later state prose sometimes frames substreams keyed by `merchant_id`, while S0 defines a canonical `merchant_u64` mapping used for RNG keying. Must be stated consistently everywhere (and referenced as a single authority).
			* **Schema-type drift for core IDs (`id64`) between layer-wide and segment schemas.**
			Needs a single definition (or explicit cast/constraint rules) to avoid cross-segment validation breaks.
			* **Artefact registry YAML bug:** duplicated YAML key(s) (e.g., repeated `role:`) risks silent overwrite.
			* **Reference metadata drift:** at least one reference artefact (population raster) has inconsistent licence/metadata between registry vs dictionary (not behavioural, but still a contract contradiction).
			* **Validation artefact consistency:** 1A describes `_passed.flag` semantics but dictionary doesn’t consistently model a standalone “validation_passed_flag_1A” dataset entry (inconsistent pattern vs later segments).

			- Segment 1B TODOs
			* **Dangling schema refs:** dictionary references `schemas.1B.yaml#/control/*` anchors, but `schemas.1B.yaml` does not define a `control:` section. This is validator-blocking.
			* **Suspicious lineage cycle:** dictionary claims `site_locations` is consumed by `1A` (downstream → upstream). Unless explicitly “validation-only exception”, this breaks the DAG.
			* **“Outside partition” wording vs actual placement of sidecars:** some prose says run summaries live “outside dataset partitions” while dictionary places JSON sidecars inside those partitions. Needs consistent meaning to avoid validator ambiguity.

	- Segment 2A TODOs
			* **Dictionary references inputs not sealed in registry (or not present in S0 sealing rules).**
			Example class of issue: ISO canonical reference appears in dictionary but isn’t enumerated/sealed as a 2A input artefact. Either add to sealed inputs or remove from dictionary.
			* **Clarify optionality of external aids:** 2A is deterministic and pinned to S0 receipt time; make sure any “override” or “nudge” inputs are treated as sealed, not environmental.

			- Segment 2B TODOs
			* **“Optional pins” vs operational requirement:** contracts present `site_timezones` (and cache) as optional, but S3/S4/S5 routing-group construction operationally requires timezone grouping. Either:
			* make `site_timezones` required for 2B, or
			* specify a complete fallback mode when 2A outputs are absent.
			* **Integration drift with 3A/3B:** contracts/lineage imply 2B consumes `zone_alloc` and/or virtual edge universes, but the current 2B state specs route virtual edges via a sealed policy pack and do not read 3A/3B egress. Decide and align:
			* update 2B to actually consume 3A/3B artefacts and enforce universe hashes, **or**
			* correct 3A/3B “consumed_by 2B” claims.
			* **Minimum sealed policy set in S0:** ensure S0 sealing rules explicitly include virtual-edge policy when S6 is in-scope (no “implied dependency”).

	- Segment 3A TODOs
			* **HashGate law divergence inside 3A vs other segments:** 3A S7 defines bundle digest differently (member-digest concat) than segments using raw-bytes concat. Must be reconciled (or explicitly versioned).
			* **Partition field naming inconsistency:** some 3A tables mix `manifest_fingerprint` vs `fingerprint` (fields/partition metadata). Needs normalisation.
			* **2B integration mismatch (again):** 3A exports `zone_alloc` + `routing_universe_hash` intended for routing coherence, but 2B specs don’t read them. Either update 2B or revise 3A contracts/lineage.

			- Segment 3B TODOs
			* **Major upstream dataset name/path mismatch:**
			3B contracts (dictionary + registry) reference a `site_catalogue` at `data/outputs/1B/...`, while:
			* the actual Layer-1 egress is `site_locations` at `data/layer1/1B/site_locations/...`, and
			* the 3B expanded specs talk in terms of `site_locations`.
			Fix by either (a) renaming contracts to `site_locations`, or (b) formally introducing a `site_catalogue` view/artifact produced by 1B (and keep both consistent).
			* **2B consumer drift:** 3B contracts claim 2B consumes certain 3B artefacts (edge universe hash / routing integration), but 2B specs currently don’t. Align one way or the other.
			* **Schema-vs-storage mismatch risk:** `sealed_inputs_3B` is treated as a parquet inventory in contracts, but schema is expressed as an “object” shape (may be intended as per-row schema, but needs explicit statement to avoid validator confusion).

	- Segment 5A TODOs
			* **S0 “receipt can succeed with missing upstream” vs “S1+ must refuse” needs a single crisp rule.**
			The design intention is clear (S0 can record world status; S1+ requires readiness), but the docs need to be consistent everywhere so orchestration and validators don’t diverge.
			* **S2 scoping ambiguity:** S2 outputs are keyed only by `(parameter_hash, scenario_id)` but some descriptions allow domain derived from the world (S1). That causes “first world wins” drift unless S2 domain is explicitly world-invariant (superset) or S2 becomes fingerprint-scoped.
			* **Idempotency vs wall-clock in S0 (again):** same `created_utc` issue.

	- Segment 5B TODOs
			* **Receipt uniqueness vs `run_id`:** some prose suggests write-once per `(fingerprint, run_id)` while paths are fingerprint-only. Must pick one identity rule.
			* **Idempotency vs wall-clock in S0 receipt (again).**
			* **`read_scope` correctness in sealed inputs:** ensure artefacts required for row-level computation (S1–S4) are never sealed as METADATA_ONLY, otherwise later states become non-compliant by design.

	- Segment 6A TODOs
			* **Field name drift in control artefacts:** specs refer to `upstream_gates` while schema anchors use a different field name (e.g., `upstream_segments`). This is validator-blocking.
			* **Clarify what “contracts / priors packs” means in sealing:** registry/dictionary don’t enumerate priors/policies the way 2B does; if a single “contracts pack” is intended to contain them, its content needs to be made explicit (or enumerated as sealed inputs).
			* **Merchant fraud roles seed-scope ambiguity:** some prose suggests seed-independent option, while contracts wire roles as seed+fingerprint. Choose one.

	- Segment 6B TODOs
			* **Partition-scope mismatches vs behaviour:**
			* `s3_campaign_catalogue_6B` scope differs between expanded specs and contracts (scenario axis vs not).
			* `s4_case_timeline_6B` similarly differs (cases spanning scenarios vs per-scenario).
			These are conceptual because they define whether cross-scenario coherence exists.
			* **Missing explicit artefact entries for behaviour configs/policies/priors:**
			6B S1–S4 rely on multiple config packs (flow models, campaign priors, outcome delay models, RNG policies, etc.), but dictionary/registry currently only enumerate produced datasets (plus a vague `contracts_6B`). Either enumerate those packs or make `contracts_6B` contents explicit and sealable.


