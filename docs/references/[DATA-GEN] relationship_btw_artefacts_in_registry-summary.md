Below is a high‑level map of how the artefacts you’ve catalogued interconnect across the eight sub‑segments of the Merchant Location Realism layer. Think of it as a pipeline of stages (columns) with the main artefact classes (rows) and arrows showing the flow of data, control, and provenance.

---

| **Stage**                                 | **Configs & Manifests**                                                                                                                                                 | **Data Priors & Inputs**                                                          | **Seed & RNG**                                                                                                                      | **Sampling & Modeling**                                                                                                                                                    | **Audit & Logging**                                                                                                                            | **Outputs & Registry**                                                                                               |
|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------|
| **1A: Merchant → Sites**                  | • `hurdle_coefficients.yaml`<br>• `nb_dispersion_coefficients.yaml`<br>• `crossborder_hyperparams.yaml`<br>• Manifest fields (`parameter_hash`, `manifest_fingerprint`) | • GDP CSV, GDP buckets<br>• Settlement share vectors<br>• Currency‐country splits | • `manifest_fingerprint` ⊕ `run_seed` → Philox master seed<br>• Sub‑streams per event                                               | • Hurdle Bernoulli → decides single vs multi<br>• NB draws for outlet counts (Gamma + Poisson mixture)<br>• Cross‑border λ\_extra formula                                  | • `rng_audit.log` (hurdle\_bernoulli, gamma\_component, ztp…)<br>• CI metrics (rejection rates, θ₁ significance)                               | • `outlet_stub` Parquet with stub schema columns (site\_id, country\_iso, tie\_break\_rank…)                         |
| **1B: Placing Sites**                     | • `spatial_blend.yaml`<br>• `fallback_policy.yml`<br>• Time‑zone manifest keys (`tz_world_metadata.json`)                                                               | • HRSL & WorldPop rasters<br>• OSM roads & airport polygons<br>• Capitals dataset | • Same Philox master seed (from 1A) → sub‑streams for spatial draws                                                                 | • Fenwick‑tree CDF builds<br>• Importance sampling from blended rasters/vectors<br>• Land/water filter, remoteness tags                                                    | • Placement audit events (pixel\_draw, triangle\_draw, tz\_mismatch…)<br>• Crash‑tolerance temp files                                          | • Site Parquet rows (`lat`, `lon`, `prior_tag`, `footfall_clipped`, …)                                               |
| **2A: Civil Time Zone**                   | • `tz_nudge.yml`<br>• `tz_overrides.yaml`<br>• `zoneinfo_version.yml`<br>• `simulation_horizon.yml`                                                                     | • tz‑world shapefile layer<br>• tzdata archive                                    | • Same Philox seed → sub‑stream for tie‑break nudges                                                                                | • Point‑in‑polygon lookup (STR‑tree) + 0.0001° nudge tie‑break<br>• DST gap/fold handling (gap\_seconds, fold parity)                                                      | • No explicit log, but exceptions (`DSTLookupTieError`, `TimeZoneLookupError`) captured in audit                                               | • Per‑site columns (`event_time_utc`, `local_time_offset`, `dst_adjusted`, `fold`)                                   |
| **2B: Routing through Sites**             | • `routing_manifest.json` (digests: site\_catalogue, weight, alias, rng\_policy, cdn\_alias…)<br>• `routing_day_effect.yml`<br>• `rng_policy.yml`                       | • `site_catalogue.parquet`                                                        | • Philox sub‑stream per merchant for day‐effect<br>• RNG for alias draws                                                            | • Compute normalized weights (`p_i`) → `<merchant>_pweights.bin`<br>• Vose alias tables (`<merchant>_alias.npz`)<br>• Day‐effect modulation<br>• O(1) sampling             | • `routing_audit.log` (checksums per batch)<br>• Validation CI (`routing_validation.yml`)                                                      | • Routed‐transaction outputs (implicit streaming to next layer)                                                      |
| **3A: Cross‑Zone Merchant Allocations**   | • `zone_mixture_policy.yml`<br>• `country_zone_alphas.yaml`<br>• `zone_floor.yml`<br>• `cross_zone_validation.yml`                                                      | • Visa/MCX cross‑border indices (license)<br>• Major‐zone CSV                     | • Philox sub‑stream per (merchant\_id, country\_iso) for Dirichlet draws                                                            | • Dirichlet‐multinomial with α from YAML + mixture threshold θ\_mix<br>• Largest‑remainder rounding with bump rule                                                         | • CI tests (`test_mix_threshold.py`, `test_rounding_conservation.py`, `test_cross_zone_validation.py`)<br>• Drift exceptions                   | • `<merchant>_zone_alloc.parquet` + `zone_alloc_index.csv`                                                           |
| **3B: Virtual Merchant Treatment**        | • `mcc_channel_rules.yaml`<br>• `cdn_country_weights.yaml`<br>• `rng_policy.yml`<br>• `virtual_validation.yml`                                                          | • `merchant_master.parquet`<br>• Akamai SOTI report data<br>• HRSL raster         | • Philox sub‑streams for CDN edge draws                                                                                             | • Derive `is_virtual` flag<br>• Build settlement node (`virtual_settlement_coords.csv`)<br>• Edge‐catalogue via rounding + sampling from HRSL                              | • CI tests (`test_virtual_rules.py`, `test_geocoder_bundle.py`, `test_virtual_validation.py`, `validate_virtual.py`)<br>• `edge_progress.log`  | • Per‑merchant `edge_catalogue/*.parquet` + index CSV                                                                |
| **4A: Reproducibility & Configurability** | • `Dockerfile.lock` + container manifest<br>• `artefact_registry.yaml`<br>• `compare_registry.py`<br>• `register_dataset.py`                                            | • All prior configs & code as listed in registry                                  | • Time‐derived master seed (time\_ns ⊕ parameter‐set hash)<br>• Philox + AES rounds<br>• Sub‑stream jumps logged in `rng_trace.log` | • Entry‐point checks (`main.py` vs `__codehash__`)<br>• Config YAML schema validation<br>• Firewall checks on streaming data                                               | • CI jobs (`validate_container_hash.yml`, `replay_rng.py`, `validate_licences.py`)<br>• Firewall logs & failure reproducers                    | • Fully‑tagged Parquet (creator\_param\_hash, master\_seed\_hex)<br>• Immutable dataset root (`synthetic_v1_<hash>`) |
| **4B: Validation (Final Checks)**         | • `validation_conf.yml`<br>• Embedded schema digests (`schema_digest`, `adv_conf_digest`, …)<br>• `.github/workflows/block_merge.yml`                                   | • Combined outputs from all prior stages                                          | • Final RNG audit (`rng_trace.log`)                                                                                                 | • Structural firewall (`firewall.py`)<br>• Adversarial AUROC test (XGBoost via `adv_embed`)<br>• Semantic GLM via `semantic_glm.py`<br>• Barcode analysis via `barcode.py` | • CI scripts (`test_virtual_validation.py`, `ci/test_cross_zone_validation.py`, …)<br>• Section‑level failure artefacts (PNGs, CSVs, Parquets) | • Validation bundle under `validation/<parameter_hash>/`<br>• HashGate upload & manifest flag                        |

---

### How to Read This Map

1. **Columns** are the eight sub‑segments (1A … 4B), each representing a distinct processing stage.
2. **Rows** group artefacts by their functional role:

   * **Configs & Manifests**: all the YAML/JSON and manifest‑generation steps that capture digests and versions.
   * **Data Priors & Inputs**: external data sources (rasters, shapefiles, catalogs) ingested at that stage.
   * **Seed & RNG**: how the parameter/manifest hashes are combined with clocks or salts to produce reproducible Philox seeds and sub‑streams.
   * **Sampling & Modeling**: the core statistical draws or deterministic transforms (hurdle, NB, Dirichlet, alias sampling, edge‑catalogue building).
   * **Audit & Logging**: every audit log, CI test, and exception class that ensures correctness, reproducibility, and drift detection.
   * **Outputs & Registry**: the Parquet/CSV/NPZ artefacts, indices, and directory conventions that materialize each stage’s results.

This structure shows, at a glance, how:

* **Provenance flows** from YAML configs → digests → manifests → seeds → data generation → logging.
* **Data flows** from priors and input catalogs through successive modeling stages to final transactional and validation outputs.
* **Governance & validation** is woven throughout via CI scripts, exception‐based aborts, and final HashGate publication.

Let me know if you’d like this visualized further or drilled into any particular connections!
