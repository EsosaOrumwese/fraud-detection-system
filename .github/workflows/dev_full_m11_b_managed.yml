name: dev-full-m11-b-managed

on:
  workflow_dispatch:
    inputs:
      aws_region:
        description: "AWS region for S3/SSM/SageMaker operations"
        required: true
        default: "eu-west-2"
        type: string
      aws_role_to_assume:
        description: "OIDC role ARN used by GitHub Actions"
        required: true
        type: string
      evidence_bucket:
        description: "S3 bucket for run-control evidence"
        required: true
        default: "fraud-platform-dev-full-evidence"
        type: string
      upstream_m11a_execution:
        description: "Upstream M11.A execution id"
        required: true
        default: "m11a_handle_closure_20260226T175701Z"
        type: string
      m11b_execution_id:
        description: "Optional fixed M11.B execution id"
        required: false
        default: ""
        type: string

permissions:
  contents: read
  id-token: write

concurrency:
  group: dev-full-m11-b-managed-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  run_m11_b_managed:
    name: Run M11.B SageMaker readiness
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Reject static AWS credential posture
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${AWS_ACCESS_KEY_ID:-}" || -n "${AWS_SECRET_ACCESS_KEY:-}" ]]; then
            echo "Static AWS credentials are forbidden; use OIDC role assumption."
            exit 1
          fi

      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ inputs.aws_region }}
          role-to-assume: ${{ inputs.aws_role_to_assume }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install runtime dependencies
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install boto3 botocore

      - name: Compute execution metadata
        id: run_meta
        shell: bash
        run: |
          set -euo pipefail
          TS="$(date -u +'%Y%m%dT%H%M%SZ')"
          if [[ -n "${{ inputs.m11b_execution_id }}" ]]; then
            M11B_EXEC="${{ inputs.m11b_execution_id }}"
          else
            M11B_EXEC="m11b_sagemaker_readiness_${TS}"
          fi
          M11B_RUN_DIR="runs/dev_substrate/dev_full/m11/${M11B_EXEC}"
          echo "timestamp=${TS}" >> "$GITHUB_OUTPUT"
          echo "m11b_execution_id=${M11B_EXEC}" >> "$GITHUB_OUTPUT"
          echo "m11b_run_dir=${M11B_RUN_DIR}" >> "$GITHUB_OUTPUT"

      - name: Execute M11.B (managed)
        shell: bash
        env:
          M11B_EXECUTION_ID: ${{ steps.run_meta.outputs.m11b_execution_id }}
          M11B_RUN_DIR: ${{ steps.run_meta.outputs.m11b_run_dir }}
          EVIDENCE_BUCKET: ${{ inputs.evidence_bucket }}
          UPSTREAM_M11A_EXECUTION: ${{ inputs.upstream_m11a_execution }}
          AWS_REGION: ${{ inputs.aws_region }}
        run: |
          set -euo pipefail
          python - <<'PY'
          from __future__ import annotations

          import json
          import os
          import re
          from datetime import datetime, timezone
          from pathlib import Path
          from typing import Any

          import boto3
          from botocore.exceptions import BotoCoreError, ClientError


          HANDLES_PATH = Path("docs/model_spec/platform/migration_to_dev/dev_full_handles.registry.v0.md")
          REQUIRED_HANDLES = [
              "ROLE_SAGEMAKER_EXECUTION",
              "SSM_SAGEMAKER_MODEL_EXEC_ROLE_ARN_PATH",
              "SSM_MLFLOW_TRACKING_URI_PATH",
              "SM_TRAINING_JOB_NAME_PREFIX",
              "SM_BATCH_TRANSFORM_JOB_NAME_PREFIX",
              "SM_MODEL_PACKAGE_GROUP_NAME",
              "SM_ENDPOINT_NAME",
              "SM_ENDPOINT_COUNT_V0",
              "SM_SERVING_MODE",
          ]


          def now_utc() -> str:
              return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


          def parse_handles(path: Path) -> dict[str, Any]:
              out: dict[str, Any] = {}
              rx = re.compile(r"^\* `([^`=]+?)\s*=\s*([^`]+)`")
              for line in path.read_text(encoding="utf-8").splitlines():
                  m = rx.match(line.strip())
                  if not m:
                      continue
                  key = m.group(1).strip()
                  raw = m.group(2).strip()
                  if raw.startswith('"') and raw.endswith('"'):
                      out[key] = raw[1:-1]
                  elif raw.lower() == "true":
                      out[key] = True
                  elif raw.lower() == "false":
                      out[key] = False
                  else:
                      out[key] = raw
              return out


          def is_placeholder(value: Any) -> bool:
              s = str(value).strip()
              s_lower = s.lower()
              if not s:
                  return True
              if s_lower in {"tbd", "todo", "none", "null", "unset", "na", "n/a"}:
                  return True
              if "to_pin" in s_lower or "placeholder" in s_lower:
                  return True
              if "<" in s and ">" in s:
                  return True
              return False


          def is_wildcard(value: Any) -> bool:
              s = str(value).strip()
              return bool(s and "*" in s)


          def s3_get_json(s3: Any, bucket: str, key: str) -> dict[str, Any]:
              payload = s3.get_object(Bucket=bucket, Key=key)["Body"].read().decode("utf-8")
              obj = json.loads(payload)
              if not isinstance(obj, dict):
                  raise ValueError("json_not_object")
              return obj


          def s3_put_json(s3: Any, bucket: str, key: str, payload: dict[str, Any]) -> None:
              body = json.dumps(payload, indent=2, ensure_ascii=True).encode("utf-8")
              s3.put_object(Bucket=bucket, Key=key, Body=body, ContentType="application/json")
              s3.head_object(Bucket=bucket, Key=key)


          def write_local(run_dir: Path, artifacts: dict[str, dict[str, Any]]) -> None:
              run_dir.mkdir(parents=True, exist_ok=True)
              for name, payload in artifacts.items():
                  (run_dir / name).write_text(json.dumps(payload, indent=2, ensure_ascii=True) + "\n", encoding="utf-8")


          def role_name_from_arn(role_arn: str) -> str:
              if "/" not in role_arn:
                  return role_arn
              return role_arn.split("/")[-1]


          execution_id = os.environ["M11B_EXECUTION_ID"]
          run_dir = Path(os.environ["M11B_RUN_DIR"])
          evidence_bucket = os.environ["EVIDENCE_BUCKET"]
          region = os.environ["AWS_REGION"]
          upstream_m11a = os.environ["UPSTREAM_M11A_EXECUTION"]

          captured_at = now_utc()
          blockers: list[dict[str, str]] = []
          read_errors: list[dict[str, str]] = []
          advisories: list[dict[str, str]] = []
          upload_errors: list[dict[str, str]] = []

          s3 = boto3.client("s3", region_name=region)
          ssm = boto3.client("ssm", region_name=region)
          iam = boto3.client("iam", region_name=region)
          sm = boto3.client("sagemaker", region_name=region)

          m11a_summary_key = f"evidence/dev_full/run_control/{upstream_m11a}/m11a_execution_summary.json"
          m11a_summary: dict[str, Any] = {}
          try:
              m11a_summary = s3_get_json(s3, evidence_bucket, m11a_summary_key)
          except (BotoCoreError, ClientError, ValueError, json.JSONDecodeError) as exc:
              read_errors.append({"surface": m11a_summary_key, "error": type(exc).__name__})
              blockers.append({"code": "M11-B2", "message": "M11.A summary unreadable."})

          if m11a_summary:
              if not bool(m11a_summary.get("overall_pass", False)):
                  blockers.append({"code": "M11-B2", "message": "M11.A overall_pass is not true."})
              if str(m11a_summary.get("next_gate", "")).strip() != "M11.B_READY":
                  blockers.append({"code": "M11-B2", "message": "M11.A next_gate is not M11.B_READY."})

          platform_run_id = str(m11a_summary.get("platform_run_id", "")).strip()
          scenario_run_id = str(m11a_summary.get("scenario_run_id", "")).strip()
          if not platform_run_id:
              blockers.append({"code": "M11-B2", "message": "platform_run_id unresolved from M11.A summary."})
          if not scenario_run_id:
              blockers.append({"code": "M11-B2", "message": "scenario_run_id unresolved from M11.A summary."})

          handle_values: dict[str, Any] = {}
          handle_rows: list[dict[str, str]] = []
          unresolved_handles: list[str] = []
          try:
              handle_values = parse_handles(HANDLES_PATH)
          except Exception as exc:  # noqa: BLE001
              blockers.append({"code": "M11-B2", "message": f"Handle registry unreadable: {type(exc).__name__}"})

          for key in REQUIRED_HANDLES:
              if key not in handle_values:
                  status = "missing"
                  value_out = ""
                  unresolved_handles.append(key)
              else:
                  value = handle_values.get(key)
                  value_out = str(value)
                  if is_placeholder(value):
                      status = "placeholder"
                      unresolved_handles.append(key)
                  elif is_wildcard(value):
                      status = "wildcard"
                      unresolved_handles.append(key)
                  else:
                      status = "resolved"
              handle_rows.append({"handle": key, "status": status, "value": value_out})

          if unresolved_handles:
              blockers.append({"code": "M11-B2", "message": "One or more required M11.B handles are unresolved."})

          role_arn_handle = str(handle_values.get("ROLE_SAGEMAKER_EXECUTION", "")).strip()
          ssm_role_path = str(handle_values.get("SSM_SAGEMAKER_MODEL_EXEC_ROLE_ARN_PATH", "")).strip()
          ssm_mlflow_path = str(handle_values.get("SSM_MLFLOW_TRACKING_URI_PATH", "")).strip()
          model_package_group_name = str(handle_values.get("SM_MODEL_PACKAGE_GROUP_NAME", "")).strip()

          ssm_role_arn_value = ""
          mlflow_uri_value = ""
          if ssm_role_path and not is_placeholder(ssm_role_path):
              try:
                  ssm_role_arn_value = str(ssm.get_parameter(Name=ssm_role_path)["Parameter"]["Value"]).strip()
              except (BotoCoreError, ClientError, KeyError) as exc:
                  read_errors.append({"surface": ssm_role_path, "error": type(exc).__name__})
                  blockers.append({"code": "M11-B2", "message": "SageMaker role ARN SSM parameter unreadable."})
          if ssm_mlflow_path and not is_placeholder(ssm_mlflow_path):
              try:
                  mlflow_uri_value = str(ssm.get_parameter(Name=ssm_mlflow_path)["Parameter"]["Value"]).strip()
              except (BotoCoreError, ClientError, KeyError) as exc:
                  read_errors.append({"surface": ssm_mlflow_path, "error": type(exc).__name__})
                  blockers.append({"code": "M11-B2", "message": "MLflow URI SSM parameter unreadable."})

          if role_arn_handle and ssm_role_arn_value and role_arn_handle != ssm_role_arn_value:
              blockers.append({"code": "M11-B2", "message": "ROLE_SAGEMAKER_EXECUTION does not match SSM role ARN value."})
          if not mlflow_uri_value or is_placeholder(mlflow_uri_value):
              blockers.append({"code": "M11-B2", "message": "MLflow tracking URI value is unresolved."})

          iam_check = {
              "role_exists": False,
              "sagemaker_trust": False,
              "attached_policy_count": 0,
              "inline_policy_count": 0,
          }
          if role_arn_handle and not is_placeholder(role_arn_handle):
              role_name = role_name_from_arn(role_arn_handle)
              try:
                  role_resp = iam.get_role(RoleName=role_name)["Role"]
                  iam_check["role_exists"] = True
                  assume_doc = role_resp.get("AssumeRolePolicyDocument", {})
                  statements = assume_doc.get("Statement", [])
                  if isinstance(statements, dict):
                      statements = [statements]
                  principals: list[str] = []
                  for stmt in statements:
                      principal = stmt.get("Principal", {})
                      service = principal.get("Service") if isinstance(principal, dict) else None
                      if isinstance(service, list):
                          principals.extend([str(s) for s in service])
                      elif service is not None:
                          principals.append(str(service))
                  iam_check["sagemaker_trust"] = "sagemaker.amazonaws.com" in principals

                  attached = iam.list_attached_role_policies(RoleName=role_name).get("AttachedPolicies", [])
                  inline = iam.list_role_policies(RoleName=role_name).get("PolicyNames", [])
                  iam_check["attached_policy_count"] = len(attached)
                  iam_check["inline_policy_count"] = len(inline)
              except (BotoCoreError, ClientError, KeyError) as exc:
                  read_errors.append({"surface": f"iam:{role_arn_handle}", "error": type(exc).__name__})
                  blockers.append({"code": "M11-B2", "message": "SageMaker execution role lookup failed."})

          if not iam_check["role_exists"]:
              blockers.append({"code": "M11-B2", "message": "SageMaker execution role does not exist."})
          if not iam_check["sagemaker_trust"]:
              blockers.append({"code": "M11-B2", "message": "SageMaker execution role trust does not include sagemaker.amazonaws.com."})
          if (iam_check["attached_policy_count"] + iam_check["inline_policy_count"]) == 0:
              blockers.append({"code": "M11-B2", "message": "SageMaker execution role has no attached or inline policies."})

          sm_probe = {
              "list_training_jobs_ok": False,
              "list_model_package_groups_ok": False,
              "model_package_group_name": model_package_group_name,
              "model_package_group_status": "unknown",
          }
          try:
              sm.list_training_jobs(MaxResults=1)
              sm_probe["list_training_jobs_ok"] = True
          except (BotoCoreError, ClientError) as exc:
              read_errors.append({"surface": "sagemaker:list_training_jobs", "error": type(exc).__name__})
              blockers.append({"code": "M11-B2", "message": "SageMaker list_training_jobs probe failed."})

          try:
              sm.list_model_package_groups(MaxResults=1)
              sm_probe["list_model_package_groups_ok"] = True
          except (BotoCoreError, ClientError) as exc:
              read_errors.append({"surface": "sagemaker:list_model_package_groups", "error": type(exc).__name__})
              blockers.append({"code": "M11-B2", "message": "SageMaker list_model_package_groups probe failed."})

          if model_package_group_name and not is_placeholder(model_package_group_name):
              try:
                  sm.describe_model_package_group(ModelPackageGroupName=model_package_group_name)
                  sm_probe["model_package_group_status"] = "exists"
              except ClientError as exc:
                  err_code = str(exc.response.get("Error", {}).get("Code", ""))
                  err_msg = str(exc.response.get("Error", {}).get("Message", ""))
                  if err_code == "AccessDeniedException":
                      sm_probe["model_package_group_status"] = "deferred_m11g_owner_access_boundary"
                      advisories.append({
                          "code": "M11-B2-ADVISORY",
                          "message": "Package-group describe/create is access-boundary deferred to M11.G owner lane.",
                      })
                  elif err_code in {"ValidationException", "ResourceNotFound"}:
                      try:
                          sm.create_model_package_group(
                              ModelPackageGroupName=model_package_group_name,
                              ModelPackageGroupDescription="Dev-full M11 readiness package group",
                              Tags=[
                                  {"Key": "project", "Value": "fraud-platform"},
                                  {"Key": "env", "Value": "dev_full"},
                                  {"Key": "phase", "Value": "M11.B"},
                              ],
                          )
                          sm.describe_model_package_group(ModelPackageGroupName=model_package_group_name)
                          sm_probe["model_package_group_status"] = "created"
                      except ClientError as create_exc:
                          create_code = str(create_exc.response.get("Error", {}).get("Code", ""))
                          create_msg = str(create_exc.response.get("Error", {}).get("Message", ""))
                          create_msg_lower = create_msg.lower()
                          if create_code == "ValidationException" and ("exists" in create_msg_lower or "already" in create_msg_lower):
                              sm.describe_model_package_group(ModelPackageGroupName=model_package_group_name)
                              sm_probe["model_package_group_status"] = "exists"
                          elif create_code == "AccessDeniedException":
                              sm_probe["model_package_group_status"] = "deferred_m11g_owner_access_boundary"
                              advisories.append({
                                  "code": "M11-B2-ADVISORY",
                                  "message": "Package-group create is access-boundary deferred to M11.G owner lane.",
                              })
                          else:
                              read_errors.append({"surface": f"sagemaker:model_package_group:{model_package_group_name}", "error": create_code or type(create_exc).__name__})
                              blockers.append({"code": "M11-B2", "message": "Model package group readiness failed."})
                      except BotoCoreError as create_exc:
                          read_errors.append({"surface": f"sagemaker:model_package_group:{model_package_group_name}", "error": type(create_exc).__name__})
                          blockers.append({"code": "M11-B2", "message": "Model package group readiness failed."})
                  else:
                      read_errors.append({"surface": f"sagemaker:model_package_group:{model_package_group_name}", "error": err_code or type(exc).__name__})
                      blockers.append({"code": "M11-B2", "message": "Model package group readiness failed."})
              except (BotoCoreError, KeyError) as exc:
                  read_errors.append({"surface": f"sagemaker:model_package_group:{model_package_group_name}", "error": type(exc).__name__})
                  blockers.append({"code": "M11-B2", "message": "Model package group readiness failed."})
          else:
              blockers.append({"code": "M11-B2", "message": "SM_MODEL_PACKAGE_GROUP_NAME unresolved."})

          dedup: list[dict[str, str]] = []
          seen = set()
          for b in blockers:
              item = {"code": str(b.get("code", "")).strip(), "message": str(b.get("message", "")).strip()}
              key = (item["code"], item["message"])
              if key in seen:
                  continue
              seen.add(key)
              dedup.append(item)
          blockers = dedup

          overall_pass = len(blockers) == 0
          next_gate = "M11.C_READY" if overall_pass else "HOLD_REMEDIATE"
          verdict = "ADVANCE_TO_M11_C" if overall_pass else "HOLD_REMEDIATE"

          readiness_snapshot = {
              "captured_at_utc": captured_at,
              "phase": "M11.B",
              "phase_id": "P14",
              "execution_id": execution_id,
              "platform_run_id": platform_run_id,
              "scenario_run_id": scenario_run_id,
              "entry_surface": f"s3://{evidence_bucket}/{m11a_summary_key}",
              "handle_matrix": handle_rows,
              "unresolved_handles": sorted(unresolved_handles),
              "ssm_checks": {
                  "ssm_sagemaker_role_arn_path": ssm_role_path,
                  "ssm_sagemaker_role_arn_value": ssm_role_arn_value,
                  "role_arn_handle": role_arn_handle,
                  "role_arn_parity": bool(ssm_role_arn_value and role_arn_handle and ssm_role_arn_value == role_arn_handle),
                  "ssm_mlflow_tracking_uri_path": ssm_mlflow_path,
                  "ssm_mlflow_tracking_uri_resolved": bool(mlflow_uri_value),
                  "ssm_mlflow_tracking_uri_value": mlflow_uri_value,
              },
              "iam_checks": iam_check,
              "sagemaker_probes": sm_probe,
              "advisories": advisories,
              "overall_pass": overall_pass,
              "blocker_count": len(blockers),
              "next_gate": next_gate,
          }

          blocker_register = {
              "captured_at_utc": captured_at,
              "phase": "M11.B",
              "phase_id": "P14",
              "execution_id": execution_id,
              "blocker_count": len(blockers),
              "blockers": blockers,
              "read_errors": read_errors,
              "advisories": advisories,
              "upload_errors": upload_errors,
          }

          summary = {
              "captured_at_utc": captured_at,
              "phase": "M11.B",
              "phase_id": "P14",
              "execution_id": execution_id,
              "platform_run_id": platform_run_id,
              "scenario_run_id": scenario_run_id,
              "overall_pass": overall_pass,
              "blocker_count": len(blockers),
              "verdict": verdict,
              "next_gate": next_gate,
              "upstream_refs": {"m11a_execution_id": upstream_m11a},
              "artifact_keys": {
                  "m11b_sagemaker_readiness_snapshot": f"evidence/dev_full/run_control/{execution_id}/m11b_sagemaker_readiness_snapshot.json",
                  "m11b_blocker_register": f"evidence/dev_full/run_control/{execution_id}/m11b_blocker_register.json",
                  "m11b_execution_summary": f"evidence/dev_full/run_control/{execution_id}/m11b_execution_summary.json",
              },
          }

          artifacts = {
              "m11b_sagemaker_readiness_snapshot.json": readiness_snapshot,
              "m11b_blocker_register.json": blocker_register,
              "m11b_execution_summary.json": summary,
          }
          write_local(run_dir, artifacts)

          run_control_prefix = f"evidence/dev_full/run_control/{execution_id}/"
          for name, payload in artifacts.items():
              key = f"{run_control_prefix}{name}"
              try:
                  s3_put_json(s3, evidence_bucket, key, payload)
              except (BotoCoreError, ClientError, ValueError) as exc:
                  upload_errors.append({"surface": key, "error": type(exc).__name__})

          if upload_errors:
              blockers.append({"code": "M11-B2", "message": "Failed to publish/readback one or more M11.B artifacts."})
              dedup = []
              seen = set()
              for b in blockers:
                  item = {"code": str(b.get("code", "")).strip(), "message": str(b.get("message", "")).strip()}
                  key = (item["code"], item["message"])
                  if key in seen:
                      continue
                  seen.add(key)
                  dedup.append(item)
              blockers = dedup
              overall_pass = False
              next_gate = "HOLD_REMEDIATE"
              verdict = "HOLD_REMEDIATE"
              readiness_snapshot["overall_pass"] = False
              readiness_snapshot["blocker_count"] = len(blockers)
              readiness_snapshot["next_gate"] = next_gate
              blocker_register["blocker_count"] = len(blockers)
              blocker_register["blockers"] = blockers
              blocker_register["upload_errors"] = upload_errors
              summary["overall_pass"] = False
              summary["blocker_count"] = len(blockers)
              summary["verdict"] = verdict
              summary["next_gate"] = next_gate
              write_local(run_dir, artifacts)

          print(json.dumps({
              "execution_id": execution_id,
              "overall_pass": summary["overall_pass"],
              "blocker_count": summary["blocker_count"],
              "verdict": summary["verdict"],
              "next_gate": summary["next_gate"],
              "run_dir": str(run_dir),
              "run_control_prefix": f"s3://{evidence_bucket}/{run_control_prefix}",
          }, ensure_ascii=True))

          if not summary["overall_pass"]:
              raise SystemExit(1)
          PY

      - name: Upload M11.B managed artifact set
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: m11-b-managed-${{ steps.run_meta.outputs.timestamp }}
          path: |
            ${{ steps.run_meta.outputs.m11b_run_dir }}
          if-no-files-found: warn
